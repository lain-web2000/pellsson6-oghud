ca65 V2.19 - Git b993d8833
Main file   : org/original.asm
Current file: org/original.asm

000000r 1               ;
000000r 1               ; Practice ROM
000000r 1               ;
000000r 1               		.include "shared.inc"
000000r 2               BANK_SELECTED = $07ff
000000r 2               
000000r 2               .define PF_SockMode $01 ; Todo move elsewhere...
000000r 2               .define PF_SaveState $02
000000r 2               .define PF_LoadState $04
000000r 2               .define PF_RestartLevel $08
000000r 2               .define PF_LevelEntrySaved $10
000000r 2               .define PF_DisablePracticeInfo $20
000000r 2               .define PF_EnableInputDisplay $40
000000r 2               
000000r 2               .macro PF_SetToLevelEnd_A
000000r 2               	lda WRAM_PracticeFlags
000000r 2               	and #(PF_LevelEntrySaved^$FF)
000000r 2               	sta WRAM_PracticeFlags
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MACRO_ThrowFrameImpl
000000r 2               ThrowFrame:
000000r 2               		lda Mirror_PPU_CTRL_REG2
000000r 2               		sta PPU_CTRL_REG2
000000r 2               		lda Mirror_PPU_CTRL_REG1
000000r 2               		and #$FC
000000r 2               		sta Mirror_PPU_CTRL_REG1
000000r 2               		sta PPU_CTRL_REG1 ; Force NT-0 (in case no button was pressed)
000000r 2               
000000r 2               		;
000000r 2               		; Wait for sprite 0
000000r 2               		;
000000r 2               		lda Sprite0HitDetectFlag  ;check for flag here
000000r 2               		beq @SkipSprite0
000000r 2               		ldx #0
000000r 2               		stx PPU_SPR_ADDR
000000r 2               		lda Sprite0Data
000000r 2               		sta PPU_SPR_DATA
000000r 2               		lda Sprite0Data+1
000000r 2               		sta PPU_SPR_DATA
000000r 2               		lda Sprite0Data+2
000000r 2               		sta PPU_SPR_DATA
000000r 2               		lda Sprite0Data+3
000000r 2               		sta PPU_SPR_DATA
000000r 2               		lda PPU_STATUS
000000r 2               		stx PPU_SCROLL_REG
000000r 2               		stx PPU_SCROLL_REG
000000r 2               @Sprite0Clr:
000000r 2               		lda PPU_STATUS
000000r 2               		and #$40
000000r 2               		bne @Sprite0Clr
000000r 2               @Sprite0Hit:
000000r 2               		lda PPU_STATUS
000000r 2               		and #$40
000000r 2               		beq @Sprite0Hit
000000r 2               		ldy #$14
000000r 2               @HBlankDelay:
000000r 2               		dey
000000r 2               		bne @HBlankDelay
000000r 2               @SkipSprite0:
000000r 2               		lda PPU_STATUS
000000r 2               		lda HorizontalScroll
000000r 2               		sta PPU_SCROLL_REG
000000r 2               		lda VerticalScroll
000000r 2               		sta PPU_SCROLL_REG
000000r 2               
000000r 2               		lda ScreenLeft_PageLoc
000000r 2               		lsr Mirror_PPU_CTRL_REG1
000000r 2               		and #$01
000000r 2               		ror
000000r 2               		rol Mirror_PPU_CTRL_REG1
000000r 2               		lda Mirror_PPU_CTRL_REG1
000000r 2               		sta PPU_CTRL_REG1
000000r 2               
000000r 2               		lda WRAM_SlowMotion
000000r 2               		cmp #4
000000r 2               		bne @done
000000r 2               		;
000000r 2               		; Latch controllers.
000000r 2               		;
000000r 2               		ldx #1
000000r 2               		stx $4016
000000r 2               		dex
000000r 2               		stx $4016
000000r 2               		;
000000r 2               		; Check A
000000r 2               		;
000000r 2               		lda $4017
000000r 2               		lsr
000000r 2               		bcs @done ; A pressed. Advance next frame
000000r 2               		lda $4017 ; B
000000r 2               		lda $4017 ; Select
000000r 2               		lda $4017 ; Start
000000r 2               		lsr
000000r 2               		bcc @VBlank0
000000r 2               		;
000000r 2               		; Start pressed - Exit frame advance mode.
000000r 2               		;
000000r 2               		stx WRAM_SlowMotion
000000r 2               		jmp @done ; Exit out of this.
000000r 2               @VBlank0:
000000r 2               		lda PPU_STATUS ; Wait for VBlank
000000r 2               		bpl @VBlank0
000000r 2               		jmp ThrowFrame
000000r 2               @done:
000000r 2               		lda Mirror_PPU_CTRL_REG1
000000r 2               		ora #$80 ; NMI
000000r 2               		sta PPU_CTRL_REG1
000000r 2               		jmp Enter_SoundEngine
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MACRO_RunSlowMo gm
000000r 2               		dec WRAM_SlowMotionLeft
000000r 2               		bmi @allow_frame
000000r 2               		lda DisableScreenFlag
000000r 2               		bne @allow_frame
000000r 2               		lda GamePauseStatus
000000r 2               		and #3
000000r 2               		bne @allow_frame
000000r 2               		ldx OperMode
000000r 2               		dex
000000r 2               		bne @allow_frame
000000r 2               		lda OperMode_Task
000000r 2               		cmp #gm
000000r 2               		bne @allow_frame
000000r 2               		jsr ThrowFrame
000000r 2               		rti
000000r 2               @allow_frame:
000000r 2               		lda WRAM_SlowMotion
000000r 2               		sta WRAM_SlowMotionLeft
000000r 2               .endmacro
000000r 2               
000000r 2               .define MMC5_MAKE_PRGBANK(id) ((id)*4)
000000r 2               .define MAKE_MMC5_CHRBANK(id) ((id)*1)
000000r 2               
000000r 2               TITLE_INIT		= $01
000000r 2               
000000r 2               BANK_LOADER		= MMC5_MAKE_PRGBANK(0)
000000r 2               BANK_CHR		= MMC5_MAKE_PRGBANK(1)
000000r 2               BANK_ORG		= MMC5_MAKE_PRGBANK(2)
000000r 2               BANK_COMMON		= MMC5_MAKE_PRGBANK(3)
000000r 2               BANK_SCEN		= MMC5_MAKE_PRGBANK(4)
000000r 2               BANK_SCEN_DATA	= MMC5_MAKE_PRGBANK(5)
000000r 2               BANK_SMBLL		= MMC5_MAKE_PRGBANK(6)
000000r 2               BANK_LLDATA		= MMC5_MAKE_PRGBANK(7)
000000r 2               
000000r 2               
000000r 2               CHR_ORG_SPR = MAKE_MMC5_CHRBANK(0)
000000r 2               CHR_ORG_BG = MAKE_MMC5_CHRBANK(1)
000000r 2               CHR_ORG_BG_ALTFONT = MAKE_MMC5_CHRBANK(2)
000000r 2               CHR_LOST_SPR = MAKE_MMC5_CHRBANK(3)
000000r 2               CHR_LOST_BG = MAKE_MMC5_CHRBANK(4)
000000r 2               CHR_LOST_BG_ALTFONT = MAKE_MMC5_CHRBANK(5)
000000r 2               CHR_PEACH_SPR = MAKE_MMC5_CHRBANK(6)
000000r 2               CHR_INTRO_BG = MAKE_MMC5_CHRBANK(7)
000000r 2               CHR_INTRO_SPR0 = MAKE_MMC5_CHRBANK(8)
000000r 2               
000000r 2               CHR_SET_BANK = $A000
000000r 2               
000000r 2               SavedRule = $07d9
000000r 2               RuleIndex = $0717 ; Previously DemoAction (can be changed to temp?)
000000r 2               PowerUps = $07e3 ; Previously unused
000000r 2               CurrentRule = $7df
000000r 2               
000000r 2               .ifndef RESTART_LEVEL_BUTTONS
000000r 2               	.define RESTART_LEVEL_BUTTONS Select_Button|Up_Dir
000000r 2               .endif
000000r 2               
000000r 2               .ifndef RESTART_GAME_BUTTONS
000000r 2               	.define RESTART_GAME_BUTTONS Select_Button|Down_Dir
000000r 2               .endif
000000r 2               
000000r 2               .ifndef SAVE_STATE_BUTTONS
000000r 2               	.define SAVE_STATE_BUTTONS Select_Button|Right_Dir
000000r 2               .endif
000000r 2               
000000r 2               .ifndef LOAD_STATE_BUTTONS
000000r 2               	.define LOAD_STATE_BUTTONS Select_Button|Left_Dir
000000r 2               .endif
000000r 2               
000000r 2               
000000r 1               		.include "org.inc"
000000r 2               CHR_SMB = 0
000000r 2               CHR_PRACTICE = 2
000000r 2               CHR_FPG = 4
000000r 2               CHR_LOADER = 6
000000r 2               
000000r 2               ;
000000r 2               ; FPG vars
000000r 2               ;
000000r 2               FpgRuleset = $0717		; DemoAction
000000r 2               FpgSelected = $075a		; NumberOfLives
000000r 2               FpgFlags  = $0761		; OffScr_NumberofLives
000000r 2               FpgLastInput = $0762	; OffScr_HalfwayPage
000000r 2               FpgScrollTo = $07d7 	; TopScoreDisplay+0
000000r 2               FpgError = $07d8		; TopScoreDisplay+1
000000r 2               FpgErrorParam = $07d9	; TopScoreDisplay+2
000000r 2               FpgOldFlags = $07da		; TopScoreDisplay+3
000000r 2               
000000r 2               ;
000000r 2               ; Practice vars
000000r 2               ;
000000r 2               ;
000000r 2               ; RAM vars
000000r 2               ;
000000r 2               PowerUpFrames				= $04	; Anywhere thats temporary
000000r 2               LastInputBits				= $075a ; Previously NumberOfLives
000000r 2               MenuSelection				= $077a ; Previously NumberOfPlayers
000000r 2               ;SaveStateFlags				= $07fc ; Previously WorldSelectEnableFlag
000000r 2               SavedEnterTimer				= $07f7
000000r 2               
000000r 2               STATUS_BAR_OFFSET = $02
000000r 2               RULE_COUNT_OFFSET = $0b
000000r 2               FRAME_NUMBER_OFFSET = $15
000000r 2               FRAMES_REMAIN_OFFSET = $0e
000000r 2               POSITION_OFFSET = $12
000000r 2               
000000r 2               
000000r 2               
000000r 1               		.include "mario.inc"
000000r 2               PPU_CTRL_REG1         = $2000
000000r 2               PPU_CTRL_REG2         = $2001
000000r 2               PPU_STATUS            = $2002
000000r 2               PPU_SPR_ADDR          = $2003
000000r 2               PPU_SPR_DATA          = $2004
000000r 2               PPU_SCROLL_REG        = $2005
000000r 2               PPU_ADDRESS           = $2006
000000r 2               PPU_DATA              = $2007
000000r 2               
000000r 2               SND_REGISTER          = $4000
000000r 2               SND_SQUARE1_REG       = $4000
000000r 2               SND_SQUARE2_REG       = $4004
000000r 2               SND_TRIANGLE_REG      = $4008
000000r 2               SND_NOISE_REG         = $400c
000000r 2               SND_DELTA_REG         = $4010
000000r 2               SND_MASTERCTRL_REG    = $4015
000000r 2               SND_VOLENV_REG        = $4080
000000r 2               SND_FDS0_REG          = $4040
000000r 2               SND_FDS1_REG          = $4041
000000r 2               SND_PULSE_4002_REG    = $4002
000000r 2               SND_PULSE_4003_REG    = $4003
000000r 2               SND_PULSE_4004_REG    = $4004
000000r 2               SND_PULSE_4005_REG    = $4005
000000r 2               SND_PULSE_4006_REG    = $4006
000000r 2               SND_TRIANGLE_400A_REG = $400A
000000r 2               SND_TRIANGLE_400B_REG = $400B
000000r 2               SND_NOISE_400E_REG    = $400E
000000r 2               SND_NOISE_400F_REG    = $400F
000000r 2               
000000r 2               SPR_DMA               = $4014
000000r 2               JOYPAD_PORT           = $4016
000000r 2               JOYPAD_PORT1          = $4016
000000r 2               JOYPAD_PORT2          = $4017
000000r 2               
000000r 2               ; GAME SPECIFIC DEFINES
000000r 2               
000000r 2               ObjectOffset          = $08
000000r 2               
000000r 2               FrameCounter          = $09
000000r 2               
000000r 2               SavedJoypadBits       = $06fc
000000r 2               SavedJoypad1Bits      = $06fc
000000r 2               SavedJoypad2Bits      = $06fd
000000r 2               JoypadBitMask         = $074a
000000r 2               JoypadOverride        = $0758
000000r 2               
000000r 2               A_B_Buttons           = $0a
000000r 2               PreviousA_B_Buttons   = $0d
000000r 2               Up_Down_Buttons       = $0b
000000r 2               Left_Right_Buttons    = $0c
000000r 2               
000000r 2               GameEngineSubroutine  = $0e
000000r 2               
000000r 2               Mirror_PPU_CTRL_REG1  = $0778
000000r 2               Mirror_PPU_CTRL_REG2  = $0779
000000r 2               
000000r 2               OperMode              = $0770
000000r 2               OperMode_Task         = $0772
000000r 2               ScreenRoutineTask     = $073c
000000r 2               
000000r 2               GamePauseStatus       = $0776
000000r 2               GamePauseTimer        = $0777
000000r 2               
000000r 2               DemoAction            = $0717
000000r 2               DemoActionTimer       = $0718
000000r 2               
000000r 2               TimerControl          = $0747
000000r 2               IntervalTimerControl  = $077f
000000r 2               
000000r 2               Timers                = $0780
000000r 2               SelectTimer           = $0780
000000r 2               PlayerAnimTimer       = $0781
000000r 2               JumpSwimTimer         = $0782
000000r 2               RunningTimer          = $0783
000000r 2               BlockBounceTimer      = $0784
000000r 2               SideCollisionTimer    = $0785
000000r 2               JumpspringTimer       = $0786
000000r 2               GameTimerCtrlTimer    = $0787
000000r 2               ClimbSideTimer        = $0789
000000r 2               EnemyFrameTimer       = $078a
000000r 2               FrenzyEnemyTimer      = $078f
000000r 2               BowserFireBreathTimer = $0790
000000r 2               StompTimer            = $0791
000000r 2               AirBubbleTimer        = $0792
000000r 2               ScrollIntervalTimer   = $0795
000000r 2               EnemyIntervalTimer    = $0796
000000r 2               BrickCoinTimer        = $079d
000000r 2               InjuryTimer           = $079e
000000r 2               StarInvincibleTimer   = $079f
000000r 2               ScreenTimer           = $07a0
000000r 2               WorldEndTimer         = $07a1
000000r 2               DemoTimer             = $07a2
000000r 2               
000000r 2               Sprite_Data           = $0200
000000r 2               
000000r 2               Sprite_Y_Position     = $0200
000000r 2               Sprite_Tilenumber     = $0201
000000r 2               Sprite_Attributes     = $0202
000000r 2               Sprite_X_Position     = $0203
000000r 2               
000000r 2               ScreenEdge_PageLoc    = $071a
000000r 2               ScreenEdge_X_Pos      = $071c
000000r 2               ScreenLeft_PageLoc    = $071a
000000r 2               ScreenRight_PageLoc   = $071b
000000r 2               ScreenLeft_X_Pos      = $071c
000000r 2               ScreenRight_X_Pos     = $071d
000000r 2               
000000r 2               PlayerFacingDir       = $33
000000r 2               DestinationPageLoc    = $34
000000r 2               VictoryWalkControl    = $35
000000r 2               ScrollFractional      = $0768
000000r 2               PrimaryMsgCounter     = $0719
000000r 2               SecondaryMsgCounter   = $0749
000000r 2               
000000r 2               HorizontalScroll      = $073f
000000r 2               VerticalScroll        = $0740
000000r 2               ScrollLock            = $0723
000000r 2               ScrollThirtyTwo       = $073d
000000r 2               Player_X_Scroll       = $06ff
000000r 2               Player_Pos_ForScroll  = $0755
000000r 2               ScrollAmount          = $0775
000000r 2               
000000r 2               AreaData              = $e7
000000r 2               AreaDataLow           = $e7
000000r 2               AreaDataHigh          = $e8
000000r 2               EnemyData             = $e9
000000r 2               EnemyDataLow          = $e9
000000r 2               EnemyDataHigh         = $ea
000000r 2               
000000r 2               AreaParserTaskNum     = $071f
000000r 2               ColumnSets            = $071e
000000r 2               CurrentPageLoc        = $0725
000000r 2               CurrentColumnPos      = $0726
000000r 2               BackloadingFlag       = $0728
000000r 2               BehindAreaParserFlag  = $0729
000000r 2               AreaObjectPageLoc     = $072a
000000r 2               AreaObjectPageSel     = $072b
000000r 2               AreaDataOffset        = $072c
000000r 2               AreaObjOffsetBuffer   = $072d
000000r 2               AreaObjectLength      = $0730
000000r 2               StaircaseControl      = $0734
000000r 2               AreaObjectHeight      = $0735
000000r 2               MushroomLedgeHalfLen  = $0736
000000r 2               EnemyDataOffset       = $0739
000000r 2               EnemyObjectPageLoc    = $073a
000000r 2               EnemyObjectPageSel    = $073b
000000r 2               MetatileBuffer        = $06a1
000000r 2               BlockBufferColumnPos  = $06a0
000000r 2               CurrentNTAddr_Low     = $0721
000000r 2               CurrentNTAddr_High    = $0720
000000r 2               AttributeBuffer       = $03f9
000000r 2               
000000r 2               LoopCommand           = $0745
000000r 2               
000000r 2               DisplayDigits         = $07d7
000000r 2               TopScoreDisplay       = $07d7
000000r 2               ScoreAndCoinDisplay   = $07dd
000000r 2               PlayerScoreDisplay    = $07dd
000000r 2               GameTimerDisplay      = $07f8
000000r 2               DigitModifier         = $0134
000000r 2               
000000r 2               VerticalFlipFlag      = $0109
000000r 2               FloateyNum_Control    = $0110
000000r 2               ShellChainCounter     = $0125
000000r 2               FloateyNum_Timer      = $012c
000000r 2               FloateyNum_X_Pos      = $0117
000000r 2               FloateyNum_Y_Pos      = $011e
000000r 2               FlagpoleFNum_Y_Pos    = $010d
000000r 2               FlagpoleFNum_YMFDummy = $010e
000000r 2               FlagpoleScore         = $010f
000000r 2               FlagpoleCollisionYPos = $070f
000000r 2               StompChainCounter     = $0484
000000r 2               
000000r 2               VRAM_Buffer1_Offset   = $0300
000000r 2               VRAM_Buffer1          = $0301
000000r 2               VRAM_Buffer2_Offset   = $0340
000000r 2               VRAM_Buffer2          = $0341
000000r 2               VRAM_Buffer_AddrCtrl  = $0773
000000r 2               Sprite0HitDetectFlag  = $0722
000000r 2               IRQUpdateFlag         = $0722
000000r 2               IRQAckFlag            = $077b
000000r 2               DisableScreenFlag     = $0774
000000r 2               DisableIntermediate   = $0769
000000r 2               ColorRotateOffset     = $06d4
000000r 2               
000000r 2               TerrainControl        = $0727
000000r 2               AreaStyle             = $0733
000000r 2               ForegroundScenery     = $0741
000000r 2               BackgroundScenery     = $0742
000000r 2               CloudTypeOverride     = $0743
000000r 2               BackgroundColorCtrl   = $0744
000000r 2               AreaType              = $074e
000000r 2               AreaAddrsLOffset      = $074f
000000r 2               AreaPointer           = $0750
000000r 2               
000000r 2               PlayerEntranceCtrl    = $0710
000000r 2               GameTimerSetting      = $0715
000000r 2               AltEntranceControl    = $0752
000000r 2               EntrancePage          = $0751
000000r 2               NumberOfPlayers       = $077a
000000r 2               UseNtBase2400 		  = $077a
000000r 2               WarpZoneControl       = $06d6
000000r 2               ChangeAreaTimer       = $06de
000000r 2               
000000r 2               MultiLoopCorrectCntr  = $06d9
000000r 2               MultiLoopPassCntr     = $06da
000000r 2               
000000r 2               FetchNewGameTimerFlag = $0757
000000r 2               GameTimerExpiredFlag  = $0759
000000r 2               
000000r 2               PrimaryHardMode       = $076a
000000r 2               SecondaryHardMode     = $06cc
000000r 2               WorldSelectNumber     = $076b
000000r 2               WorldSelectEnableFlag = $07fc
000000r 2               ContinueWorld         = $07fd
000000r 2               
000000r 2               .define IsPlayingLuigi CurrentPlayer
000000r 2               
000000r 2               CurrentPlayer         = $0753
000000r 2               PlayerSize            = $0754
000000r 2               PlayerStatus          = $0756
000000r 2               
000000r 2               ;OnscreenPlayerInfo    = $075a
000000r 2               ;NumberofLives         = $075a ;used by current player
000000r 2               HalfwayPage           = $075b
000000r 2               LevelNumber           = $075c ;the actual dash number
000000r 2               Hidden1UpFlag         = $075d
000000r 2               CoinTally             = $075e
000000r 2               WorldNumber           = $075f
000000r 2               AreaNumber            = $0760 ;internal number used to find areas
000000r 2               
000000r 2               CoinTallyFor1Ups      = $0748
000000r 2               
000000r 2               OffscreenPlayerInfo   = $0761
000000r 2               OffScr_NumberofLives  = $0761 ;used by offscreen player
000000r 2               OffScr_HalfwayPage    = $0762
000000r 2               OffScr_LevelNumber    = $0763
000000r 2               OffScr_Hidden1UpFlag  = $0764
000000r 2               OffScr_CoinTally      = $0765
000000r 2               OffScr_WorldNumber    = $0766
000000r 2               OffScr_AreaNumber     = $0767
000000r 2               
000000r 2               BalPlatformAlignment  = $03a0
000000r 2               Platform_X_Scroll     = $03a1
000000r 2               PlatformCollisionFlag = $03a2
000000r 2               YPlatformTopYPos      = $0401
000000r 2               YPlatformCenterYPos   = $58
000000r 2               
000000r 2               BrickCoinTimerFlag    = $06bc
000000r 2               StarFlagTaskControl   = $0746
000000r 2               
000000r 2               PseudoRandomBitReg    = $07a7
000000r 2               
000000r 2               SprShuffleAmtOffset   = $06e0
000000r 2               SprShuffleAmt         = $06e1
000000r 2               SprDataOffset         = $06e4
000000r 2               Player_SprDataOffset  = $06e4
000000r 2               Enemy_SprDataOffset   = $06e5
000000r 2               Block_SprDataOffset   = $06ec
000000r 2               Alt_SprDataOffset     = $06ec
000000r 2               Bubble_SprDataOffset  = $06ee
000000r 2               FBall_SprDataOffset   = $06f1
000000r 2               Misc_SprDataOffset    = $06f3
000000r 2               SprDataOffset_Ctrl    = $03ee
000000r 2               
000000r 2               Player_State          = $1d
000000r 2               Enemy_State           = $1e
000000r 2               Fireball_State        = $24
000000r 2               Block_State           = $26
000000r 2               Misc_State            = $2a
000000r 2               
000000r 2               Player_MovingDir      = $45
000000r 2               Enemy_MovingDir       = $46
000000r 2               
000000r 2               SprObject_X_Speed     = $57
000000r 2               Player_X_Speed        = $57
000000r 2               Enemy_X_Speed         = $58
000000r 2               Fireball_X_Speed      = $5e
000000r 2               Block_X_Speed         = $60
000000r 2               Misc_X_Speed          = $64
000000r 2               
000000r 2               Jumpspring_FixedYPos  = $58
000000r 2               JumpspringAnimCtrl    = $070e
000000r 2               JumpspringForce       = $06db
000000r 2               
000000r 2               SprObject_PageLoc     = $6d
000000r 2               Player_PageLoc        = $6d
000000r 2               Enemy_PageLoc         = $6e
000000r 2               Fireball_PageLoc      = $74
000000r 2               Block_PageLoc         = $76
000000r 2               Misc_PageLoc          = $7a
000000r 2               Bubble_PageLoc        = $83
000000r 2               
000000r 2               SprObject_X_Position  = $86
000000r 2               Player_X_Position     = $86
000000r 2               Enemy_X_Position      = $87
000000r 2               Fireball_X_Position   = $8d
000000r 2               Block_X_Position      = $8f
000000r 2               Misc_X_Position       = $93
000000r 2               Bubble_X_Position     = $9c
000000r 2               
000000r 2               SprObject_Y_Speed     = $9f
000000r 2               Player_Y_Speed        = $9f
000000r 2               Enemy_Y_Speed         = $a0
000000r 2               Fireball_Y_Speed      = $a6
000000r 2               Block_Y_Speed         = $a8
000000r 2               Misc_Y_Speed          = $ac
000000r 2               
000000r 2               SprObject_Y_HighPos   = $b5
000000r 2               Player_Y_HighPos      = $b5
000000r 2               Enemy_Y_HighPos       = $b6
000000r 2               Fireball_Y_HighPos    = $bc
000000r 2               Block_Y_HighPos       = $be
000000r 2               Misc_Y_HighPos        = $c2
000000r 2               Bubble_Y_HighPos      = $cb
000000r 2               
000000r 2               SprObject_Y_Position  = $ce
000000r 2               Player_Y_Position     = $ce
000000r 2               Enemy_Y_Position      = $cf
000000r 2               Fireball_Y_Position   = $d5
000000r 2               Block_Y_Position      = $d7
000000r 2               Misc_Y_Position       = $db
000000r 2               Bubble_Y_Position     = $e4
000000r 2               
000000r 2               SprObject_Rel_XPos    = $03ad
000000r 2               Player_Rel_XPos       = $03ad
000000r 2               Enemy_Rel_XPos        = $03ae
000000r 2               Fireball_Rel_XPos     = $03af
000000r 2               Bubble_Rel_XPos       = $03b0
000000r 2               Block_Rel_XPos        = $03b1
000000r 2               Misc_Rel_XPos         = $03b3
000000r 2               
000000r 2               SprObject_Rel_YPos    = $03b8
000000r 2               Player_Rel_YPos       = $03b8
000000r 2               Enemy_Rel_YPos        = $03b9
000000r 2               Fireball_Rel_YPos     = $03ba
000000r 2               Bubble_Rel_YPos       = $03bb
000000r 2               Block_Rel_YPos        = $03bc
000000r 2               Misc_Rel_YPos         = $03be
000000r 2               
000000r 2               SprObject_SprAttrib   = $03c4
000000r 2               Player_SprAttrib      = $03c4
000000r 2               Enemy_SprAttrib       = $03c5
000000r 2               
000000r 2               SprObject_X_MoveForce = $0400
000000r 2               Enemy_X_MoveForce     = $0401
000000r 2               
000000r 2               SprObject_YMF_Dummy   = $0416
000000r 2               Player_YMF_Dummy      = $0416
000000r 2               Enemy_YMF_Dummy       = $0417
000000r 2               Bubble_YMF_Dummy      = $042c
000000r 2               
000000r 2               SprObject_Y_MoveForce = $0433
000000r 2               Player_Y_MoveForce    = $0433
000000r 2               Enemy_Y_MoveForce     = $0434
000000r 2               Block_Y_MoveForce     = $043c
000000r 2               
000000r 2               DisableCollisionDet   = $0716
000000r 2               Player_CollisionBits  = $0490
000000r 2               Enemy_CollisionBits   = $0491
000000r 2               
000000r 2               SprObj_BoundBoxCtrl   = $0499
000000r 2               Player_BoundBoxCtrl   = $0499
000000r 2               Enemy_BoundBoxCtrl    = $049a
000000r 2               Fireball_BoundBoxCtrl = $04a0
000000r 2               Misc_BoundBoxCtrl     = $04a2
000000r 2               
000000r 2               EnemyFrenzyBuffer     = $06cb
000000r 2               EnemyFrenzyQueue      = $06cd
000000r 2               Enemy_Flag            = $0f
000000r 2               Enemy_ID              = $16
000000r 2               
000000r 2               PlayerGfxOffset       = $06d5
000000r 2               Player_XSpeedAbsolute = $0700
000000r 2               FrictionAdderHigh     = $0701
000000r 2               FrictionAdderLow      = $0702
000000r 2               RunningSpeed          = $0703
000000r 2               SwimmingFlag          = $0704
000000r 2               Player_X_MoveForce    = $0705
000000r 2               DiffToHaltJump        = $0706
000000r 2               JumpOrigin_Y_HighPos  = $0707
000000r 2               JumpOrigin_Y_Position = $0708
000000r 2               VerticalForce         = $0709
000000r 2               VerticalForceDown     = $070a
000000r 2               PlayerChangeSizeFlag  = $070b
000000r 2               PlayerAnimTimerSet    = $070c
000000r 2               PlayerAnimCtrl        = $070d
000000r 2               DeathMusicLoaded      = $0712
000000r 2               FlagpoleSoundQueue    = $0713
000000r 2               CrouchingFlag         = $0714
000000r 2               MaximumLeftSpeed      = $0450
000000r 2               MaximumRightSpeed     = $0456
000000r 2               
000000r 2               SprObject_OffscrBits  = $03d0
000000r 2               Player_OffscreenBits  = $03d0
000000r 2               Enemy_OffscreenBits   = $03d1
000000r 2               FBall_OffscreenBits   = $03d2
000000r 2               Bubble_OffscreenBits  = $03d3
000000r 2               Block_OffscreenBits   = $03d4
000000r 2               Misc_OffscreenBits    = $03d6
000000r 2               EnemyOffscrBitsMasked = $03d8
000000r 2               
000000r 2               Cannon_Offset         = $046a
000000r 2               Cannon_PageLoc        = $046b
000000r 2               Cannon_X_Position     = $0471
000000r 2               Cannon_Y_Position     = $0477
000000r 2               Cannon_Timer          = $047d
000000r 2               
000000r 2               Whirlpool_Offset      = $046a
000000r 2               Whirlpool_PageLoc     = $046b
000000r 2               Whirlpool_LeftExtent  = $0471
000000r 2               Whirlpool_Length      = $0477
000000r 2               Whirlpool_Flag        = $047d
000000r 2               
000000r 2               VineFlagOffset        = $0398
000000r 2               VineHeight            = $0399
000000r 2               VineObjOffset         = $039a
000000r 2               VineStart_Y_Position  = $039d
000000r 2               
000000r 2               Block_Orig_YPos       = $03e4
000000r 2               Block_BBuf_Low        = $03e6
000000r 2               Block_Metatile        = $03e8
000000r 2               Block_PageLoc2        = $03ea
000000r 2               Block_RepFlag         = $03ec
000000r 2               Block_ResidualCounter = $03f0
000000r 2               Block_Orig_XPos       = $03f1
000000r 2               
000000r 2               BoundingBox_UL_XPos   = $04ac
000000r 2               BoundingBox_UL_YPos   = $04ad
000000r 2               BoundingBox_DR_XPos   = $04ae
000000r 2               BoundingBox_DR_YPos   = $04af
000000r 2               BoundingBox_UL_Corner = $04ac
000000r 2               BoundingBox_LR_Corner = $04ae
000000r 2               EnemyBoundingBoxCoord = $04b0
000000r 2               
000000r 2               PowerUpType           = $39
000000r 2               
000000r 2               FireballBouncingFlag  = $3a
000000r 2               FireballCounter       = $06ce
000000r 2               FireballThrowingTimer = $0711
000000r 2               
000000r 2               HammerEnemyOffset     = $06ae
000000r 2               JumpCoinMiscOffset    = $06b7
000000r 2               
000000r 2               Block_Buffer_1        = $0500
000000r 2               Block_Buffer_2        = $05d0
000000r 2               
000000r 2               HammerThrowingTimer   = $03a2
000000r 2               HammerBroJumpTimer    = $3c
000000r 2               Misc_Collision_Flag   = $06be
000000r 2               
000000r 2               RedPTroopaOrigXPos    = $0401
000000r 2               RedPTroopaCenterYPos  = $58
000000r 2               
000000r 2               XMovePrimaryCounter   = $a0
000000r 2               XMoveSecondaryCounter = $58
000000r 2               
000000r 2               CheepCheepMoveMFlag   = $58
000000r 2               CheepCheepOrigYPos    = $0434
000000r 2               BitMFilter            = $06dd
000000r 2               
000000r 2               LakituReappearTimer   = $06d1
000000r 2               LakituMoveSpeed       = $58
000000r 2               LakituMoveDirection   = $a0
000000r 2               
000000r 2               FirebarSpinState_Low  = $58
000000r 2               FirebarSpinState_High = $a0
000000r 2               FirebarSpinSpeed      = $0388
000000r 2               FirebarSpinDirection  = $34
000000r 2               
000000r 2               DuplicateObj_Offset   = $06cf
000000r 2               NumberofGroupEnemies  = $06d3
000000r 2               
000000r 2               BlooperMoveCounter    = $a0
000000r 2               BlooperMoveSpeed      = $58
000000r 2               
000000r 2               BowserBodyControls    = $0363
000000r 2               BowserFeetCounter     = $0364
000000r 2               BowserMovementSpeed   = $0365
000000r 2               BowserOrigXPos        = $0366
000000r 2               BowserFlameTimerCtrl  = $0367
000000r 2               BowserFront_Offset    = $0368
000000r 2               BridgeCollapseOffset  = $0369
000000r 2               BowserGfxFlag         = $036a
000000r 2               BowserHitPoints       = $0483
000000r 2               MaxRangeFromOrigin    = $06dc
000000r 2               
000000r 2               BowserFlamePRandomOfs = $0417
000000r 2               
000000r 2               PiranhaPlantUpYPos    = $0417
000000r 2               PiranhaPlantDownYPos  = $0434
000000r 2               PiranhaPlant_Y_Speed  = $58
000000r 2               PiranhaPlant_MoveFlag = $a0
000000r 2               
000000r 2               FireworksCounter      = $06d7
000000r 2               ExplosionGfxCounter   = $58
000000r 2               ExplosionTimerCounter = $a0
000000r 2               
000000r 2               ;sound related defines
000000r 2               Squ2_NoteLenBuffer    = $07b3
000000r 2               Squ2_NoteLenCounter   = $07b4
000000r 2               Squ2_EnvelopeDataCtrl = $07b5
000000r 2               Squ1_NoteLenCounter   = $07b6
000000r 2               Squ1_EnvelopeDataCtrl = $07b7
000000r 2               Tri_NoteLenBuffer     = $07b8
000000r 2               Tri_NoteLenCounter    = $07b9
000000r 2               Noise_BeatLenCounter  = $07ba
000000r 2               Squ1_SfxLenCounter    = $07bb
000000r 2               Squ2_SfxLenCounter    = $07bd
000000r 2               Sfx_SecondaryCounter  = $07be
000000r 2               Noise_SfxLenCounter   = $07bf
000000r 2               
000000r 2               PauseSoundQueue       = $fa
000000r 2               Square1SoundQueue     = $ff
000000r 2               Square2SoundQueue     = $fe
000000r 2               NoiseSoundQueue       = $fd
000000r 2               AreaMusicQueue        = $fb
000000r 2               EventMusicQueue       = $fc
000000r 2               
000000r 2               Square1SoundBuffer    = $f1
000000r 2               Square2SoundBuffer    = $f2
000000r 2               NoiseSoundBuffer      = $f3
000000r 2               AreaMusicBuffer       = $f4
000000r 2               EventMusicBuffer      = $07b1
000000r 2               PauseSoundBuffer      = $07b2
000000r 2               
000000r 2               MusicData             = $f5
000000r 2               MusicDataLow          = $f5
000000r 2               MusicDataHigh         = $f6
000000r 2               MusicOffset_Square2   = $f7
000000r 2               MusicOffset_Square1   = $f8
000000r 2               MusicOffset_Triangle  = $f9
000000r 2               MusicOffset_Noise     = $07b0
000000r 2               
000000r 2               NoteLenLookupTblOfs   = $f0
000000r 2               DAC_Counter           = $07c0
000000r 2               NoiseDataLoopbackOfs  = $07c1
000000r 2               NoteLengthTblAdder    = $07c4
000000r 2               AreaMusicBuffer_Alt   = $07c5
000000r 2               PauseModeFlag         = $07c6
000000r 2               GroundMusicHeaderOfs  = $07c7
000000r 2               AltRegContentFlag     = $07ca
000000r 2               
000000r 2               ;-------------------------------------------------------------------------------------
000000r 2               ;CONSTANTS
000000r 2               
000000r 2               ;sound effects constants
000000r 2               Sfx_SmallJump         = %10000000
000000r 2               Sfx_Flagpole          = %01000000
000000r 2               Sfx_Fireball          = %00100000
000000r 2               Sfx_PipeDown_Injury   = %00010000
000000r 2               Sfx_EnemySmack        = %00001000
000000r 2               Sfx_EnemyStomp        = %00000100
000000r 2               Sfx_Bump              = %00000010
000000r 2               Sfx_BigJump           = %00000001
000000r 2               
000000r 2               Sfx_BowserFall        = %10000000
000000r 2               Sfx_ExtraLife         = %01000000
000000r 2               Sfx_PowerUpGrab       = %00100000
000000r 2               Sfx_TimerTick         = %00010000
000000r 2               Sfx_Blast             = %00001000
000000r 2               Sfx_GrowVine          = %00000100
000000r 2               Sfx_GrowPowerUp       = %00000010
000000r 2               Sfx_CoinGrab          = %00000001
000000r 2               
000000r 2               Sfx_BowserFlame       = %00000010
000000r 2               Sfx_BrickShatter      = %00000001
000000r 2               
000000r 2               ;music constants
000000r 2               Silence               = %10000000
000000r 2               
000000r 2               StarPowerMusic        = %01000000
000000r 2               PipeIntroMusic        = %00100000
000000r 2               CloudMusic            = %00010000
000000r 2               CastleMusic           = %00001000
000000r 2               UndergroundMusic      = %00000100
000000r 2               WaterMusic            = %00000010
000000r 2               GroundMusic           = %00000001
000000r 2               
000000r 2               TimeRunningOutMusic   = %01000000
000000r 2               EndOfLevelMusic       = %00100000
000000r 2               AltGameOverMusic      = %00010000
000000r 2               EndOfCastleMusic      = %00001000
000000r 2               VictoryMusic          = %00000100
000000r 2               GameOverMusic         = %00000010
000000r 2               DeathMusic            = %00000001
000000r 2               
000000r 2               ;enemy object constants
000000r 2               GreenKoopa            = $00
000000r 2               BuzzyBeetle           = $02
000000r 2               RedKoopa              = $03
000000r 2               HammerBro             = $05
000000r 2               Goomba                = $06
000000r 2               Bloober               = $07
000000r 2               BulletBill_FrenzyVar  = $08
000000r 2               GreyCheepCheep        = $0a
000000r 2               RedCheepCheep         = $0b
000000r 2               Podoboo               = $0c
000000r 2               PiranhaPlant          = $0d
000000r 2               GreenParatroopaJump   = $0e
000000r 2               RedParatroopa         = $0f
000000r 2               GreenParatroopaFly    = $10
000000r 2               Lakitu                = $11
000000r 2               Spiny                 = $12
000000r 2               FlyCheepCheepFrenzy   = $14
000000r 2               FlyingCheepCheep      = $14
000000r 2               BowserFlame           = $15
000000r 2               Fireworks             = $16
000000r 2               BBill_CCheep_Frenzy   = $17
000000r 2               Stop_Frenzy           = $18
000000r 2               Bowser                = $2d
000000r 2               PowerUpObject         = $2e
000000r 2               VineObject            = $2f
000000r 2               FlagpoleFlagObject    = $30
000000r 2               StarFlagObject        = $31
000000r 2               JumpspringObject      = $32
000000r 2               BulletBill_CannonVar  = $33
000000r 2               RetainerObject        = $35
000000r 2               TallEnemy             = $09
000000r 2               
000000r 2               ;other constants
000000r 2               World1 = 0
000000r 2               World2 = 1
000000r 2               World3 = 2
000000r 2               World4 = 3
000000r 2               World5 = 4
000000r 2               World6 = 5
000000r 2               World7 = 6
000000r 2               World8 = 7
000000r 2               Level1 = 0
000000r 2               Level2 = 1
000000r 2               Level3 = 2
000000r 2               Level4 = 3
000000r 2               
000000r 2               WarmBootOffset        = <$07d6
000000r 2               ColdBootOffset        = <$07fe
000000r 2               TitleScreenDataOffset = $1ec0
000000r 2               SoundMemory           = $07b0
000000r 2               
000000r 2               .define SwimTileRepOffset		PlayerGraphicsTable + $9e
000000r 2               .define MusicHeaderOffsetData	MusicHeaderData - 1
000000r 2               .define MHD 					MusicHeaderData
000000r 2               
000000r 2               A_Button              = %10000000
000000r 2               B_Button              = %01000000
000000r 2               Select_Button         = %00100000
000000r 2               Start_Button          = %00010000
000000r 2               Up_Dir                = %00001000
000000r 2               Down_Dir              = %00000100
000000r 2               Left_Dir              = %00000010
000000r 2               Right_Dir             = %00000001
000000r 2               
000000r 2               TitleScreenModeValue  = 0
000000r 2               GameModeValue         = 1
000000r 2               VictoryModeValue      = 2
000000r 2               GameOverModeValue     = 3
000000r 2               
000000r 1               		.include "macros.inc"
000000r 2               .macro lsr_by n
000000r 2               	.repeat n, i
000000r 2               		lsr
000000r 2               	.endrep
000000r 2               .endmacro
000000r 2               
000000r 2               .macro DoUpdateSockHash
000000r 2               		.local @dont_render
000000r 2               		lda WRAM_PracticeFlags
000000r 2               		and #PF_SockMode
000000r 2               		bne @dont_render
000000r 2               		lda IntervalTimerControl
000000r 2               		and #3
000000r 2               		cmp #2
000000r 2               		bne @dont_render
000000r 2               		jsr Enter_ForceUpdateSockHash
000000r 2               	@dont_render:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro practice_callgate
000000r 2               	.res $FE00 - *, $EA
000000r 2               
000000r 2               	Enter_EndOfCastle:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp EndOfCastle
000000r 2               
000000r 2               	Enter_RenderIntermediateTime:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp RenderIntermediateTime
000000r 2               
000000r 2               	Enter_FrameToTime:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp FrameToTime
000000r 2               
000000r 2               	Enter_UpdateGameTimer:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp UpdateGameTimer
000000r 2               
000000r 2               	Enter_InitializeWRAM:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp InitializeWRAM
000000r 2               
000000r 2               	Enter_SetDefaultWRAM:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp SetDefaultWRAM
000000r 2               
000000r 2               	Enter_FactoryResetWRAM:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp FactoryResetWRAM
000000r 2               
000000r 2               	Enter_RedrawSockTimer:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp RedrawSockTimer
000000r 2               
000000r 2               	Enter_PracticeInit:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp PracticeInit
000000r 2               
000000r 2               	Enter_ForceUpdateSockHash:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp ForceUpdateSockHash
000000r 2               
000000r 2               	Enter_PracticeOnFrame:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp PracticeOnFrame
000000r 2               
000000r 2               	Enter_PracticeTitleMenu:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp PracticeTitleMenu
000000r 2               
000000r 2               	Enter_UpdateFrameRule:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp UpdateFrameRule
000000r 2               
000000r 2               	Enter_WritePracticeTop:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp WritePracticeTop
000000r 2               
000000r 2               	Enter_RedrawUserVars:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp RedrawUserVars
000000r 2               
000000r 2               	Enter_RedrawAll:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp RedrawAll
000000r 2               
000000r 2               	Enter_RedrawFrameNumbers:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp RedrawFrameNumbers
000000r 2               
000000r 2               	Enter_ProcessLevelLoad:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp ProcessLevelLoad
000000r 2               
000000r 2               	Enter_LoadPhysicsData:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp LoadPhysicsData
000000r 2               
000000r 2               	Enter_LoadMarioPhysics:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp LoadMarioPhysics
000000r 2               
000000r 2               	Enter_LL_LoadWarpzone:
000000r 2               		lda #BANK_LLDATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp LoadWarpzone
000000r 2               
000000r 2               	Enter_LL_GetAreaDataAddrs:
000000r 2               		lda #BANK_LLDATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp GetAreaDataAddrs
000000r 2               
000000r 2               	Enter_LL_LoadAreaPointer:
000000r 2               		lda #BANK_LLDATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp LoadAreaPointer
000000r 2               
000000r 2               	Enter_LL_WriteHalfwayPages:
000000r 2               		lda #BANK_LLDATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp WriteHalfwayPages
000000r 2               
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro scenarios_callgate
000000r 2               	.res $FE00 - *, $EA
000000r 2               	Enter_ScenLoadArea:
000000r 2               		lda #BANK_SCEN_DATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp ScenLoadArea
000000r 2               
000000r 2               	Enter_ScenReset:
000000r 2               		lda #BANK_SCEN_DATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp ScenReset
000000r 2               
000000r 2               	Enter_ScenUpdateSelected:
000000r 2               		lda #BANK_SCEN_DATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp ScenUpdateSelected
000000r 2               
000000r 2               	Enter_ScenValidate:
000000r 2               		lda #BANK_SCEN_DATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp ScenValidate
000000r 2               
000000r 2               .endmacro
000000r 2               
000000r 2               MMC5_PRGMode          = $5100
000000r 2               MMC5_CHRMode          = $5101
000000r 2               MMC5_RAMProtect1      = $5102
000000r 2               MMC5_RAMProtect2      = $5103
000000r 2               MMC5_ExRamMode        = $5104
000000r 2               MMC5_Nametables       = $5105
000000r 2               MMC5_FillTile         = $5106
000000r 2               MMC5_CHRBank          = $5120
000000r 2               MMC5_PRGBank          = $5113
000000r 2               MMC5_VSplitMode       = $5200
000000r 2               MMC5_VSplitScroll     = $5201
000000r 2               MMC5_VSplitBank       = $5202
000000r 2               MMC5_SLCompare        = $5203
000000r 2               MMC5_SLIRQ            = $5204
000000r 2               MMC5_ExRamOfs         = $3C00
000000r 2               
000000r 2               ;
000000r 2               ; Lower banks
000000r 2               ;
000000r 2               .macro control_bank
000000r 2               	.res $FF00 - *, $EA
000000r 2               
000000r 2               	Enter_SoundEngine:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp SoundEngineExternal
000000r 2               
000000r 2               	ReturnBank:
000000r 2               		lda BANK_SELECTED
000000r 2               		jmp SetBankFromA
000000r 2               
000000r 2               	SetChrBank0FromA:
000000r 2               		sta MMC5_CHRBank+3
000000r 2               		rts
000000r 2               
000000r 2               	SetChrBank1FromA:
000000r 2               		sta MMC5_CHRBank+7
000000r 2               		rts
000000r 2               
000000r 2               	SetChrBanksFromAX:
000000r 2               		jsr SetChrBank0FromA
000000r 2               		txa
000000r 2               		jmp SetChrBank1FromA
000000r 2               
000000r 2               	SetBankFromA:
000000r 2               		clc
000000r 2               		ora #$82			; mark as prg-rom
000000r 2               		sta MMC5_PRGBank+4
000000r 2               		rts
000000r 2               
000000r 2               	MapperReset:
000000r 2               		;
000000r 2               		; clear mapper state
000000r 2               		;
000000r 2               		sei
000000r 2               		cld ;absolutely useless :)
000000r 2               		ldx #$FF
000000r 2               		txs
000000r 2               		lda #%01000000         ; disable apu irq
000000r 2               		sta $4017
000000r 2               		lda #%10
000000r 2               		sta MMC5_RAMProtect1
000000r 2               		lda #%01
000000r 2               		sta MMC5_RAMProtect2
000000r 2               		lda #1
000000r 2               		sta MMC5_CHRMode       ; use 1kb chr banking
000000r 2               		lda #0
000000r 2               		sta MMC5_PRGMode       ; use 32kb prg banking
000000r 2               		lsr a
000000r 2               		sta MMC5_PRGBank       ; use bank 0 for prg-ram
000000r 2               		lda #%11
000000r 2               		sta MMC5_ExRamMode
000000r 2               		lda #BANK_LOADER
000000r 2               		sta BANK_SELECTED
000000r 2               		jsr SetBankFromA       ; set startup bank
000000r 2               		lda #$44
000000r 2               		sta MMC5_Nametables    ; set vertical mirroring
000000r 2               		jmp $8000
000000r 2               
000000r 2               	StartBank:
000000r 2               		;
000000r 2               		; 0 Bank selected
000000r 2               		;
000000r 2               		sta BANK_SELECTED
000000r 2               		ldx #$00
000000r 2               		stx PPU_CTRL_REG1
000000r 2               		stx PPU_CTRL_REG2
000000r 2               		jsr SetBankFromA
000000r 2               		jmp Start
000000r 2               
000000r 2               	IRQ:
000000r 2               		sei
000000r 2               		php
000000r 2               		pha
000000r 2               		lda MMC5_SLIRQ
000000r 2               		lda Mirror_PPU_CTRL_REG1      ; waste some time to get to the end of the scanline
000000r 2               		lda Mirror_PPU_CTRL_REG1      ; waste some time to get to the end of the scanline
000000r 2               		lda Mirror_PPU_CTRL_REG1      ; waste some time to get to the end of the scanline
000000r 2               		lda Mirror_PPU_CTRL_REG1
000000r 2               		and #%11110110           ;mask out sprite address and nametable
000000r 2               		ora UseNtBase2400
000000r 2               		sta Mirror_PPU_CTRL_REG1      ;update the register and its mirror
000000r 2               		sta PPU_CTRL_REG1
000000r 2               		lda HorizontalScroll
000000r 2               		sta PPU_SCROLL_REG           ;set scroll regs for the screen under the status bar
000000r 2               		lda #$00
000000r 2               		sta PPU_SCROLL_REG
000000r 2               		sta IRQAckFlag           ;indicate IRQ was acknowledged
000000r 2               		tya                      ; waste some time to match 2j irq
000000r 2               		ldy #$18                 ; ...
000000r 2               	:   dey                      ; ...
000000r 2               		bne :-                   ; ...
000000r 2               		tay                      ; ...
000000r 2               		pla
000000r 2               		plp
000000r 2               		cli
000000r 2               		rti
000000r 2               
000000r 2               		.res $FFFA - *, $ea
000000r 2               		;
000000r 2               		; Interrupt table
000000r 2               		;
000000r 2               		.word NonMaskableInterrupt
000000r 2               		.word MapperReset
000000r 2               		.word IRQ
000000r 2               
000000r 2               .endmacro
000000r 2               
000000r 1               		.include "wram.inc"
000000r 2               ;
000000r 2               ; ramvars.inc is auto-generated from ram_region.asm
000000r 2               ; don't alter directly. bad idea. very bad idea.
000000r 2               ;
000000r 2               WRAM_StartAddress = $6000
000000r 2               WRAM_Magic = $6000
000000r 2               WRAM_MenuIndex = $6004
000000r 2               WRAM_PracticeFlags = $6005
000000r 2               WRAM_CharSet = $6006
000000r 2               WRAM_DelaySaveFrames = $6007
000000r 2               WRAM_DelayUserFrames = $6008
000000r 2               WRAM_SaveFramesLeft = $6009
000000r 2               WRAM_UserFramesLeft = $600A
000000r 2               WRAM_SaveStateBank = $600B
000000r 2               WRAM_DisableMusic = $600C
000000r 2               WRAM_DisableSound = $600D
000000r 2               WRAM_SaveButtons = $600E
000000r 2               WRAM_LoadButtons = $600F
000000r 2               WRAM_TitleButtons = $6010
000000r 2               WRAM_RestartButtons = $6011
000000r 2               WRAM_SlowMotion = $6012
000000r 2               WRAM_SlowMotionLeft = $6013
000000r 2               WRAM_ToSaveFile = $6014
000000r 2               WRAM_LoadedLevel = $6014
000000r 2               WRAM_LoadedWorld = $6015
000000r 2               WRAM_LevelAreaPointer = $6016
000000r 2               WRAM_LevelAreaType = $6017
000000r 2               WRAM_LevelIntervalTimerControl = $6018
000000r 2               WRAM_LevelFrameCounter = $6019
000000r 2               WRAM_LevelPlayerStatus = $601A
000000r 2               WRAM_LevelPlayerSize = $601B
000000r 2               WRAM_EntrySockTimer = $601C
000000r 2               WRAM_LevelRandomData = $601D
000000r 2               WRAM_LevelFrameRuleData = $6024
000000r 2               WRAM_EnemyData = $6028
000000r 2               WRAM_LevelData = $6094
000000r 2               WRAM_IsContraMode = $6194
000000r 2               WRAM_Temp = $6196
000000r 2               WRAM_OrgUser0 = $61FA
000000r 2               WRAM_OrgUser1 = $61FC
000000r 2               WRAM_LostUser0 = $61FE
000000r 2               WRAM_LostUser1 = $6200
000000r 2               WRAM_OrgRules = $6202
000000r 2               WRAM_LostRules = $6282
000000r 2               WRAM_OrgTimes = $6352
000000r 2               WRAM_OrgTimesEnd = $6392
000000r 2               WRAM_LostTimes = $6392
000000r 2               WRAM_LostTimesEnd = $63D2
000000r 2               WRAM_ExtTimes = $63D2
000000r 2               WRAM_ExtTimesEnd = $63FA
000000r 2               WRAM_Timer = $63FA
000000r 2               WRAM_PrettyTime = $63FC
000000r 2               WRAM_PrettyTimeMin = $63FC
000000r 2               WRAM_PrettyTimeSec = $63FD
000000r 2               WRAM_PrettyTimeFrac = $63FE
000000r 2               WRAM_LostStart = $63FF
000000r 2               WRAM_LeafY = $63FF
000000r 2               WRAM_LeafX = $640B
000000r 2               WRAM_PlayerColors = $6417
000000r 2               WRAM_JumpMForceData = $641F
000000r 2               WRAM_FallMForceData = $6426
000000r 2               WRAM_FrictionData = $642D
000000r 2               WRAM_EnemyAttributeData = $6430
000000r 2               WRAM_PiranhaPlantAttributeData = $643D
000000r 2               WRAM_UnknownAttributeData0 = $6448
000000r 2               WRAM_UnknownAttributeData1 = $6449
000000r 2               WRAM_UnknownAttributeData2 = $644A
000000r 2               WRAM_MushroomSelection = $644B
000000r 2               WRAM_SelectMario = $644E
000000r 2               WRAM_SelectLuigi = $6450
000000r 2               WRAM_PiranhaPlantDist = $6452
000000r 2               WRAM_HalfwayPageNybbles = $6453
000000r 2               WRAM_LostEnd = $6465
000000r 2               WRAM_SaveLost = $6465
000000r 2               WRAM_SaveRAM = $64CB
000000r 2               WRAM_SaveWRAM = $6CCB
000000r 2               WRAM_SaveLevel = $6D4B
000000r 2               WRAM_SaveNT = $6E4B
000000r 2               WRAM_SavePAL = $764B
000000r 2               WRAM_StoredInputs = $766B
000000r 2               FrameRuleData = $7676
000000r 2               
000000r 1               		.include "text.inc"
000000r 2               .ifndef __TEXT_INC_DEF__
000000r 2               .define __TEXT_INC_DEF__
000000r 2               
000000r 2               .charmap '0', 0
000000r 2               .charmap '1', 1
000000r 2               .charmap '2', 2
000000r 2               .charmap '3', 3
000000r 2               .charmap '4', 4
000000r 2               .charmap '5', 5
000000r 2               .charmap '6', 6
000000r 2               .charmap '7', 7
000000r 2               .charmap '8', 8
000000r 2               .charmap '9', 9
000000r 2               .charmap 'A', $0A
000000r 2               .charmap 'B', $0B
000000r 2               .charmap 'C', $0C
000000r 2               .charmap 'D', $0D
000000r 2               .charmap 'E', $0E
000000r 2               .charmap 'F', $0F
000000r 2               .charmap 'G', $10
000000r 2               .charmap 'H', $11
000000r 2               .charmap 'I', $12
000000r 2               .charmap 'J', $13
000000r 2               .charmap 'K', $14
000000r 2               .charmap 'L', $15
000000r 2               .charmap 'M', $16
000000r 2               .charmap 'N', $17
000000r 2               .charmap 'O', $18
000000r 2               .charmap 'P', $19
000000r 2               .charmap 'Q', $1a
000000r 2               .charmap 'R', $1b
000000r 2               .charmap 'S', $1c
000000r 2               .charmap 'T', $1d
000000r 2               .charmap 'U', $1e
000000r 2               .charmap 'V', $1f
000000r 2               .charmap 'W', $20
000000r 2               .charmap 'X', $21
000000r 2               .charmap 'Y', $22
000000r 2               .charmap 'Z', $23
000000r 2               .charmap '-', $28
000000r 2               .charmap '!', $2b
000000r 2               .charmap '*', $29
000000r 2               .charmap ' ', $24
000000r 2               .charmap '.', $2a
000000r 2               .charmap ':', $28
000000r 2               
000000r 2               .macro text_block at, txt
000000r 2               	.byte at >> 8
000000r 2               	.byte at & $ff
000000r 2               	.byte .strlen(txt)
000000r 2               	.byte txt
000000r 2               .endmacro
000000r 2               
000000r 2               .macro inline_write_block name
000000r 2               	.local @more_bytes
000000r 2               	ldx #0
000000r 2               	ldy VRAM_Buffer1_Offset
000000r 2               @more_bytes:
000000r 2               	lda name, x
000000r 2               	sta VRAM_Buffer1, y
000000r 2               	inx
000000r 2               	iny
000000r 2               	cmp #0
000000r 2               	bne @more_bytes
000000r 2               	dey
000000r 2               	sty VRAM_Buffer1_Offset
000000r 2               .endmacro
000000r 2               
000000r 2               .endif
000000r 2               
000000r 2               
000000r 2               
000000r 2               
000000r 1               		.org $8000
008000  1               		.segment "bank3"
008000  1               
008000  1               Start:
008000  1  A9 10                     lda #%00010000               ;init PPU control register 1
008002  1  8D 00 20                  sta PPU_CTRL_REG1
008005  1  A9 00                     lda #0
008007  1  8D 01 20                  sta PPU_CTRL_REG2
00800A  1  A2 FF                     ldx #$ff                     ;reset stack pointer
00800C  1  9A                        txs
00800D  1  AD 02 20     VBlank1:     lda PPU_STATUS               ;wait two frames
008010  1  10 FB                     bpl VBlank1
008012  1  AD 02 20     VBlank2:     lda PPU_STATUS
008015  1  10 FB                     bpl VBlank2
008017  1  A0 FE                     ldy #ColdBootOffset          ;load default cold boot pointer
008019  1  20 AC BA     ColdBoot:    jsr InitializeMemory         ;clear memory using pointer in Y
00801C  1  8D 11 40                  sta SND_DELTA_REG+1          ;reset delta counter load register
00801F  1  8D 70 07                  sta OperMode                 ;reset primary mode of operation
008022  1  A9 A5                     lda #$a5                     ;set warm boot flag
008024  1  8D A7 07                  sta PseudoRandomBitReg       ;set seed for pseudorandom register
008027  1               
008027  1  20 40 FE                  jsr Enter_PracticeInit
00802A  1               
00802A  1  A9 00                     lda #CHR_ORG_SPR
00802C  1  AC 94 61                  ldy WRAM_IsContraMode
00802F  1  F0 02                     beq @not_peach
008031  1  A9 06                     lda #CHR_PEACH_SPR
008033  1               @not_peach:
008033  1  A2 01                     ldx #CHR_ORG_BG
008035  1  AC 06 60                  ldy WRAM_CharSet
008038  1  C0 02                     cpy #2
00803A  1  D0 02                     bne @not_lost
00803C  1  A2 02                     ldx #CHR_ORG_BG_ALTFONT
00803E  1               @not_lost:
00803E  1  20 16 FF                  jsr SetChrBanksFromAX
008041  1               
008041  1  A9 0F                     lda #%00001111
008043  1  8D 15 40                  sta SND_MASTERCTRL_REG       ;enable all sound channels except dmc
008046  1  A9 06                     lda #%00000110
008048  1  8D 01 20                  sta PPU_CTRL_REG2            ;turn off clipping for OAM and background
00804B  1  20 3E BC                  jsr MoveAllSpritesOffscreen
00804E  1  20 FB BB                  jsr InitializeNameTables     ;initialize both name tables
008051  1  EE 74 07                  inc DisableScreenFlag        ;set flag to disable screen output
008054  1  AD 78 07                  lda Mirror_PPU_CTRL_REG1
008057  1  09 80                     ora #%10000000               ;enable NMIs
008059  1  20 2C BB                  jsr WritePPUReg1
00805C  1  4C 5C 80     EndlessLoop: jmp EndlessLoop              ;endless loop, need I say more?
00805F  1               
00805F  1               
00805F  1               ;-----------------------------------------------------------------
00805F  1               
00805F  1  AD 79 07 8D  MACRO_ThrowFrameImpl
008063  1  01 20 AD 78  
008067  1  07 29 FC 8D  
00810A  1               
00810A  1               NonMaskableInterrupt:
00810A  1  AD 78 07                    lda Mirror_PPU_CTRL_REG1  ;disable NMIs in mirror reg
00810D  1  29 7F                       and #%01111111            ;save all other bits
00810F  1  8D 78 07                    sta Mirror_PPU_CTRL_REG1
008112  1  29 7E                       and #%01111110            ;alter name table address to be $2800
008114  1  8D 00 20                    sta PPU_CTRL_REG1         ;(essentially $2000) but save other bits
008117  1  AD 79 07                    lda Mirror_PPU_CTRL_REG2  ;disable OAM and background display by default
00811A  1  29 E6                       and #%11100110
00811C  1  AC 74 07                    ldy DisableScreenFlag     ;get screen disable flag
00811F  1  D0 05                       bne ScreenOff             ;if set, used bits as-is
008121  1  AD 79 07                    lda Mirror_PPU_CTRL_REG2  ;otherwise reenable bits and save them
008124  1  09 1E                       ora #%00011110
008126  1  8D 79 07     ScreenOff:     sta Mirror_PPU_CTRL_REG2  ;save bits for later but not in register at the moment
008129  1  29 E7                       and #%11100111            ;disable screen for now
00812B  1  8D 01 20                    sta PPU_CTRL_REG2
00812E  1  AE 02 20                    ldx PPU_STATUS            ;reset flip-flop and reset scroll registers to zero
008131  1  A9 00                       lda #$00
008133  1  20 25 BB                    jsr InitScroll
008136  1               
008136  1  CE 13 60 30                 MACRO_RunSlowMo 3
00813A  1  1D AD 74 07  
00813E  1  D0 18 AD 76  
00815E  1               
00815E  1  A9 00                       lda #0
008160  1  8D 03 20                    sta PPU_SPR_ADDR          ;reset spr-ram address register
008163  1  A9 02                       lda #$02                  ;perform spr-ram DMA access on $0200-$02ff
008165  1  8D 14 40                    sta SPR_DMA
008168  1               
008168  1  AD 05 60                    lda WRAM_PracticeFlags
00816B  1  29 40                       and #PF_EnableInputDisplay
00816D  1  F0 0B                       beq DrawBuffer            ;if input display not enabled, don't print it
00816F  1  A9 6B                       lda #<WRAM_StoredInputs   ;otherwise set indirect at $00 to WRAM stored inputs
008171  1  85 00                       sta $00
008173  1  A9 76                       lda #>WRAM_StoredInputs
008175  1  85 01                       sta $01
008177  1  20 1C BB                    jsr UpdateScreen          ;update input display
00817A  1  AE 73 07     DrawBuffer:    ldx VRAM_Buffer_AddrCtrl  ;load control for pointer to buffer contents
00817D  1  BD 35 82                    lda VRAM_AddrTable_Low,x  ;set indirect at $00 to pointer
008180  1  85 00                       sta $00
008182  1  BD 48 82                    lda VRAM_AddrTable_High,x
008185  1  85 01                       sta $01
008187  1  20 1C BB                    jsr UpdateScreen          ;update screen with buffer contents
00818A  1  A0 00                       ldy #$00
00818C  1  AE 73 07                    ldx VRAM_Buffer_AddrCtrl  ;check for usage of $0341
00818F  1  E0 06                       cpx #$06
008191  1  D0 01                       bne InitBuffer
008193  1  C8                          iny                       ;get offset based on usage
008194  1  BE 5B 82     InitBuffer:    ldx VRAM_Buffer_Offset,y
008197  1  A9 00                       lda #$00                  ;clear buffer header at last location
008199  1  9D 00 03                    sta VRAM_Buffer1_Offset,x
00819C  1  9D 01 03                    sta VRAM_Buffer1,x
00819F  1  8D 73 07                    sta VRAM_Buffer_AddrCtrl  ;reinit address control to $0301
0081A2  1  AD 79 07                    lda Mirror_PPU_CTRL_REG2  ;copy mirror of $2001 to register
0081A5  1  8D 01 20                    sta PPU_CTRL_REG2
0081A8  1               
0081A8  1  20 50 FE                    jsr Enter_PracticeOnFrame
0081AB  1               
0081AB  1  AD 76 07                    lda GamePauseStatus       ;check for pause status
0081AE  1  29 03                       and #3
0081B0  1  D0 28                       bne PauseSkip
0081B2  1  AD 47 07                    lda TimerControl          ;if master timer control not set, decrement
0081B5  1  F0 05                       beq DecTimers             ;all frame and interval timers
0081B7  1  CE 47 07                    dec TimerControl
0081BA  1  D0 19                       bne NoDecTimers
0081BC  1  A2 14        DecTimers:     ldx #$14                  ;load end offset for end of frame timers
0081BE  1  CE 7F 07                    dec IntervalTimerControl  ;decrement interval timer control,
0081C1  1  10 07                       bpl DecTimersLoop         ;if not expired, only frame timers will decrement
0081C3  1  A9 14                       lda #$14
0081C5  1  8D 7F 07                    sta IntervalTimerControl  ;if control for interval timers expired,
0081C8  1  A2 23                       ldx #$23                  ;interval timers will decrement along with frame timers
0081CA  1  BD 80 07     DecTimersLoop: lda Timers,x              ;check current timer
0081CD  1  F0 03                       beq SkipExpTimer          ;if current timer expired, branch to skip,
0081CF  1  DE 80 07                    dec Timers,x              ;otherwise decrement the current timer
0081D2  1  CA           SkipExpTimer:  dex                       ;move onto next timer
0081D3  1  10 F5                       bpl DecTimersLoop         ;do this until all timers are dealt with
0081D5  1  E6 09        NoDecTimers:   inc FrameCounter          ;increment frame counter
0081D7  1  20 80 F1                    jsr AdvanceRandom
0081DA  1               PauseSkip:
0081DA  1  AD 76 07                    lda GamePauseStatus
0081DD  1  29 02                       and #$02
0081DF  1  D0 25                       bne SkipSprite0
0081E1  1  AD 22 07                    lda Sprite0HitDetectFlag  ;check for flag here
0081E4  1  F0 20                       beq SkipSprite0
0081E6  1               Sprite0Clr:
0081E6  1  AD 02 20                    lda PPU_STATUS            ;wait for sprite 0 flag to clear, which will
0081E9  1  29 40                       and #%01000000            ;not happen until vblank has ended
0081EB  1  D0 F9                       bne Sprite0Clr
0081ED  1  AD 76 07                    lda GamePauseStatus       ;if in pause mode, do not bother with sprites at all
0081F0  1  29 03                       and #3
0081F2  1  D0 06                       bne Sprite0Hit
0081F4  1  20 41 BC                    jsr MoveSpritesOffscreen
0081F7  1  20 5D 82                    jsr SpriteShuffler
0081FA  1               Sprite0Hit:
0081FA  1  AD 02 20                    lda PPU_STATUS            ;do sprite #0 hit detection
0081FD  1  29 40                       and #%01000000
0081FF  1  F0 F9                       beq Sprite0Hit
008201  1  A0 14                       ldy #$14                  ;small delay, to wait until we hit horizontal blank time
008203  1               HBlankDelay:
008203  1  88                          dey
008204  1  D0 FD                       bne HBlankDelay
008206  1               SkipSprite0:
008206  1  AD 3F 07                    lda HorizontalScroll      ;set scroll registers from variables
008209  1  8D 05 20                    sta PPU_SCROLL_REG
00820C  1  AD 40 07                    lda VerticalScroll
00820F  1  8D 05 20                    sta PPU_SCROLL_REG
008212  1  AD 78 07                    lda Mirror_PPU_CTRL_REG1  ;load saved mirror of $2000
008215  1  48                          pha
008216  1  8D 00 20                    sta PPU_CTRL_REG1
008219  1  AD 76 07                    lda GamePauseStatus       ;if in pause mode, do not perform operation mode stuff
00821C  1  29 03                       and #3
00821E  1  D0 03                       bne SkipMainOper
008220  1  20 A9 82                    jsr OperModeExecutionTree ;otherwise do one of many, many possible subroutines
008223  1               SkipMainOper:
008223  1  AD 02 20                    lda PPU_STATUS            ;reset flip-flop
008226  1  68                          pla
008227  1  09 80                       ora #%10000000            ;reactivate NMIs
008229  1  8D 00 20                    sta PPU_CTRL_REG1
00822C  1  AD 76 07                    lda GamePauseStatus
00822F  1  29 FD                       and #$FD
008231  1  8D 76 07                    sta GamePauseStatus
008234  1  40                          rti                       ;we are done until the next frame!
008235  1               
008235  1               ;-------------------------------------------------------------------------------------
008235  1               ;$00 - vram buffer address table low, also used for pseudorandom bit
008235  1               ;$01 - vram buffer address table high
008235  1               
008235  1               VRAM_AddrTable_Low:
008235  1  01 60 84           .byte <VRAM_Buffer1, <WaterPaletteData, <GroundPaletteData
008238  1  A8 CC 00           .byte <UndergroundPaletteData, <CastlePaletteData, <VRAM_Buffer1_Offset
00823B  1  41 41 08           .byte <VRAM_Buffer2, <VRAM_Buffer2, <BowserPaletteData
00823E  1  F0 F8 00           .byte <DaySnowPaletteData, <NightSnowPaletteData, <MushroomPaletteData
008241  1  10 24 38           .byte <MarioThanksMessage, <LuigiThanksMessage, <MushroomRetainerSaved
008244  1  64 7B 9A           .byte <PrincessSaved1, <PrincessSaved2, <WorldSelectMessage1
008247  1  AB                 .byte <WorldSelectMessage2
008248  1               
008248  1               VRAM_AddrTable_High:
008248  1  03 8A 8A           .byte >VRAM_Buffer1, >WaterPaletteData, >GroundPaletteData
00824B  1  8A 8A 03           .byte >UndergroundPaletteData, >CastlePaletteData, >VRAM_Buffer1_Offset
00824E  1  03 03 8B           .byte >VRAM_Buffer2, >VRAM_Buffer2, >BowserPaletteData
008251  1  8A 8A 8B           .byte >DaySnowPaletteData, >NightSnowPaletteData, >MushroomPaletteData
008254  1  8B 8B 8B           .byte >MarioThanksMessage, >LuigiThanksMessage, >MushroomRetainerSaved
008257  1  8B 8B 8B           .byte >PrincessSaved1, >PrincessSaved2, >WorldSelectMessage1
00825A  1  8B                 .byte >WorldSelectMessage2
00825B  1               
00825B  1               VRAM_Buffer_Offset:
00825B  1  00 40              .byte <VRAM_Buffer1_Offset, <VRAM_Buffer2_Offset
00825D  1               
00825D  1               ;-------------------------------------------------------------------------------------
00825D  1               ;$00 - used for preset value
00825D  1               
00825D  1               SpriteShuffler:
00825D  1  AC 4E 07                    ldy AreaType                ;load level type, likely residual code
008260  1  A9 28                       lda #$28                    ;load preset value which will put it at
008262  1  85 00                       sta $00                     ;sprite #10
008264  1  A2 0E                       ldx #$0e                    ;start at the end of OAM data offsets
008266  1  BD E4 06     ShuffleLoop:   lda SprDataOffset,x         ;check for offset value against
008269  1  C5 00                       cmp $00                     ;the preset value
00826B  1  90 0F                       bcc NextSprOffset           ;if less, skip this part
00826D  1  AC E0 06                    ldy SprShuffleAmtOffset     ;get current offset to preset value we want to add
008270  1  18                          clc
008271  1  79 E1 06                    adc SprShuffleAmt,y         ;get shuffle amount, add to current sprite offset
008274  1  90 03                       bcc StrSprOffset            ;if not exceeded $ff, skip second add
008276  1  18                          clc
008277  1  65 00                       adc $00                     ;otherwise add preset value $28 to offset
008279  1  9D E4 06     StrSprOffset:  sta SprDataOffset,x         ;store new offset here or old one if branched to here
00827C  1  CA           NextSprOffset: dex                         ;move backwards to next one
00827D  1  10 E7                       bpl ShuffleLoop
00827F  1  AE E0 06                    ldx SprShuffleAmtOffset     ;load offset
008282  1  E8                          inx
008283  1  E0 03                       cpx #$03                    ;check if offset + 1 goes to 3
008285  1  D0 02                       bne SetAmtOffset            ;if offset + 1 not 3, store
008287  1  A2 00                       ldx #$00                    ;otherwise, init to 0
008289  1  8E E0 06     SetAmtOffset:  stx SprShuffleAmtOffset
00828C  1  A2 08                       ldx #$08                    ;load offsets for values and storage
00828E  1  A0 02                       ldy #$02
008290  1  B9 E9 06     SetMiscOffset: lda SprDataOffset+5,y       ;load one of three OAM data offsets
008293  1  9D F1 06                    sta Misc_SprDataOffset-2,x  ;store first one unmodified, but
008296  1  18                          clc                         ;add eight to the second and eight
008297  1  69 08                       adc #$08                    ;more to the third one
008299  1  9D F2 06                    sta Misc_SprDataOffset-1,x  ;note that due to the way X is set up,
00829C  1  18                          clc                         ;this code loads into the misc sprite offsets
00829D  1  69 08                       adc #$08
00829F  1  9D F3 06                    sta Misc_SprDataOffset,x
0082A2  1  CA                          dex
0082A3  1  CA                          dex
0082A4  1  CA                          dex
0082A5  1  88                          dey
0082A6  1  10 E8                       bpl SetMiscOffset           ;do this until all misc spr offsets are loaded
0082A8  1  60                          rts
0082A9  1               
0082A9  1               ;-------------------------------------------------------------------------------------
0082A9  1               
0082A9  1               OperModeExecutionTree:
0082A9  1  AD 70 07           lda OperMode     ;this is the heart of the entire program,
0082AC  1  20 97 BA           jsr JumpEngine   ;most of what goes on starts here
0082AF  1               
0082AF  1  B5 82              .word TitleScreenMode
0082B1  1  B6 A8              .word GameMode
0082B3  1  FA 82              .word VictoryMode
0082B5  1                     ; .word GameOverMode
0082B5  1               
0082B5  1               ;-------------------------------------------------------------------------------------
0082B5  1               
0082B5  1               TitleScreenMode:
0082B5  1  AD 72 07           lda OperMode_Task
0082B8  1  20 97 BA           jsr JumpEngine
0082BB  1               
0082BB  1  F6 B8              .word InitializeGame
0082BD  1  D0 84              .word ScreenRoutines
0082BF  1  D3 8B              .word PrimaryGameSetup
0082C1  1  CB 82              .word RunTitleScreen
0082C3  1               
0082C3  1               IsBigWorld:
0082C3  1  01 01 00 01    .byte 1, 1, 0, 1, 0, 0, 1, 0
0082C7  1  00 00 01 00  
0082CB  1               
0082CB  1               RunTitleScreen:
0082CB  1  20 58 FE         jsr Enter_PracticeTitleMenu
0082CE  1  AD 72 07         lda OperMode_Task
0082D1  1  C9 04            cmp #4
0082D3  1  D0 24            bne @not_running
0082D5  1  AE 5C 07         ldx LevelNumber
0082D8  1  AC 5F 07         ldy WorldNumber
0082DB  1  B9 C3 82         lda IsBigWorld, y
0082DE  1  F0 05            beq @save_area
0082E0  1  E0 02            cpx #2
0082E2  1  30 01            bmi @save_area
0082E4  1  E8               inx
0082E5  1               @save_area:
0082E5  1  8E 60 07         stx AreaNumber
0082E8  1                   ;
0082E8  1                   ; Start it...
0082E8  1                   ;
0082E8  1  20 4F BC         jsr LoadAreaPointer
0082EB  1  EE 5D 07         inc Hidden1UpFlag
0082EE  1  EE 57 07         inc FetchNewGameTimerFlag
0082F1  1  EE 70 07         inc OperMode
0082F4  1  A9 00            lda #$00
0082F6  1  8D 72 07         sta OperMode_Task
0082F9  1               @not_running:
0082F9  1  60               rts
0082FA  1               
0082FA  1               ;-------------------------------------------------------------------------------------
0082FA  1               
0082FA  1               VictoryMode:
0082FA  1  20 0F 83                 jsr VictoryModeSubroutines  ;run victory mode subroutines
0082FD  1  AD 72 07                 lda OperMode_Task           ;get current task of victory mode
008300  1  F0 07                    beq AutoPlayer              ;if on bridge collapse, skip enemy processing
008302  1  A2 00                    ldx #$00
008304  1  86 08                    stx ObjectOffset            ;otherwise reset enemy object offset
008306  1  20 07 B5                 jsr EnemiesAndLoopsCore     ;and run enemy code
008309  1  20 9A EC     AutoPlayer: jsr RelativePlayerPosition  ;get player's relative coordinates
00830C  1  4C 79 EA                 jmp PlayerGfxHandler        ;draw the player, then leave
00830F  1               
00830F  1               VictoryModeSubroutines:
00830F  1  AD 72 07           lda OperMode_Task
008312  1  20 97 BA           jsr JumpEngine
008315  1               
008315  1  F7 CC              .word BridgeCollapse
008317  1  1F 83              .word SetupVictoryMode
008319  1  2C 83              .word PlayerVictoryWalk
00831B  1  65 83              .word PrintVictoryMessages
00831D  1  D0 83              .word PlayerEndWorld
00831F  1               
00831F  1               ;-------------------------------------------------------------------------------------
00831F  1               
00831F  1               SetupVictoryMode:
00831F  1  AE 1B 07           ldx ScreenRight_PageLoc  ;get page location of right side of screen
008322  1  E8                 inx                      ;increment to next page
008323  1  86 34              stx DestinationPageLoc   ;store here
008325  1  A9 08              lda #EndOfCastleMusic
008327  1  85 FC              sta EventMusicQueue      ;play win castle music
008329  1  4C 0E 86           jmp IncModeTask_B        ;jump to set next major task in victory mode
00832C  1               
00832C  1               ;-------------------------------------------------------------------------------------
00832C  1               
00832C  1               PlayerVictoryWalk:
00832C  1  A0 00                     ldy #$00                ;set value here to not walk player by default
00832E  1  84 35                     sty VictoryWalkControl
008330  1  A5 6D                     lda Player_PageLoc      ;get player's page location
008332  1  C5 34                     cmp DestinationPageLoc  ;compare with destination page location
008334  1  D0 06                     bne PerformWalk         ;if page locations don't match, branch
008336  1  A5 86                     lda Player_X_Position   ;otherwise get player's horizontal position
008338  1  C9 60                     cmp #$60                ;compare with preset horizontal position
00833A  1  B0 03                     bcs DontWalk            ;if still on other page, branch ahead
00833C  1  E6 35        PerformWalk: inc VictoryWalkControl  ;otherwise increment value and Y
00833E  1  C8                        iny                     ;note Y will be used to walk the player
00833F  1  98           DontWalk:    tya                     ;put contents of Y in A and
008340  1  20 A5 AA                  jsr AutoControlPlayer   ;use A to move player to the right or not
008343  1  AD 1A 07                  lda ScreenLeft_PageLoc  ;check page location of left side of screen
008346  1  C5 34                     cmp DestinationPageLoc  ;against set value here
008348  1  F0 16                     beq ExitVWalk           ;branch if equal to change modes if necessary
00834A  1  AD 68 07                  lda ScrollFractional
00834D  1  18                        clc                     ;do fixed point math on fractional part of scroll
00834E  1  69 80                     adc #$80
008350  1  8D 68 07                  sta ScrollFractional    ;save fractional movement amount
008353  1  A9 01                     lda #$01                ;set 1 pixel per frame
008355  1  69 00                     adc #$00                ;add carry from previous addition
008357  1  A8                        tay                     ;use as scroll amount
008358  1  20 95 A9                  jsr ScrollScreen        ;do sub to scroll the screen
00835B  1  20 40 A9                  jsr UpdScrollVar        ;do another sub to update screen and scroll variables
00835E  1  E6 35                     inc VictoryWalkControl  ;increment value to stay in this routine
008360  1  A5 35        ExitVWalk:   lda VictoryWalkControl  ;load value set here
008362  1  F0 68                     beq IncModeTask_A       ;if zero, branch to change modes
008364  1  60                        rts                     ;otherwise leave
008365  1               
008365  1               ;-------------------------------------------------------------------------------------
008365  1               
008365  1               PrintVictoryMessages:
008365  1  AD 49 07                    lda SecondaryMsgCounter   ;load secondary message counter
008368  1  D0 48                       bne IncMsgCounter         ;if set, branch to increment message counters
00836A  1  AD 19 07                    lda PrimaryMsgCounter     ;otherwise load primary message counter
00836D  1  F0 18                       beq ThankPlayer           ;if set to zero, branch to print first message
00836F  1  C9 09                       cmp #$09                  ;if at 9 or above, branch elsewhere (this comparison
008371  1  B0 3F                       bcs IncMsgCounter         ;is residual code, counter never reaches 9)
008373  1  AC 5F 07                    ldy WorldNumber           ;check world number
008376  1  C0 07                       cpy #World8
008378  1  D0 09                       bne MRetainerMsg          ;if not at world 8, skip to next part
00837A  1  C9 03                       cmp #$03                  ;check primary message counter again
00837C  1  90 34                       bcc IncMsgCounter         ;if not at 3 yet (world 8 only), branch to increment
00837E  1  E9 01                       sbc #$01                  ;otherwise subtract one
008380  1  4C 87 83                    jmp ThankPlayer           ;and skip to next part
008383  1  C9 02        MRetainerMsg:  cmp #$02                  ;check primary message counter
008385  1  90 2B                       bcc IncMsgCounter         ;if not at 2 yet (world 1-7 only), branch
008387  1  A8           ThankPlayer:   tay                       ;put primary message counter into Y
008388  1  D0 08                       bne SecondPartMsg         ;if counter nonzero, skip this part, do not print first message
00838A  1  AD 53 07                    lda CurrentPlayer         ;otherwise get player currently on the screen
00838D  1  F0 14                       beq EvalForMusic          ;if mario, branch
00838F  1  C8                          iny                       ;otherwise increment Y once for luigi and
008390  1  D0 11                       bne EvalForMusic          ;do an unconditional branch to the same place
008392  1  C8           SecondPartMsg: iny                       ;increment Y to do world 8's message
008393  1  AD 5F 07                    lda WorldNumber
008396  1  C9 07                       cmp #World8               ;check world number
008398  1  F0 09                       beq EvalForMusic          ;if at world 8, branch to next part
00839A  1  88                          dey                       ;otherwise decrement Y for world 1-7's message
00839B  1  C0 04                       cpy #$04                  ;if counter at 4 (world 1-7 only)
00839D  1  B0 26                       bcs SetEndTimer           ;branch to set victory end timer
00839F  1  C0 03                       cpy #$03                  ;if counter at 3 (world 1-7 only)
0083A1  1  B0 0F                       bcs IncMsgCounter         ;branch to keep counting
0083A3  1  C0 03        EvalForMusic:  cpy #$03                  ;if counter not yet at 3 (world 8 only), branch
0083A5  1  D0 04                       bne PrintMsg              ;to print message only (note world 1-7 will only
0083A7  1  A9 04                       lda #VictoryMusic         ;reach this code if counter = 0, and will always branch)
0083A9  1  85 FC                       sta EventMusicQueue       ;otherwise load victory music first (world 8 only)
0083AB  1  98           PrintMsg:      tya                       ;put primary message counter in A
0083AC  1  18                          clc                       ;add $0c or 12 to counter thus giving an appropriate value,
0083AD  1  69 0C                       adc #$0c                  ;($0c-$0d = first), ($0e = world 1-7's), ($0f-$12 = world 8's)
0083AF  1  8D 73 07                    sta VRAM_Buffer_AddrCtrl  ;write message counter to vram address controller
0083B2  1  AD 49 07     IncMsgCounter: lda SecondaryMsgCounter
0083B5  1  18                          clc
0083B6  1  69 04                       adc #$04                      ;add four to secondary message counter
0083B8  1  8D 49 07                    sta SecondaryMsgCounter
0083BB  1  AD 19 07                    lda PrimaryMsgCounter
0083BE  1  69 00                       adc #$00                      ;add carry to primary message counter
0083C0  1  8D 19 07                    sta PrimaryMsgCounter
0083C3  1  C9 07                       cmp #$07                      ;check primary counter one more time
0083C5  1  90 08        SetEndTimer:   bcc ExitMsgs                  ;if not reached value yet, branch to leave
0083C7  1  A9 06                       lda #$06
0083C9  1  8D A1 07                    sta WorldEndTimer             ;otherwise set world end timer
0083CC  1  EE 72 07     IncModeTask_A: inc OperMode_Task             ;move onto next task in mode
0083CF  1  60           ExitMsgs:      rts                           ;leave
0083D0  1               
0083D0  1               ;-------------------------------------------------------------------------------------
0083D0  1               
0083D0  1               PlayerEndWorld:
0083D0  1  AD A1 07                    lda WorldEndTimer          ;check to see if world end timer expired
0083D3  1  D0 28                       bne EndExitOne             ;branch to leave if not
0083D5  1  AC 5F 07                    ldy WorldNumber            ;check world number
0083D8  1  C0 07                       cpy #World8                ;if on world 8, player is done with game,
0083DA  1  B0 22                       bcs EndChkBButton          ;thus branch to read controller
0083DC  1  A9 00                       lda #$00
0083DE  1  8D 60 07                    sta AreaNumber             ;otherwise initialize area number used as offset
0083E1  1  8D 5C 07                    sta LevelNumber            ;and level number control to start at area 1
0083E4  1  8D 72 07                    sta OperMode_Task          ;initialize secondary mode of operation
0083E7  1               
0083E7  1  AD 05 60 29                 PF_SetToLevelEnd_A
0083EB  1  EF 8D 05 60  
0083EF  1               
0083EF  1  EE 5F 07                    inc WorldNumber            ;increment world number to move onto the next world
0083F2  1  20 4F BC                    jsr LoadAreaPointer        ;get area address offset for the next area
0083F5  1  EE 57 07                    inc FetchNewGameTimerFlag  ;set flag to load game timer from header
0083F8  1  A9 01                       lda #GameModeValue
0083FA  1  8D 70 07                    sta OperMode               ;set mode of operation to game mode
0083FD  1  60           EndExitOne:    rts                        ;and leave
0083FE  1               EndChkBButton:
0083FE  1  AD FC 06                    lda SavedJoypad1Bits
008401  1  0D FD 06                    ora SavedJoypad2Bits       ;check to see if B button was pressed on
008404  1  29 40                       and #B_Button              ;either controller
008406  1  F0 F5                       beq EndExitOne
008408  1  4C 00 80                    jmp Start ; hackreset
00840B  1               
00840B  1               ;-------------------------------------------------------------------------------------
00840B  1               
00840B  1               ;data is used as tiles for numbers
00840B  1               ;that appear when you defeat enemies
00840B  1               FloateyNumTileData:
00840B  1  FF FF              .byte $ff, $ff ;dummy
00840D  1  F6 FB              .byte $f6, $fb ; "100"
00840F  1  F7 FB              .byte $f7, $fb ; "200"
008411  1  F8 FB              .byte $f8, $fb ; "400"
008413  1  F9 FB              .byte $f9, $fb ; "500"
008415  1  FA FB              .byte $fa, $fb ; "800"
008417  1  F6 50              .byte $f6, $50 ; "1000"
008419  1  F7 50              .byte $f7, $50 ; "2000"
00841B  1  F8 50              .byte $f8, $50 ; "4000"
00841D  1  F9 50              .byte $f9, $50 ; "5000"
00841F  1  FA 50              .byte $fa, $50 ; "8000"
008421  1  FD FE              .byte $fd, $fe ; "1-UP"
008423  1               
008423  1               ;high nybble is digit number, low nybble is number to
008423  1               ;add to the digit of the player's score
008423  1               ScoreUpdateData:
008423  1  FF                 .byte $ff ;dummy
008424  1  41 42 44 45        .byte $41, $42, $44, $45, $48
008428  1  48           
008429  1  31 32 34 35        .byte $31, $32, $34, $35, $38, $00
00842D  1  38 00        
00842F  1               
00842F  1               FloateyNumbersRoutine:
00842F  1  BD 10 01                   lda FloateyNum_Control,x     ;load control for floatey number
008432  1  F0 C9                      beq EndExitOne               ;if zero, branch to leave
008434  1  C9 0B                      cmp #$0b                     ;if less than $0b, branch
008436  1  90 05                      bcc ChkNumTimer
008438  1  A9 0B                      lda #$0b                     ;otherwise set to $0b, thus keeping
00843A  1  9D 10 01                   sta FloateyNum_Control,x     ;it in range
00843D  1  A8           ChkNumTimer:  tay                          ;use as Y
00843E  1  BD 2C 01                   lda FloateyNum_Timer,x       ;check value here
008441  1  D0 04                      bne DecNumTimer              ;if nonzero, branch ahead
008443  1  9D 10 01                   sta FloateyNum_Control,x     ;initialize floatey number control and leave
008446  1  60                         rts
008447  1  DE 2C 01     DecNumTimer:  dec FloateyNum_Timer,x       ;decrement value here
00844A  1  C9 2B                      cmp #$2b                     ;if not reached a certain point, branch
00844C  1  D0 1B                      bne ChkTallEnemy
00844E  1  C0 0B                      cpy #$0b                     ;check offset for $0b
008450  1  D0 04                      bne LoadNumTiles             ;branch ahead if not found
008452  1  A9 40                      lda #Sfx_ExtraLife
008454  1  85 FE                      sta Square2SoundQueue        ;and play the 1-up sound
008456  1  B9 23 84     LoadNumTiles: lda ScoreUpdateData,y        ;load point value here
008459  1  4A                         lsr                          ;move high nybble to low
00845A  1  4A                         lsr
00845B  1  4A                         lsr
00845C  1  4A                         lsr
00845D  1  AA                         tax                          ;use as X offset, essentially the digit
00845E  1  B9 23 84                   lda ScoreUpdateData,y        ;load again and this time
008461  1  29 0F                      and #%00001111               ;mask out the high nybble
008463  1  9D 34 01                   sta DigitModifier,x          ;store as amount to add to the digit
008466  1  20 DE BC                   jsr AddToScore               ;update the score accordingly
008469  1  BC E5 06     ChkTallEnemy: ldy Enemy_SprDataOffset,x    ;get OAM data offset for enemy object
00846C  1  B5 16                      lda Enemy_ID,x               ;get enemy object identifier
00846E  1  C9 12                      cmp #Spiny
008470  1  F0 22                      beq FloateyPart              ;branch if spiny
008472  1  C9 0D                      cmp #PiranhaPlant
008474  1  F0 1E                      beq FloateyPart              ;branch if piranha plant
008476  1  C9 05                      cmp #HammerBro
008478  1  F0 12                      beq GetAltOffset             ;branch elsewhere if hammer bro
00847A  1  C9 0A                      cmp #GreyCheepCheep
00847C  1  F0 16                      beq FloateyPart              ;branch if cheep-cheep of either color
00847E  1  C9 0B                      cmp #RedCheepCheep
008480  1  F0 12                      beq FloateyPart
008482  1  C9 09                      cmp #TallEnemy
008484  1  B0 06                      bcs GetAltOffset             ;branch elsewhere if enemy object => $09
008486  1  B5 1E                      lda Enemy_State,x
008488  1  C9 02                      cmp #$02                     ;if enemy state defeated or otherwise
00848A  1  B0 08                      bcs FloateyPart              ;$02 or greater, branch beyond this part
00848C  1  AE EE 03     GetAltOffset: ldx SprDataOffset_Ctrl       ;load some kind of control bit
00848F  1  BC EC 06                   ldy Alt_SprDataOffset,x      ;get alternate OAM data offset
008492  1  A6 08                      ldx ObjectOffset             ;get enemy object offset again
008494  1  BD 1E 01     FloateyPart:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate for
008497  1  C9 18                      cmp #$18                     ;floatey number, if coordinate in the
008499  1  90 05                      bcc SetupNumSpr              ;status bar, branch
00849B  1  E9 01                      sbc #$01
00849D  1  9D 1E 01                   sta FloateyNum_Y_Pos,x       ;otherwise subtract one and store as new
0084A0  1  BD 1E 01     SetupNumSpr:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate
0084A3  1  E9 08                      sbc #$08                     ;subtract eight and dump into the
0084A5  1  20 51 E1                   jsr DumpTwoSpr               ;left and right sprite's Y coordinates
0084A8  1  BD 17 01                   lda FloateyNum_X_Pos,x       ;get horizontal coordinate
0084AB  1  99 03 02                   sta Sprite_X_Position,y      ;store into X coordinate of left sprite
0084AE  1  18                         clc
0084AF  1  69 08                      adc #$08                     ;add eight pixels and store into X
0084B1  1  99 07 02                   sta Sprite_X_Position+4,y    ;coordinate of right sprite
0084B4  1  A9 02                      lda #$02
0084B6  1  99 02 02                   sta Sprite_Attributes,y      ;set palette control in attribute bytes
0084B9  1  99 06 02                   sta Sprite_Attributes+4,y    ;of left and right sprites
0084BC  1  BD 10 01                   lda FloateyNum_Control,x
0084BF  1  0A                         asl                          ;multiply our floatey number control by 2
0084C0  1  AA                         tax                          ;and use as offset for look-up table
0084C1  1  BD 0B 84                   lda FloateyNumTileData,x
0084C4  1  99 01 02                   sta Sprite_Tilenumber,y      ;display first half of number of points
0084C7  1  BD 0C 84                   lda FloateyNumTileData+1,x
0084CA  1  99 05 02                   sta Sprite_Tilenumber+4,y    ;display the second half
0084CD  1  A6 08                      ldx ObjectOffset             ;get enemy object offset and leave
0084CF  1  60                         rts
0084D0  1               
0084D0  1               ;-------------------------------------------------------------------------------------
0084D0  1               
0084D0  1               ScreenRoutines:
0084D0  1  AD 3C 07           lda ScreenRoutineTask        ;run one of the following subroutines
0084D3  1  20 97 BA           jsr JumpEngine
0084D6  1               
0084D6  1  F4 84              .word InitScreen
0084D8  1  07 85              .word SetupIntermediate
0084DA  1  75 85              .word WriteTopStatusLine
0084DC  1  27 85              .word WriteBottomStatusLine
0084DE  1  60 85              .word DisplayTimeUp
0084E0  1  28 87              .word ResetSpritesAndScreenTimer
0084E2  1  7D 85              .word DisplayIntermediate
0084E4  1  28 87              .word ResetSpritesAndScreenTimer
0084E6  1  BE 85              .word AreaParserTaskControl
0084E8  1  94 EE              .word GetAreaPalette
0084EA  1  C0 EE              .word GetBackgroundColor
0084EC  1  30 EF              .word GetAlternatePalette1
0084EE  1  D7 85              .word DrawTitleScreen
0084F0  1  0A 86              .word ClearBuffersDrawIcon
0084F2  1  0E 86              .word WriteTopScore
0084F4  1               
0084F4  1               ;-------------------------------------------------------------------------------------
0084F4  1               
0084F4  1               InitScreen:
0084F4  1  20 3E BC           jsr MoveAllSpritesOffscreen ;initialize all sprites including sprite #0
0084F7  1  20 FB BB           jsr InitializeNameTables    ;and erase both name and attribute tables
0084FA  1  AD 70 07           lda OperMode
0084FD  1  F0 05              beq NextSubtask             ;if mode still 0, do not load
0084FF  1  A2 03              ldx #$03                    ;into buffer pointer
008501  1  4C 9A EE           jmp SetVRAMAddr_A
008504  1               NextSubtask:
008504  1  4C 3C EF           jmp IncSubtask           ;move onto next task
008507  1               
008507  1               ;-------------------------------------------------------------------------------------
008507  1               
008507  1               SetupIntermediate:
008507  1  AD 44 07           lda BackgroundColorCtrl  ;save current background color control
00850A  1  48                 pha                      ;and player status to stack
00850B  1  AD 56 07           lda PlayerStatus
00850E  1  48                 pha
00850F  1  A9 00              lda #$00                 ;set background color to black
008511  1  8D 56 07           sta PlayerStatus         ;and player status to not fiery
008514  1  A9 02              lda #$02                 ;this is the ONLY time background color control
008516  1  8D 44 07           sta BackgroundColorCtrl  ;is set to less than 4
008519  1  20 CE EE           jsr GetPlayerColors
00851C  1  68                 pla                      ;we only execute this routine for
00851D  1  8D 56 07           sta PlayerStatus         ;the intermediate lives display
008520  1  68                 pla                      ;and once we're done, we return bg
008521  1  8D 44 07           sta BackgroundColorCtrl  ;color ctrl and player status from stack
008524  1  4C 3C EF           jmp IncSubtask           ;then move onto the next task
008527  1               
008527  1               ;-------------------------------------------------------------------------------------
008527  1               
008527  1               WriteBottomStatusLine:
008527  1  20 E7 BC           jsr GetSBNybbles        ;write player's score and coin tally to screen
00852A  1  AE 00 03           ldx VRAM_Buffer1_Offset
00852D  1  A9 20              lda #$20                ;write address for world-area number on screen
00852F  1  9D 01 03           sta VRAM_Buffer1,x
008532  1  A9 73              lda #$73
008534  1  9D 02 03           sta VRAM_Buffer1+1,x
008537  1  A9 03              lda #$03                ;write length for it
008539  1  9D 03 03           sta VRAM_Buffer1+2,x
00853C  1  AC 5F 07           ldy WorldNumber         ;first the world number
00853F  1  C8                 iny
008540  1  98                 tya
008541  1  9D 04 03           sta VRAM_Buffer1+3,x
008544  1  A9 28              lda #$28                ;next the dash
008546  1  9D 05 03           sta VRAM_Buffer1+4,x
008549  1  AC 5C 07           ldy LevelNumber         ;next the level number
00854C  1  C8                 iny                     ;increment for proper number display
00854D  1  98                 tya
00854E  1  9D 06 03           sta VRAM_Buffer1+5,x
008551  1  A9 00              lda #$00                ;put null terminator on
008553  1  9D 07 03           sta VRAM_Buffer1+6,x
008556  1  8A                 txa                     ;move the buffer offset up by 6 bytes
008557  1  18                 clc
008558  1  69 06              adc #$06
00855A  1  8D 00 03           sta VRAM_Buffer1_Offset
00855D  1  4C 3C EF           jmp IncSubtask
008560  1               
008560  1               ;-------------------------------------------------------------------------------------
008560  1               
008560  1               DisplayTimeUp:
008560  1  AD 59 07               lda GameTimerExpiredFlag  ;if game timer not expired, increment task
008563  1  F0 0A                  beq NoTimeUp              ;control 2 tasks forward, otherwise, stay here
008565  1  A9 00                  lda #$00
008567  1  8D 59 07               sta GameTimerExpiredFlag  ;reset timer expiration flag
00856A  1  A9 02                  lda #$02                  ;output time-up screen to buffer
00856C  1  4C 9C 85               jmp OutputInter
00856F  1  EE 3C 07     NoTimeUp: inc ScreenRoutineTask     ;increment control task 2 tasks forward
008572  1  4C 3C EF               jmp IncSubtask
008575  1               
008575  1               ;-------------------------------------------------------------------------------------
008575  1               
008575  1               WriteTopStatusLine:
008575  1  A9 00              lda #$00          ;select main status bar
008577  1  20 A6 86           jsr WriteGameText ;output it
00857A  1  4C 3C EF           jmp IncSubtask    ;onto the next task
00857D  1               
00857D  1               DisplayIntermediate:
00857D  1  AD 70 07                    lda OperMode                 ;check primary mode of operation
008580  1  F0 36                       beq NoInter                  ;if in title screen mode, skip this
008582  1  C9 03                       cmp #GameOverModeValue       ;are we in game over mode?
008584  1  F0 25                       beq GameOverInter            ;if so, proceed to display game over screen
008586  1  AD 52 07                    lda AltEntranceControl       ;otherwise check for mode of alternate entry
008589  1  D0 2D                       bne NoInter                  ;and branch if found
00858B  1  AC 4E 07                    ldy AreaType                 ;check if we are on castle level
00858E  1  C0 03                       cpy #$03                     ;and if so, branch (possibly residual)
008590  1  F0 05                       beq PlayerInter
008592  1  AD 69 07                    lda DisableIntermediate      ;if this flag is set, skip intermediate lives display
008595  1  D0 21                       bne NoInter                  ;and jump to specific task, otherwise
008597  1  20 D2 B8     PlayerInter:   jsr DrawPlayer_Intermediate  ;put player in appropriate place for
00859A  1  A9 01                       lda #$01                     ;lives display, then output lives display to buffer
00859C  1  20 A6 86     OutputInter:   jsr WriteGameText
00859F  1  20 08 FE     		       jsr Enter_RenderIntermediateTime
0085A2  1  20 30 87                    jsr ResetScreenTimer
0085A5  1  A9 00                       lda #$00
0085A7  1  8D 74 07                    sta DisableScreenFlag        ;reenable screen output
0085AA  1  60                          rts
0085AB  1  A9 12        GameOverInter: lda #$12                     ;set screen timer
0085AD  1  8D A0 07                    sta ScreenTimer
0085B0  1  A9 03                       lda #$03                     ;output game over screen to buffer
0085B2  1  20 A6 86                    jsr WriteGameText
0085B5  1  4C 0E 86                    jmp IncModeTask_B
0085B8  1  A9 08        NoInter:       lda #$08                     ;set for specific task and leave
0085BA  1  8D 3C 07                    sta ScreenRoutineTask
0085BD  1  60                          rts
0085BE  1               
0085BE  1               ;-------------------------------------------------------------------------------------
0085BE  1               
0085BE  1               AreaParserTaskControl:
0085BE  1  EE 74 07                inc DisableScreenFlag     ;turn off screen
0085C1  1  20 96 8D     TaskLoop:  jsr AreaParserTaskHandler ;render column set of current area
0085C4  1  AD 1F 07                lda AreaParserTaskNum     ;check number of tasks
0085C7  1  D0 F8                   bne TaskLoop              ;if tasks still not all done, do another one
0085C9  1  CE 1E 07                dec ColumnSets            ;do we need to render more column sets?
0085CC  1  10 03                   bpl OutputCol
0085CE  1  EE 3C 07                inc ScreenRoutineTask     ;if not, move on to the next task
0085D1  1  A9 06        OutputCol: lda #$06                  ;set vram buffer to output rendered column set
0085D3  1  8D 73 07                sta VRAM_Buffer_AddrCtrl  ;on next NMI
0085D6  1  60                      rts
0085D7  1               
0085D7  1               ;-------------------------------------------------------------------------------------
0085D7  1               
0085D7  1               ;$00 - vram buffer address table low
0085D7  1               ;$01 - vram buffer address table high
0085D7  1               
0085D7  1               DrawTitleScreen:
0085D7  1  AD 70 07                 lda OperMode                 ;are we in title screen mode?
0085DA  1  D0 32                    bne IncModeTask_B            ;if not, exit
0085DC  1  A9 1E                    lda #>TitleScreenDataOffset  ;load address $1ec0 into
0085DE  1  8D 06 20                 sta PPU_ADDRESS              ;the vram address register
0085E1  1  A9 C0                    lda #<TitleScreenDataOffset
0085E3  1  8D 06 20                 sta PPU_ADDRESS
0085E6  1  A9 03                    lda #$03                     ;put address $0300 into
0085E8  1  85 01                    sta $01                      ;the indirect at $00
0085EA  1  A0 00                    ldy #$00
0085EC  1  84 00                    sty $00
0085EE  1  AD 07 20                 lda PPU_DATA                 ;do one garbage read
0085F1  1  AD 07 20     OutputTScr: lda PPU_DATA                 ;get title screen from chr-rom
0085F4  1  91 00                    sta ($00),y                  ;store 256 bytes into buffer
0085F6  1  C8                       iny
0085F7  1  D0 02                    bne ChkHiByte                ;if not past 256 bytes, do not increment
0085F9  1  E6 01                    inc $01                      ;otherwise increment high byte of indirect
0085FB  1  A5 01        ChkHiByte:  lda $01                      ;check high byte?
0085FD  1  C9 04                    cmp #$04                     ;at $0400?
0085FF  1  D0 F0                    bne OutputTScr               ;if not, loop back and do another
008601  1  C0 3A                    cpy #$3a                     ;check if offset points past end of data
008603  1  90 EC                    bcc OutputTScr               ;if not, loop back and do another
008605  1  A9 05                    lda #$05                     ;set buffer transfer control to $0300,
008607  1  4C 39 EF                 jmp SetVRAMAddr_B            ;increment task and exit
00860A  1               
00860A  1               ;-------------------------------------------------------------------------------------
00860A  1               
00860A  1               ClearBuffersDrawIcon:
00860A  1  EE 3C 07                  inc ScreenRoutineTask      ;move onto next task
00860D  1  60                        rts
00860E  1               
00860E  1               ;-------------------------------------------------------------------------------------
00860E  1               
00860E  1               WriteTopScore:
00860E  1  EE 72 07     IncModeTask_B: inc OperMode_Task  ;move onto next mode
008611  1  60                          rts
008612  1               
008612  1               ;-------------------------------------------------------------------------------------
008612  1               
008612  1               GameText:
008612  1               TopStatusBarLine:
008612  1  20 43 05 16    .byte $20, $43, $05, $16, $0a, $1b, $12, $18 ; "MARIO"
008616  1  0A 1B 12 18  
00861A  1  20 52 0B 20    .byte $20, $52, $0b, $20, $18, $1b, $15, $0d ; "WORLD  TIME"
00861E  1  18 1B 15 0D  
008622  1  24 24 1D 12    .byte $24, $24, $1d, $12, $16, $0e
008626  1  16 0E        
008628  1  20 68 05 00    .byte $20, $68, $05, $00, $24, $24, $2e, $29 ; score trailing digit and coin display
00862C  1  24 24 2E 29  
008630  1  23 C0 7F AA    .byte $23, $c0, $7f, $aa ; attribute table data, clears name table 0 to palette 2
008634  1  23 C2 01 EA    .byte $23, $c2, $01, $ea ; attribute table data, used for coin icon in status bar
008638  1  FF             .byte $ff ; end of data block
008639  1               
008639  1               WorldLivesDisplay:
008639  1  21 CD 07 24    .byte $21, $cd, $07, $24, $24 ; cross with spaces used on
00863D  1  24           
00863E  1  29 24 24 24    .byte $29, $24, $24, $24, $24 ; lives display
008642  1  24           
008643  1  21 4B 09 20    .byte $21, $4b, $09, $20, $18 ; "WORLD  - " used on lives display
008647  1  18           
008648  1  1B 15 0D 24    .byte $1b, $15, $0d, $24, $24, $28, $24
00864C  1  24 28 24     
00864F  1  22 0C 47 24    .byte $22, $0c, $47, $24 ; possibly used to clear time up
008653  1  23 DC 01 BA    .byte $23, $dc, $01, $ba ; attribute table data for crown if more than 9 lives
008657  1  FF             .byte $ff
008658  1               
008658  1               OnePlayerTimeUp:
008658  1  22 0C 07 1D    .byte $22, $0c, $07, $1d, $12, $16, $0e, $24, $1e, $19 ; "TIME UP"
00865C  1  12 16 0E 24  
008660  1  1E 19        
008662  1  FF             .byte $ff
008663  1               
008663  1               WarpZoneWelcome:
008663  1  25 84 15 20    .byte $25, $84, $15, $20, $0e, $15, $0c, $18, $16 ; "WELCOME TO WARP ZONE!"
008667  1  0E 15 0C 18  
00866B  1  16           
00866C  1  0E 24 1D 18    .byte $0e, $24, $1d, $18, $24, $20, $0a, $1b, $19
008670  1  24 20 0A 1B  
008674  1  19           
008675  1  24 23 18 17    .byte $24, $23, $18, $17, $0e, $2b
008679  1  0E 2B        
00867B  1  26 25 01 24    .byte $26, $25, $01, $24         ; placeholder for left pipe
00867F  1  26 2D 01 24    .byte $26, $2d, $01, $24         ; placeholder for middle pipe
008683  1  26 35 01 24    .byte $26, $35, $01, $24         ; placeholder for right pipe
008687  1  27 D9 46 AA    .byte $27, $d9, $46, $aa         ; attribute data
00868B  1  27 E1 45 AA    .byte $27, $e1, $45, $aa
00868F  1  FF             .byte $ff
008690  1               
008690  1                LuigiName:
008690  1  15 1E 12 10    .byte $15, $1e, $12, $10, $12    ; "LUIGI", no address or length
008694  1  12           
008695  1               
008695  1               WarpZoneNumbers:
008695  1  04 03 02 00    .byte $04, $03, $02, $00         ; warp zone numbers, note spaces on middle
008699  1  24 05 24 00    .byte $24, $05, $24, $00         ; zone, partly responsible for
00869D  1  08 07 06 00    .byte $08, $07, $06, $00         ; the minus world
0086A1  1               
0086A1  1               GameTextOffsets:
0086A1  1  00             .byte TopStatusBarLine-GameText
0086A2  1  27             .byte WorldLivesDisplay-GameText
0086A3  1  46             .byte OnePlayerTimeUp-GameText
0086A4  1  00             .byte 0
0086A5  1  51             .byte WarpZoneWelcome-GameText
0086A6  1               
0086A6  1               WriteGameText:
0086A6  1  48                          pha                      ;save text number to stack
0086A7  1  A8                          tay
0086A8  1  C0 01                       cpy #$01                 ;if set to do top status bar or world/lives display,
0086AA  1  90 06                       bcc LdGameText           ;branch to use current offset as-is
0086AC  1  C0 04                       cpy #$04                 ;if set to do time-up or game over,
0086AE  1  90 02                       bcc LdGameText           ;branch to check players
0086B0  1  A0 04                       ldy #$04                 ;otherwise warp zone, therefore set offset
0086B2  1  BE A1 86     LdGameText:    ldx GameTextOffsets,y    ;get offset to message we want to print
0086B5  1  A0 00                       ldy #0
0086B7  1  BD 12 86     GameTextLoop:  lda GameText,x           ;load message data
0086BA  1  C9 FF                       cmp #$ff                 ;check for terminator
0086BC  1  F0 07                       beq EndGameText          ;branch to end text if found
0086BE  1               WriteTextByte:
0086BE  1  99 01 03                    sta VRAM_Buffer1,y       ;otherwise write data to buffer
0086C1  1  E8                          inx
0086C2  1  C8                          iny
0086C3  1  D0 F2                       bne GameTextLoop         ;do this for 256 bytes if no terminator found
0086C5  1  A9 00        EndGameText:   lda #$00                 ;put null terminator at end
0086C7  1  99 01 03                    sta VRAM_Buffer1,y
0086CA  1  8C 00 03                    sty VRAM_Buffer1_Offset
0086CD  1  68                          pla                      ;pull original text number from stack
0086CE  1  AA                          tax
0086CF  1  C9 02                       cmp #$02                 ;are we printing warp zone?
0086D1  1  B0 3A                       bcs PrintWarpZoneNumbers
0086D3  1  CA                          dex                      ;are we printing the world/lives display?
0086D4  1  D0 14                       bne CheckPlayerName      ;if not, branch to check player's name
0086D6  1  A9 CE                       lda #$ce
0086D8  1  8D 08 03     PutLives:      sta VRAM_Buffer1+7
0086DB  1  AC 5F 07                    ldy WorldNumber          ;write world and level numbers (incremented for display)
0086DE  1  C8                          iny                      ;to the buffer in the spaces surrounding the dash
0086DF  1  8C 14 03                    sty VRAM_Buffer1+19
0086E2  1  AC 5C 07                    ldy LevelNumber
0086E5  1  C8                          iny
0086E6  1  8C 16 03                    sty VRAM_Buffer1+21      ;we're done here
0086E9  1  60           			   rts
0086EA  1               
0086EA  1               CheckPlayerName:
0086EA  1  AD 53 07                  lda $0753    ;check number of players
0086ED  1  F0 1D                     beq ExitChkName        ;if only 1 player, leave
0086EF  1  AD 53 07                  lda CurrentPlayer      ;load current player
0086F2  1  CA                        dex                    ;check to see if current message number is for time up
0086F3  1  D0 09                     bne ChkLuigi
0086F5  1  AC 70 07                  ldy OperMode           ;check for game over mode
0086F8  1  C0 03                     cpy #GameOverModeValue
0086FA  1  F0 02                     beq ChkLuigi
0086FC  1  49 01                     eor #%00000001         ;if not, must be time up, invert d0 to do other player
0086FE  1  4A           ChkLuigi:    lsr
0086FF  1  90 0B                     bcc ExitChkName        ;if mario is current player, do not change the name
008701  1  A0 04                     ldy #$04
008703  1  B9 90 86     NameLoop:    lda LuigiName,y        ;otherwise, replace "MARIO" with "LUIGI"
008706  1  99 04 03                  sta VRAM_Buffer1+3,y
008709  1  88                        dey
00870A  1  10 F7                     bpl NameLoop           ;do this until each letter is replaced
00870C  1  60           ExitChkName: rts
00870D  1               
00870D  1               PrintWarpZoneNumbers:
00870D  1  E9 04                     sbc #$04               ;subtract 4 and then shift to the left
00870F  1  0A                        asl                    ;twice to get proper warp zone number
008710  1  0A                        asl                    ;offset
008711  1  AA                        tax
008712  1  A0 00                     ldy #$00
008714  1  BD 95 86     WarpNumLoop: lda WarpZoneNumbers,x  ;print warp zone numbers into the
008717  1  99 1C 03                  sta VRAM_Buffer1+27,y  ;placeholders from earlier
00871A  1  E8                        inx
00871B  1  C8                        iny                    ;put a number in every fourth space
00871C  1  C8                        iny
00871D  1  C8                        iny
00871E  1  C8                        iny
00871F  1  C0 0C                     cpy #$0c
008721  1  90 F1                     bcc WarpNumLoop
008723  1  A9 2C                     lda #$2c               ;load new buffer pointer at end of message
008725  1  4C 2C EF                  jmp SetVRAMOffset
008728  1               
008728  1               ;-------------------------------------------------------------------------------------
008728  1               
008728  1               ResetSpritesAndScreenTimer:
008728  1  AD A0 07              lda ScreenTimer             ;check if screen timer has expired
00872B  1  D0 0B                 bne NoReset                 ;if not, branch to leave
00872D  1  20 3E BC              jsr MoveAllSpritesOffscreen ;otherwise reset sprites now
008730  1               
008730  1               ResetScreenTimer:
008730  1  A9 07                 lda #$07                    ;reset timer again
008732  1  8D A0 07              sta ScreenTimer
008735  1  EE 3C 07              inc ScreenRoutineTask       ;move onto next task
008738  1  60           NoReset: rts
008739  1               
008739  1               ;-------------------------------------------------------------------------------------
008739  1               ;$00 - temp vram buffer offset
008739  1               ;$01 - temp metatile buffer offset
008739  1               ;$02 - temp metatile graphics table offset
008739  1               ;$03 - used to store attribute bits
008739  1               ;$04 - used to determine attribute table row
008739  1               ;$05 - used to determine attribute table column
008739  1               ;$06 - metatile graphics table address low
008739  1               ;$07 - metatile graphics table address high
008739  1               
008739  1               RenderAreaGraphics:
008739  1  AD 26 07                 lda CurrentColumnPos         ;store LSB of where we're at
00873C  1  29 01                    and #$01
00873E  1  85 05                    sta $05
008740  1  AC 40 03                 ldy VRAM_Buffer2_Offset      ;store vram buffer offset
008743  1  84 00                    sty $00
008745  1  AD 21 07                 lda CurrentNTAddr_Low        ;get current name table address we're supposed to render
008748  1  99 42 03                 sta VRAM_Buffer2+1,y
00874B  1  AD 20 07                 lda CurrentNTAddr_High
00874E  1  99 41 03                 sta VRAM_Buffer2,y
008751  1  A9 9A                    lda #$9a                     ;store length byte of 26 here with d7 set
008753  1  99 43 03                 sta VRAM_Buffer2+2,y         ;to increment by 32 (in columns)
008756  1  A9 00                    lda #$00                     ;init attribute row
008758  1  85 04                    sta $04
00875A  1  AA                       tax
00875B  1  86 01        DrawMTLoop: stx $01                      ;store init value of 0 or incremented offset for buffer
00875D  1  BD A1 06                 lda MetatileBuffer,x         ;get first metatile number, and mask out all but 2 MSB
008760  1  29 C0                    and #%11000000
008762  1  85 03                    sta $03                      ;store attribute table bits here
008764  1  0A                       asl                          ;note that metatile format is:
008765  1  2A                       rol                          ;%xx000000 - attribute table bits,
008766  1  2A                       rol                          ;%00xxxxxx - metatile number
008767  1  A8                       tay                          ;rotate bits to d1-d0 and use as offset here
008768  1  B9 C4 88                 lda MetatileGraphics_Low,y   ;get address to graphics table from here
00876B  1  85 06                    sta $06
00876D  1  B9 C8 88                 lda MetatileGraphics_High,y
008770  1  85 07                    sta $07
008772  1  BD A1 06                 lda MetatileBuffer,x         ;get metatile number again
008775  1  0A                       asl                          ;multiply by 4 and use as tile offset
008776  1  0A                       asl
008777  1  85 02                    sta $02
008779  1  AD 1F 07                 lda AreaParserTaskNum        ;get current task number for level processing and
00877C  1  29 01                    and #%00000001               ;mask out all but LSB, then invert LSB, multiply by 2
00877E  1  49 01                    eor #%00000001               ;to get the correct column position in the metatile,
008780  1  0A                       asl                          ;then add to the tile offset so we can draw either side
008781  1  65 02                    adc $02                      ;of the metatiles
008783  1  A8                       tay
008784  1  A6 00                    ldx $00                      ;use vram buffer offset from before as X
008786  1  B1 06                    lda ($06),y
008788  1  9D 44 03                 sta VRAM_Buffer2+3,x         ;get first tile number (top left or top right) and store
00878B  1  C8                       iny
00878C  1  B1 06                    lda ($06),y                  ;now get the second (bottom left or bottom right) and store
00878E  1  9D 45 03                 sta VRAM_Buffer2+4,x
008791  1  A4 04                    ldy $04                      ;get current attribute row
008793  1  A5 05                    lda $05                      ;get LSB of current column where we're at, and
008795  1  D0 0E                    bne RightCheck               ;branch if set (clear = left attrib, set = right)
008797  1  A5 01                    lda $01                      ;get current row we're rendering
008799  1  4A                       lsr                          ;branch if LSB set (clear = top left, set = bottom left)
00879A  1  B0 19                    bcs LLeft
00879C  1  26 03                    rol $03                      ;rotate attribute bits 3 to the left
00879E  1  26 03                    rol $03                      ;thus in d1-d0, for upper left square
0087A0  1  26 03                    rol $03
0087A2  1  4C BB 87                 jmp SetAttrib
0087A5  1  A5 01        RightCheck: lda $01                      ;get LSB of current row we're rendering
0087A7  1  4A                       lsr                          ;branch if set (clear = top right, set = bottom right)
0087A8  1  B0 0F                    bcs NextMTRow
0087AA  1  46 03                    lsr $03                      ;shift attribute bits 4 to the right
0087AC  1  46 03                    lsr $03                      ;thus in d3-d2, for upper right square
0087AE  1  46 03                    lsr $03
0087B0  1  46 03                    lsr $03
0087B2  1  4C BB 87                 jmp SetAttrib
0087B5  1  46 03        LLeft:      lsr $03                      ;shift attribute bits 2 to the right
0087B7  1  46 03                    lsr $03                      ;thus in d5-d4 for lower left square
0087B9  1  E6 04        NextMTRow:  inc $04                      ;move onto next attribute row
0087BB  1  B9 F9 03     SetAttrib:  lda AttributeBuffer,y        ;get previously saved bits from before
0087BE  1  05 03                    ora $03                      ;if any, and put new bits, if any, onto
0087C0  1  99 F9 03                 sta AttributeBuffer,y        ;the old, and store
0087C3  1  E6 00                    inc $00                      ;increment vram buffer offset by 2
0087C5  1  E6 00                    inc $00
0087C7  1  A6 01                    ldx $01                      ;get current gfx buffer row, and check for
0087C9  1  E8                       inx                          ;the bottom of the screen
0087CA  1  E0 0D                    cpx #$0d
0087CC  1  90 8D                    bcc DrawMTLoop               ;if not there yet, loop back
0087CE  1  A4 00                    ldy $00                      ;get current vram buffer offset, increment by 3
0087D0  1  C8                       iny                          ;(for name table address and length bytes)
0087D1  1  C8                       iny
0087D2  1  C8                       iny
0087D3  1  A9 00                    lda #$00
0087D5  1  99 41 03                 sta VRAM_Buffer2,y           ;put null terminator at end of data for name table
0087D8  1  8C 40 03                 sty VRAM_Buffer2_Offset      ;store new buffer offset
0087DB  1  EE 21 07                 inc CurrentNTAddr_Low        ;increment name table address low
0087DE  1  AD 21 07                 lda CurrentNTAddr_Low        ;check current low byte
0087E1  1  29 1F                    and #%00011111               ;if no wraparound, just skip this part
0087E3  1  D0 0D                    bne ExitDrawM
0087E5  1  A9 80                    lda #$80                     ;if wraparound occurs, make sure low byte stays
0087E7  1  8D 21 07                 sta CurrentNTAddr_Low        ;just under the status bar
0087EA  1  AD 20 07                 lda CurrentNTAddr_High       ;and then invert d2 of the name table address high
0087ED  1  49 04                    eor #%00000100               ;to move onto the next appropriate name table
0087EF  1  8D 20 07                 sta CurrentNTAddr_High
0087F2  1  4C 48 88     ExitDrawM:  jmp SetVRAMCtrl              ;jump to set buffer to $0341 and leave
0087F5  1               
0087F5  1               ;-------------------------------------------------------------------------------------
0087F5  1               ;$00 - temp attribute table address high (big endian order this time!)
0087F5  1               ;$01 - temp attribute table address low
0087F5  1               
0087F5  1               RenderAttributeTables:
0087F5  1  AD 21 07                  lda CurrentNTAddr_Low    ;get low byte of next name table address
0087F8  1  29 1F                     and #%00011111           ;to be written to, mask out all but 5 LSB,
0087FA  1  38                        sec                      ;subtract four
0087FB  1  E9 04                     sbc #$04
0087FD  1  29 1F                     and #%00011111           ;mask out bits again and store
0087FF  1  85 01                     sta $01
008801  1  AD 20 07                  lda CurrentNTAddr_High   ;get high byte and branch if borrow not set
008804  1  B0 02                     bcs SetATHigh
008806  1  49 04                     eor #%00000100           ;otherwise invert d2
008808  1  29 04        SetATHigh:   and #%00000100           ;mask out all other bits
00880A  1  09 23                     ora #$23                 ;add $2300 to the high byte and store
00880C  1  85 00                     sta $00
00880E  1  A5 01                     lda $01                  ;get low byte - 4, divide by 4, add offset for
008810  1  4A                        lsr                      ;attribute table and store
008811  1  4A                        lsr
008812  1  69 C0                     adc #$c0                 ;we should now have the appropriate block of
008814  1  85 01                     sta $01                  ;attribute table in our temp address
008816  1  A2 00                     ldx #$00
008818  1  AC 40 03                  ldy VRAM_Buffer2_Offset  ;get buffer offset
00881B  1  A5 00        AttribLoop:  lda $00
00881D  1  99 41 03                  sta VRAM_Buffer2,y       ;store high byte of attribute table address
008820  1  A5 01                     lda $01
008822  1  18                        clc                      ;get low byte, add 8 because we want to start
008823  1  69 08                     adc #$08                 ;below the status bar, and store
008825  1  99 42 03                  sta VRAM_Buffer2+1,y
008828  1  85 01                     sta $01                  ;also store in temp again
00882A  1  BD F9 03                  lda AttributeBuffer,x    ;fetch current attribute table byte and store
00882D  1  99 44 03                  sta VRAM_Buffer2+3,y     ;in the buffer
008830  1  A9 01                     lda #$01
008832  1  99 43 03                  sta VRAM_Buffer2+2,y     ;store length of 1 in buffer
008835  1  4A                        lsr
008836  1  9D F9 03                  sta AttributeBuffer,x    ;clear current byte in attribute buffer
008839  1  C8                        iny                      ;increment buffer offset by 4 bytes
00883A  1  C8                        iny
00883B  1  C8                        iny
00883C  1  C8                        iny
00883D  1  E8                        inx                      ;increment attribute offset and check to see
00883E  1  E0 07                     cpx #$07                 ;if we're at the end yet
008840  1  90 D9                     bcc AttribLoop
008842  1  99 41 03                  sta VRAM_Buffer2,y       ;put null terminator at the end
008845  1  8C 40 03                  sty VRAM_Buffer2_Offset  ;store offset in case we want to do any more
008848  1  A9 06        SetVRAMCtrl: lda #$06
00884A  1  8D 73 07                  sta VRAM_Buffer_AddrCtrl ;set buffer to $0341 and leave
00884D  1  60                        rts
00884E  1               
00884E  1               ;-------------------------------------------------------------------------------------
00884E  1               
00884E  1               ;$00 - used as temporary counter in ColorRotation
00884E  1               
00884E  1               ColorRotatePalette:
00884E  1  27 27 27 17         .byte $27, $27, $27, $17, $07, $17
008852  1  07 17        
008854  1               
008854  1               BlankPalette:
008854  1  3F 0C 04 FF         .byte $3f, $0c, $04, $ff, $ff, $ff, $ff, $00
008858  1  FF FF FF 00  
00885C  1               
00885C  1               ;used based on area type
00885C  1               Palette3Data:
00885C  1  0F 07 12 0F         .byte $0f, $07, $12, $0f
008860  1  0F 07 17 0F         .byte $0f, $07, $17, $0f
008864  1  0F 07 17 1C         .byte $0f, $07, $17, $1c
008868  1  0F 07 17 00         .byte $0f, $07, $17, $00
00886C  1               
00886C  1               ColorRotation:
00886C  1  A5 09                      lda FrameCounter         ;get frame counter
00886E  1  29 07                      and #$07                 ;mask out all but three LSB
008870  1  D0 51                      bne ExitColorRot         ;branch if not set to zero to do this every eighth frame
008872  1  AE 00 03                   ldx VRAM_Buffer1_Offset  ;check vram buffer offset
008875  1  E0 31                      cpx #$31
008877  1  B0 4A                      bcs ExitColorRot         ;if offset over 48 bytes, branch to leave
008879  1  A8                         tay                      ;otherwise use frame counter's 3 LSB as offset here
00887A  1  B9 54 88     GetBlankPal:  lda BlankPalette,y       ;get blank palette for palette 3
00887D  1  9D 01 03                   sta VRAM_Buffer1,x       ;store it in the vram buffer
008880  1  E8                         inx                      ;increment offsets
008881  1  C8                         iny
008882  1  C0 08                      cpy #$08
008884  1  90 F4                      bcc GetBlankPal          ;do this until all bytes are copied
008886  1  AE 00 03                   ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
008889  1  A9 03                      lda #$03
00888B  1  85 00                      sta $00                  ;set counter here
00888D  1  AD 4E 07                   lda AreaType             ;get area type
008890  1  0A                         asl                      ;multiply by 4 to get proper offset
008891  1  0A                         asl
008892  1  A8                         tay                      ;save as offset here
008893  1  B9 5C 88     GetAreaPal:   lda Palette3Data,y       ;fetch palette to be written based on area type
008896  1  9D 04 03                   sta VRAM_Buffer1+3,x     ;store it to overwrite blank palette in vram buffer
008899  1  C8                         iny
00889A  1  E8                         inx
00889B  1  C6 00                      dec $00                  ;decrement counter
00889D  1  10 F4                      bpl GetAreaPal           ;do this until the palette is all copied
00889F  1  AE 00 03                   ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
0088A2  1  AC D4 06                   ldy ColorRotateOffset    ;get color cycling offset
0088A5  1  B9 4E 88                   lda ColorRotatePalette,y
0088A8  1  9D 05 03                   sta VRAM_Buffer1+4,x     ;get and store current color in second slot of palette
0088AB  1  AD 00 03                   lda VRAM_Buffer1_Offset
0088AE  1  18                         clc                      ;add seven bytes to vram buffer offset
0088AF  1  69 07                      adc #$07
0088B1  1  8D 00 03                   sta VRAM_Buffer1_Offset
0088B4  1  EE D4 06                   inc ColorRotateOffset    ;increment color cycling offset
0088B7  1  AD D4 06                   lda ColorRotateOffset
0088BA  1  C9 06                      cmp #$06                 ;check to see if it's still in range
0088BC  1  90 05                      bcc ExitColorRot         ;if so, branch to leave
0088BE  1  A9 00                      lda #$00
0088C0  1  8D D4 06                   sta ColorRotateOffset    ;otherwise, init to keep it in range
0088C3  1  60           ExitColorRot: rts                      ;leave
0088C4  1               
0088C4  1               ;-------------------------------------------------------------------------------------
0088C4  1               ;METATILE GRAPHICS TABLE
0088C4  1               
0088C4  1               MetatileGraphics_Low:
0088C4  1  CC 68 20 48    .byte <Palette0_MTiles, <Palette1_MTiles, <Palette2_MTiles, <Palette3_MTiles
0088C8  1               
0088C8  1               MetatileGraphics_High:
0088C8  1  88 89 8A 8A    .byte >Palette0_MTiles, >Palette1_MTiles, >Palette2_MTiles, >Palette3_MTiles
0088CC  1               
0088CC  1               Palette0_MTiles:
0088CC  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank
0088D0  1  27 27 27 27    .byte $27, $27, $27, $27 ;black metatile
0088D4  1  24 24 24 35    .byte $24, $24, $24, $35 ;bush left
0088D8  1  36 25 37 25    .byte $36, $25, $37, $25 ;bush middle
0088DC  1  24 38 24 24    .byte $24, $38, $24, $24 ;bush right
0088E0  1  24 30 30 26    .byte $24, $30, $30, $26 ;mountain left
0088E4  1  26 26 34 26    .byte $26, $26, $34, $26 ;mountain left bottom/middle center
0088E8  1  24 31 24 32    .byte $24, $31, $24, $32 ;mountain middle top
0088EC  1  33 26 24 33    .byte $33, $26, $24, $33 ;mountain right
0088F0  1  34 26 26 26    .byte $34, $26, $26, $26 ;mountain right bottom
0088F4  1  26 26 26 26    .byte $26, $26, $26, $26 ;mountain middle bottom
0088F8  1  24 C0 24 C0    .byte $24, $c0, $24, $c0 ;bridge guardrail
0088FC  1  24 7F 7F 24    .byte $24, $7f, $7f, $24 ;chain
008900  1  B8 BA B9 BB    .byte $b8, $ba, $b9, $bb ;tall tree top, top half
008904  1  B8 BC B9 BD    .byte $b8, $bc, $b9, $bd ;short tree top
008908  1  BA BC BB BD    .byte $ba, $bc, $bb, $bd ;tall tree top, bottom half
00890C  1  60 64 61 65    .byte $60, $64, $61, $65 ;warp pipe end left, points up
008910  1  62 66 63 67    .byte $62, $66, $63, $67 ;warp pipe end right, points up
008914  1  60 64 61 65    .byte $60, $64, $61, $65 ;decoration pipe end left, points up
008918  1  62 66 63 67    .byte $62, $66, $63, $67 ;decoration pipe end right, points up
00891C  1  68 68 69 69    .byte $68, $68, $69, $69 ;pipe shaft left
008920  1  26 26 6A 6A    .byte $26, $26, $6a, $6a ;pipe shaft right
008924  1  4B 4C 4D 4E    .byte $4b, $4c, $4d, $4e ;tree ledge left edge
008928  1  4D 4F 4D 4F    .byte $4d, $4f, $4d, $4f ;tree ledge middle
00892C  1  4D 4E 50 51    .byte $4d, $4e, $50, $51 ;tree ledge right edge
008930  1  6B 70 2C 2D    .byte $6b, $70, $2c, $2d ;mushroom left edge
008934  1  6C 71 6D 72    .byte $6c, $71, $6d, $72 ;mushroom middle
008938  1  6E 73 6F 74    .byte $6e, $73, $6f, $74 ;mushroom right edge
00893C  1  86 8A 87 8B    .byte $86, $8a, $87, $8b ;sideways pipe end top
008940  1  88 8C 88 8C    .byte $88, $8c, $88, $8c ;sideways pipe shaft top
008944  1  89 8D 69 69    .byte $89, $8d, $69, $69 ;sideways pipe joint top
008948  1  8E 91 8F 92    .byte $8e, $91, $8f, $92 ;sideways pipe end bottom
00894C  1  26 93 26 93    .byte $26, $93, $26, $93 ;sideways pipe shaft bottom
008950  1  90 94 69 69    .byte $90, $94, $69, $69 ;sideways pipe joint bottom
008954  1  A4 E9 EA EB    .byte $a4, $e9, $ea, $eb ;seaplant
008958  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank, used on bricks or blocks that are hit
00895C  1  24 2F 24 3D    .byte $24, $2f, $24, $3d ;flagpole ball
008960  1  A2 A2 A3 A3    .byte $a2, $a2, $a3, $a3 ;flagpole shaft
008964  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank, used in conjunction with vines
008968  1               
008968  1               Palette1_MTiles:
008968  1  A2 A2 A3 A3    .byte $a2, $a2, $a3, $a3 ;vertical rope
00896C  1  99 24 99 24    .byte $99, $24, $99, $24 ;horizontal rope
008970  1  24 A2 3E 3F    .byte $24, $a2, $3e, $3f ;left pulley
008974  1  5B 5C 24 A3    .byte $5b, $5c, $24, $a3 ;right pulley
008978  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank used for balance rope
00897C  1  9D 47 9E 47    .byte $9d, $47, $9e, $47 ;castle top
008980  1  47 47 27 27    .byte $47, $47, $27, $27 ;castle window left
008984  1  47 47 47 47    .byte $47, $47, $47, $47 ;castle brick wall
008988  1  27 27 47 47    .byte $27, $27, $47, $47 ;castle window right
00898C  1  A9 47 AA 47    .byte $a9, $47, $aa, $47 ;castle top w/ brick
008990  1  9B 27 9C 27    .byte $9b, $27, $9c, $27 ;entrance top
008994  1  27 27 27 27    .byte $27, $27, $27, $27 ;entrance bottom
008998  1  52 52 52 52    .byte $52, $52, $52, $52 ;green ledge stump
00899C  1  80 A0 81 A1    .byte $80, $a0, $81, $a1 ;fence
0089A0  1  BE BE BF BF    .byte $be, $be, $bf, $bf ;tree trunk
0089A4  1  75 BA 76 BB    .byte $75, $ba, $76, $bb ;mushroom stump top
0089A8  1  BA BA BB BB    .byte $ba, $ba, $bb, $bb ;mushroom stump bottom
0089AC  1  45 47 45 47    .byte $45, $47, $45, $47 ;breakable brick w/ line
0089B0  1  47 47 47 47    .byte $47, $47, $47, $47 ;breakable brick
0089B4  1  45 47 45 47    .byte $45, $47, $45, $47 ;breakable brick (not used)
0089B8  1  B4 B6 B5 B7    .byte $b4, $b6, $b5, $b7 ;cracked rock terrain
0089BC  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (power-up)
0089C0  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (vine)
0089C4  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (star)
0089C8  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (coins)
0089CC  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (1-up)
0089D0  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (power-up)
0089D4  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (vine)
0089D8  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (star)
0089DC  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (coins)
0089E0  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (1-up)
0089E4  1  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (1 coin)
0089E8  1  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (1-up)
0089EC  1  AB AC AD AE    .byte $ab, $ac, $ad, $ae ;solid block (3-d block)
0089F0  1  5D 5E 5D 5E    .byte $5d, $5e, $5d, $5e ;solid block (white wall)
0089F4  1  C1 24 C1 24    .byte $c1, $24, $c1, $24 ;bridge
0089F8  1  C6 C8 C7 C9    .byte $c6, $c8, $c7, $c9 ;bullet bill cannon barrel
0089FC  1  CA CC CB CD    .byte $ca, $cc, $cb, $cd ;bullet bill cannon top
008A00  1  2A 2A 40 40    .byte $2a, $2a, $40, $40 ;bullet bill cannon bottom
008A04  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank used for jumpspring
008A08  1  24 47 24 47    .byte $24, $47, $24, $47 ;half brick used for jumpspring
008A0C  1  82 83 84 85    .byte $82, $83, $84, $85 ;solid block (water level, green rock)
008A10  1  24 47 24 47    .byte $24, $47, $24, $47 ;half brick (???)
008A14  1  86 8A 87 8B    .byte $86, $8a, $87, $8b ;water pipe top
008A18  1  8E 91 8F 92    .byte $8e, $91, $8f, $92 ;water pipe bottom
008A1C  1  24 2F 24 3D    .byte $24, $2f, $24, $3d ;flag ball (residual object)
008A20  1               
008A20  1               Palette2_MTiles:
008A20  1  24 24 24 35    .byte $24, $24, $24, $35 ;cloud left
008A24  1  36 25 37 25    .byte $36, $25, $37, $25 ;cloud middle
008A28  1  24 38 24 24    .byte $24, $38, $24, $24 ;cloud right
008A2C  1  24 24 39 24    .byte $24, $24, $39, $24 ;cloud bottom left
008A30  1  3A 24 3B 24    .byte $3a, $24, $3b, $24 ;cloud bottom middle
008A34  1  3C 24 24 24    .byte $3c, $24, $24, $24 ;cloud bottom right
008A38  1  41 26 41 26    .byte $41, $26, $41, $26 ;water/lava top
008A3C  1  26 26 26 26    .byte $26, $26, $26, $26 ;water/lava
008A40  1  B0 B1 B2 B3    .byte $b0, $b1, $b2, $b3 ;cloud level terrain
008A44  1  77 79 77 79    .byte $77, $79, $77, $79 ;bowser's bridge
008A48  1               
008A48  1               Palette3_MTiles:
008A48  1  53 55 54 56    .byte $53, $55, $54, $56 ;question block (coin)
008A4C  1  53 55 54 56    .byte $53, $55, $54, $56 ;question block (power-up)
008A50  1  A5 A7 A6 A8    .byte $a5, $a7, $a6, $a8 ;coin
008A54  1  C2 C4 C3 C5    .byte $c2, $c4, $c3, $c5 ;underwater coin
008A58  1  57 59 58 5A    .byte $57, $59, $58, $5a ;empty block
008A5C  1  7B 7D 7C 7E    .byte $7b, $7d, $7c, $7e ;axe
008A60  1               
008A60  1               ;-------------------------------------------------------------------------------------
008A60  1               ;VRAM BUFFER DATA FOR LOCATIONS IN PRG-ROM
008A60  1               
008A60  1               WaterPaletteData:
008A60  1  3F 00 20       .byte $3f, $00, $20
008A63  1  0F 15 12 25    .byte $0f, $15, $12, $25
008A67  1  0F 3A 1A 0F    .byte $0f, $3a, $1a, $0f
008A6B  1  0F 30 12 0F    .byte $0f, $30, $12, $0f
008A6F  1  0F 27 12 0F    .byte $0f, $27, $12, $0f
008A73  1  22 16 27 18    .byte $22, $16, $27, $18
008A77  1  0F 10 30 27    .byte $0f, $10, $30, $27
008A7B  1  0F 16 30 27    .byte $0f, $16, $30, $27
008A7F  1  0F 0F 30 10    .byte $0f, $0f, $30, $10
008A83  1  00             .byte $00
008A84  1               
008A84  1               GroundPaletteData:
008A84  1  3F 00 20       .byte $3f, $00, $20
008A87  1  0F 29 1A 0F    .byte $0f, $29, $1a, $0f
008A8B  1  0F 36 17 0F    .byte $0f, $36, $17, $0f
008A8F  1  0F 30 21 0F    .byte $0f, $30, $21, $0f
008A93  1  0F 27 17 0F    .byte $0f, $27, $17, $0f
008A97  1  0F 16 27 18    .byte $0f, $16, $27, $18
008A9B  1  0F 1A 30 27    .byte $0f, $1a, $30, $27
008A9F  1  0F 16 30 27    .byte $0f, $16, $30, $27
008AA3  1  0F 0F 36 17    .byte $0f, $0f, $36, $17
008AA7  1  00             .byte $00
008AA8  1               
008AA8  1               UndergroundPaletteData:
008AA8  1  3F 00 20       .byte $3f, $00, $20
008AAB  1  0F 29 1A 09    .byte $0f, $29, $1a, $09
008AAF  1  0F 3C 1C 0F    .byte $0f, $3c, $1c, $0f
008AB3  1  0F 30 21 1C    .byte $0f, $30, $21, $1c
008AB7  1  0F 27 17 1C    .byte $0f, $27, $17, $1c
008ABB  1  0F 16 27 18    .byte $0f, $16, $27, $18
008ABF  1  0F 1C 36 17    .byte $0f, $1c, $36, $17
008AC3  1  0F 16 30 27    .byte $0f, $16, $30, $27
008AC7  1  0F 0C 3C 1C    .byte $0f, $0c, $3c, $1c
008ACB  1  00             .byte $00
008ACC  1               
008ACC  1               CastlePaletteData:
008ACC  1  3F 00 20       .byte $3f, $00, $20
008ACF  1  0F 30 10 00    .byte $0f, $30, $10, $00
008AD3  1  0F 30 10 00    .byte $0f, $30, $10, $00
008AD7  1  0F 30 16 00    .byte $0f, $30, $16, $00
008ADB  1  0F 27 17 00    .byte $0f, $27, $17, $00
008ADF  1  0F 16 27 18    .byte $0f, $16, $27, $18
008AE3  1  0F 1C 36 17    .byte $0f, $1c, $36, $17
008AE7  1  0F 16 30 27    .byte $0f, $16, $30, $27
008AEB  1  0F 00 30 10    .byte $0f, $00, $30, $10
008AEF  1  00             .byte $00
008AF0  1               
008AF0  1               DaySnowPaletteData:
008AF0  1  3F 00 04       .byte $3f, $00, $04
008AF3  1  22 30 00 10    .byte $22, $30, $00, $10
008AF7  1  00             .byte $00
008AF8  1               
008AF8  1               NightSnowPaletteData:
008AF8  1  3F 00 04       .byte $3f, $00, $04
008AFB  1  0F 30 00 10    .byte $0f, $30, $00, $10
008AFF  1  00             .byte $00
008B00  1               
008B00  1               MushroomPaletteData:
008B00  1  3F 00 04       .byte $3f, $00, $04
008B03  1  22 27 16 0F    .byte $22, $27, $16, $0f
008B07  1  00             .byte $00
008B08  1               
008B08  1               BowserPaletteData:
008B08  1  3F 14 04       .byte $3f, $14, $04
008B0B  1  0F 1A 30 27    .byte $0f, $1a, $30, $27
008B0F  1  00             .byte $00
008B10  1               
008B10  1               MarioThanksMessage:
008B10  1               ;"THANK YOU MARIO!"
008B10  1  25 48 10 1D     text_block $2548, "THANK YOU MARIO!"
008B14  1  11 0A 17 14  
008B18  1  24 22 18 1E  
008B23  1  00               .byte 0
008B24  1               
008B24  1               LuigiThanksMessage:
008B24  1  25 48 10 1D      text_block $2548, "THANK YOU LUIGI!"
008B28  1  11 0A 17 14  
008B2C  1  24 22 18 1E  
008B37  1  00               .byte 0
008B38  1               
008B38  1               MushroomRetainerSaved:
008B38  1  25 C5 16 0B      text_block $25C5, "BUT OUR PRINCESS IS IN"
008B3C  1  1E 1D 24 18  
008B40  1  1E 1B 24 19  
008B51  1  26 05 0F 0A      text_block $2605, "ANOTHER CASTLE!"
008B55  1  17 18 1D 11  
008B59  1  0E 1B 24 0C  
008B63  1  00               .byte 0
008B64  1               
008B64  1               PrincessSaved1:
008B64  1               ;"YOUR QUEST IS OVER."
008B64  1  25 A3 13 22    text_block $25a3, "YOUR QUEST IS OVER."
008B68  1  18 1E 1B 24  
008B6C  1  1A 1E 0E 1C  
008B7A  1  00             .byte $00
008B7B  1               
008B7B  1               
008B7B  1               PrincessSaved2:
008B7B  1               ;"WE PRESENT YOU A NEW QUEST."
008B7B  1  25 E3 1B 20    text_block $25e3, "WE PRESENT YOU A NEW QUEST."
008B7F  1  0E 24 19 1B  
008B83  1  0E 1C 0E 17  
008B99  1  00             .byte $00
008B9A  1               
008B9A  1               WorldSelectMessage1:
008B9A  1               ;"PUSH BUTTON B"
008B9A  1  26 4A 0D       .byte $26, $4a, $0d
008B9D  1  19 1E 1C 11    .byte $19, $1e, $1c, $11, $24
008BA1  1  24           
008BA2  1  0B 1E 1D 1D    .byte $0b, $1e, $1d, $1d, $18, $17, $24, $0b
008BA6  1  18 17 24 0B  
008BAA  1  00             .byte $00
008BAB  1               
008BAB  1               WorldSelectMessage2:
008BAB  1               ;"TO SELECT A WORLD"
008BAB  1  26 88 11       .byte $26, $88, $11
008BAE  1  1D 18 24 1C    .byte $1d, $18, $24, $1c, $0e, $15, $0e, $0c, $1d, $24
008BB2  1  0E 15 0E 0C  
008BB6  1  1D 24        
008BB8  1  0A 24 20 18    .byte $0a, $24, $20, $18, $1b, $15, $0d
008BBC  1  1B 15 0D     
008BBF  1  00             .byte $00
008BC0  1               
008BC0  1               ;-------------------------------------------------------------------------------------
008BC0  1               
008BC0  1               DefaultSprOffsets:
008BC0  1  04 30 48 60        .byte $04, $30, $48, $60, $78, $90, $a8, $c0
008BC4  1  78 90 A8 C0  
008BC8  1  D8 E8 24 F8        .byte $d8, $e8, $24, $f8, $fc, $28, $2c
008BCC  1  FC 28 2C     
008BCF  1               
008BCF  1               Sprite0Data:
008BCF  1  18 FF 23 58        .byte $18, $ff, $23, $58
008BD3  1               
008BD3  1               ;-------------------------------------------------------------------------------------
008BD3  1               
008BD3  1               PrimaryGameSetup:
008BD3  1  A9 01              lda #$01
008BD5  1  8D 57 07           sta FetchNewGameTimerFlag   ;set flag to load game timer from header
008BD8  1  8D 54 07           sta PlayerSize              ;set player's size to small
008BDB  1               
008BDB  1               SecondaryGameSetup:
008BDB  1  20 88 FE                  jsr Enter_ProcessLevelLoad
008BDE  1  A9 00                     lda #$00
008BE0  1  8D 74 07                  sta DisableScreenFlag     ;enable screen output
008BE3  1  A8                        tay
008BE4  1  99 00 03     ClearVRLoop: sta VRAM_Buffer1-1,y      ;clear buffer at $0300-$03ff
008BE7  1  C8                        iny
008BE8  1  D0 FA                     bne ClearVRLoop
008BEA  1  8D 59 07                  sta GameTimerExpiredFlag  ;clear game timer exp flag
008BED  1  8D 69 07                  sta DisableIntermediate   ;clear skip lives display flag
008BF0  1  8D 28 07                  sta BackloadingFlag       ;clear value here
008BF3  1  A9 FF                     lda #$ff
008BF5  1  8D A0 03                  sta BalPlatformAlignment  ;initialize balance platform assignment flag
008BF8  1  AD 1A 07                  lda ScreenLeft_PageLoc    ;get left side page location
008BFB  1  4E 78 07                  lsr Mirror_PPU_CTRL_REG1  ;shift LSB of ppu register #1 mirror out
008BFE  1  29 01                     and #$01                  ;mask out all but LSB of page location
008C00  1  6A                        ror                       ;rotate LSB of page location into carry then onto mirror
008C01  1  2E 78 07                  rol Mirror_PPU_CTRL_REG1  ;this is to set the proper PPU name table
008C04  1  20 3F 8C                  jsr GetAreaMusic          ;load proper music into queue
008C07  1  A9 38                     lda #$38                  ;load sprite shuffle amounts to be used later
008C09  1  8D E3 06                  sta SprShuffleAmt+2
008C0C  1  A9 48                     lda #$48
008C0E  1  8D E2 06                  sta SprShuffleAmt+1
008C11  1  A9 58                     lda #$58
008C13  1  8D E1 06                  sta SprShuffleAmt
008C16  1  A2 0E                     ldx #$0e                  ;load default OAM offsets into $06e4-$06f2
008C18  1  BD C0 8B     ShufAmtLoop: lda DefaultSprOffsets,x
008C1B  1  9D E4 06                  sta SprDataOffset,x
008C1E  1  CA                        dex                       ;do this until they're all set
008C1F  1  10 F7                     bpl ShufAmtLoop
008C21  1  A0 03                     ldy #$03                  ;set up sprite #0
008C23  1  B9 CF 8B     ISpr0Loop:   lda Sprite0Data,y
008C26  1  99 00 02                  sta Sprite_Data,y
008C29  1  88                        dey
008C2A  1  10 F7                     bpl ISpr0Loop
008C2C  1  20 95 8D                  jsr DoNothing2            ;these jsrs doesn't do anything useful
008C2F  1  20 90 8D                  jsr DoNothing1
008C32  1  EE 22 07                  inc Sprite0HitDetectFlag  ;set sprite #0 check flag
008C35  1  EE 72 07                  inc OperMode_Task         ;increment to next task
008C38  1  60                        rts
008C39  1               
008C39  1               ;-------------------------------------------------------------------------------------
008C39  1               
008C39  1               MusicSelectData:
008C39  1  02 01 04 08        .byte WaterMusic, GroundMusic, UndergroundMusic, CastleMusic
008C3D  1  10 20              .byte CloudMusic, PipeIntroMusic
008C3F  1               
008C3F  1               GetAreaMusic:
008C3F  1  AD 70 07                  lda OperMode           ;if in title screen mode, leave
008C42  1  F0 23                     beq ExitGetM
008C44  1  AD 52 07                  lda AltEntranceControl ;check for specific alternate mode of entry
008C47  1  C9 02                     cmp #$02               ;if found, branch without checking starting position
008C49  1  F0 0D                     beq ChkAreaType        ;from area object data header
008C4B  1  A0 05                     ldy #$05               ;select music for pipe intro scene by default
008C4D  1  AD 10 07                  lda PlayerEntranceCtrl ;check value from level header for certain values
008C50  1  C9 06                     cmp #$06
008C52  1  F0 0E                     beq StoreMusic         ;load music for pipe intro scene if header
008C54  1  C9 07                     cmp #$07               ;start position either value $06 or $07
008C56  1  F0 0A                     beq StoreMusic
008C58  1  AC 4E 07     ChkAreaType: ldy AreaType           ;load area type as offset for music bit
008C5B  1  AD 43 07                  lda CloudTypeOverride
008C5E  1  F0 02                     beq StoreMusic         ;check for cloud type override
008C60  1  A0 04                     ldy #$04               ;select music for cloud type level if found
008C62  1  B9 39 8C     StoreMusic:  lda MusicSelectData,y  ;otherwise select appropriate music for level type
008C65  1  85 FB                     sta AreaMusicQueue     ;store in queue and leave
008C67  1  60           ExitGetM:    rts
008C68  1               
008C68  1               ;-------------------------------------------------------------------------------------
008C68  1               
008C68  1               PlayerStarting_X_Pos:
008C68  1  28 18              .byte $28, $18
008C6A  1  38 28              .byte $38, $28
008C6C  1               
008C6C  1               AltYPosOffset:
008C6C  1  08 00              .byte $08, $00
008C6E  1               
008C6E  1               PlayerStarting_Y_Pos:
008C6E  1  00 20 B0 50        .byte $00, $20, $b0, $50, $00, $00, $b0, $b0
008C72  1  00 00 B0 B0  
008C76  1  F0                 .byte $f0
008C77  1               
008C77  1               PlayerBGPriorityData:
008C77  1  00 20 00 00        .byte $00, $20, $00, $00, $00, $00, $00, $00
008C7B  1  00 00 00 00  
008C7F  1               
008C7F  1               GameTimerData:
008C7F  1  20                 .byte $20 ;dummy byte, used as part of bg priority data
008C80  1  04 03 02           .byte $04, $03, $02
008C83  1               
008C83  1               Entrance_GameTimerSetup:
008C83  1  AD 1A 07               lda ScreenLeft_PageLoc      ;set current page for area objects
008C86  1  85 6D                  sta Player_PageLoc          ;as page location for player
008C88  1  A9 28                  lda #$28                    ;store value here
008C8A  1  8D 0A 07               sta VerticalForceDown       ;for fractional movement downwards if necessary
008C8D  1  A9 01                  lda #$01                    ;set high byte of player position and
008C8F  1  85 33                  sta PlayerFacingDir         ;set facing direction so that player faces right
008C91  1  85 B5                  sta Player_Y_HighPos
008C93  1  A9 00                  lda #$00                    ;set player state to on the ground by default
008C95  1  85 1D                  sta Player_State
008C97  1  CE 90 04               dec Player_CollisionBits    ;initialize player's collision bits
008C9A  1  A0 00                  ldy #$00                    ;initialize halfway page
008C9C  1  8C 5B 07               sty HalfwayPage
008C9F  1  AD 4E 07               lda AreaType                ;check area type
008CA2  1  D0 01                  bne ChkStPos                ;if water type, set swimming flag, otherwise do not set
008CA4  1  C8                     iny
008CA5  1  8C 04 07     ChkStPos: sty SwimmingFlag
008CA8  1  AE 10 07               ldx PlayerEntranceCtrl      ;get starting position loaded from header
008CAB  1  AC 52 07               ldy AltEntranceControl      ;check alternate mode of entry flag for 0 or 1
008CAE  1  F0 07                  beq SetStPos
008CB0  1  C0 01                  cpy #$01
008CB2  1  F0 03                  beq SetStPos
008CB4  1  BE 6A 8C               ldx AltYPosOffset-2,y       ;if not 0 or 1, override $0710 with new offset in X
008CB7  1  B9 68 8C     SetStPos: lda PlayerStarting_X_Pos,y  ;load appropriate horizontal position
008CBA  1  85 86                  sta Player_X_Position       ;and vertical positions for the player, using
008CBC  1  BD 6E 8C               lda PlayerStarting_Y_Pos,x  ;AltEntranceControl as offset for horizontal and either $0710
008CBF  1  85 CE                  sta Player_Y_Position       ;or value that overwrote $0710 as offset for vertical
008CC1  1  BD 77 8C               lda PlayerBGPriorityData,x
008CC4  1  8D C4 03               sta Player_SprAttrib        ;set player sprite attributes using offset in X
008CC7  1  20 CE EE               jsr GetPlayerColors         ;get appropriate player palette
008CCA  1  AC 15 07               ldy GameTimerSetting        ;get timer control value from header
008CCD  1  F0 1A                  beq ChkOverR                ;if set to zero, branch (do not use dummy byte for this)
008CCF  1  AD 57 07               lda FetchNewGameTimerFlag   ;do we need to set the game timer? if not, use
008CD2  1  F0 15                  beq ChkOverR                ;old game timer setting
008CD4  1  B9 7F 8C               lda GameTimerData,y         ;if game timer is set and game timer flag is also set,
008CD7  1  8D F8 07               sta GameTimerDisplay        ;use value of game timer control for first digit of game timer
008CDA  1  A9 01                  lda #$01
008CDC  1  8D FA 07               sta GameTimerDisplay+2      ;set last digit of game timer to 1
008CDF  1  4A                     lsr
008CE0  1  8D F9 07               sta GameTimerDisplay+1      ;set second digit of game timer
008CE3  1  8D 57 07               sta FetchNewGameTimerFlag   ;clear flag for game timer reset
008CE6  1  8D 9F 07               sta StarInvincibleTimer     ;clear star mario timer
008CE9  1  AC 58 07     ChkOverR: ldy JoypadOverride          ;if controller bits not set, branch to skip this part
008CEC  1  F0 14                  beq ChkSwimE
008CEE  1  A9 03                  lda #$03                    ;set player state to climbing
008CF0  1  85 1D                  sta Player_State
008CF2  1  A2 00                  ldx #$00                    ;set offset for first slot, for block object
008CF4  1  20 3B BE               jsr InitBlock_XY_Pos
008CF7  1  A9 F0                  lda #$f0                    ;set vertical coordinate for block object
008CF9  1  85 D7                  sta Block_Y_Position
008CFB  1  A2 05                  ldx #$05                    ;set offset in X for last enemy object buffer slot
008CFD  1  A0 00                  ldy #$00                    ;set offset in Y for object coordinates used earlier
008CFF  1  20 53 EE               jsr Setup_Vine              ;do a sub to grow vine
008D02  1  AC 4E 07     ChkSwimE: ldy AreaType                ;if level not water-type,
008D05  1  D0 03                  bne SetPESub                ;skip this subroutine
008D07  1  20 D2 B0               jsr SetupBubble             ;otherwise, execute sub to set up air bubbles
008D0A  1  A9 07        SetPESub: lda #$07                    ;set to run player entrance subroutine
008D0C  1  85 0E                  sta GameEngineSubroutine    ;on the next frame of game engine
008D0E  1  60                     rts
008D0F  1               
008D0F  1               ;-------------------------------------------------------------------------------------
008D0F  1               
008D0F  1               ;page numbers are in order from -1 to -4
008D0F  1               HalfwayPageNybbles:
008D0F  1  56 40              .byte $56, $40
008D11  1  65 70              .byte $65, $70
008D13  1  66 40              .byte $66, $40
008D15  1  66 40              .byte $66, $40
008D17  1  66 40              .byte $66, $40
008D19  1  66 60              .byte $66, $60
008D1B  1  65 70              .byte $65, $70
008D1D  1  00 00              .byte $00, $00
008D1F  1               
008D1F  1               PlayerLoseLife:
008D1F  1  EE 74 07                  inc DisableScreenFlag    ;disable screen and sprite 0 check
008D22  1  A9 00                     lda #$00
008D24  1  8D 22 07                  sta Sprite0HitDetectFlag
008D27  1  A9 80                     lda #Silence             ;silence music
008D29  1  85 FC                     sta EventMusicQueue
008D2B  1  AD 5F 07     StillInGame: lda WorldNumber          ;multiply world number by 2 and use
008D2E  1  0A                        asl                      ;as offset
008D2F  1  AA                        tax
008D30  1  AD 5C 07                  lda LevelNumber          ;if in area -3 or -4, increment
008D33  1  29 02                     and #$02                 ;offset by one byte, otherwise
008D35  1  F0 01                     beq GetHalfway           ;leave offset alone
008D37  1  E8                        inx
008D38  1  BC 0F 8D     GetHalfway:  ldy HalfwayPageNybbles,x ;get halfway page number with offset
008D3B  1  AD 5C 07                  lda LevelNumber          ;check area number's LSB
008D3E  1  4A                        lsr
008D3F  1  98                        tya                      ;if in area -2 or -4, use lower nybble
008D40  1  B0 04                     bcs MaskHPNyb
008D42  1  4A                        lsr                      ;move higher nybble to lower if area
008D43  1  4A                        lsr                      ;number is -1 or -3
008D44  1  4A                        lsr
008D45  1  4A                        lsr
008D46  1  29 0F        MaskHPNyb:   and #%00001111           ;mask out all but lower nybble
008D48  1  CD 1A 07                  cmp ScreenLeft_PageLoc
008D4B  1  F0 04                     beq SetHalfway           ;left side of screen must be at the halfway page,
008D4D  1  90 02                     bcc SetHalfway           ;otherwise player must start at the
008D4F  1  A9 00                     lda #$00                 ;beginning of the level
008D51  1  8D 5B 07     SetHalfway:  sta HalfwayPage          ;store as halfway page for player
008D54  1               			;
008D54  1               			; TODO XXX What does this do? :)
008D54  1               			;
008D54  1  20 4F BC     			jsr LoadAreaPointer       ;update level pointer with
008D57  1  A9 01        			lda #$01                  ;actual world and area numbers, then
008D59  1  8D 54 07     			sta PlayerSize            ;reset player's size, status, and
008D5C  1  EE 57 07     			inc FetchNewGameTimerFlag ;set game timer flag to reload
008D5F  1  A9 00        			lda #$00                  ;game timer from header
008D61  1  8D 47 07     			sta TimerControl          ;also set flag for timers to count again
008D64  1  8D 56 07     			sta PlayerStatus
008D67  1  85 0E        			sta GameEngineSubroutine  ;reset task for game core
008D69  1  8D 72 07     			sta OperMode_Task         ;set modes and leave
008D6C  1  A9 01        			lda #$01                  ;if in game over mode, switch back to
008D6E  1  8D 70 07     			sta OperMode
008D71  1  60           			rts
008D72  1               			;
008D72  1               			; Old code
008D72  1               			;
008D72  1               			;jmp ContinueGame         ;continue the game
008D72  1               
008D72  1               ;-------------------------------------------------------------------------------------
008D72  1               
008D72  1               ContinueGame:
008D72  1  20 4F BC                jsr LoadAreaPointer       ;update level pointer with
008D75  1  A9 01                   lda #$01                  ;actual world and area numbers, then
008D77  1  8D 54 07                sta PlayerSize            ;reset player's size, status, and
008D7A  1  EE 57 07                inc FetchNewGameTimerFlag ;set game timer flag to reload
008D7D  1  A9 00                   lda #$00                  ;game timer from header
008D7F  1  8D 47 07                sta TimerControl          ;also set flag for timers to count again
008D82  1  8D 56 07                sta PlayerStatus
008D85  1  85 0E                   sta GameEngineSubroutine  ;reset task for game core
008D87  1  8D 72 07                sta OperMode_Task         ;set modes and leave
008D8A  1  A9 01                   lda #$01                  ;if in game over mode, switch back to
008D8C  1  8D 70 07                sta OperMode              ;game mode, because game is still on
008D8F  1  60           GameIsOn:  rts
008D90  1               
008D90  1               ;-------------------------------------------------------------------------------------
008D90  1               
008D90  1               DoNothing1:
008D90  1  A9 FF              lda #$ff       ;this is residual code, this value is
008D92  1  8D C9 06           sta $06c9      ;not used anywhere in the program
008D95  1               DoNothing2:
008D95  1  60                 rts
008D96  1               
008D96  1               ;-------------------------------------------------------------------------------------
008D96  1               
008D96  1               AreaParserTaskHandler:
008D96  1  AC 1F 07                   ldy AreaParserTaskNum     ;check number of tasks here
008D99  1  D0 05                      bne DoAPTasks             ;if already set, go ahead
008D9B  1  A0 08                      ldy #$08
008D9D  1  8C 1F 07                   sty AreaParserTaskNum     ;otherwise, set eight by default
008DA0  1  88           DoAPTasks:    dey
008DA1  1  98                         tya
008DA2  1  20 AE 8D                   jsr AreaParserTasks
008DA5  1  CE 1F 07                   dec AreaParserTaskNum     ;if all tasks not complete do not
008DA8  1  D0 03                      bne SkipATRender          ;render attribute table yet
008DAA  1  20 F5 87                   jsr RenderAttributeTables
008DAD  1  60           SkipATRender: rts
008DAE  1               
008DAE  1               AreaParserTasks:
008DAE  1  20 97 BA           jsr JumpEngine
008DB1  1               
008DB1  1  C1 8D              .word IncrementColumnPos
008DB3  1  39 87              .word RenderAreaGraphics
008DB5  1  39 87              .word RenderAreaGraphics
008DB7  1  E2 8E              .word AreaParserCore
008DB9  1  C1 8D              .word IncrementColumnPos
008DBB  1  39 87              .word RenderAreaGraphics
008DBD  1  39 87              .word RenderAreaGraphics
008DBF  1  E2 8E              .word AreaParserCore
008DC1  1               
008DC1  1               ;-------------------------------------------------------------------------------------
008DC1  1               
008DC1  1               IncrementColumnPos:
008DC1  1  EE 26 07                inc CurrentColumnPos     ;increment column where we're at
008DC4  1  AD 26 07                lda CurrentColumnPos
008DC7  1  29 0F                   and #%00001111           ;mask out higher nybble
008DC9  1  D0 06                   bne NoColWrap
008DCB  1  8D 26 07                sta CurrentColumnPos     ;if no bits left set, wrap back to zero (0-f)
008DCE  1  EE 25 07                inc CurrentPageLoc       ;and increment page number where we're at
008DD1  1  EE A0 06     NoColWrap: inc BlockBufferColumnPos ;increment column offset where we're at
008DD4  1  AD A0 06                lda BlockBufferColumnPos
008DD7  1  29 1F                   and #%00011111           ;mask out all but 5 LSB (0-1f)
008DD9  1  8D A0 06                sta BlockBufferColumnPos ;and save
008DDC  1  60                      rts
008DDD  1               
008DDD  1               ;-------------------------------------------------------------------------------------
008DDD  1               ;$00 - used as counter, store for low nybble for background, ceiling byte for terrain
008DDD  1               ;$01 - used to store floor byte for terrain
008DDD  1               ;$07 - used to store terrain metatile
008DDD  1               ;$06-$07 - used to store block buffer address
008DDD  1               
008DDD  1               BSceneDataOffsets:
008DDD  1  00 30 60           .byte $00, $30, $60
008DE0  1               
008DE0  1               BackSceneryData:
008DE0  1  93 00 00 11     .byte $93, $00, $00, $11, $12, $12, $13, $00 ;clouds
008DE4  1  12 12 13 00  
008DE8  1  00 51 52 53     .byte $00, $51, $52, $53, $00, $00, $00, $00
008DEC  1  00 00 00 00  
008DF0  1  00 00 01 02     .byte $00, $00, $01, $02, $02, $03, $00, $00
008DF4  1  02 03 00 00  
008DF8  1  00 00 00 00     .byte $00, $00, $00, $00, $91, $92, $93, $00
008DFC  1  91 92 93 00  
008E00  1  00 00 00 51     .byte $00, $00, $00, $51, $52, $53, $41, $42
008E04  1  52 53 41 42  
008E08  1  43 00 00 00     .byte $43, $00, $00, $00, $00, $00, $91, $92
008E0C  1  00 00 91 92  
008E10  1               
008E10  1  97 87 88 89     .byte $97, $87, $88, $89, $99, $00, $00, $00 ;mountains and bushes
008E14  1  99 00 00 00  
008E18  1  11 12 13 A4     .byte $11, $12, $13, $a4, $a5, $a5, $a5, $a6
008E1C  1  A5 A5 A5 A6  
008E20  1  97 98 99 01     .byte $97, $98, $99, $01, $02, $03, $00, $a4
008E24  1  02 03 00 A4  
008E28  1  A5 A6 00 11     .byte $a5, $a6, $00, $11, $12, $12, $12, $13
008E2C  1  12 12 12 13  
008E30  1  00 00 00 00     .byte $00, $00, $00, $00, $01, $02, $02, $03
008E34  1  01 02 02 03  
008E38  1  00 A4 A5 A5     .byte $00, $a4, $a5, $a5, $a6, $00, $00, $00
008E3C  1  A6 00 00 00  
008E40  1               
008E40  1  11 12 12 13     .byte $11, $12, $12, $13, $00, $00, $00, $00 ;trees and fences
008E44  1  00 00 00 00  
008E48  1  00 00 00 9C     .byte $00, $00, $00, $9c, $00, $8b, $aa, $aa
008E4C  1  00 8B AA AA  
008E50  1  AA AA 11 12     .byte $aa, $aa, $11, $12, $13, $8b, $00, $9c
008E54  1  13 8B 00 9C  
008E58  1  9C 00 00 01     .byte $9c, $00, $00, $01, $02, $03, $11, $12
008E5C  1  02 03 11 12  
008E60  1  12 13 00 00     .byte $12, $13, $00, $00, $00, $00, $aa, $aa
008E64  1  00 00 AA AA  
008E68  1  9C AA 00 8B     .byte $9c, $aa, $00, $8b, $00, $01, $02, $03
008E6C  1  00 01 02 03  
008E70  1               
008E70  1               BackSceneryMetatiles:
008E70  1  80 83 00        .byte $80, $83, $00 ;cloud left
008E73  1  81 84 00        .byte $81, $84, $00 ;cloud middle
008E76  1  82 85 00        .byte $82, $85, $00 ;cloud right
008E79  1  02 00 00        .byte $02, $00, $00 ;bush left
008E7C  1  03 00 00        .byte $03, $00, $00 ;bush middle
008E7F  1  04 00 00        .byte $04, $00, $00 ;bush right
008E82  1  00 05 06        .byte $00, $05, $06 ;mountain left
008E85  1  07 06 0A        .byte $07, $06, $0a ;mountain middle
008E88  1  00 08 09        .byte $00, $08, $09 ;mountain right
008E8B  1  4D 00 00        .byte $4d, $00, $00 ;fence
008E8E  1  0D 0F 4E        .byte $0d, $0f, $4e ;tall tree
008E91  1  0E 4E 4E        .byte $0e, $4e, $4e ;short tree
008E94  1               
008E94  1               FSceneDataOffsets:
008E94  1  00 0D 1A           .byte $00, $0d, $1a
008E97  1               
008E97  1               ForeSceneryData:
008E97  1  86 87 87 87     .byte $86, $87, $87, $87, $87, $87, $87   ;in water
008E9B  1  87 87 87     
008E9E  1  87 87 87 87     .byte $87, $87, $87, $87, $69, $69
008EA2  1  69 69        
008EA4  1               
008EA4  1  00 00 00 00     .byte $00, $00, $00, $00, $00, $45, $47   ;wall
008EA8  1  00 45 47     
008EAB  1  47 47 47 47     .byte $47, $47, $47, $47, $00, $00
008EAF  1  00 00        
008EB1  1               
008EB1  1  00 00 00 00     .byte $00, $00, $00, $00, $00, $00, $00   ;over water
008EB5  1  00 00 00     
008EB8  1  00 00 00 00     .byte $00, $00, $00, $00, $86, $87
008EBC  1  86 87        
008EBE  1               
008EBE  1               TerrainMetatiles:
008EBE  1  69 54 52 62        .byte $69, $54, $52, $62
008EC2  1               
008EC2  1               TerrainRenderBits:
008EC2  1  00 00              .byte %00000000, %00000000 ;no ceiling or floor
008EC4  1  00 18              .byte %00000000, %00011000 ;no ceiling, floor 2
008EC6  1  01 18              .byte %00000001, %00011000 ;ceiling 1, floor 2
008EC8  1  07 18              .byte %00000111, %00011000 ;ceiling 3, floor 2
008ECA  1  0F 18              .byte %00001111, %00011000 ;ceiling 4, floor 2
008ECC  1  FF 18              .byte %11111111, %00011000 ;ceiling 8, floor 2
008ECE  1  01 1F              .byte %00000001, %00011111 ;ceiling 1, floor 5
008ED0  1  07 1F              .byte %00000111, %00011111 ;ceiling 3, floor 5
008ED2  1  0F 1F              .byte %00001111, %00011111 ;ceiling 4, floor 5
008ED4  1  81 1F              .byte %10000001, %00011111 ;ceiling 1, floor 6
008ED6  1  01 00              .byte %00000001, %00000000 ;ceiling 1, no floor
008ED8  1  8F 1F              .byte %10001111, %00011111 ;ceiling 4, floor 6
008EDA  1  F1 1F              .byte %11110001, %00011111 ;ceiling 1, floor 9
008EDC  1  F9 18              .byte %11111001, %00011000 ;ceiling 1, middle 5, floor 2
008EDE  1  F1 18              .byte %11110001, %00011000 ;ceiling 1, middle 4, floor 2
008EE0  1  FF 1F              .byte %11111111, %00011111 ;completely solid top to bottom
008EE2  1               
008EE2  1               AreaParserCore:
008EE2  1  AD 28 07           lda BackloadingFlag       ;check to see if we are starting right of start
008EE5  1  F0 03              beq RenderSceneryTerrain  ;if not, go ahead and render background, foreground and terrain
008EE7  1  20 EE 8F           jsr ProcessAreaData       ;otherwise skip ahead and load level data
008EEA  1               
008EEA  1               RenderSceneryTerrain:
008EEA  1  A2 0C                  ldx #$0c
008EEC  1  A9 00                  lda #$00
008EEE  1  9D A1 06     ClrMTBuf: sta MetatileBuffer,x       ;clear out metatile buffer
008EF1  1  CA                     dex
008EF2  1  10 FA                  bpl ClrMTBuf
008EF4  1  AC 42 07               ldy BackgroundScenery      ;do we need to render the background scenery?
008EF7  1  F0 42                  beq RendFore               ;if not, skip to check the foreground
008EF9  1  AD 25 07               lda CurrentPageLoc         ;otherwise check for every third page
008EFC  1  C9 03        ThirdP:   cmp #$03
008EFE  1  30 05                  bmi RendBack               ;if less than three we're there
008F00  1  38                     sec
008F01  1  E9 03                  sbc #$03                   ;if 3 or more, subtract 3 and
008F03  1  10 F7                  bpl ThirdP                 ;do an unconditional branch
008F05  1  0A           RendBack: asl                        ;move results to higher nybble
008F06  1  0A                     asl
008F07  1  0A                     asl
008F08  1  0A                     asl
008F09  1  79 DC 8D               adc BSceneDataOffsets-1,y  ;add to it offset loaded from here
008F0C  1  6D 26 07               adc CurrentColumnPos       ;add to the result our current column position
008F0F  1  AA                     tax
008F10  1  BD E0 8D               lda BackSceneryData,x      ;load data from sum of offsets
008F13  1  F0 26                  beq RendFore               ;if zero, no scenery for that part
008F15  1  48                     pha
008F16  1  29 0F                  and #$0f                   ;save to stack and clear high nybble
008F18  1  38                     sec
008F19  1  E9 01                  sbc #$01                   ;subtract one (because low nybble is $01-$0c)
008F1B  1  85 00                  sta $00                    ;save low nybble
008F1D  1  0A                     asl                        ;multiply by three (shift to left and add result to old one)
008F1E  1  65 00                  adc $00                    ;note that since d7 was nulled, the carry flag is always clear
008F20  1  AA                     tax                        ;save as offset for background scenery metatile data
008F21  1  68                     pla                        ;get high nybble from stack, move low
008F22  1  4A                     lsr
008F23  1  4A                     lsr
008F24  1  4A                     lsr
008F25  1  4A                     lsr
008F26  1  A8                     tay                        ;use as second offset (used to determine height)
008F27  1  A9 03                  lda #$03                   ;use previously saved memory location for counter
008F29  1  85 00                  sta $00
008F2B  1  BD 70 8E     SceLoop1: lda BackSceneryMetatiles,x ;load metatile data from offset of (lsb - 1) * 3
008F2E  1  99 A1 06               sta MetatileBuffer,y       ;store into buffer from offset of (msb / 16)
008F31  1  E8                     inx
008F32  1  C8                     iny
008F33  1  C0 0B                  cpy #$0b                   ;if at this location, leave loop
008F35  1  F0 04                  beq RendFore
008F37  1  C6 00                  dec $00                    ;decrement until counter expires, barring exception
008F39  1  D0 F0                  bne SceLoop1
008F3B  1  AE 41 07     RendFore: ldx ForegroundScenery      ;check for foreground data needed or not
008F3E  1  F0 13                  beq RendTerr               ;if not, skip this part
008F40  1  BC 93 8E               ldy FSceneDataOffsets-1,x  ;load offset from location offset by header value, then
008F43  1  A2 00                  ldx #$00                   ;reinit X
008F45  1  B9 97 8E     SceLoop2: lda ForeSceneryData,y      ;load data until counter expires
008F48  1  F0 03                  beq NoFore                 ;do not store if zero found
008F4A  1  9D A1 06               sta MetatileBuffer,x
008F4D  1  C8           NoFore:   iny
008F4E  1  E8                     inx
008F4F  1  E0 0D                  cpx #$0d                   ;store up to end of metatile buffer
008F51  1  D0 F2                  bne SceLoop2
008F53  1  AC 4E 07     RendTerr: ldy AreaType               ;check world type for water level
008F56  1  D0 0C                  bne TerMTile               ;if not water level, skip this part
008F58  1  AD 5F 07               lda WorldNumber            ;check world number, if not world number eight
008F5B  1  C9 07                  cmp #World8                ;then skip this part
008F5D  1  D0 05                  bne TerMTile
008F5F  1  A9 62                  lda #$62                   ;if set as water level and world number eight,
008F61  1  4C 6E 8F               jmp StoreMT                ;use castle wall metatile as terrain type
008F64  1  B9 BE 8E     TerMTile: lda TerrainMetatiles,y     ;otherwise get appropriate metatile for area type
008F67  1  AC 43 07               ldy CloudTypeOverride      ;check for cloud type override
008F6A  1  F0 02                  beq StoreMT                ;if not set, keep value otherwise
008F6C  1  A9 88                  lda #$88                   ;use cloud block terrain
008F6E  1  85 07        StoreMT:  sta $07                    ;store value here
008F70  1  A2 00                  ldx #$00                   ;initialize X, use as metatile buffer offset
008F72  1  AD 27 07               lda TerrainControl         ;use yet another value from the header
008F75  1  0A                     asl                        ;multiply by 2 and use as yet another offset
008F76  1  A8                     tay
008F77  1  B9 C2 8E     TerrLoop: lda TerrainRenderBits,y    ;get one of the terrain rendering bit data
008F7A  1  85 00                  sta $00
008F7C  1  C8                     iny                        ;increment Y and use as offset next time around
008F7D  1  84 01                  sty $01
008F7F  1  AD 43 07               lda CloudTypeOverride      ;skip if value here is zero
008F82  1  F0 0A                  beq NoCloud2
008F84  1  E0 00                  cpx #$00                   ;otherwise, check if we're doing the ceiling byte
008F86  1  F0 06                  beq NoCloud2
008F88  1  A5 00                  lda $00                    ;if not, mask out all but d3
008F8A  1  29 08                  and #%00001000
008F8C  1  85 00                  sta $00
008F8E  1  A0 00        NoCloud2: ldy #$00                   ;start at beginning of bitmasks
008F90  1  B9 34 B7     TerrBChk: lda Bitmasks,y             ;load bitmask, then perform AND on contents of first byte
008F93  1  24 00                  bit $00
008F95  1  F0 05                  beq NextTBit               ;if not set, skip this part (do not write terrain to buffer)
008F97  1  A5 07                  lda $07
008F99  1  9D A1 06               sta MetatileBuffer,x       ;load terrain type metatile number and store into buffer here
008F9C  1  E8           NextTBit: inx                        ;continue until end of buffer
008F9D  1  E0 0D                  cpx #$0d
008F9F  1  F0 18                  beq RendBBuf               ;if we're at the end, break out of this loop
008FA1  1  AD 4E 07               lda AreaType               ;check world type for underground area
008FA4  1  C9 02                  cmp #$02
008FA6  1  D0 08                  bne EndUChk                ;if not underground, skip this part
008FA8  1  E0 0B                  cpx #$0b
008FAA  1  D0 04                  bne EndUChk                ;if we're at the bottom of the screen, override
008FAC  1  A9 54                  lda #$54                   ;old terrain type with ground level terrain type
008FAE  1  85 07                  sta $07
008FB0  1  C8           EndUChk:  iny                        ;increment bitmasks offset in Y
008FB1  1  C0 08                  cpy #$08
008FB3  1  D0 DB                  bne TerrBChk               ;if not all bits checked, loop back
008FB5  1  A4 01                  ldy $01
008FB7  1  D0 BE                  bne TerrLoop               ;unconditional branch, use Y to load next byte
008FB9  1  20 EE 8F     RendBBuf: jsr ProcessAreaData        ;do the area data loading routine now
008FBC  1  AD A0 06               lda BlockBufferColumnPos
008FBF  1  20 3E EE               jsr GetBlockBufferAddr     ;get block buffer address from where we're at
008FC2  1  A2 00                  ldx #$00
008FC4  1  A0 00                  ldy #$00                   ;init index regs and start at beginning of smaller buffer
008FC6  1  84 00        ChkMTLow: sty $00
008FC8  1  BD A1 06               lda MetatileBuffer,x       ;load stored metatile number
008FCB  1  29 C0                  and #%11000000             ;mask out all but 2 MSB
008FCD  1  0A                     asl
008FCE  1  2A                     rol                        ;make %xx000000 into %000000xx
008FCF  1  2A                     rol
008FD0  1  A8                     tay                        ;use as offset in Y
008FD1  1  BD A1 06               lda MetatileBuffer,x       ;reload original unmasked value here
008FD4  1  D9 EA 8F               cmp BlockBuffLowBounds,y   ;check for certain values depending on bits set
008FD7  1  B0 02                  bcs StrBlock               ;if equal or greater, branch
008FD9  1  A9 00                  lda #$00                   ;if less, init value before storing
008FDB  1  A4 00        StrBlock: ldy $00                    ;get offset for block buffer
008FDD  1  91 06                  sta ($06),y                ;store value into block buffer
008FDF  1  98                     tya
008FE0  1  18                     clc                        ;add 16 (move down one row) to offset
008FE1  1  69 10                  adc #$10
008FE3  1  A8                     tay
008FE4  1  E8                     inx                        ;increment column value
008FE5  1  E0 0D                  cpx #$0d
008FE7  1  90 DD                  bcc ChkMTLow               ;continue until we pass last row, then leave
008FE9  1  60                     rts
008FEA  1               
008FEA  1               ;numbers lower than these with the same attribute bits
008FEA  1               ;will not be stored in the block buffer
008FEA  1               BlockBuffLowBounds:
008FEA  1  10 51 88 C0        .byte $10, $51, $88, $c0
008FEE  1               
008FEE  1               ;-------------------------------------------------------------------------------------
008FEE  1               ;$00 - used to store area object identifier
008FEE  1               ;$07 - used as adder to find proper area object code
008FEE  1               
008FEE  1               ProcessAreaData:
008FEE  1  A2 02                    ldx #$02                 ;start at the end of area object buffer
008FF0  1  86 08        ProcADLoop: stx ObjectOffset
008FF2  1  A9 00                    lda #$00                 ;reset flag
008FF4  1  8D 29 07                 sta BehindAreaParserFlag
008FF7  1  AC 2C 07                 ldy AreaDataOffset       ;get offset of area data pointer
008FFA  1  B1 E7                    lda (AreaData),y         ;get first byte of area object
008FFC  1  C9 FD                    cmp #$fd                 ;if end-of-area, skip all this crap
008FFE  1  F0 4B                    beq RdyDecode
009000  1  BD 30 07                 lda AreaObjectLength,x   ;check area object buffer flag
009003  1  10 46                    bpl RdyDecode            ;if buffer not negative, branch, otherwise
009005  1  C8                       iny
009006  1  B1 E7                    lda (AreaData),y         ;get second byte of area object
009008  1  0A                       asl                      ;check for page select bit (d7), branch if not set
009009  1  90 0B                    bcc Chk1Row13
00900B  1  AD 2B 07                 lda AreaObjectPageSel    ;check page select
00900E  1  D0 06                    bne Chk1Row13
009010  1  EE 2B 07                 inc AreaObjectPageSel    ;if not already set, set it now
009013  1  EE 2A 07                 inc AreaObjectPageLoc    ;and increment page location
009016  1  88           Chk1Row13:  dey
009017  1  B1 E7                    lda (AreaData),y         ;reread first byte of level object
009019  1  29 0F                    and #$0f                 ;mask out high nybble
00901B  1  C9 0D                    cmp #$0d                 ;row 13?
00901D  1  D0 1B                    bne Chk1Row14
00901F  1  C8                       iny                      ;if so, reread second byte of level object
009020  1  B1 E7                    lda (AreaData),y
009022  1  88                       dey                      ;decrement to get ready to read first byte
009023  1  29 40                    and #%01000000           ;check for d6 set (if not, object is page control)
009025  1  D0 1C                    bne CheckRear
009027  1  AD 2B 07                 lda AreaObjectPageSel    ;if page select is set, do not reread
00902A  1  D0 17                    bne CheckRear
00902C  1  C8                       iny                      ;if d6 not set, reread second byte
00902D  1  B1 E7                    lda (AreaData),y
00902F  1  29 1F                    and #%00011111           ;mask out all but 5 LSB and store in page control
009031  1  8D 2A 07                 sta AreaObjectPageLoc
009034  1  EE 2B 07                 inc AreaObjectPageSel    ;increment page select
009037  1  4C 54 90                 jmp NextAObj
00903A  1  C9 0E        Chk1Row14:  cmp #$0e                 ;row 14?
00903C  1  D0 05                    bne CheckRear
00903E  1  AD 28 07                 lda BackloadingFlag      ;check flag for saved page number and branch if set
009041  1  D0 08                    bne RdyDecode            ;to render the object (otherwise bg might not look right)
009043  1  AD 2A 07     CheckRear:  lda AreaObjectPageLoc    ;check to see if current page of level object is
009046  1  CD 25 07                 cmp CurrentPageLoc       ;behind current page of renderer
009049  1  90 06                    bcc SetBehind            ;if so branch
00904B  1  20 7B 90     RdyDecode:  jsr DecodeAreaData       ;do sub and do not turn on flag
00904E  1  4C 57 90                 jmp ChkLength
009051  1  EE 29 07     SetBehind:  inc BehindAreaParserFlag ;turn on flag if object is behind renderer
009054  1  20 6F 90     NextAObj:   jsr IncAreaObjOffset     ;increment buffer offset and move on
009057  1  A6 08        ChkLength:  ldx ObjectOffset         ;get buffer offset
009059  1  BD 30 07                 lda AreaObjectLength,x   ;check object length for anything stored here
00905C  1  30 03                    bmi ProcLoopb            ;if not, branch to handle loopback
00905E  1  DE 30 07                 dec AreaObjectLength,x   ;otherwise decrement length or get rid of it
009061  1  CA           ProcLoopb:  dex                      ;decrement buffer offset
009062  1  10 8C                    bpl ProcADLoop           ;and loopback unless exceeded buffer
009064  1  AD 29 07                 lda BehindAreaParserFlag ;check for flag set if objects were behind renderer
009067  1  D0 85                    bne ProcessAreaData      ;branch if true to load more level data, otherwise
009069  1  AD 28 07                 lda BackloadingFlag      ;check for flag set if starting right of page $00
00906C  1  D0 80                    bne ProcessAreaData      ;branch if true to load more level data, otherwise leave
00906E  1  60           EndAParse:  rts
00906F  1               
00906F  1               IncAreaObjOffset:
00906F  1  EE 2C 07           inc AreaDataOffset    ;increment offset of level pointer
009072  1  EE 2C 07           inc AreaDataOffset
009075  1  A9 00              lda #$00              ;reset page select
009077  1  8D 2B 07           sta AreaObjectPageSel
00907A  1  60                 rts
00907B  1               
00907B  1               DecodeAreaData:
00907B  1  BD 30 07               lda AreaObjectLength,x     ;check current buffer flag
00907E  1  30 03                  bmi Chk1stB
009080  1  BC 2D 07               ldy AreaObjOffsetBuffer,x  ;if not, get offset from buffer
009083  1  A2 10        Chk1stB:  ldx #$10                   ;load offset of 16 for special row 15
009085  1  B1 E7                  lda (AreaData),y           ;get first byte of level object again
009087  1  C9 FD                  cmp #$fd
009089  1  F0 E3                  beq EndAParse              ;if end of level, leave this routine
00908B  1  29 0F                  and #$0f                   ;otherwise, mask out low nybble
00908D  1  C9 0F                  cmp #$0f                   ;row 15?
00908F  1  F0 08                  beq ChkRow14               ;if so, keep the offset of 16
009091  1  A2 08                  ldx #$08                   ;otherwise load offset of 8 for special row 12
009093  1  C9 0C                  cmp #$0c                   ;row 12?
009095  1  F0 02                  beq ChkRow14               ;if so, keep the offset value of 8
009097  1  A2 00                  ldx #$00                   ;otherwise nullify value by default
009099  1  86 07        ChkRow14: stx $07                    ;store whatever value we just loaded here
00909B  1  A6 08                  ldx ObjectOffset           ;get object offset again
00909D  1  C9 0E                  cmp #$0e                   ;row 14?
00909F  1  D0 08                  bne ChkRow13
0090A1  1  A9 00                  lda #$00                   ;if so, load offset with $00
0090A3  1  85 07                  sta $07
0090A5  1  A9 2E                  lda #$2e                   ;and load A with another value
0090A7  1  D0 53                  bne NormObj                ;unconditional branch
0090A9  1  C9 0D        ChkRow13: cmp #$0d                   ;row 13?
0090AB  1  D0 1B                  bne ChkSRows
0090AD  1  A9 22                  lda #$22                   ;if so, load offset with 34
0090AF  1  85 07                  sta $07
0090B1  1  C8                     iny                        ;get next byte
0090B2  1  B1 E7                  lda (AreaData),y
0090B4  1  29 40                  and #%01000000             ;mask out all but d6 (page control obj bit)
0090B6  1  F0 63                  beq LeavePar               ;if d6 clear, branch to leave (we handled this earlier)
0090B8  1  B1 E7                  lda (AreaData),y           ;otherwise, get byte again
0090BA  1  29 7F                  and #%01111111             ;mask out d7
0090BC  1  C9 4B                  cmp #$4b                   ;check for loop command in low nybble
0090BE  1  D0 03                  bne Mask2MSB               ;(plus d6 set for object other than page control)
0090C0  1  EE 45 07               inc LoopCommand            ;if loop command, set loop command flag
0090C3  1  29 3F        Mask2MSB: and #%00111111             ;mask out d7 and d6
0090C5  1  4C FC 90               jmp NormObj                ;and jump
0090C8  1  C9 0C        ChkSRows: cmp #$0c                   ;row 12-15?
0090CA  1  B0 27                  bcs SpecObj
0090CC  1  C8                     iny                        ;if not, get second byte of level object
0090CD  1  B1 E7                  lda (AreaData),y
0090CF  1  29 70                  and #%01110000             ;mask out all but d6-d4
0090D1  1  D0 0B                  bne LrgObj                 ;if any bits set, branch to handle large object
0090D3  1  A9 16                  lda #$16
0090D5  1  85 07                  sta $07                    ;otherwise set offset of 24 for small object
0090D7  1  B1 E7                  lda (AreaData),y           ;reload second byte of level object
0090D9  1  29 0F                  and #%00001111             ;mask out higher nybble and jump
0090DB  1  4C FC 90               jmp NormObj
0090DE  1  85 00        LrgObj:   sta $00                    ;store value here (branch for large objects)
0090E0  1  C9 70                  cmp #$70                   ;check for vertical pipe object
0090E2  1  D0 0A                  bne NotWPipe
0090E4  1  B1 E7                  lda (AreaData),y           ;if not, reload second byte
0090E6  1  29 08                  and #%00001000             ;mask out all but d3 (usage control bit)
0090E8  1  F0 04                  beq NotWPipe               ;if d3 clear, branch to get original value
0090EA  1  A9 00                  lda #$00                   ;otherwise, nullify value for warp pipe
0090EC  1  85 00                  sta $00
0090EE  1  A5 00        NotWPipe: lda $00                    ;get value and jump ahead
0090F0  1  4C F8 90               jmp MoveAOId
0090F3  1  C8           SpecObj:  iny                        ;branch here for rows 12-15
0090F4  1  B1 E7                  lda (AreaData),y
0090F6  1  29 70                  and #%01110000             ;get next byte and mask out all but d6-d4
0090F8  1  4A           MoveAOId: lsr                        ;move d6-d4 to lower nybble
0090F9  1  4A                     lsr
0090FA  1  4A                     lsr
0090FB  1  4A                     lsr
0090FC  1  85 00        NormObj:  sta $00                    ;store value here (branch for small objects and rows 13 and 14)
0090FE  1  BD 30 07               lda AreaObjectLength,x     ;is there something stored here already?
009101  1  10 42                  bpl RunAObj                ;if so, branch to do its particular sub
009103  1  AD 2A 07               lda AreaObjectPageLoc      ;otherwise check to see if the object we've loaded is on the
009106  1  CD 25 07               cmp CurrentPageLoc         ;same page as the renderer, and if so, branch
009109  1  F0 11                  beq InitRear
00910B  1  AC 2C 07               ldy AreaDataOffset         ;if not, get old offset of level pointer
00910E  1  B1 E7                  lda (AreaData),y           ;and reload first byte
009110  1  29 0F                  and #%00001111
009112  1  C9 0E                  cmp #$0e                   ;row 14?
009114  1  D0 05                  bne LeavePar
009116  1  AD 28 07               lda BackloadingFlag        ;if so, check backloading flag
009119  1  D0 21                  bne StrAObj                ;if set, branch to render object, else leave
00911B  1  60           LeavePar: rts
00911C  1  AD 28 07     InitRear: lda BackloadingFlag        ;check backloading flag to see if it's been initialized
00911F  1  F0 0B                  beq BackColC               ;branch to column-wise check
009121  1  A9 00                  lda #$00                   ;if not, initialize both backloading and
009123  1  8D 28 07               sta BackloadingFlag        ;behind-renderer flags and leave
009126  1  8D 29 07               sta BehindAreaParserFlag
009129  1  85 08                  sta ObjectOffset
00912B  1  60           LoopCmdE: rts
00912C  1  AC 2C 07     BackColC: ldy AreaDataOffset         ;get first byte again
00912F  1  B1 E7                  lda (AreaData),y
009131  1  29 F0                  and #%11110000             ;mask out low nybble and move high to low
009133  1  4A                     lsr
009134  1  4A                     lsr
009135  1  4A                     lsr
009136  1  4A                     lsr
009137  1  CD 26 07               cmp CurrentColumnPos       ;is this where we're at?
00913A  1  D0 DF                  bne LeavePar               ;if not, branch to leave
00913C  1  AD 2C 07     StrAObj:  lda AreaDataOffset         ;if so, load area obj offset and store in buffer
00913F  1  9D 2D 07               sta AreaObjOffsetBuffer,x
009142  1  20 6F 90               jsr IncAreaObjOffset       ;do sub to increment to next object data
009145  1  A5 00        RunAObj:  lda $00                    ;get stored value and add offset to it
009147  1  18                     clc                        ;then use the jump engine with current contents of A
009148  1  65 07                  adc $07
00914A  1  20 97 BA               jsr JumpEngine
00914D  1               
00914D  1               ;large objects (rows $00-$0b or 00-11, d6-d4 set)
00914D  1  B9 93              .word VerticalPipe         ;used by warp pipes
00914F  1  14 92              .word AreaStyleObject
009151  1  02 95              .word RowOfBricks
009153  1  12 95              .word RowOfSolidBlocks
009155  1  C6 94              .word RowOfCoins
009157  1  24 95              .word ColumnOfBricks
009159  1  2D 95              .word ColumnOfSolidBlocks
00915B  1  B9 93              .word VerticalPipe         ;used by decoration pipes
00915D  1               
00915D  1               ;objects for special row $0c or 12
00915D  1  15 96              .word Hole_Empty
00915F  1  8E 92              .word PulleyRopeObject
009161  1  4D 94              .word Bridge_High
009163  1  50 94              .word Bridge_Middle
009165  1  53 94              .word Bridge_Low
009167  1  2B 94              .word Hole_Water
009169  1  3C 94              .word QuestionBlockRow_High
00916B  1  3F 94              .word QuestionBlockRow_Low
00916D  1               
00916D  1               ;objects for special row $0f or 15
00916D  1  A4 94              .word EndlessRope
00916F  1  AB 94              .word BalancePlatRope
009171  1  DA 92              .word CastleObject
009173  1  8B 95              .word StaircaseObject
009175  1  7F 93              .word ExitPipe
009177  1  68 94              .word FlagBalls_Residual
009179  1               
009179  1               ;small objects (rows $00-$0b or 00-11, d6-d4 all clear)
009179  1  E2 95              .word QuestionBlock     ;power-up
00917B  1  E2 95              .word QuestionBlock     ;coin
00917D  1  E2 95              .word QuestionBlock     ;hidden, coin
00917F  1  D5 95              .word Hidden1UpBlock    ;hidden, 1-up
009181  1  ED 95              .word BrickWithItem     ;brick, power-up
009183  1  ED 95              .word BrickWithItem     ;brick, vine
009185  1  ED 95              .word BrickWithItem     ;brick, star
009187  1  E8 95              .word BrickWithCoins    ;brick, coins
009189  1  ED 95              .word BrickWithItem     ;brick, 1-up
00918B  1  43 93              .word WaterPipe
00918D  1  ED 94              .word EmptyBlock
00918F  1  A7 95              .word Jumpspring
009191  1               
009191  1               ;objects for special row $0d or 13 (d6 set)
009191  1  56 93              .word IntroPipe
009193  1  72 94              .word FlagpoleObject
009195  1  DD 94              .word AxeObj
009197  1  E2 94              .word ChainObj
009199  1  D5 94              .word CastleBridgeObj
00919B  1  D8 91              .word ScrollLockObject_Warp
00919D  1  F3 91              .word ScrollLockObject
00919F  1  F3 91              .word ScrollLockObject
0091A1  1  FF 91              .word AreaFrenzy            ;flying cheep-cheeps
0091A3  1  FF 91              .word AreaFrenzy            ;bullet bills or swimming cheep-cheeps
0091A5  1  FF 91              .word AreaFrenzy            ;stop frenzy
0091A7  1  2B 91              .word LoopCmdE
0091A9  1               
0091A9  1               ;object for special row $0e or 14
0091A9  1  AB 91              .word AlterAreaAttributes
0091AB  1               
0091AB  1               ;-------------------------------------------------------------------------------------
0091AB  1               ;(these apply to all area object subroutines in this section unless otherwise stated)
0091AB  1               ;$00 - used to store offset used to find object code
0091AB  1               ;$07 - starts with adder from area parser, used to store row offset
0091AB  1               
0091AB  1               AlterAreaAttributes:
0091AB  1  BC 2D 07              ldy AreaObjOffsetBuffer,x ;load offset for level object data saved in buffer
0091AE  1  C8                    iny                       ;load second byte
0091AF  1  B1 E7                 lda (AreaData),y
0091B1  1  48                    pha                       ;save in stack for now
0091B2  1  29 40                 and #%01000000
0091B4  1  D0 12                 bne Alter2                ;branch if d6 is set
0091B6  1  68                    pla
0091B7  1  48                    pha                       ;pull and push offset to copy to A
0091B8  1  29 0F                 and #%00001111            ;mask out high nybble and store as
0091BA  1  8D 27 07              sta TerrainControl        ;new terrain height type bits
0091BD  1  68                    pla
0091BE  1  29 30                 and #%00110000            ;pull and mask out all but d5 and d4
0091C0  1  4A                    lsr                       ;move bits to lower nybble and store
0091C1  1  4A                    lsr                       ;as new background scenery bits
0091C2  1  4A                    lsr
0091C3  1  4A                    lsr
0091C4  1  8D 42 07              sta BackgroundScenery     ;then leave
0091C7  1  60                    rts
0091C8  1  68           Alter2:  pla
0091C9  1  29 07                 and #%00000111            ;mask out all but 3 LSB
0091CB  1  C9 04                 cmp #$04                  ;if four or greater, set color control bits
0091CD  1  90 05                 bcc SetFore               ;and nullify foreground scenery bits
0091CF  1  8D 44 07              sta BackgroundColorCtrl
0091D2  1  A9 00                 lda #$00
0091D4  1  8D 41 07     SetFore: sta ForegroundScenery     ;otherwise set new foreground scenery bits
0091D7  1  60                    rts
0091D8  1               
0091D8  1               ;--------------------------------
0091D8  1               
0091D8  1               ScrollLockObject_Warp:
0091D8  1  A2 04                 ldx #$04            ;load value of 4 for game text routine as default
0091DA  1  AD 5F 07              lda WorldNumber     ;warp zone (4-3-2), then check world number
0091DD  1  F0 08                 beq WarpNum
0091DF  1  E8                    inx                 ;if world number > 1, increment for next warp zone (5)
0091E0  1  AC 4E 07              ldy AreaType        ;check area type
0091E3  1  88                    dey
0091E4  1  D0 01                 bne WarpNum         ;if ground area type, increment for last warp zone
0091E6  1  E8                    inx                 ;(8-7-6) and move on
0091E7  1  8A           WarpNum: txa
0091E8  1  8D D6 06              sta WarpZoneControl ;store number here to be used by warp zone routine
0091EB  1  20 A6 86              jsr WriteGameText   ;print text and warp zone numbers
0091EE  1  A9 0D                 lda #PiranhaPlant
0091F0  1  20 7E EE              jsr KillEnemies     ;load identifier for piranha plants and do sub
0091F3  1               
0091F3  1               ScrollLockObject:
0091F3  1  AD 23 07           lda ScrollLock      ;invert scroll lock to turn it on
0091F6  1  49 01              eor #%00000001
0091F8  1  8D 23 07           sta ScrollLock
0091FB  1  60                 rts
0091FC  1               
0091FC  1               ;--------------------------------
0091FC  1               
0091FC  1               FrenzyIDData:
0091FC  1  14 17 18           .byte FlyCheepCheepFrenzy, BBill_CCheep_Frenzy, Stop_Frenzy
0091FF  1               
0091FF  1  A6 00        AreaFrenzy:  ldx $00               ;use area object identifier bit as offset
009201  1  BD F4 91                  lda FrenzyIDData-8,x  ;note that it starts at 8, thus weird address here
009204  1  A0 05                     ldy #$05
009206  1  88           FreCompLoop: dey                   ;check regular slots of enemy object buffer
009207  1  30 07                     bmi ExitAFrenzy       ;if all slots checked and enemy object not found, branch to store
009209  1  D9 16 00                  cmp Enemy_ID,y    ;check for enemy object in buffer versus frenzy object
00920C  1  D0 F8                     bne FreCompLoop
00920E  1  A9 00                     lda #$00              ;if enemy object already present, nullify queue and leave
009210  1  8D CD 06     ExitAFrenzy: sta EnemyFrenzyQueue  ;store enemy into frenzy queue
009213  1  60                        rts
009214  1               
009214  1               ;--------------------------------
009214  1               ;$06 - used by MushroomLedge to store length
009214  1               
009214  1               AreaStyleObject:
009214  1  AD 33 07           lda AreaStyle        ;load level object style and jump to the right sub
009217  1  20 97 BA           jsr JumpEngine
00921A  1  20 92              .word TreeLedge        ;also used for cloud type levels
00921C  1  4C 92              .word MushroomLedge
00921E  1  3D 95              .word BulletBillCannon
009220  1               
009220  1               TreeLedge:
009220  1  20 8F 96               jsr GetLrgObjAttrib     ;get row and length of green ledge
009223  1  BD 30 07               lda AreaObjectLength,x  ;check length counter for expiration
009226  1  F0 1F                  beq EndTreeL
009228  1  10 11                  bpl MidTreeL
00922A  1  98                     tya
00922B  1  9D 30 07               sta AreaObjectLength,x  ;store lower nybble into buffer flag as length of ledge
00922E  1  AD 25 07               lda CurrentPageLoc
009231  1  0D 26 07               ora CurrentColumnPos    ;are we at the start of the level?
009234  1  F0 05                  beq MidTreeL
009236  1  A9 16                  lda #$16                ;render start of tree ledge
009238  1  4C 84 92               jmp NoUnder
00923B  1  A6 07        MidTreeL: ldx $07
00923D  1  A9 17                  lda #$17                ;render middle of tree ledge
00923F  1  9D A1 06               sta MetatileBuffer,x    ;note that this is also used if ledge position is
009242  1  A9 4C                  lda #$4c                ;at the start of level for continuous effect
009244  1  4C 7E 92               jmp AllUnder            ;now render the part underneath
009247  1  A9 18        EndTreeL: lda #$18                ;render end of tree ledge
009249  1  4C 84 92               jmp NoUnder
00924C  1               
00924C  1               MushroomLedge:
00924C  1  20 80 96               jsr ChkLrgObjLength        ;get shroom dimensions
00924F  1  84 06                  sty $06                    ;store length here for now
009251  1  90 0C                  bcc EndMushL
009253  1  BD 30 07               lda AreaObjectLength,x     ;divide length by 2 and store elsewhere
009256  1  4A                     lsr
009257  1  9D 36 07               sta MushroomLedgeHalfLen,x
00925A  1  A9 19                  lda #$19                   ;render start of mushroom
00925C  1  4C 84 92               jmp NoUnder
00925F  1  A9 1B        EndMushL: lda #$1b                   ;if at the end, render end of mushroom
009261  1  BC 30 07               ldy AreaObjectLength,x
009264  1  F0 1E                  beq NoUnder
009266  1  BD 36 07               lda MushroomLedgeHalfLen,x ;get divided length and store where length
009269  1  85 06                  sta $06                    ;was stored originally
00926B  1  A6 07                  ldx $07
00926D  1  A9 1A                  lda #$1a
00926F  1  9D A1 06               sta MetatileBuffer,x       ;render middle of mushroom
009272  1  C4 06                  cpy $06                    ;are we smack dab in the center?
009274  1  D0 2C                  bne MushLExit              ;if not, branch to leave
009276  1  E8                     inx
009277  1  A9 4F                  lda #$4f
009279  1  9D A1 06               sta MetatileBuffer,x       ;render stem top of mushroom underneath the middle
00927C  1  A9 50                  lda #$50
00927E  1  E8           AllUnder: inx
00927F  1  A0 0F                  ldy #$0f                   ;set $0f to render all way down
009281  1  4C 51 96               jmp RenderUnderPart       ;now render the stem of mushroom
009284  1  A6 07        NoUnder:  ldx $07                    ;load row of ledge
009286  1  A0 00                  ldy #$00                   ;set 0 for no bottom on this part
009288  1  4C 51 96               jmp RenderUnderPart
00928B  1               
00928B  1               ;--------------------------------
00928B  1               
00928B  1               ;tiles used by pulleys and rope object
00928B  1               PulleyRopeMetatiles:
00928B  1  42 41 43           .byte $42, $41, $43
00928E  1               
00928E  1               PulleyRopeObject:
00928E  1  20 80 96                jsr ChkLrgObjLength       ;get length of pulley/rope object
009291  1  A0 00                   ldy #$00                  ;initialize metatile offset
009293  1  B0 07                   bcs RenderPul             ;if starting, render left pulley
009295  1  C8                      iny
009296  1  BD 30 07                lda AreaObjectLength,x    ;if not at the end, render rope
009299  1  D0 01                   bne RenderPul
00929B  1  C8                      iny                       ;otherwise render right pulley
00929C  1  B9 8B 92     RenderPul: lda PulleyRopeMetatiles,y
00929F  1  8D A1 06                sta MetatileBuffer        ;render at the top of the screen
0092A2  1  60           MushLExit: rts                       ;and leave
0092A3  1               
0092A3  1               ;--------------------------------
0092A3  1               ;$06 - used to store upper limit of rows for CastleObject
0092A3  1               
0092A3  1               CastleMetatiles:
0092A3  1  00 45 45 45        .byte $00, $45, $45, $45, $00
0092A7  1  00           
0092A8  1  00 48 47 46        .byte $00, $48, $47, $46, $00
0092AC  1  00           
0092AD  1  45 49 49 49        .byte $45, $49, $49, $49, $45
0092B1  1  45           
0092B2  1  47 47 4A 47        .byte $47, $47, $4a, $47, $47
0092B6  1  47           
0092B7  1  47 47 4B 47        .byte $47, $47, $4b, $47, $47
0092BB  1  47           
0092BC  1  49 49 49 49        .byte $49, $49, $49, $49, $49
0092C0  1  49           
0092C1  1  47 4A 47 4A        .byte $47, $4a, $47, $4a, $47
0092C5  1  47           
0092C6  1  47 4B 47 4B        .byte $47, $4b, $47, $4b, $47
0092CA  1  47           
0092CB  1  47 47 47 47        .byte $47, $47, $47, $47, $47
0092CF  1  47           
0092D0  1  4A 47 4A 47        .byte $4a, $47, $4a, $47, $4a
0092D4  1  4A           
0092D5  1  4B 47 4B 47        .byte $4b, $47, $4b, $47, $4b
0092D9  1  4B           
0092DA  1               
0092DA  1               CastleObject:
0092DA  1  20 8F 96                 jsr GetLrgObjAttrib      ;save lower nybble as starting row
0092DD  1  84 07                    sty $07                  ;if starting row is above $0a, game will crash!!!
0092DF  1  A0 04                    ldy #$04
0092E1  1  20 83 96                 jsr ChkLrgObjFixedLength ;load length of castle if not already loaded
0092E4  1  8A                       txa
0092E5  1  48                       pha                      ;save obj buffer offset to stack
0092E6  1  BC 30 07                 ldy AreaObjectLength,x   ;use current length as offset for castle data
0092E9  1  A6 07                    ldx $07                  ;begin at starting row
0092EB  1  A9 0B                    lda #$0b
0092ED  1  85 06                    sta $06                  ;load upper limit of number of rows to print
0092EF  1  B9 A3 92     CRendLoop:  lda CastleMetatiles,y    ;load current byte using offset
0092F2  1  9D A1 06                 sta MetatileBuffer,x
0092F5  1  E8                       inx                      ;store in buffer and increment buffer offset
0092F6  1  A5 06                    lda $06
0092F8  1  F0 07                    beq ChkCFloor            ;have we reached upper limit yet?
0092FA  1  C8                       iny                      ;if not, increment column-wise
0092FB  1  C8                       iny                      ;to byte in next row
0092FC  1  C8                       iny
0092FD  1  C8                       iny
0092FE  1  C8                       iny
0092FF  1  C6 06                    dec $06                  ;move closer to upper limit
009301  1  E0 0B        ChkCFloor:  cpx #$0b                 ;have we reached the row just before floor?
009303  1  D0 EA                    bne CRendLoop            ;if not, go back and do another row
009305  1  68                       pla
009306  1  AA                       tax                      ;get obj buffer offset from before
009307  1  AD 25 07                 lda CurrentPageLoc
00930A  1  F0 36                    beq ExitCastle           ;if we're at page 0, we do not need to do anything else
00930C  1  BD 30 07                 lda AreaObjectLength,x   ;check length
00930F  1  C9 01                    cmp #$01                 ;if length almost about to expire, put brick at floor
009311  1  F0 2A                    beq PlayerStop
009313  1  A4 07                    ldy $07                  ;check starting row for tall castle ($00)
009315  1  D0 04                    bne NotTall
009317  1  C9 03                    cmp #$03                 ;if found, then check to see if we're at the second column
009319  1  F0 22                    beq PlayerStop
00931B  1  C9 02        NotTall:    cmp #$02                 ;if not tall castle, check to see if we're at the third column
00931D  1  D0 23                    bne ExitCastle           ;if we aren't and the castle is tall, don't create flag yet
00931F  1  20 9F 96                 jsr GetAreaObjXPosition  ;otherwise, obtain and save horizontal pixel coordinate
009322  1  48                       pha
009323  1  20 1E 94                 jsr FindEmptyEnemySlot   ;find an empty place on the enemy object buffer
009326  1  68                       pla
009327  1  95 87                    sta Enemy_X_Position,x   ;then write horizontal coordinate for star flag
009329  1  AD 25 07                 lda CurrentPageLoc
00932C  1  95 6E                    sta Enemy_PageLoc,x      ;set page location for star flag
00932E  1  A9 01                    lda #$01
009330  1  95 B6                    sta Enemy_Y_HighPos,x    ;set vertical high byte
009332  1  95 0F                    sta Enemy_Flag,x         ;set flag for buffer
009334  1  A9 90                    lda #$90
009336  1  95 CF                    sta Enemy_Y_Position,x   ;set vertical coordinate
009338  1  A9 31                    lda #StarFlagObject      ;set star flag value in buffer itself
00933A  1  95 16                    sta Enemy_ID,x
00933C  1  60                       rts
00933D  1  A0 52        PlayerStop: ldy #$52                 ;put brick at floor to stop player at end of level
00933F  1  8C AB 06                 sty MetatileBuffer+10    ;this is only done if we're on the second column
009342  1  60           ExitCastle: rts
009343  1               
009343  1               ;--------------------------------
009343  1               
009343  1               WaterPipe:
009343  1  20 8F 96           jsr GetLrgObjAttrib     ;get row and lower nybble
009346  1  BC 30 07           ldy AreaObjectLength,x  ;get length (residual code, water pipe is 1 col thick)
009349  1  A6 07              ldx $07                 ;get row
00934B  1  A9 6B              lda #$6b
00934D  1  9D A1 06           sta MetatileBuffer,x    ;draw something here and below it
009350  1  A9 6C              lda #$6c
009352  1  9D A2 06           sta MetatileBuffer+1,x
009355  1  60                 rts
009356  1               
009356  1               ;--------------------------------
009356  1               ;$05 - used to store length of vertical shaft in RenderSidewaysPipe
009356  1               ;$06 - used to store leftover horizontal length in RenderSidewaysPipe
009356  1               ; and vertical length in VerticalPipe and GetPipeHeight
009356  1               
009356  1               IntroPipe:
009356  1  A0 03                       ldy #$03                 ;check if length set, if not set, set it
009358  1  20 83 96                    jsr ChkLrgObjFixedLength
00935B  1  A0 0A                       ldy #$0a                 ;set fixed value and render the sideways part
00935D  1  20 87 93                    jsr RenderSidewaysPipe
009360  1  B0 10                       bcs NoBlankP             ;if carry flag set, not time to draw vertical pipe part
009362  1  A2 06                       ldx #$06                 ;blank everything above the vertical pipe part
009364  1  A9 00        VPipeSectLoop: lda #$00                 ;all the way to the top of the screen
009366  1  9D A1 06                    sta MetatileBuffer,x     ;because otherwise it will look like exit pipe
009369  1  CA                          dex
00936A  1  10 F8                       bpl VPipeSectLoop
00936C  1  B9 B1 93                    lda VerticalPipeData,y   ;draw the end of the vertical pipe part
00936F  1  8D A8 06                    sta MetatileBuffer+7
009372  1  60           NoBlankP:      rts
009373  1               
009373  1               SidePipeShaftData:
009373  1  15 14              .byte $15, $14  ;used to control whether or not vertical pipe shaft
009375  1  00 00              .byte $00, $00  ;is drawn, and if so, controls the metatile number
009377  1               SidePipeTopPart:
009377  1  15 1E              .byte $15, $1e  ;top part of sideways part of pipe
009379  1  1D 1C              .byte $1d, $1c
00937B  1               SidePipeBottomPart:
00937B  1  15 21              .byte $15, $21  ;bottom part of sideways part of pipe
00937D  1  20 1F              .byte $20, $1f
00937F  1               
00937F  1               ExitPipe:
00937F  1  A0 03              ldy #$03                 ;check if length set, if not set, set it
009381  1  20 83 96           jsr ChkLrgObjFixedLength
009384  1  20 8F 96           jsr GetLrgObjAttrib      ;get vertical length, then plow on through RenderSidewaysPipe
009387  1               
009387  1               RenderSidewaysPipe:
009387  1  88                         dey                       ;decrement twice to make room for shaft at bottom
009388  1  88                         dey                       ;and store here for now as vertical length
009389  1  84 05                      sty $05
00938B  1  BC 30 07                   ldy AreaObjectLength,x    ;get length left over and store here
00938E  1  84 06                      sty $06
009390  1  A6 05                      ldx $05                   ;get vertical length plus one, use as buffer offset
009392  1  E8                         inx
009393  1  B9 73 93                   lda SidePipeShaftData,y   ;check for value $00 based on horizontal offset
009396  1  C9 00                      cmp #$00
009398  1  F0 08                      beq DrawSidePart          ;if found, do not draw the vertical pipe shaft
00939A  1  A2 00                      ldx #$00
00939C  1  A4 05                      ldy $05                   ;init buffer offset and get vertical length
00939E  1  20 51 96                   jsr RenderUnderPart       ;and render vertical shaft using tile number in A
0093A1  1  18                         clc                       ;clear carry flag to be used by IntroPipe
0093A2  1  A4 06        DrawSidePart: ldy $06                   ;render side pipe part at the bottom
0093A4  1  B9 77 93                   lda SidePipeTopPart,y
0093A7  1  9D A1 06                   sta MetatileBuffer,x      ;note that the pipe parts are stored
0093AA  1  B9 7B 93                   lda SidePipeBottomPart,y  ;backwards horizontally
0093AD  1  9D A2 06                   sta MetatileBuffer+1,x
0093B0  1  60                         rts
0093B1  1               
0093B1  1               VerticalPipeData:
0093B1  1  11 10              .byte $11, $10 ;used by pipes that lead somewhere
0093B3  1  15 14              .byte $15, $14
0093B5  1  13 12              .byte $13, $12 ;used by decoration pipes
0093B7  1  15 14              .byte $15, $14
0093B9  1               
0093B9  1               VerticalPipe:
0093B9  1  20 0D 94               jsr GetPipeHeight
0093BC  1  A5 00                  lda $00                  ;check to see if value was nullified earlier
0093BE  1  F0 04                  beq WarpPipe             ;(if d3, the usage control bit of second byte, was set)
0093C0  1  C8                     iny
0093C1  1  C8                     iny
0093C2  1  C8                     iny
0093C3  1  C8                     iny                      ;add four if usage control bit was not set
0093C4  1  98           WarpPipe: tya                      ;save value in stack
0093C5  1  48                     pha
0093C6  1  AD 60 07               lda AreaNumber
0093C9  1  0D 5F 07               ora WorldNumber          ;if at world 1-1, do not add piranha plant ever
0093CC  1  F0 2B                  beq DrawPipe
0093CE  1  BC 30 07               ldy AreaObjectLength,x   ;if on second column of pipe, branch
0093D1  1  F0 26                  beq DrawPipe             ;(because we only need to do this once)
0093D3  1  20 1E 94               jsr FindEmptyEnemySlot   ;check for an empty moving data buffer space
0093D6  1  B0 21                  bcs DrawPipe             ;if not found, too many enemies, thus skip
0093D8  1  20 9F 96               jsr GetAreaObjXPosition  ;get horizontal pixel coordinate
0093DB  1  18                     clc
0093DC  1  69 08                  adc #$08                 ;add eight to put the piranha plant in the center
0093DE  1  95 87                  sta Enemy_X_Position,x   ;store as enemy's horizontal coordinate
0093E0  1  AD 25 07               lda CurrentPageLoc       ;add carry to current page number
0093E3  1  69 00                  adc #$00
0093E5  1  95 6E                  sta Enemy_PageLoc,x      ;store as enemy's page coordinate
0093E7  1  A9 01                  lda #$01
0093E9  1  95 B6                  sta Enemy_Y_HighPos,x
0093EB  1  95 0F                  sta Enemy_Flag,x         ;activate enemy flag
0093ED  1  20 A7 96               jsr GetAreaObjYPosition  ;get piranha plant's vertical coordinate and store here
0093F0  1  95 CF                  sta Enemy_Y_Position,x
0093F2  1  A9 0D                  lda #PiranhaPlant        ;write piranha plant's value into buffer
0093F4  1  95 16                  sta Enemy_ID,x
0093F6  1  20 98 C4               jsr InitPiranhaPlant
0093F9  1  68           DrawPipe: pla                      ;get value saved earlier and use as Y
0093FA  1  A8                     tay
0093FB  1  A6 07                  ldx $07                  ;get buffer offset
0093FD  1  B9 B1 93               lda VerticalPipeData,y   ;draw the appropriate pipe with the Y we loaded earlier
009400  1  9D A1 06               sta MetatileBuffer,x     ;render the top of the pipe
009403  1  E8                     inx
009404  1  B9 B3 93               lda VerticalPipeData+2,y ;render the rest of the pipe
009407  1  A4 06                  ldy $06                  ;subtract one from length and render the part underneath
009409  1  88                     dey
00940A  1  4C 51 96               jmp RenderUnderPart
00940D  1               
00940D  1               GetPipeHeight:
00940D  1  A0 01              ldy #$01       ;check for length loaded, if not, load
00940F  1  20 83 96           jsr ChkLrgObjFixedLength ;pipe length of 2 (horizontal)
009412  1  20 8F 96           jsr GetLrgObjAttrib
009415  1  98                 tya            ;get saved lower nybble as height
009416  1  29 07              and #$07       ;save only the three lower bits as
009418  1  85 06              sta $06        ;vertical length, then load Y with
00941A  1  BC 30 07           ldy AreaObjectLength,x    ;length left over
00941D  1  60                 rts
00941E  1               
00941E  1               FindEmptyEnemySlot:
00941E  1  A2 00                      ldx #$00          ;start at first enemy slot
009420  1  18           EmptyChkLoop: clc               ;clear carry flag by default
009421  1  B5 0F                      lda Enemy_Flag,x  ;check enemy buffer for nonzero
009423  1  F0 05                      beq ExitEmptyChk  ;if zero, leave
009425  1  E8                         inx
009426  1  E0 05                      cpx #$05          ;if nonzero, check next value
009428  1  D0 F6                      bne EmptyChkLoop
00942A  1  60           ExitEmptyChk: rts               ;if all values nonzero, carry flag is set
00942B  1               
00942B  1               ;--------------------------------
00942B  1               
00942B  1               Hole_Water:
00942B  1  20 80 96           jsr ChkLrgObjLength   ;get low nybble and save as length
00942E  1  A9 86              lda #$86              ;render waves
009430  1  8D AB 06           sta MetatileBuffer+10
009433  1  A2 0B              ldx #$0b
009435  1  A0 01              ldy #$01              ;now render the water underneath
009437  1  A9 87              lda #$87
009439  1  4C 51 96           jmp RenderUnderPart
00943C  1               
00943C  1               ;--------------------------------
00943C  1               
00943C  1               QuestionBlockRow_High:
00943C  1  A9 03              lda #$03    ;start on the fourth row
00943E  1  2C                 .byte $2c     ;BIT instruction opcode
00943F  1               
00943F  1               QuestionBlockRow_Low:
00943F  1  A9 07              lda #$07             ;start on the eighth row
009441  1  48                 pha                  ;save whatever row to the stack for now
009442  1  20 80 96           jsr ChkLrgObjLength  ;get low nybble and save as length
009445  1  68                 pla
009446  1  AA                 tax                  ;render question boxes with coins
009447  1  A9 C0              lda #$c0
009449  1  9D A1 06           sta MetatileBuffer,x
00944C  1  60                 rts
00944D  1               
00944D  1               ;--------------------------------
00944D  1               
00944D  1               Bridge_High:
00944D  1  A9 06              lda #$06  ;start on the seventh row from top of screen
00944F  1  2C                 .byte $2c   ;BIT instruction opcode
009450  1               
009450  1               Bridge_Middle:
009450  1  A9 07              lda #$07  ;start on the eighth row
009452  1  2C                 .byte $2c   ;BIT instruction opcode
009453  1               
009453  1               Bridge_Low:
009453  1  A9 09              lda #$09             ;start on the tenth row
009455  1  48                 pha                  ;save whatever row to the stack for now
009456  1  20 80 96           jsr ChkLrgObjLength  ;get low nybble and save as length
009459  1  68                 pla
00945A  1  AA                 tax                  ;render bridge railing
00945B  1  A9 0B              lda #$0b
00945D  1  9D A1 06           sta MetatileBuffer,x
009460  1  E8                 inx
009461  1  A0 00              ldy #$00             ;now render the bridge itself
009463  1  A9 63              lda #$63
009465  1  4C 51 96           jmp RenderUnderPart
009468  1               
009468  1               ;--------------------------------
009468  1               
009468  1               FlagBalls_Residual:
009468  1  20 8F 96           jsr GetLrgObjAttrib  ;get low nybble from object byte
00946B  1  A2 02              ldx #$02             ;render flag balls on third row from top
00946D  1  A9 6D              lda #$6d             ;of screen downwards based on low nybble
00946F  1  4C 51 96           jmp RenderUnderPart
009472  1               
009472  1               ;--------------------------------
009472  1               
009472  1               FlagpoleObject:
009472  1  A9 24              lda #$24                 ;render flagpole ball on top
009474  1  8D A1 06           sta MetatileBuffer
009477  1  A2 01              ldx #$01                 ;now render the flagpole shaft
009479  1  A0 08              ldy #$08
00947B  1  A9 25              lda #$25
00947D  1  20 51 96           jsr RenderUnderPart
009480  1  A9 61              lda #$61                 ;render solid block at the bottom
009482  1  8D AB 06           sta MetatileBuffer+10
009485  1  20 9F 96           jsr GetAreaObjXPosition
009488  1  38                 sec                      ;get pixel coordinate of where the flagpole is,
009489  1  E9 08              sbc #$08                 ;subtract eight pixels and use as horizontal
00948B  1  85 8C              sta Enemy_X_Position+5   ;coordinate for the flag
00948D  1  AD 25 07           lda CurrentPageLoc
009490  1  E9 00              sbc #$00                 ;subtract borrow from page location and use as
009492  1  85 73              sta Enemy_PageLoc+5      ;page location for the flag
009494  1  A9 30              lda #$30
009496  1  85 D4              sta Enemy_Y_Position+5   ;set vertical coordinate for flag
009498  1  A9 B0              lda #$b0
00949A  1  8D 0D 01           sta FlagpoleFNum_Y_Pos   ;set initial vertical coordinate for flagpole's floatey number
00949D  1  A9 30              lda #FlagpoleFlagObject
00949F  1  85 1B              sta Enemy_ID+5           ;set flag identifier, note that identifier and coordinates
0094A1  1  E6 14              inc Enemy_Flag+5         ;use last space in enemy object buffer
0094A3  1  60                 rts
0094A4  1               
0094A4  1               ;--------------------------------
0094A4  1               
0094A4  1               EndlessRope:
0094A4  1  A2 00              ldx #$00       ;render rope from the top to the bottom of screen
0094A6  1  A0 0F              ldy #$0f
0094A8  1  4C BD 94           jmp DrawRope
0094AB  1               
0094AB  1               BalancePlatRope:
0094AB  1  8A                     txa                 ;save object buffer offset for now
0094AC  1  48                     pha
0094AD  1  A2 01                  ldx #$01            ;blank out all from second row to the bottom
0094AF  1  A0 0F                  ldy #$0f            ;with blank used for balance platform rope
0094B1  1  A9 44                  lda #$44
0094B3  1  20 51 96               jsr RenderUnderPart
0094B6  1  68                     pla                 ;get back object buffer offset
0094B7  1  AA                     tax
0094B8  1  20 8F 96               jsr GetLrgObjAttrib ;get vertical length from lower nybble
0094BB  1  A2 01                  ldx #$01
0094BD  1  A9 40        DrawRope: lda #$40            ;render the actual rope
0094BF  1  4C 51 96               jmp RenderUnderPart
0094C2  1               
0094C2  1               ;--------------------------------
0094C2  1               
0094C2  1               CoinMetatileData:
0094C2  1  C3 C2 C2 C2        .byte $c3, $c2, $c2, $c2
0094C6  1               
0094C6  1               RowOfCoins:
0094C6  1  AC 4E 07           ldy AreaType            ;get area type
0094C9  1  B9 C2 94           lda CoinMetatileData,y  ;load appropriate coin metatile
0094CC  1  4C 18 95           jmp GetRow
0094CF  1               
0094CF  1               ;--------------------------------
0094CF  1               
0094CF  1               C_ObjectRow:
0094CF  1  06 07 08           .byte $06, $07, $08
0094D2  1               
0094D2  1               C_ObjectMetatile:
0094D2  1  C5 0C 89           .byte $c5, $0c, $89
0094D5  1               
0094D5  1               CastleBridgeObj:
0094D5  1  A0 0C              ldy #$0c                  ;load length of 13 columns
0094D7  1  20 83 96           jsr ChkLrgObjFixedLength
0094DA  1  4C E2 94           jmp ChainObj
0094DD  1               
0094DD  1               AxeObj:
0094DD  1  A9 08              lda #$08                  ;load bowser's palette into sprite portion of palette
0094DF  1  8D 73 07           sta VRAM_Buffer_AddrCtrl
0094E2  1               
0094E2  1               ChainObj:
0094E2  1  A4 00              ldy $00                   ;get value loaded earlier from decoder
0094E4  1  BE CD 94           ldx C_ObjectRow-2,y       ;get appropriate row and metatile for object
0094E7  1  B9 D0 94           lda C_ObjectMetatile-2,y
0094EA  1  4C F4 94           jmp ColObj
0094ED  1               
0094ED  1               EmptyBlock:
0094ED  1  20 8F 96             jsr GetLrgObjAttrib  ;get row location
0094F0  1  A6 07                ldx $07
0094F2  1  A9 C4                lda #$c4
0094F4  1  A0 00        ColObj: ldy #$00             ;column length of 1
0094F6  1  4C 51 96             jmp RenderUnderPart
0094F9  1               
0094F9  1               ;--------------------------------
0094F9  1               
0094F9  1               SolidBlockMetatiles:
0094F9  1  69 61 61 62        .byte $69, $61, $61, $62
0094FD  1               
0094FD  1               BrickMetatiles:
0094FD  1  22 51 52 52        .byte $22, $51, $52, $52
009501  1  88                 .byte $88 ;used only by row of bricks object
009502  1               
009502  1               RowOfBricks:
009502  1  AC 4E 07                 ldy AreaType           ;load area type obtained from area offset pointer
009505  1  AD 43 07                 lda CloudTypeOverride  ;check for cloud type override
009508  1  F0 02                    beq DrawBricks
00950A  1  A0 04                    ldy #$04               ;if cloud type, override area type
00950C  1  B9 FD 94     DrawBricks: lda BrickMetatiles,y   ;get appropriate metatile
00950F  1  4C 18 95                 jmp GetRow             ;and go render it
009512  1               
009512  1               RowOfSolidBlocks:
009512  1  AC 4E 07              ldy AreaType               ;load area type obtained from area offset pointer
009515  1  B9 F9 94              lda SolidBlockMetatiles,y  ;get metatile
009518  1  48           GetRow:  pha                        ;store metatile here
009519  1  20 80 96              jsr ChkLrgObjLength        ;get row number, load length
00951C  1  A6 07        DrawRow: ldx $07
00951E  1  A0 00                 ldy #$00                   ;set vertical height of 1
009520  1  68                    pla
009521  1  4C 51 96              jmp RenderUnderPart        ;render object
009524  1               
009524  1               ColumnOfBricks:
009524  1  AC 4E 07           ldy AreaType          ;load area type obtained from area offset
009527  1  B9 FD 94           lda BrickMetatiles,y  ;get metatile (no cloud override as for row)
00952A  1  4C 33 95           jmp GetRow2
00952D  1               
00952D  1               ColumnOfSolidBlocks:
00952D  1  AC 4E 07              ldy AreaType               ;load area type obtained from area offset
009530  1  B9 F9 94              lda SolidBlockMetatiles,y  ;get metatile
009533  1  48           GetRow2: pha                        ;save metatile to stack for now
009534  1  20 8F 96              jsr GetLrgObjAttrib        ;get length and row
009537  1  68                    pla                        ;restore metatile
009538  1  A6 07                 ldx $07                    ;get starting row
00953A  1  4C 51 96              jmp RenderUnderPart        ;now render the column
00953D  1               
00953D  1               ;--------------------------------
00953D  1               
00953D  1               BulletBillCannon:
00953D  1  20 8F 96                  jsr GetLrgObjAttrib      ;get row and length of bullet bill cannon
009540  1  A6 07                     ldx $07                  ;start at first row
009542  1  A9 64                     lda #$64                 ;render bullet bill cannon
009544  1  9D A1 06                  sta MetatileBuffer,x
009547  1  E8                        inx
009548  1  88                        dey                      ;done yet?
009549  1  30 0E                     bmi SetupCannon
00954B  1  A9 65                     lda #$65                 ;if not, render middle part
00954D  1  9D A1 06                  sta MetatileBuffer,x
009550  1  E8                        inx
009551  1  88                        dey                      ;done yet?
009552  1  30 05                     bmi SetupCannon
009554  1  A9 66                     lda #$66                 ;if not, render bottom until length expires
009556  1  20 51 96                  jsr RenderUnderPart
009559  1  AE 6A 04     SetupCannon: ldx Cannon_Offset        ;get offset for data used by cannons and whirlpools
00955C  1  20 A7 96                  jsr GetAreaObjYPosition  ;get proper vertical coordinate for cannon
00955F  1  9D 77 04                  sta Cannon_Y_Position,x  ;and store it here
009562  1  AD 25 07                  lda CurrentPageLoc
009565  1  9D 6B 04                  sta Cannon_PageLoc,x     ;store page number for cannon here
009568  1  20 9F 96                  jsr GetAreaObjXPosition  ;get proper horizontal coordinate for cannon
00956B  1  9D 71 04                  sta Cannon_X_Position,x  ;and store it here
00956E  1  E8                        inx
00956F  1  E0 06                     cpx #$06                 ;increment and check offset
009571  1  90 02                     bcc StrCOffset           ;if not yet reached sixth cannon, branch to save offset
009573  1  A2 00                     ldx #$00                 ;otherwise initialize it
009575  1  8E 6A 04     StrCOffset:  stx Cannon_Offset        ;save new offset and leave
009578  1  60                        rts
009579  1               
009579  1               ;--------------------------------
009579  1               
009579  1               StaircaseHeightData:
009579  1  07 07 06 05        .byte $07, $07, $06, $05, $04, $03, $02, $01, $00
00957D  1  04 03 02 01  
009581  1  00           
009582  1               
009582  1               StaircaseRowData:
009582  1  03 03 04 05        .byte $03, $03, $04, $05, $06, $07, $08, $09, $0a
009586  1  06 07 08 09  
00958A  1  0A           
00958B  1               
00958B  1               StaircaseObject:
00958B  1  20 80 96                jsr ChkLrgObjLength       ;check and load length
00958E  1  90 05                   bcc NextStair             ;if length already loaded, skip init part
009590  1  A9 09                   lda #$09                  ;start past the end for the bottom
009592  1  8D 34 07                sta StaircaseControl      ;of the staircase
009595  1  CE 34 07     NextStair: dec StaircaseControl      ;move onto next step (or first if starting)
009598  1  AC 34 07                ldy StaircaseControl
00959B  1  BE 82 95                ldx StaircaseRowData,y    ;get starting row and height to render
00959E  1  B9 79 95                lda StaircaseHeightData,y
0095A1  1  A8                      tay
0095A2  1  A9 61                   lda #$61                  ;now render solid block staircase
0095A4  1  4C 51 96                jmp RenderUnderPart
0095A7  1               
0095A7  1               ;--------------------------------
0095A7  1               
0095A7  1               Jumpspring:
0095A7  1  20 8F 96           jsr GetLrgObjAttrib
0095AA  1  20 1E 94           jsr FindEmptyEnemySlot      ;find empty space in enemy object buffer
0095AD  1  20 9F 96           jsr GetAreaObjXPosition     ;get horizontal coordinate for jumpspring
0095B0  1  95 87              sta Enemy_X_Position,x      ;and store
0095B2  1  AD 25 07           lda CurrentPageLoc          ;store page location of jumpspring
0095B5  1  95 6E              sta Enemy_PageLoc,x
0095B7  1  20 A7 96           jsr GetAreaObjYPosition     ;get vertical coordinate for jumpspring
0095BA  1  95 CF              sta Enemy_Y_Position,x      ;and store
0095BC  1  95 58              sta Jumpspring_FixedYPos,x  ;store as permanent coordinate here
0095BE  1  A9 32              lda #JumpspringObject
0095C0  1  95 16              sta Enemy_ID,x              ;write jumpspring object to enemy object buffer
0095C2  1  A0 01              ldy #$01
0095C4  1  94 B6              sty Enemy_Y_HighPos,x       ;store vertical high byte
0095C6  1  F6 0F              inc Enemy_Flag,x            ;set flag for enemy object buffer
0095C8  1  A6 07              ldx $07
0095CA  1  A9 67              lda #$67                    ;draw metatiles in two rows where jumpspring is
0095CC  1  9D A1 06           sta MetatileBuffer,x
0095CF  1  A9 68              lda #$68
0095D1  1  9D A2 06           sta MetatileBuffer+1,x
0095D4  1  60                 rts
0095D5  1               
0095D5  1               ;--------------------------------
0095D5  1               ;$07 - used to save ID of brick object
0095D5  1               
0095D5  1               Hidden1UpBlock:
0095D5  1  AD 5D 07           lda Hidden1UpFlag  ;if flag not set, do not render object
0095D8  1  F0 36              beq ExitDecBlock
0095DA  1  A9 00              lda #$00           ;if set, init for the next one
0095DC  1  8D 5D 07           sta Hidden1UpFlag
0095DF  1  4C ED 95           jmp BrickWithItem  ;jump to code shared with unbreakable bricks
0095E2  1               
0095E2  1               QuestionBlock:
0095E2  1  20 0A 96           jsr GetAreaObjectID ;get value from level decoder routine
0095E5  1  4C 00 96           jmp DrawQBlk        ;go to render it
0095E8  1               
0095E8  1               BrickWithCoins:
0095E8  1  A9 00              lda #$00                 ;initialize multi-coin timer flag
0095EA  1  8D BC 06           sta BrickCoinTimerFlag
0095ED  1               
0095ED  1               BrickWithItem:
0095ED  1  20 0A 96               jsr GetAreaObjectID         ;save area object ID
0095F0  1  84 07                  sty $07
0095F2  1  A9 00                  lda #$00                    ;load default adder for bricks with lines
0095F4  1  AC 4E 07               ldy AreaType                ;check level type for ground level
0095F7  1  88                     dey
0095F8  1  F0 02                  beq BWithL                  ;if ground type, do not start with 5
0095FA  1  A9 05                  lda #$05                    ;otherwise use adder for bricks without lines
0095FC  1  18           BWithL:   clc                         ;add object ID to adder
0095FD  1  65 07                  adc $07
0095FF  1  A8                     tay                         ;use as offset for metatile
009600  1  B9 9F BE     DrawQBlk: lda BrickQBlockMetatiles,y  ;get appropriate metatile for brick (question block
009603  1  48                     pha                         ;if branched to here from question block routine)
009604  1  20 8F 96               jsr GetLrgObjAttrib         ;get row from location byte
009607  1  4C 1C 95               jmp DrawRow                 ;now render the object
00960A  1               
00960A  1               GetAreaObjectID:
00960A  1  A5 00                      lda $00    ;get value saved from area parser routine
00960C  1  38                         sec
00960D  1  E9 00                      sbc #$00   ;possibly residual code
00960F  1  A8                         tay        ;save to Y
009610  1  60           ExitDecBlock: rts
009611  1               
009611  1               ;--------------------------------
009611  1               
009611  1               HoleMetatiles:
009611  1  87 00 00 00        .byte $87, $00, $00, $00
009615  1               
009615  1               Hole_Empty:
009615  1  20 80 96                 jsr ChkLrgObjLength          ;get lower nybble and save as length
009618  1  90 2D                    bcc NoWhirlP                 ;skip this part if length already loaded
00961A  1  AD 4E 07                 lda AreaType                 ;check for water type level
00961D  1  D0 28                    bne NoWhirlP                 ;if not water type, skip this part
00961F  1  AE 6A 04                 ldx Whirlpool_Offset         ;get offset for data used by cannons and whirlpools
009622  1  20 9F 96                 jsr GetAreaObjXPosition      ;get proper vertical coordinate of where we're at
009625  1  38                       sec
009626  1  E9 10                    sbc #$10                     ;subtract 16 pixels
009628  1  9D 71 04                 sta Whirlpool_LeftExtent,x   ;store as left extent of whirlpool
00962B  1  AD 25 07                 lda CurrentPageLoc           ;get page location of where we're at
00962E  1  E9 00                    sbc #$00                     ;subtract borrow
009630  1  9D 6B 04                 sta Whirlpool_PageLoc,x      ;save as page location of whirlpool
009633  1  C8                       iny
009634  1  C8                       iny                          ;increment length by 2
009635  1  98                       tya
009636  1  0A                       asl                          ;multiply by 16 to get size of whirlpool
009637  1  0A                       asl                          ;note that whirlpool will always be
009638  1  0A                       asl                          ;two blocks bigger than actual size of hole
009639  1  0A                       asl                          ;and extend one block beyond each edge
00963A  1  9D 77 04                 sta Whirlpool_Length,x       ;save size of whirlpool here
00963D  1  E8                       inx
00963E  1  E0 05                    cpx #$05                     ;increment and check offset
009640  1  90 02                    bcc StrWOffset               ;if not yet reached fifth whirlpool, branch to save offset
009642  1  A2 00                    ldx #$00                     ;otherwise initialize it
009644  1  8E 6A 04     StrWOffset: stx Whirlpool_Offset         ;save new offset here
009647  1  AE 4E 07     NoWhirlP:   ldx AreaType                 ;get appropriate metatile, then
00964A  1  BD 11 96                 lda HoleMetatiles,x          ;render the hole proper
00964D  1  A2 08                    ldx #$08
00964F  1  A0 0F                    ldy #$0f                     ;start at ninth row and go to bottom, run RenderUnderPart
009651  1               
009651  1               ;--------------------------------
009651  1               
009651  1               RenderUnderPart:
009651  1  8C 35 07                  sty AreaObjectHeight  ;store vertical length to render
009654  1  BC A1 06                  ldy MetatileBuffer,x  ;check current spot to see if there's something
009657  1  F0 18                     beq DrawThisRow       ;we need to keep, if nothing, go ahead
009659  1  C0 17                     cpy #$17
00965B  1  F0 17                     beq WaitOneRow        ;if middle part (tree ledge), wait until next row
00965D  1  C0 1A                     cpy #$1a
00965F  1  F0 13                     beq WaitOneRow        ;if middle part (mushroom ledge), wait until next row
009661  1  C0 C0                     cpy #$c0
009663  1  F0 0C                     beq DrawThisRow       ;if question block w/ coin, overwrite
009665  1  C0 C0                     cpy #$c0
009667  1  B0 0B                     bcs WaitOneRow        ;if any other metatile with palette 3, wait until next row
009669  1  C0 54                     cpy #$54
00966B  1  D0 04                     bne DrawThisRow       ;if cracked rock terrain, overwrite
00966D  1  C9 50                     cmp #$50
00966F  1  F0 03                     beq WaitOneRow        ;if stem top of mushroom, wait until next row
009671  1  9D A1 06     DrawThisRow: sta MetatileBuffer,x  ;render contents of A from routine that called this
009674  1  E8           WaitOneRow:  inx
009675  1  E0 0D                     cpx #$0d              ;stop rendering if we're at the bottom of the screen
009677  1  B0 06                     bcs ExitUPartR
009679  1  AC 35 07                  ldy AreaObjectHeight  ;decrement, and stop rendering if there is no more length
00967C  1  88                        dey
00967D  1  10 D2                     bpl RenderUnderPart
00967F  1  60           ExitUPartR:  rts
009680  1               
009680  1               ;--------------------------------
009680  1               
009680  1               ChkLrgObjLength:
009680  1  20 8F 96             jsr GetLrgObjAttrib     ;get row location and size (length if branched to from here)
009683  1               
009683  1               ChkLrgObjFixedLength:
009683  1  BD 30 07             lda AreaObjectLength,x  ;check for set length counter
009686  1  18                   clc                     ;clear carry flag for not just starting
009687  1  10 05                bpl LenSet              ;if counter not set, load it, otherwise leave alone
009689  1  98                   tya                     ;save length into length counter
00968A  1  9D 30 07             sta AreaObjectLength,x
00968D  1  38                   sec                     ;set carry flag if just starting
00968E  1  60           LenSet: rts
00968F  1               
00968F  1               
00968F  1               GetLrgObjAttrib:
00968F  1  BC 2D 07           ldy AreaObjOffsetBuffer,x ;get offset saved from area obj decoding routine
009692  1  B1 E7              lda (AreaData),y          ;get first byte of level object
009694  1  29 0F              and #%00001111
009696  1  85 07              sta $07                   ;save row location
009698  1  C8                 iny
009699  1  B1 E7              lda (AreaData),y          ;get next byte, save lower nybble (length or height)
00969B  1  29 0F              and #%00001111            ;as Y, then leave
00969D  1  A8                 tay
00969E  1  60                 rts
00969F  1               
00969F  1               ;--------------------------------
00969F  1               
00969F  1               GetAreaObjXPosition:
00969F  1  AD 26 07           lda CurrentColumnPos    ;multiply current offset where we're at by 16
0096A2  1  0A                 asl                     ;to obtain horizontal pixel coordinate
0096A3  1  0A                 asl
0096A4  1  0A                 asl
0096A5  1  0A                 asl
0096A6  1  60                 rts
0096A7  1               
0096A7  1               ;--------------------------------
0096A7  1               
0096A7  1               GetAreaObjYPosition:
0096A7  1  A5 07              lda $07  ;multiply value by 16
0096A9  1  0A                 asl
0096AA  1  0A                 asl      ;this will give us the proper vertical pixel coordinate
0096AB  1  0A                 asl
0096AC  1  0A                 asl
0096AD  1  18                 clc
0096AE  1  69 20              adc #32  ;add 32 pixels for the status bar
0096B0  1  60                 rts
0096B1  1               
0096B1  1               ;-------------------------------------------------------------------------------------
0096B1  1               
0096B1  1               ;unused space
0096B1  1  FF FF              .byte $ff, $ff
0096B3  1               
0096B3  1               ;-------------------------------------------------------------------------------------
0096B3  1               
0096B3  1               AreaDataOfsLoopback:
0096B3  1  12 36 0E 0E        .byte $12, $36, $0e, $0e, $0e, $32, $32, $32, $0a, $26, $40
0096B7  1  0E 32 32 32  
0096BB  1  0A 26 40     
0096BE  1               
0096BE  1               ;bonus area data offsets, included here for comparison purposes
0096BE  1               ;underground bonus area  - c2
0096BE  1               ;cloud area 1 (day)      - 2b
0096BE  1               ;cloud area 2 (night)    - 34
0096BE  1               ;water area (5-2/6-2)    - 00
0096BE  1               ;water area (8-4)        - 02
0096BE  1               ;warp zone area (4-2)    - 2f
0096BE  1               
0096BE  1               EnemyDataAddrLow:
0096BE  1  4A 71 8A B9        .byte <E_CastleArea1, <E_CastleArea2, <E_CastleArea3, <E_CastleArea4, <E_CastleArea5, <E_CastleArea6
0096C2  1  E4 F9        
0096C4  1  33 58 75 83        .byte <E_GroundArea1, <E_GroundArea2, <E_GroundArea3, <E_GroundArea4, <E_GroundArea5, <E_GroundArea6
0096C8  1  AA DB        
0096CA  1  F9 16 2B 55        .byte <E_GroundArea7, <E_GroundArea8, <E_GroundArea9, <E_GroundArea10, <E_GroundArea11, <E_GroundArea12
0096CE  1  56 7A        
0096D0  1  83 A8 CB D4        .byte <E_GroundArea13, <E_GroundArea14, <E_GroundArea15, <E_GroundArea16, <E_GroundArea17, <E_GroundArea18
0096D4  1  D5 0F        
0096D6  1  3A 68 84 8D        .byte <E_GroundArea19, <E_GroundArea20, <E_GroundArea21, <E_GroundArea22, <E_UndergroundArea1
0096DA  1  B2           
0096DB  1  DF 0D 3A 4B        .byte <E_UndergroundArea2, <E_UndergroundArea3, <E_WaterArea1, <E_WaterArea2, <E_WaterArea3
0096DF  1  75           
0096E0  1               
0096E0  1               EnemyDataAddrHigh:
0096E0  1  97 97 97 97        .byte >E_CastleArea1, >E_CastleArea2, >E_CastleArea3, >E_CastleArea4, >E_CastleArea5, >E_CastleArea6
0096E4  1  97 97        
0096E6  1  98 98 98 98        .byte >E_GroundArea1, >E_GroundArea2, >E_GroundArea3, >E_GroundArea4, >E_GroundArea5, >E_GroundArea6
0096EA  1  98 98        
0096EC  1  98 99 99 99        .byte >E_GroundArea7, >E_GroundArea8, >E_GroundArea9, >E_GroundArea10, >E_GroundArea11, >E_GroundArea12
0096F0  1  99 99        
0096F2  1  99 99 99 99        .byte >E_GroundArea13, >E_GroundArea14, >E_GroundArea15, >E_GroundArea16, >E_GroundArea17, >E_GroundArea18
0096F6  1  99 9A        
0096F8  1  9A 9A 9A 9A        .byte >E_GroundArea19, >E_GroundArea20, >E_GroundArea21, >E_GroundArea22, >E_UndergroundArea1
0096FC  1  9A           
0096FD  1  9A 9B 9B 9B        .byte >E_UndergroundArea2, >E_UndergroundArea3, >E_WaterArea1, >E_WaterArea2, >E_WaterArea3
009701  1  9B           
009702  1               
009702  1               AreaDataHOffsets:
009702  1  00 03 19 1C        .byte $00, $03, $19, $1c
009706  1               
009706  1               AreaDataAddrLow:
009706  1  E0 1F 9A 45        .byte <L_WaterArea1, <L_WaterArea2, <L_WaterArea3, <L_GroundArea1, <L_GroundArea2, <L_GroundArea3
00970A  1  A8 11        
00970C  1  64 F3 68 CD        .byte <L_GroundArea4, <L_GroundArea5, <L_GroundArea6, <L_GroundArea7, <L_GroundArea8, <L_GroundArea9
009710  1  22 A7        
009712  1  0C 15 54 69        .byte <L_GroundArea10, <L_GroundArea11, <L_GroundArea12, <L_GroundArea13, <L_GroundArea14, <L_GroundArea15
009716  1  D0 35        
009718  1  A8 D9 6C DF        .byte <L_GroundArea16, <L_GroundArea17, <L_GroundArea18, <L_GroundArea19, <L_GroundArea20, <L_GroundArea21
00971C  1  58 B1        
00971E  1  DC 0F B2 53        .byte <L_GroundArea22, <L_UndergroundArea1, <L_UndergroundArea2, <L_UndergroundArea3, <L_CastleArea1
009722  1  89           
009723  1  EA 69 DC 49        .byte <L_CastleArea2, <L_CastleArea3, <L_CastleArea4, <L_CastleArea5, <L_CastleArea6
009727  1  D4           
009728  1               
009728  1               AreaDataAddrHigh:
009728  1  A7 A8 A8 9E        .byte >L_WaterArea1, >L_WaterArea2, >L_WaterArea3, >L_GroundArea1, >L_GroundArea2, >L_GroundArea3
00972C  1  9E 9F        
00972E  1  9F 9F A0 A0        .byte >L_GroundArea4, >L_GroundArea5, >L_GroundArea6, >L_GroundArea7, >L_GroundArea8, >L_GroundArea9
009732  1  A1 A1        
009734  1  A2 A2 A2 A2        .byte >L_GroundArea10, >L_GroundArea11, >L_GroundArea12, >L_GroundArea13, >L_GroundArea14, >L_GroundArea15
009738  1  A2 A3        
00973A  1  A3 A3 A4 A4        .byte >L_GroundArea16, >L_GroundArea17, >L_GroundArea18, >L_GroundArea19, >L_GroundArea20, >L_GroundArea21
00973E  1  A5 A5        
009740  1  A5 A6 A6 A7        .byte >L_GroundArea22, >L_UndergroundArea1, >L_UndergroundArea2, >L_UndergroundArea3, >L_CastleArea1
009744  1  9B           
009745  1  9B 9C 9C 9D        .byte >L_CastleArea2, >L_CastleArea3, >L_CastleArea4, >L_CastleArea5, >L_CastleArea6
009749  1  9D           
00974A  1               
00974A  1               ;ENEMY OBJECT DATA
00974A  1               
00974A  1               ;level 1-4/6-4
00974A  1               E_CastleArea1:
00974A  1  76 DD BB 4C        .byte $76, $dd, $bb, $4c, $ea, $1d, $1b, $cc, $56, $5d
00974E  1  EA 1D 1B CC  
009752  1  56 5D        
009754  1  16 9D C6 1D        .byte $16, $9d, $c6, $1d, $36, $9d, $c9, $1d, $04, $db
009758  1  36 9D C9 1D  
00975C  1  04 DB        
00975E  1  49 1D 84 1B        .byte $49, $1d, $84, $1b, $c9, $5d, $88, $95, $0f, $08
009762  1  C9 5D 88 95  
009766  1  0F 08        
009768  1  30 4C 78 2D        .byte $30, $4c, $78, $2d, $a6, $28, $90, $b5
00976C  1  A6 28 90 B5  
009770  1  FF                 .byte $ff
009771  1               
009771  1               ;level 4-4
009771  1               E_CastleArea2:
009771  1  0F 03 56 1B        .byte $0f, $03, $56, $1b, $c9, $1b, $0f, $07, $36, $1b
009775  1  C9 1B 0F 07  
009779  1  36 1B        
00977B  1  AA 1B 48 95        .byte $aa, $1b, $48, $95, $0f, $0a, $2a, $1b, $5b, $0c
00977F  1  0F 0A 2A 1B  
009783  1  5B 0C        
009785  1  78 2D 90 B5        .byte $78, $2d, $90, $b5
009789  1  FF                 .byte $ff
00978A  1               
00978A  1               ;level 2-4/5-4
00978A  1               E_CastleArea3:
00978A  1  0B 8C 4B 4C        .byte $0b, $8c, $4b, $4c, $77, $5f, $eb, $0c, $bd, $db
00978E  1  77 5F EB 0C  
009792  1  BD DB        
009794  1  19 9D 75 1D        .byte $19, $9d, $75, $1d, $7d, $5b, $d9, $1d, $3d, $dd
009798  1  7D 5B D9 1D  
00979C  1  3D DD        
00979E  1  99 1D 26 9D        .byte $99, $1d, $26, $9d, $5a, $2b, $8a, $2c, $ca, $1b
0097A2  1  5A 2B 8A 2C  
0097A6  1  CA 1B        
0097A8  1  20 95 7B 5C        .byte $20, $95, $7b, $5c, $db, $4c, $1b, $cc, $3b, $cc
0097AC  1  DB 4C 1B CC  
0097B0  1  3B CC        
0097B2  1  78 2D A6 28        .byte $78, $2d, $a6, $28, $90, $b5
0097B6  1  90 B5        
0097B8  1  FF                 .byte $ff
0097B9  1               
0097B9  1               ;level 3-4
0097B9  1               E_CastleArea4:
0097B9  1  0B 8C 3B 1D        .byte $0b, $8c, $3b, $1d, $8b, $1d, $ab, $0c, $db, $1d
0097BD  1  8B 1D AB 0C  
0097C1  1  DB 1D        
0097C3  1  0F 03 65 1D        .byte $0f, $03, $65, $1d, $6b, $1b, $05, $9d, $0b, $1b
0097C7  1  6B 1B 05 9D  
0097CB  1  0B 1B        
0097CD  1  05 9B 0B 1D        .byte $05, $9b, $0b, $1d, $8b, $0c, $1b, $8c, $70, $15
0097D1  1  8B 0C 1B 8C  
0097D5  1  70 15        
0097D7  1  7B 0C DB 0C        .byte $7b, $0c, $db, $0c, $0f, $08, $78, $2d, $a6, $28
0097DB  1  0F 08 78 2D  
0097DF  1  A6 28        
0097E1  1  90 B5              .byte $90, $b5
0097E3  1  FF                 .byte $ff
0097E4  1               
0097E4  1               ;level 7-4
0097E4  1               E_CastleArea5:
0097E4  1  27 A9 4B 0C        .byte $27, $a9, $4b, $0c, $68, $29, $0f, $06, $77, $1b
0097E8  1  68 29 0F 06  
0097EC  1  77 1B        
0097EE  1  0F 0B 60 15        .byte $0f, $0b, $60, $15, $4b, $8c, $78, $2d, $90, $b5
0097F2  1  4B 8C 78 2D  
0097F6  1  90 B5        
0097F8  1  FF                 .byte $ff
0097F9  1               
0097F9  1               ;level 8-4
0097F9  1               E_CastleArea6:
0097F9  1  0F 03 8E 65        .byte $0f, $03, $8e, $65, $e1, $bb, $38, $6d, $a8, $3e, $e5, $e7
0097FD  1  E1 BB 38 6D  
009801  1  A8 3E E5 E7  
009805  1  0F 08 0B 02        .byte $0f, $08, $0b, $02, $2b, $02, $5e, $65, $e1, $bb, $0e
009809  1  2B 02 5E 65  
00980D  1  E1 BB 0E     
009810  1  DB 0E BB 8E        .byte $db, $0e, $bb, $8e, $db, $0e, $fe, $65, $ec, $0f, $0d
009814  1  DB 0E FE 65  
009818  1  EC 0F 0D     
00981B  1  4E 65 E1 0F        .byte $4e, $65, $e1, $0f, $0e, $4e, $02, $e0, $0f, $10, $fe, $e5, $e1
00981F  1  0E 4E 02 E0  
009823  1  0F 10 FE E5  
009828  1  1B 85 7B 0C        .byte $1b, $85, $7b, $0c, $5b, $95, $78, $2d, $90, $b5
00982C  1  5B 95 78 2D  
009830  1  90 B5        
009832  1  FF                 .byte $ff
009833  1               
009833  1               ;level 3-3
009833  1               E_GroundArea1:
009833  1  A5 86 E4 28        .byte $a5, $86, $e4, $28, $18, $a8, $45, $83, $69, $03
009837  1  18 A8 45 83  
00983B  1  69 03        
00983D  1  C6 29 9B 83        .byte $c6, $29, $9b, $83, $16, $a4, $88, $24, $e9, $28
009841  1  16 A4 88 24  
009845  1  E9 28        
009847  1  05 A8 7B 28        .byte $05, $a8, $7b, $28, $24, $8f, $c8, $03, $e8, $03
00984B  1  24 8F C8 03  
00984F  1  E8 03        
009851  1  46 A8 85 24        .byte $46, $a8, $85, $24, $c8, $24
009855  1  C8 24        
009857  1  FF                 .byte $ff
009858  1               
009858  1               ;level 8-3
009858  1               E_GroundArea2:
009858  1  EB 8E 0F 03        .byte $eb, $8e, $0f, $03, $fb, $05, $17, $85, $db, $8e
00985C  1  FB 05 17 85  
009860  1  DB 8E        
009862  1  0F 07 57 05        .byte $0f, $07, $57, $05, $7b, $05, $9b, $80, $2b, $85
009866  1  7B 05 9B 80  
00986A  1  2B 85        
00986C  1  FB 05 0F 0B        .byte $fb, $05, $0f, $0b, $1b, $05, $9b, $05
009870  1  1B 05 9B 05  
009874  1  FF                 .byte $ff
009875  1               
009875  1               ;level 4-1
009875  1               E_GroundArea3:
009875  1  2E C2 66 E2        .byte $2e, $c2, $66, $e2, $11, $0f, $07, $02, $11, $0f, $0c
009879  1  11 0F 07 02  
00987D  1  11 0F 0C     
009880  1  12 11              .byte $12, $11
009882  1  FF                 .byte $ff
009883  1               
009883  1               ;level 6-2
009883  1               E_GroundArea4:
009883  1  0E C2 A8 AB        .byte $0e, $c2, $a8, $ab, $00, $bb, $8e, $6b, $82, $de, $00, $a0
009887  1  00 BB 8E 6B  
00988B  1  82 DE 00 A0  
00988F  1  33 86 43 06        .byte $33, $86, $43, $06, $3e, $b4, $a0, $cb, $02, $0f, $07
009893  1  3E B4 A0 CB  
009897  1  02 0F 07     
00989A  1  7E 42 A6 83        .byte $7e, $42, $a6, $83, $02, $0f, $0a, $3b, $02, $cb, $37
00989E  1  02 0F 0A 3B  
0098A2  1  02 CB 37     
0098A5  1  0F 0C E3 0E        .byte $0f, $0c, $e3, $0e
0098A9  1  FF                 .byte $ff
0098AA  1               
0098AA  1               ;level 3-1
0098AA  1               E_GroundArea5:
0098AA  1  9B 8E CA 0E        .byte $9b, $8e, $ca, $0e, $ee, $42, $44, $5b, $86, $80, $b8
0098AE  1  EE 42 44 5B  
0098B2  1  86 80 B8     
0098B5  1  1B 80 50 BA        .byte $1b, $80, $50, $ba, $10, $b7, $5b, $00, $17, $85
0098B9  1  10 B7 5B 00  
0098BD  1  17 85        
0098BF  1  4B 05 FE 34        .byte $4b, $05, $fe, $34, $40, $b7, $86, $c6, $06, $5b, $80
0098C3  1  40 B7 86 C6  
0098C7  1  06 5B 80     
0098CA  1  83 00 D0 38        .byte $83, $00, $d0, $38, $5b, $8e, $8a, $0e, $a6, $00
0098CE  1  5B 8E 8A 0E  
0098D2  1  A6 00        
0098D4  1  BB 0E C5 80        .byte $bb, $0e, $c5, $80, $f3, $00
0098D8  1  F3 00        
0098DA  1  FF                 .byte $ff
0098DB  1               
0098DB  1               ;level 1-1
0098DB  1               E_GroundArea6:
0098DB  1  1E C2 00 6B        .byte $1e, $c2, $00, $6b, $06, $8b, $86, $63, $b7, $0f, $05
0098DF  1  06 8B 86 63  
0098E3  1  B7 0F 05     
0098E6  1  03 06 23 06        .byte $03, $06, $23, $06, $4b, $b7, $bb, $00, $5b, $b7
0098EA  1  4B B7 BB 00  
0098EE  1  5B B7        
0098F0  1  FB 37 3B B7        .byte $fb, $37, $3b, $b7, $0f, $0b, $1b, $37
0098F4  1  0F 0B 1B 37  
0098F8  1  FF                 .byte $ff
0098F9  1               
0098F9  1               ;level 1-3/5-3
0098F9  1               E_GroundArea7:
0098F9  1  2B D7 E3 03        .byte $2b, $d7, $e3, $03, $c2, $86, $e2, $06, $76, $a5
0098FD  1  C2 86 E2 06  
009901  1  76 A5        
009903  1  A3 8F 03 86        .byte $a3, $8f, $03, $86, $2b, $57, $68, $28, $e9, $28
009907  1  2B 57 68 28  
00990B  1  E9 28        
00990D  1  E5 83 24 8F        .byte $e5, $83, $24, $8f, $36, $a8, $5b, $03
009911  1  36 A8 5B 03  
009915  1  FF                 .byte $ff
009916  1               
009916  1               ;level 2-3/7-3
009916  1               E_GroundArea8:
009916  1  0F 02 78 40        .byte $0f, $02, $78, $40, $48, $ce, $f8, $c3, $f8, $c3
00991A  1  48 CE F8 C3  
00991E  1  F8 C3        
009920  1  0F 07 7B 43        .byte $0f, $07, $7b, $43, $c6, $d0, $0f, $8a, $c8, $50
009924  1  C6 D0 0F 8A  
009928  1  C8 50        
00992A  1  FF                 .byte $ff
00992B  1               
00992B  1               ;level 2-1
00992B  1               E_GroundArea9:
00992B  1  85 86 0B 80        .byte $85, $86, $0b, $80, $1b, $00, $db, $37, $77, $80
00992F  1  1B 00 DB 37  
009933  1  77 80        
009935  1  EB 37 FE 2B        .byte $eb, $37, $fe, $2b, $20, $2b, $80, $7b, $38, $ab, $b8
009939  1  20 2B 80 7B  
00993D  1  38 AB B8     
009940  1  77 86 FE 42        .byte $77, $86, $fe, $42, $20, $49, $86, $8b, $06, $9b, $80
009944  1  20 49 86 8B  
009948  1  06 9B 80     
00994B  1  7B 8E 5B B7        .byte $7b, $8e, $5b, $b7, $9b, $0e, $bb, $0e, $9b, $80
00994F  1  9B 0E BB 0E  
009953  1  9B 80        
009955  1               ;end of data terminator here is also used by pipe intro area
009955  1               E_GroundArea10:
009955  1  FF                 .byte $ff
009956  1               
009956  1               ;level 5-1
009956  1               E_GroundArea11:
009956  1  0B 80 60 38        .byte $0b, $80, $60, $38, $10, $b8, $c0, $3b, $db, $8e
00995A  1  10 B8 C0 3B  
00995E  1  DB 8E        
009960  1  40 B8 F0 38        .byte $40, $b8, $f0, $38, $7b, $8e, $a0, $b8, $c0, $b8
009964  1  7B 8E A0 B8  
009968  1  C0 B8        
00996A  1  FB 00 A0 B8        .byte $fb, $00, $a0, $b8, $30, $bb, $ee, $42, $88, $0f, $0b
00996E  1  30 BB EE 42  
009972  1  88 0F 0B     
009975  1  2B 0E 67 0E        .byte $2b, $0e, $67, $0e
009979  1  FF                 .byte $ff
00997A  1               
00997A  1               ;cloud level used in levels 2-1 and 5-2
00997A  1               E_GroundArea12:
00997A  1  0A AA 0E 28        .byte $0a, $aa, $0e, $28, $2a, $0e, $31, $88
00997E  1  2A 0E 31 88  
009982  1  FF                 .byte $ff
009983  1               
009983  1               ;level 4-3
009983  1               E_GroundArea13:
009983  1  C7 83 D7 03        .byte $c7, $83, $d7, $03, $42, $8f, $7a, $03, $05, $a4
009987  1  42 8F 7A 03  
00998B  1  05 A4        
00998D  1  78 24 A6 25        .byte $78, $24, $a6, $25, $e4, $25, $4b, $83, $e3, $03
009991  1  E4 25 4B 83  
009995  1  E3 03        
009997  1  05 A4 89 24        .byte $05, $a4, $89, $24, $b5, $24, $09, $a4, $65, $24
00999B  1  B5 24 09 A4  
00999F  1  65 24        
0099A1  1  C9 24 0F 08        .byte $c9, $24, $0f, $08, $85, $25
0099A5  1  85 25        
0099A7  1  FF                 .byte $ff
0099A8  1               
0099A8  1               ;level 6-3
0099A8  1               E_GroundArea14:
0099A8  1  CD A5 B5 A8        .byte $cd, $a5, $b5, $a8, $07, $a8, $76, $28, $cc, $25
0099AC  1  07 A8 76 28  
0099B0  1  CC 25        
0099B2  1  65 A4 A9 24        .byte $65, $a4, $a9, $24, $e5, $24, $19, $a4, $0f, $07
0099B6  1  E5 24 19 A4  
0099BA  1  0F 07        
0099BC  1  95 28 E6 24        .byte $95, $28, $e6, $24, $19, $a4, $d7, $29, $16, $a9
0099C0  1  19 A4 D7 29  
0099C4  1  16 A9        
0099C6  1  58 29 97 29        .byte $58, $29, $97, $29
0099CA  1  FF                 .byte $ff
0099CB  1               
0099CB  1               ;level 6-1
0099CB  1               E_GroundArea15:
0099CB  1  0F 02 02 11        .byte $0f, $02, $02, $11, $0f, $07, $02, $11
0099CF  1  0F 07 02 11  
0099D3  1  FF                 .byte $ff
0099D4  1               
0099D4  1               ;warp zone area used in level 4-2
0099D4  1               E_GroundArea16:
0099D4  1  FF                 .byte $ff
0099D5  1               
0099D5  1               ;level 8-1
0099D5  1               E_GroundArea17:
0099D5  1  2B 82 AB 38        .byte $2b, $82, $ab, $38, $de, $42, $e2, $1b, $b8, $eb
0099D9  1  DE 42 E2 1B  
0099DD  1  B8 EB        
0099DF  1  3B DB 80 8B        .byte $3b, $db, $80, $8b, $b8, $1b, $82, $fb, $b8, $7b
0099E3  1  B8 1B 82 FB  
0099E7  1  B8 7B        
0099E9  1  80 FB 3C 5B        .byte $80, $fb, $3c, $5b, $bc, $7b, $b8, $1b, $8e, $cb
0099ED  1  BC 7B B8 1B  
0099F1  1  8E CB        
0099F3  1  0E 1B 8E 0F        .byte $0e, $1b, $8e, $0f, $0d, $2b, $3b, $bb, $b8, $eb, $82
0099F7  1  0D 2B 3B BB  
0099FB  1  B8 EB 82     
0099FE  1  4B B8 BB 38        .byte $4b, $b8, $bb, $38, $3b, $b7, $bb, $02, $0f, $13
009A02  1  3B B7 BB 02  
009A06  1  0F 13        
009A08  1  1B 00 CB 80        .byte $1b, $00, $cb, $80, $6b, $bc
009A0C  1  6B BC        
009A0E  1  FF                 .byte $ff
009A0F  1               
009A0F  1               ;level 5-2
009A0F  1               E_GroundArea18:
009A0F  1  7B 80 AE 00        .byte $7b, $80, $ae, $00, $80, $8b, $8e, $e8, $05, $f9, $86
009A13  1  80 8B 8E E8  
009A17  1  05 F9 86     
009A1A  1  17 86 16 85        .byte $17, $86, $16, $85, $4e, $2b, $80, $ab, $8e, $87, $85
009A1E  1  4E 2B 80 AB  
009A22  1  8E 87 85     
009A25  1  C3 05 8B 82        .byte $c3, $05, $8b, $82, $9b, $02, $ab, $02, $bb, $86
009A29  1  9B 02 AB 02  
009A2D  1  BB 86        
009A2F  1  CB 06 D3 03        .byte $cb, $06, $d3, $03, $3b, $8e, $6b, $0e, $a7, $8e
009A33  1  3B 8E 6B 0E  
009A37  1  A7 8E        
009A39  1  FF                 .byte $ff
009A3A  1               
009A3A  1               ;level 8-2
009A3A  1               E_GroundArea19:
009A3A  1  29 8E 52 11        .byte $29, $8e, $52, $11, $83, $0e, $0f, $03, $9b, $0e
009A3E  1  83 0E 0F 03  
009A42  1  9B 0E        
009A44  1  2B 8E 5B 0E        .byte $2b, $8e, $5b, $0e, $cb, $8e, $fb, $0e, $fb, $82
009A48  1  CB 8E FB 0E  
009A4C  1  FB 82        
009A4E  1  9B 82 BB 02        .byte $9b, $82, $bb, $02, $fe, $42, $e8, $bb, $8e, $0f, $0a
009A52  1  FE 42 E8 BB  
009A56  1  8E 0F 0A     
009A59  1  AB 0E CB 0E        .byte $ab, $0e, $cb, $0e, $f9, $0e, $88, $86, $a6, $06
009A5D  1  F9 0E 88 86  
009A61  1  A6 06        
009A63  1  DB 02 B6 8E        .byte $db, $02, $b6, $8e
009A67  1  FF                 .byte $ff
009A68  1               
009A68  1               ;level 7-1
009A68  1               E_GroundArea20:
009A68  1  AB CE DE 42        .byte $ab, $ce, $de, $42, $c0, $cb, $ce, $5b, $8e, $1b, $ce
009A6C  1  C0 CB CE 5B  
009A70  1  8E 1B CE     
009A73  1  4B 85 67 45        .byte $4b, $85, $67, $45, $0f, $07, $2b, $00, $7b, $85
009A77  1  0F 07 2B 00  
009A7B  1  7B 85        
009A7D  1  97 05 0F 0A        .byte $97, $05, $0f, $0a, $92, $02
009A81  1  92 02        
009A83  1  FF                 .byte $ff
009A84  1               
009A84  1               ;cloud level used in levels 3-1 and 6-2
009A84  1               E_GroundArea21:
009A84  1  0A AA 0E 24        .byte $0a, $aa, $0e, $24, $4a, $1e, $23, $aa
009A88  1  4A 1E 23 AA  
009A8C  1  FF                 .byte $ff
009A8D  1               
009A8D  1               ;level 3-2
009A8D  1               E_GroundArea22:
009A8D  1  1B 80 BB 38        .byte $1b, $80, $bb, $38, $4b, $bc, $eb, $3b, $0f, $04
009A91  1  4B BC EB 3B  
009A95  1  0F 04        
009A97  1  2B 00 AB 38        .byte $2b, $00, $ab, $38, $eb, $00, $cb, $8e, $fb, $80
009A9B  1  EB 00 CB 8E  
009A9F  1  FB 80        
009AA1  1  AB B8 6B 80        .byte $ab, $b8, $6b, $80, $fb, $3c, $9b, $bb, $5b, $bc
009AA5  1  FB 3C 9B BB  
009AA9  1  5B BC        
009AAB  1  FB 00 6B B8        .byte $fb, $00, $6b, $b8, $fb, $38
009AAF  1  FB 38        
009AB1  1  FF                 .byte $ff
009AB2  1               
009AB2  1               ;level 1-2
009AB2  1               E_UndergroundArea1:
009AB2  1  0B 86 1A 06        .byte $0b, $86, $1a, $06, $db, $06, $de, $c2, $02, $f0, $3b
009AB6  1  DB 06 DE C2  
009ABA  1  02 F0 3B     
009ABD  1  BB 80 EB 06        .byte $bb, $80, $eb, $06, $0b, $86, $93, $06, $f0, $39
009AC1  1  0B 86 93 06  
009AC5  1  F0 39        
009AC7  1  0F 06 60 B8        .byte $0f, $06, $60, $b8, $1b, $86, $a0, $b9, $b7, $27
009ACB  1  1B 86 A0 B9  
009ACF  1  B7 27        
009AD1  1  BD 27 2B 83        .byte $bd, $27, $2b, $83, $a1, $26, $a9, $26, $ee, $25, $0b
009AD5  1  A1 26 A9 26  
009AD9  1  EE 25 0B     
009ADC  1  27 B4              .byte $27, $b4
009ADE  1  FF                 .byte $ff
009ADF  1               
009ADF  1               ;level 4-2
009ADF  1               E_UndergroundArea2:
009ADF  1  0F 02 1E 2F        .byte $0f, $02, $1e, $2f, $60, $e0, $3a, $a5, $a7, $db, $80
009AE3  1  60 E0 3A A5  
009AE7  1  A7 DB 80     
009AEA  1  3B 82 8B 02        .byte $3b, $82, $8b, $02, $fe, $42, $68, $70, $bb, $25, $a7
009AEE  1  FE 42 68 70  
009AF2  1  BB 25 A7     
009AF5  1  2C 27 B2 26        .byte $2c, $27, $b2, $26, $b9, $26, $9b, $80, $a8, $82
009AF9  1  B9 26 9B 80  
009AFD  1  A8 82        
009AFF  1  B5 27 BC 27        .byte $b5, $27, $bc, $27, $b0, $bb, $3b, $82, $87, $34
009B03  1  B0 BB 3B 82  
009B07  1  87 34        
009B09  1  EE 25 6B           .byte $ee, $25, $6b
009B0C  1  FF                 .byte $ff
009B0D  1               
009B0D  1               ;underground bonus rooms area used in many levels
009B0D  1               E_UndergroundArea3:
009B0D  1  1E A5 0A 2E        .byte $1e, $a5, $0a, $2e, $28, $27, $2e, $33, $c7, $0f, $03, $1e, $40, $07
009B11  1  28 27 2E 33  
009B15  1  C7 0F 03 1E  
009B1B  1  2E 30 E7 0F        .byte $2e, $30, $e7, $0f, $05, $1e, $24, $44, $0f, $07, $1e, $22, $6a
009B1F  1  05 1E 24 44  
009B23  1  0F 07 1E 22  
009B28  1  2E 23 AB 0F        .byte $2e, $23, $ab, $0f, $09, $1e, $41, $68, $1e, $2a, $8a, $2e, $23, $a2
009B2C  1  09 1E 41 68  
009B30  1  1E 2A 8A 2E  
009B36  1  2E 32 EA           .byte $2e, $32, $ea
009B39  1  FF                 .byte $ff
009B3A  1               
009B3A  1               ;water area used in levels 5-2 and 6-2
009B3A  1               E_WaterArea1:
009B3A  1  3B 87 66 27        .byte $3b, $87, $66, $27, $cc, $27, $ee, $31, $87, $ee, $23, $a7
009B3E  1  CC 27 EE 31  
009B42  1  87 EE 23 A7  
009B46  1  3B 87 DB 07        .byte $3b, $87, $db, $07
009B4A  1  FF                 .byte $ff
009B4B  1               
009B4B  1               ;level 2-2/7-2
009B4B  1               E_WaterArea2:
009B4B  1  0F 01 2E 25        .byte $0f, $01, $2e, $25, $2b, $2e, $25, $4b, $4e, $25, $cb, $6b, $07
009B4F  1  2B 2E 25 4B  
009B53  1  4E 25 CB 6B  
009B58  1  97 47 E9 87        .byte $97, $47, $e9, $87, $47, $c7, $7a, $07, $d6, $c7
009B5C  1  47 C7 7A 07  
009B60  1  D6 C7        
009B62  1  78 07 38 87        .byte $78, $07, $38, $87, $ab, $47, $e3, $07, $9b, $87
009B66  1  AB 47 E3 07  
009B6A  1  9B 87        
009B6C  1  0F 09 68 47        .byte $0f, $09, $68, $47, $db, $c7, $3b, $c7
009B70  1  DB C7 3B C7  
009B74  1  FF                 .byte $ff
009B75  1               
009B75  1               ;water area used in level 8-4
009B75  1               E_WaterArea3:
009B75  1  47 9B CB 07        .byte $47, $9b, $cb, $07, $fa, $1d, $86, $9b, $3a, $87
009B79  1  FA 1D 86 9B  
009B7D  1  3A 87        
009B7F  1  56 07 88 1B        .byte $56, $07, $88, $1b, $07, $9d, $2e, $65, $f0
009B83  1  07 9D 2E 65  
009B87  1  F0           
009B88  1  FF                 .byte $ff
009B89  1               
009B89  1               ;AREA OBJECT DATA
009B89  1               
009B89  1               ;level 1-4/6-4
009B89  1               L_CastleArea1:
009B89  1  9B 07              .byte $9b, $07
009B8B  1  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $ce, $03, $dc, $51
009B8F  1  07 34 CE 03  
009B93  1  DC 51        
009B95  1  EE 07 73 E0        .byte $ee, $07, $73, $e0, $74, $0a, $7e, $06, $9e, $0a
009B99  1  74 0A 7E 06  
009B9D  1  9E 0A        
009B9F  1  CE 06 E4 00        .byte $ce, $06, $e4, $00, $e8, $0a, $fe, $0a, $2e, $89
009BA3  1  E8 0A FE 0A  
009BA7  1  2E 89        
009BA9  1  4E 0B 54 0A        .byte $4e, $0b, $54, $0a, $14, $8a, $c4, $0a, $34, $8a
009BAD  1  14 8A C4 0A  
009BB1  1  34 8A        
009BB3  1  7E 06 C7 0A        .byte $7e, $06, $c7, $0a, $01, $e0, $02, $0a, $47, $0a
009BB7  1  01 E0 02 0A  
009BBB  1  47 0A        
009BBD  1  81 60 82 0A        .byte $81, $60, $82, $0a, $c7, $0a, $0e, $87, $7e, $02
009BC1  1  C7 0A 0E 87  
009BC5  1  7E 02        
009BC7  1  A7 02 B3 02        .byte $a7, $02, $b3, $02, $d7, $02, $e3, $02, $07, $82
009BCB  1  D7 02 E3 02  
009BCF  1  07 82        
009BD1  1  13 02 3E 06        .byte $13, $02, $3e, $06, $7e, $02, $ae, $07, $fe, $0a
009BD5  1  7E 02 AE 07  
009BD9  1  FE 0A        
009BDB  1  0D C4 CD 43        .byte $0d, $c4, $cd, $43, $ce, $09, $de, $0b, $dd, $42
009BDF  1  CE 09 DE 0B  
009BE3  1  DD 42        
009BE5  1  FE 02 5D C7        .byte $fe, $02, $5d, $c7
009BE9  1  FD                 .byte $fd
009BEA  1               
009BEA  1               ;level 4-4
009BEA  1               L_CastleArea2:
009BEA  1  5B 07              .byte $5b, $07
009BEC  1  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $5e, $0a, $68, $64
009BF0  1  07 34 5E 0A  
009BF4  1  68 64        
009BF6  1  98 64 A8 64        .byte $98, $64, $a8, $64, $ce, $06, $fe, $02, $0d, $01
009BFA  1  CE 06 FE 02  
009BFE  1  0D 01        
009C00  1  1E 0E 7E 02        .byte $1e, $0e, $7e, $02, $94, $63, $b4, $63, $d4, $63
009C04  1  94 63 B4 63  
009C08  1  D4 63        
009C0A  1  F4 63 14 E3        .byte $f4, $63, $14, $e3, $2e, $0e, $5e, $02, $64, $35
009C0E  1  2E 0E 5E 02  
009C12  1  64 35        
009C14  1  88 72 BE 0E        .byte $88, $72, $be, $0e, $0d, $04, $ae, $02, $ce, $08
009C18  1  0D 04 AE 02  
009C1C  1  CE 08        
009C1E  1  CD 4B FE 02        .byte $cd, $4b, $fe, $02, $0d, $05, $68, $31, $7e, $0a
009C22  1  0D 05 68 31  
009C26  1  7E 0A        
009C28  1  96 31 A9 63        .byte $96, $31, $a9, $63, $a8, $33, $d5, $30, $ee, $02
009C2C  1  A8 33 D5 30  
009C30  1  EE 02        
009C32  1  E6 62 F4 61        .byte $e6, $62, $f4, $61, $04, $b1, $08, $3f, $44, $33
009C36  1  04 B1 08 3F  
009C3A  1  44 33        
009C3C  1  94 63 A4 31        .byte $94, $63, $a4, $31, $e4, $31, $04, $bf, $08, $3f
009C40  1  E4 31 04 BF  
009C44  1  08 3F        
009C46  1  04 BF 08 3F        .byte $04, $bf, $08, $3f, $cd, $4b, $03, $e4, $0e, $03
009C4A  1  CD 4B 03 E4  
009C4E  1  0E 03        
009C50  1  2E 01 7E 06        .byte $2e, $01, $7e, $06, $be, $02, $de, $06, $fe, $0a
009C54  1  BE 02 DE 06  
009C58  1  FE 0A        
009C5A  1  0D C4 CD 43        .byte $0d, $c4, $cd, $43, $ce, $09, $de, $0b, $dd, $42
009C5E  1  CE 09 DE 0B  
009C62  1  DD 42        
009C64  1  FE 02 5D C7        .byte $fe, $02, $5d, $c7
009C68  1  FD                 .byte $fd
009C69  1               
009C69  1               ;level 2-4/5-4
009C69  1               L_CastleArea3:
009C69  1  9B 07              .byte $9b, $07
009C6B  1  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $fe, $00, $27, $b1
009C6F  1  07 34 FE 00  
009C73  1  27 B1        
009C75  1  65 32 75 0A        .byte $65, $32, $75, $0a, $71, $00, $b7, $31, $08, $e4
009C79  1  71 00 B7 31  
009C7D  1  08 E4        
009C7F  1  18 64 1E 04        .byte $18, $64, $1e, $04, $57, $3b, $bb, $0a, $17, $8a
009C83  1  57 3B BB 0A  
009C87  1  17 8A        
009C89  1  27 3A 73 0A        .byte $27, $3a, $73, $0a, $7b, $0a, $d7, $0a, $e7, $3a
009C8D  1  7B 0A D7 0A  
009C91  1  E7 3A        
009C93  1  3B 8A 97 0A        .byte $3b, $8a, $97, $0a, $fe, $08, $24, $8a, $2e, $00
009C97  1  FE 08 24 8A  
009C9B  1  2E 00        
009C9D  1  3E 40 38 64        .byte $3e, $40, $38, $64, $6f, $00, $9f, $00, $be, $43
009CA1  1  6F 00 9F 00  
009CA5  1  BE 43        
009CA7  1  C8 0A C9 63        .byte $c8, $0a, $c9, $63, $ce, $07, $fe, $07, $2e, $81
009CAB  1  CE 07 FE 07  
009CAF  1  2E 81        
009CB1  1  66 42 6A 42        .byte $66, $42, $6a, $42, $79, $0a, $be, $00, $c8, $64
009CB5  1  79 0A BE 00  
009CB9  1  C8 64        
009CBB  1  F8 64 08 E4        .byte $f8, $64, $08, $e4, $2e, $07, $7e, $03, $9e, $07
009CBF  1  2E 07 7E 03  
009CC3  1  9E 07        
009CC5  1  BE 03 DE 07        .byte $be, $03, $de, $07, $fe, $0a, $03, $a5, $0d, $44
009CC9  1  FE 0A 03 A5  
009CCD  1  0D 44        
009CCF  1  CD 43 CE 09        .byte $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02
009CD3  1  DD 42 DE 0B  
009CD7  1  FE 02        
009CD9  1  5D C7              .byte $5d, $c7
009CDB  1  FD                 .byte $fd
009CDC  1               
009CDC  1               ;level 3-4
009CDC  1               L_CastleArea4:
009CDC  1  9B 07              .byte $9b, $07
009CDE  1  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $fe, $06, $0c, $81
009CE2  1  07 34 FE 06  
009CE6  1  0C 81        
009CE8  1  39 0A 5C 01        .byte $39, $0a, $5c, $01, $89, $0a, $ac, $01, $d9, $0a
009CEC  1  89 0A AC 01  
009CF0  1  D9 0A        
009CF2  1  FC 01 2E 83        .byte $fc, $01, $2e, $83, $a7, $01, $b7, $00, $c7, $01
009CF6  1  A7 01 B7 00  
009CFA  1  C7 01        
009CFC  1  DE 0A FE 02        .byte $de, $0a, $fe, $02, $4e, $83, $5a, $32, $63, $0a
009D00  1  4E 83 5A 32  
009D04  1  63 0A        
009D06  1  69 0A 7E 02        .byte $69, $0a, $7e, $02, $ee, $03, $fa, $32, $03, $8a
009D0A  1  EE 03 FA 32  
009D0E  1  03 8A        
009D10  1  09 0A 1E 02        .byte $09, $0a, $1e, $02, $ee, $03, $fa, $32, $03, $8a
009D14  1  EE 03 FA 32  
009D18  1  03 8A        
009D1A  1  09 0A 14 42        .byte $09, $0a, $14, $42, $1e, $02, $7e, $0a, $9e, $07
009D1E  1  1E 02 7E 0A  
009D22  1  9E 07        
009D24  1  FE 0A 2E 86        .byte $fe, $0a, $2e, $86, $5e, $0a, $8e, $06, $be, $0a
009D28  1  5E 0A 8E 06  
009D2C  1  BE 0A        
009D2E  1  EE 07 3E 83        .byte $ee, $07, $3e, $83, $5e, $07, $fe, $0a, $0d, $c4
009D32  1  5E 07 FE 0A  
009D36  1  0D C4        
009D38  1  41 52 51 52        .byte $41, $52, $51, $52, $cd, $43, $ce, $09, $de, $0b
009D3C  1  CD 43 CE 09  
009D40  1  DE 0B        
009D42  1  DD 42 FE 02        .byte $dd, $42, $fe, $02, $5d, $c7
009D46  1  5D C7        
009D48  1  FD                 .byte $fd
009D49  1               
009D49  1               ;level 7-4
009D49  1               L_CastleArea5:
009D49  1  5B 07              .byte $5b, $07
009D4B  1  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $fe, $0a, $ae, $86
009D4F  1  07 34 FE 0A  
009D53  1  AE 86        
009D55  1  BE 07 FE 02        .byte $be, $07, $fe, $02, $0d, $02, $27, $32, $46, $61
009D59  1  0D 02 27 32  
009D5D  1  46 61        
009D5F  1  55 62 5E 0E        .byte $55, $62, $5e, $0e, $1e, $82, $68, $3c, $74, $3a
009D63  1  1E 82 68 3C  
009D67  1  74 3A        
009D69  1  7D 4B 5E 8E        .byte $7d, $4b, $5e, $8e, $7d, $4b, $7e, $82, $84, $62
009D6D  1  7D 4B 7E 82  
009D71  1  84 62        
009D73  1  94 61 A4 31        .byte $94, $61, $a4, $31, $bd, $4b, $ce, $06, $fe, $02
009D77  1  BD 4B CE 06  
009D7B  1  FE 02        
009D7D  1  0D 06 34 31        .byte $0d, $06, $34, $31, $3e, $0a, $64, $32, $75, $0a
009D81  1  3E 0A 64 32  
009D85  1  75 0A        
009D87  1  7B 61 A4 33        .byte $7b, $61, $a4, $33, $ae, $02, $de, $0e, $3e, $82
009D8B  1  AE 02 DE 0E  
009D8F  1  3E 82        
009D91  1  64 32 78 32        .byte $64, $32, $78, $32, $b4, $36, $c8, $36, $dd, $4b
009D95  1  B4 36 C8 36  
009D99  1  DD 4B        
009D9B  1  44 B2 58 32        .byte $44, $b2, $58, $32, $94, $63, $a4, $3e, $ba, $30
009D9F  1  94 63 A4 3E  
009DA3  1  BA 30        
009DA5  1  C9 61 CE 06        .byte $c9, $61, $ce, $06, $dd, $4b, $ce, $86, $dd, $4b
009DA9  1  DD 4B CE 86  
009DAD  1  DD 4B        
009DAF  1  FE 02 2E 86        .byte $fe, $02, $2e, $86, $5e, $02, $7e, $06, $fe, $02
009DB3  1  5E 02 7E 06  
009DB7  1  FE 02        
009DB9  1  1E 86 3E 02        .byte $1e, $86, $3e, $02, $5e, $06, $7e, $02, $9e, $06
009DBD  1  5E 06 7E 02  
009DC1  1  9E 06        
009DC3  1  FE 0A 0D C4        .byte $fe, $0a, $0d, $c4, $cd, $43, $ce, $09, $de, $0b
009DC7  1  CD 43 CE 09  
009DCB  1  DE 0B        
009DCD  1  DD 42 FE 02        .byte $dd, $42, $fe, $02, $5d, $c7
009DD1  1  5D C7        
009DD3  1  FD                 .byte $fd
009DD4  1               
009DD4  1               ;level 8-4
009DD4  1               L_CastleArea6:
009DD4  1  5B 06              .byte $5b, $06
009DD6  1  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $5e, $0a, $ae, $02
009DDA  1  07 34 5E 0A  
009DDE  1  AE 02        
009DE0  1  0D 01 39 73        .byte $0d, $01, $39, $73, $0d, $03, $39, $7b, $4d, $4b
009DE4  1  0D 03 39 7B  
009DE8  1  4D 4B        
009DEA  1  DE 06 1E 8A        .byte $de, $06, $1e, $8a, $ae, $06, $c4, $33, $16, $fe
009DEE  1  AE 06 C4 33  
009DF2  1  16 FE        
009DF4  1  A5 77 FE 02        .byte $a5, $77, $fe, $02, $fe, $82, $0d, $07, $39, $73
009DF8  1  FE 82 0D 07  
009DFC  1  39 73        
009DFE  1  A8 74 ED 4B        .byte $a8, $74, $ed, $4b, $49, $fb, $e8, $74, $fe, $0a
009E02  1  49 FB E8 74  
009E06  1  FE 0A        
009E08  1  2E 82 67 02        .byte $2e, $82, $67, $02, $84, $7a, $87, $31, $0d, $0b
009E0C  1  84 7A 87 31  
009E10  1  0D 0B        
009E12  1  FE 02 0D 0C        .byte $fe, $02, $0d, $0c, $39, $73, $5e, $06, $c6, $76
009E16  1  39 73 5E 06  
009E1A  1  C6 76        
009E1C  1  45 FF BE 0A        .byte $45, $ff, $be, $0a, $dd, $48, $fe, $06, $3d, $cb
009E20  1  DD 48 FE 06  
009E24  1  3D CB        
009E26  1  46 7E AD 4A        .byte $46, $7e, $ad, $4a, $fe, $82, $39, $f3, $a9, $7b
009E2A  1  FE 82 39 F3  
009E2E  1  A9 7B        
009E30  1  4E 8A 9E 07        .byte $4e, $8a, $9e, $07, $fe, $0a, $0d, $c4, $cd, $43
009E34  1  FE 0A 0D C4  
009E38  1  CD 43        
009E3A  1  CE 09 DE 0B        .byte $ce, $09, $de, $0b, $dd, $42, $fe, $02, $5d, $c7
009E3E  1  DD 42 FE 02  
009E42  1  5D C7        
009E44  1  FD                 .byte $fd
009E45  1               
009E45  1               ;level 3-3
009E45  1               L_GroundArea1:
009E45  1  94 11              .byte $94, $11
009E47  1  0F 26 FE 10        .byte $0f, $26, $fe, $10, $28, $94, $65, $15, $eb, $12
009E4B  1  28 94 65 15  
009E4F  1  EB 12        
009E51  1  FA 41 4A 96        .byte $fa, $41, $4a, $96, $54, $40, $a4, $42, $b7, $13
009E55  1  54 40 A4 42  
009E59  1  B7 13        
009E5B  1  E9 19 F5 15        .byte $e9, $19, $f5, $15, $11, $80, $47, $42, $71, $13
009E5F  1  11 80 47 42  
009E63  1  71 13        
009E65  1  80 41 15 92        .byte $80, $41, $15, $92, $1b, $1f, $24, $40, $55, $12
009E69  1  1B 1F 24 40  
009E6D  1  55 12        
009E6F  1  64 40 95 12        .byte $64, $40, $95, $12, $a4, $40, $d2, $12, $e1, $40
009E73  1  A4 40 D2 12  
009E77  1  E1 40        
009E79  1  13 C0 2C 17        .byte $13, $c0, $2c, $17, $2f, $12, $49, $13, $83, $40
009E7D  1  2F 12 49 13  
009E81  1  83 40        
009E83  1  9F 14 A3 40        .byte $9f, $14, $a3, $40, $17, $92, $83, $13, $92, $41
009E87  1  17 92 83 13  
009E8B  1  92 41        
009E8D  1  B9 14 C5 12        .byte $b9, $14, $c5, $12, $c8, $40, $d4, $40, $4b, $92
009E91  1  C8 40 D4 40  
009E95  1  4B 92        
009E97  1  78 1B 9C 94        .byte $78, $1b, $9c, $94, $9f, $11, $df, $14, $fe, $11
009E9B  1  9F 11 DF 14  
009E9F  1  FE 11        
009EA1  1  7D C1 9E 42        .byte $7d, $c1, $9e, $42, $cf, $20
009EA5  1  CF 20        
009EA7  1  FD                 .byte $fd
009EA8  1               
009EA8  1               ;level 8-3
009EA8  1               L_GroundArea2:
009EA8  1  90 B1              .byte $90, $b1
009EAA  1  0F 26 29 91        .byte $0f, $26, $29, $91, $7e, $42, $fe, $40, $28, $92
009EAE  1  7E 42 FE 40  
009EB2  1  28 92        
009EB4  1  4E 42 2E C0        .byte $4e, $42, $2e, $c0, $57, $73, $c3, $25, $c7, $27
009EB8  1  57 73 C3 25  
009EBC  1  C7 27        
009EBE  1  23 84 33 20        .byte $23, $84, $33, $20, $5c, $01, $77, $63, $88, $62
009EC2  1  5C 01 77 63  
009EC6  1  88 62        
009EC8  1  99 61 AA 60        .byte $99, $61, $aa, $60, $bc, $01, $ee, $42, $4e, $c0
009ECC  1  BC 01 EE 42  
009ED0  1  4E C0        
009ED2  1  69 11 7E 42        .byte $69, $11, $7e, $42, $de, $40, $f8, $62, $0e, $c2
009ED6  1  DE 40 F8 62  
009EDA  1  0E C2        
009EDC  1  AE 40 D7 63        .byte $ae, $40, $d7, $63, $e7, $63, $33, $a7, $37, $27
009EE0  1  E7 63 33 A7  
009EE4  1  37 27        
009EE6  1  43 04 CC 01        .byte $43, $04, $cc, $01, $e7, $73, $0c, $81, $3e, $42
009EEA  1  E7 73 0C 81  
009EEE  1  3E 42        
009EF0  1  0D 0A 5E 40        .byte $0d, $0a, $5e, $40, $88, $72, $be, $42, $e7, $87
009EF4  1  88 72 BE 42  
009EF8  1  E7 87        
009EFA  1  FE 40 39 E1        .byte $fe, $40, $39, $e1, $4e, $00, $69, $60, $87, $60
009EFE  1  4E 00 69 60  
009F02  1  87 60        
009F04  1  A5 60 C3 31        .byte $a5, $60, $c3, $31, $fe, $31, $6d, $c1, $be, $42
009F08  1  FE 31 6D C1  
009F0C  1  BE 42        
009F0E  1  EF 20              .byte $ef, $20
009F10  1  FD                 .byte $fd
009F11  1               
009F11  1               ;level 4-1
009F11  1               L_GroundArea3:
009F11  1  52 21              .byte $52, $21
009F13  1  0F 20 6E 40        .byte $0f, $20, $6e, $40, $58, $f2, $93, $01, $97, $00
009F17  1  58 F2 93 01  
009F1B  1  97 00        
009F1D  1  0C 81 97 40        .byte $0c, $81, $97, $40, $a6, $41, $c7, $40, $0d, $04
009F21  1  A6 41 C7 40  
009F25  1  0D 04        
009F27  1  03 01 07 01        .byte $03, $01, $07, $01, $23, $01, $27, $01, $ec, $03
009F2B  1  23 01 27 01  
009F2F  1  EC 03        
009F31  1  AC F3 C3 03        .byte $ac, $f3, $c3, $03, $78, $e2, $94, $43, $47, $f3
009F35  1  78 E2 94 43  
009F39  1  47 F3        
009F3B  1  74 43 47 FB        .byte $74, $43, $47, $fb, $74, $43, $2c, $f1, $4c, $63
009F3F  1  74 43 2C F1  
009F43  1  4C 63        
009F45  1  47 00 57 21        .byte $47, $00, $57, $21, $5c, $01, $7c, $72, $39, $f1
009F49  1  5C 01 7C 72  
009F4D  1  39 F1        
009F4F  1  EC 02 4C 81        .byte $ec, $02, $4c, $81, $d8, $62, $ec, $01, $0d, $0d
009F53  1  D8 62 EC 01  
009F57  1  0D 0D        
009F59  1  0F 38 C7 07        .byte $0f, $38, $c7, $07, $ed, $4a, $1d, $c1, $5f, $26
009F5D  1  ED 4A 1D C1  
009F61  1  5F 26        
009F63  1  FD                 .byte $fd
009F64  1               
009F64  1               ;level 6-2
009F64  1               L_GroundArea4:
009F64  1  54 21              .byte $54, $21
009F66  1  0F 26 A7 22        .byte $0f, $26, $a7, $22, $37, $fb, $73, $20, $83, $07
009F6A  1  37 FB 73 20  
009F6E  1  83 07        
009F70  1  87 02 93 20        .byte $87, $02, $93, $20, $c7, $73, $04, $f1, $06, $31
009F74  1  C7 73 04 F1  
009F78  1  06 31        
009F7A  1  39 71 59 71        .byte $39, $71, $59, $71, $e7, $73, $37, $a0, $47, $04
009F7E  1  E7 73 37 A0  
009F82  1  47 04        
009F84  1  86 7C E5 71        .byte $86, $7c, $e5, $71, $e7, $31, $33, $a4, $39, $71
009F88  1  E7 31 33 A4  
009F8C  1  39 71        
009F8E  1  A9 71 D3 23        .byte $a9, $71, $d3, $23, $08, $f2, $13, $05, $27, $02
009F92  1  08 F2 13 05  
009F96  1  27 02        
009F98  1  49 71 75 75        .byte $49, $71, $75, $75, $e8, $72, $67, $f3, $99, $71
009F9C  1  E8 72 67 F3  
009FA0  1  99 71        
009FA2  1  E7 20 F4 72        .byte $e7, $20, $f4, $72, $f7, $31, $17, $a0, $33, $20
009FA6  1  F7 31 17 A0  
009FAA  1  33 20        
009FAC  1  39 71 73 28        .byte $39, $71, $73, $28, $bc, $05, $39, $f1, $79, $71
009FB0  1  BC 05 39 F1  
009FB4  1  79 71        
009FB6  1  A6 21 C3 06        .byte $a6, $21, $c3, $06, $d3, $20, $dc, $00, $fc, $00
009FBA  1  D3 20 DC 00  
009FBE  1  FC 00        
009FC0  1  07 A2 13 21        .byte $07, $a2, $13, $21, $5f, $32, $8c, $00, $98, $7a
009FC4  1  5F 32 8C 00  
009FC8  1  98 7A        
009FCA  1  C7 63 D9 61        .byte $c7, $63, $d9, $61, $03, $a2, $07, $22, $74, $72
009FCE  1  03 A2 07 22  
009FD2  1  74 72        
009FD4  1  77 31 E7 73        .byte $77, $31, $e7, $73, $39, $f1, $58, $72, $77, $73
009FD8  1  39 F1 58 72  
009FDC  1  77 73        
009FDE  1  D8 72 7F B1        .byte $d8, $72, $7f, $b1, $97, $73, $b6, $64, $c5, $65
009FE2  1  97 73 B6 64  
009FE6  1  C5 65        
009FE8  1  D4 66 E3 67        .byte $d4, $66, $e3, $67, $f3, $67, $8d, $c1, $cf, $26
009FEC  1  F3 67 8D C1  
009FF0  1  CF 26        
009FF2  1  FD                 .byte $fd
009FF3  1               
009FF3  1               ;level 3-1
009FF3  1               L_GroundArea5:
009FF3  1  52 31              .byte $52, $31
009FF5  1  0F 20 6E 66        .byte $0f, $20, $6e, $66, $07, $81, $36, $01, $66, $00
009FF9  1  07 81 36 01  
009FFD  1  66 00        
009FFF  1  A7 22 08 F2        .byte $a7, $22, $08, $f2, $67, $7b, $dc, $02, $98, $f2
00A003  1  67 7B DC 02  
00A007  1  98 F2        
00A009  1  D7 20 39 F1        .byte $d7, $20, $39, $f1, $9f, $33, $dc, $27, $dc, $57
00A00D  1  9F 33 DC 27  
00A011  1  DC 57        
00A013  1  23 83 57 63        .byte $23, $83, $57, $63, $6c, $51, $87, $63, $99, $61
00A017  1  6C 51 87 63  
00A01B  1  99 61        
00A01D  1  A3 06 B3 21        .byte $a3, $06, $b3, $21, $77, $f3, $f3, $21, $f7, $2a
00A021  1  77 F3 F3 21  
00A025  1  F7 2A        
00A027  1  13 81 23 22        .byte $13, $81, $23, $22, $53, $00, $63, $22, $e9, $0b
00A02B  1  53 00 63 22  
00A02F  1  E9 0B        
00A031  1  0C 83 13 21        .byte $0c, $83, $13, $21, $16, $22, $33, $05, $8f, $35
00A035  1  16 22 33 05  
00A039  1  8F 35        
00A03B  1  EC 01 63 A0        .byte $ec, $01, $63, $a0, $67, $20, $73, $01, $77, $01
00A03F  1  67 20 73 01  
00A043  1  77 01        
00A045  1  83 20 87 20        .byte $83, $20, $87, $20, $b3, $20, $b7, $20, $c3, $01
00A049  1  B3 20 B7 20  
00A04D  1  C3 01        
00A04F  1  C7 00 D3 20        .byte $c7, $00, $d3, $20, $d7, $20, $67, $a0, $77, $07
00A053  1  D7 20 67 A0  
00A057  1  77 07        
00A059  1  87 22 E8 62        .byte $87, $22, $e8, $62, $f5, $65, $1c, $82, $7f, $38
00A05D  1  F5 65 1C 82  
00A061  1  7F 38        
00A063  1  8D C1 CF 26        .byte $8d, $c1, $cf, $26
00A067  1  FD                 .byte $fd
00A068  1               
00A068  1               ;level 1-1
00A068  1               L_GroundArea6:
00A068  1  50 21              .byte $50, $21
00A06A  1  07 81 47 24        .byte $07, $81, $47, $24, $57, $00, $63, $01, $77, $01
00A06E  1  57 00 63 01  
00A072  1  77 01        
00A074  1  C9 71 68 F2        .byte $c9, $71, $68, $f2, $e7, $73, $97, $fb, $06, $83
00A078  1  E7 73 97 FB  
00A07C  1  06 83        
00A07E  1  5C 01 D7 22        .byte $5c, $01, $d7, $22, $e7, $00, $03, $a7, $6c, $02
00A082  1  E7 00 03 A7  
00A086  1  6C 02        
00A088  1  B3 22 E3 01        .byte $b3, $22, $e3, $01, $e7, $07, $47, $a0, $57, $06
00A08C  1  E7 07 47 A0  
00A090  1  57 06        
00A092  1  A7 01 D3 00        .byte $a7, $01, $d3, $00, $d7, $01, $07, $81, $67, $20
00A096  1  D7 01 07 81  
00A09A  1  67 20        
00A09C  1  93 22 03 A3        .byte $93, $22, $03, $a3, $1c, $61, $17, $21, $6f, $33
00A0A0  1  1C 61 17 21  
00A0A4  1  6F 33        
00A0A6  1  C7 63 D8 62        .byte $c7, $63, $d8, $62, $e9, $61, $fa, $60, $4f, $b3
00A0AA  1  E9 61 FA 60  
00A0AE  1  4F B3        
00A0B0  1  87 63 9C 01        .byte $87, $63, $9c, $01, $b7, $63, $c8, $62, $d9, $61
00A0B4  1  B7 63 C8 62  
00A0B8  1  D9 61        
00A0BA  1  EA 60 39 F1        .byte $ea, $60, $39, $f1, $87, $21, $a7, $01, $b7, $20
00A0BE  1  87 21 A7 01  
00A0C2  1  B7 20        
00A0C4  1  39 F1 5F 38        .byte $39, $f1, $5f, $38, $6d, $c1, $af, $26
00A0C8  1  6D C1 AF 26  
00A0CC  1  FD                 .byte $fd
00A0CD  1               
00A0CD  1               ;level 1-3/5-3
00A0CD  1               L_GroundArea7:
00A0CD  1  90 11              .byte $90, $11
00A0CF  1  0F 26 FE 10        .byte $0f, $26, $fe, $10, $2a, $93, $87, $17, $a3, $14
00A0D3  1  2A 93 87 17  
00A0D7  1  A3 14        
00A0D9  1  B2 42 0A 92        .byte $b2, $42, $0a, $92, $19, $40, $36, $14, $50, $41
00A0DD  1  19 40 36 14  
00A0E1  1  50 41        
00A0E3  1  82 16 2B 93        .byte $82, $16, $2b, $93, $24, $41, $bb, $14, $b8, $00
00A0E7  1  24 41 BB 14  
00A0EB  1  B8 00        
00A0ED  1  C2 43 C3 13        .byte $c2, $43, $c3, $13, $1b, $94, $67, $12, $c4, $15
00A0F1  1  1B 94 67 12  
00A0F5  1  C4 15        
00A0F7  1  53 C1 D2 41        .byte $53, $c1, $d2, $41, $12, $c1, $29, $13, $85, $17
00A0FB  1  12 C1 29 13  
00A0FF  1  85 17        
00A101  1  1B 92 1A 42        .byte $1b, $92, $1a, $42, $47, $13, $83, $41, $a7, $13
00A105  1  47 13 83 41  
00A109  1  A7 13        
00A10B  1  0E 91 A7 63        .byte $0e, $91, $a7, $63, $b7, $63, $c5, $65, $d5, $65
00A10F  1  B7 63 C5 65  
00A113  1  D5 65        
00A115  1  DD 4A E3 67        .byte $dd, $4a, $e3, $67, $f3, $67, $8d, $c1, $ae, $42
00A119  1  F3 67 8D C1  
00A11D  1  AE 42        
00A11F  1  DF 20              .byte $df, $20
00A121  1  FD                 .byte $fd
00A122  1               
00A122  1               ;level 2-3/7-3
00A122  1               L_GroundArea8:
00A122  1  90 11              .byte $90, $11
00A124  1  0F 26 6E 10        .byte $0f, $26, $6e, $10, $8b, $17, $af, $32, $d8, $62
00A128  1  8B 17 AF 32  
00A12C  1  D8 62        
00A12E  1  E8 62 FC 3F        .byte $e8, $62, $fc, $3f, $ad, $c8, $f8, $64, $0c, $be
00A132  1  AD C8 F8 64  
00A136  1  0C BE        
00A138  1  43 43 F8 64        .byte $43, $43, $f8, $64, $0c, $bf, $73, $40, $84, $40
00A13C  1  0C BF 73 40  
00A140  1  84 40        
00A142  1  93 40 A4 40        .byte $93, $40, $a4, $40, $b3, $40, $f8, $64, $48, $e4
00A146  1  B3 40 F8 64  
00A14A  1  48 E4        
00A14C  1  5C 39 83 40        .byte $5c, $39, $83, $40, $92, $41, $b3, $40, $f8, $64
00A150  1  92 41 B3 40  
00A154  1  F8 64        
00A156  1  48 E4 5C 39        .byte $48, $e4, $5c, $39, $f8, $64, $13, $c2, $37, $65
00A15A  1  F8 64 13 C2  
00A15E  1  37 65        
00A160  1  4C 24 63 00        .byte $4c, $24, $63, $00, $97, $65, $c3, $42, $0b, $97
00A164  1  97 65 C3 42  
00A168  1  0B 97        
00A16A  1  AC 32 F8 64        .byte $ac, $32, $f8, $64, $0c, $be, $53, $45, $9d, $48
00A16E  1  0C BE 53 45  
00A172  1  9D 48        
00A174  1  F8 64 2A E2        .byte $f8, $64, $2a, $e2, $3c, $47, $56, $43, $ba, $62
00A178  1  3C 47 56 43  
00A17C  1  BA 62        
00A17E  1  F8 64 0C B7        .byte $f8, $64, $0c, $b7, $88, $64, $bc, $31, $d4, $45
00A182  1  88 64 BC 31  
00A186  1  D4 45        
00A188  1  FC 31 3C B1        .byte $fc, $31, $3c, $b1, $78, $64, $8c, $38, $0b, $9c
00A18C  1  78 64 8C 38  
00A190  1  0B 9C        
00A192  1  1A 33 18 61        .byte $1a, $33, $18, $61, $28, $61, $39, $60, $5d, $4a
00A196  1  28 61 39 60  
00A19A  1  5D 4A        
00A19C  1  EE 11 0F B8        .byte $ee, $11, $0f, $b8, $1d, $c1, $3e, $42, $6f, $20
00A1A0  1  1D C1 3E 42  
00A1A4  1  6F 20        
00A1A6  1  FD                 .byte $fd
00A1A7  1               
00A1A7  1               ;level 2-1
00A1A7  1               L_GroundArea9:
00A1A7  1  52 31              .byte $52, $31
00A1A9  1  0F 20 6E 40        .byte $0f, $20, $6e, $40, $f7, $20, $07, $84, $17, $20
00A1AD  1  F7 20 07 84  
00A1B1  1  17 20        
00A1B3  1  4F 34 C3 03        .byte $4f, $34, $c3, $03, $c7, $02, $d3, $22, $27, $e3
00A1B7  1  C7 02 D3 22  
00A1BB  1  27 E3        
00A1BD  1  39 61 E7 73        .byte $39, $61, $e7, $73, $5c, $e4, $57, $00, $6c, $73
00A1C1  1  5C E4 57 00  
00A1C5  1  6C 73        
00A1C7  1  47 A0 53 06        .byte $47, $a0, $53, $06, $63, $22, $a7, $73, $fc, $73
00A1CB  1  63 22 A7 73  
00A1CF  1  FC 73        
00A1D1  1  13 A1 33 05        .byte $13, $a1, $33, $05, $43, $21, $5c, $72, $c3, $23
00A1D5  1  43 21 5C 72  
00A1D9  1  C3 23        
00A1DB  1  CC 03 77 FB        .byte $cc, $03, $77, $fb, $ac, $02, $39, $f1, $a7, $73
00A1DF  1  AC 02 39 F1  
00A1E3  1  A7 73        
00A1E5  1  D3 04 E8 72        .byte $d3, $04, $e8, $72, $e3, $22, $26, $f4, $bc, $02
00A1E9  1  E3 22 26 F4  
00A1ED  1  BC 02        
00A1EF  1  8C 81 A8 62        .byte $8c, $81, $a8, $62, $17, $87, $43, $24, $a7, $01
00A1F3  1  17 87 43 24  
00A1F7  1  A7 01        
00A1F9  1  C3 04 08 F2        .byte $c3, $04, $08, $f2, $97, $21, $a3, $02, $c9, $0b
00A1FD  1  97 21 A3 02  
00A201  1  C9 0B        
00A203  1  E1 69 F1 69        .byte $e1, $69, $f1, $69, $8d, $c1, $cf, $26
00A207  1  8D C1 CF 26  
00A20B  1  FD                 .byte $fd
00A20C  1               
00A20C  1               ;pipe intro area
00A20C  1               L_GroundArea10:
00A20C  1  38 11              .byte $38, $11
00A20E  1  0F 26 AD 40        .byte $0f, $26, $ad, $40, $3d, $c7
00A212  1  3D C7        
00A214  1  FD                 .byte $fd
00A215  1               
00A215  1               ;level 5-1
00A215  1               L_GroundArea11:
00A215  1  95 B1              .byte $95, $b1
00A217  1  0F 26 0D 02        .byte $0f, $26, $0d, $02, $c8, $72, $1c, $81, $38, $72
00A21B  1  C8 72 1C 81  
00A21F  1  38 72        
00A221  1  0D 05 97 34        .byte $0d, $05, $97, $34, $98, $62, $a3, $20, $b3, $06
00A225  1  98 62 A3 20  
00A229  1  B3 06        
00A22B  1  C3 20 CC 03        .byte $c3, $20, $cc, $03, $f9, $91, $2c, $81, $48, $62
00A22F  1  F9 91 2C 81  
00A233  1  48 62        
00A235  1  0D 09 37 63        .byte $0d, $09, $37, $63, $47, $03, $57, $21, $8c, $02
00A239  1  47 03 57 21  
00A23D  1  8C 02        
00A23F  1  C5 79 C7 31        .byte $c5, $79, $c7, $31, $f9, $11, $39, $f1, $a9, $11
00A243  1  F9 11 39 F1  
00A247  1  A9 11        
00A249  1  6F B4 D3 65        .byte $6f, $b4, $d3, $65, $e3, $65, $7d, $c1, $bf, $26
00A24D  1  E3 65 7D C1  
00A251  1  BF 26        
00A253  1  FD                 .byte $fd
00A254  1               
00A254  1               ;cloud level used in levels 2-1 and 5-2
00A254  1               L_GroundArea12:
00A254  1  00 C1              .byte $00, $c1
00A256  1  4C 00 F4 4F        .byte $4c, $00, $f4, $4f, $0d, $02, $02, $42, $43, $4f
00A25A  1  0D 02 02 42  
00A25E  1  43 4F        
00A260  1  52 C2 DE 00        .byte $52, $c2, $de, $00, $5a, $c2, $4d, $c7
00A264  1  5A C2 4D C7  
00A268  1  FD                 .byte $fd
00A269  1               
00A269  1               ;level 4-3
00A269  1               L_GroundArea13:
00A269  1  90 51              .byte $90, $51
00A26B  1  0F 26 EE 10        .byte $0f, $26, $ee, $10, $0b, $94, $33, $14, $42, $42
00A26F  1  0B 94 33 14  
00A273  1  42 42        
00A275  1  77 16 86 44        .byte $77, $16, $86, $44, $02, $92, $4a, $16, $69, $42
00A279  1  02 92 4A 16  
00A27D  1  69 42        
00A27F  1  73 14 B0 00        .byte $73, $14, $b0, $00, $c7, $12, $05, $c0, $1c, $17
00A283  1  C7 12 05 C0  
00A287  1  1C 17        
00A289  1  1F 11 36 12        .byte $1f, $11, $36, $12, $8f, $14, $91, $40, $1b, $94
00A28D  1  8F 14 91 40  
00A291  1  1B 94        
00A293  1  35 12 34 42        .byte $35, $12, $34, $42, $60, $42, $61, $12, $87, $12
00A297  1  60 42 61 12  
00A29B  1  87 12        
00A29D  1  96 40 A3 14        .byte $96, $40, $a3, $14, $1c, $98, $1f, $11, $47, $12
00A2A1  1  1C 98 1F 11  
00A2A5  1  47 12        
00A2A7  1  9F 15 CC 15        .byte $9f, $15, $cc, $15, $cf, $11, $05, $c0, $1f, $15
00A2AB  1  CF 11 05 C0  
00A2AF  1  1F 15        
00A2B1  1  39 12 7C 16        .byte $39, $12, $7c, $16, $7f, $11, $82, $40, $98, $12
00A2B5  1  7F 11 82 40  
00A2B9  1  98 12        
00A2BB  1  DF 15 16 C4        .byte $df, $15, $16, $c4, $17, $14, $54, $12, $9b, $16
00A2BF  1  17 14 54 12  
00A2C3  1  9B 16        
00A2C5  1  28 94 CE 01        .byte $28, $94, $ce, $01, $3d, $c1, $5e, $42, $8f, $20
00A2C9  1  3D C1 5E 42  
00A2CD  1  8F 20        
00A2CF  1  FD                 .byte $fd
00A2D0  1               
00A2D0  1               ;level 6-3
00A2D0  1               L_GroundArea14:
00A2D0  1  97 11              .byte $97, $11
00A2D2  1  0F 26 FE 10        .byte $0f, $26, $fe, $10, $2b, $92, $57, $12, $8b, $12
00A2D6  1  2B 92 57 12  
00A2DA  1  8B 12        
00A2DC  1  C0 41 F7 13        .byte $c0, $41, $f7, $13, $5b, $92, $69, $0b, $bb, $12
00A2E0  1  5B 92 69 0B  
00A2E4  1  BB 12        
00A2E6  1  B2 46 19 93        .byte $b2, $46, $19, $93, $71, $00, $17, $94, $7c, $14
00A2EA  1  71 00 17 94  
00A2EE  1  7C 14        
00A2F0  1  7F 11 93 41        .byte $7f, $11, $93, $41, $bf, $15, $fc, $13, $ff, $11
00A2F4  1  BF 15 FC 13  
00A2F8  1  FF 11        
00A2FA  1  2F 95 50 42        .byte $2f, $95, $50, $42, $51, $12, $58, $14, $a6, $12
00A2FE  1  51 12 58 14  
00A302  1  A6 12        
00A304  1  DB 12 1B 93        .byte $db, $12, $1b, $93, $46, $43, $7b, $12, $8d, $49
00A308  1  46 43 7B 12  
00A30C  1  8D 49        
00A30E  1  B7 14 1B 94        .byte $b7, $14, $1b, $94, $49, $0b, $bb, $12, $fc, $13
00A312  1  49 0B BB 12  
00A316  1  FC 13        
00A318  1  FF 12 03 C1        .byte $ff, $12, $03, $c1, $2f, $15, $43, $12, $4b, $13
00A31C  1  2F 15 43 12  
00A320  1  4B 13        
00A322  1  77 13 9D 4A        .byte $77, $13, $9d, $4a, $15, $c1, $a1, $41, $c3, $12
00A326  1  15 C1 A1 41  
00A32A  1  C3 12        
00A32C  1  FE 01 7D C1        .byte $fe, $01, $7d, $c1, $9e, $42, $cf, $20
00A330  1  9E 42 CF 20  
00A334  1  FD                 .byte $fd
00A335  1               
00A335  1               ;level 6-1
00A335  1               L_GroundArea15:
00A335  1  52 21              .byte $52, $21
00A337  1  0F 20 6E 44        .byte $0f, $20, $6e, $44, $0c, $f1, $4c, $01, $aa, $35
00A33B  1  0C F1 4C 01  
00A33F  1  AA 35        
00A341  1  D9 34 EE 20        .byte $d9, $34, $ee, $20, $08, $b3, $37, $32, $43, $04
00A345  1  08 B3 37 32  
00A349  1  43 04        
00A34B  1  4E 21 53 20        .byte $4e, $21, $53, $20, $7c, $01, $97, $21, $b7, $07
00A34F  1  7C 01 97 21  
00A353  1  B7 07        
00A355  1  9C 81 E7 42        .byte $9c, $81, $e7, $42, $5f, $b3, $97, $63, $ac, $02
00A359  1  5F B3 97 63  
00A35D  1  AC 02        
00A35F  1  C5 41 49 E0        .byte $c5, $41, $49, $e0, $58, $61, $76, $64, $85, $65
00A363  1  58 61 76 64  
00A367  1  85 65        
00A369  1  94 66 A4 22        .byte $94, $66, $a4, $22, $a6, $03, $c8, $22, $dc, $02
00A36D  1  A6 03 C8 22  
00A371  1  DC 02        
00A373  1  68 F2 96 42        .byte $68, $f2, $96, $42, $13, $82, $17, $02, $af, $34
00A377  1  13 82 17 02  
00A37B  1  AF 34        
00A37D  1  F6 21 FC 06        .byte $f6, $21, $fc, $06, $26, $80, $2a, $24, $36, $01
00A381  1  26 80 2A 24  
00A385  1  36 01        
00A387  1  8C 00 FF 35        .byte $8c, $00, $ff, $35, $4e, $a0, $55, $21, $77, $20
00A38B  1  4E A0 55 21  
00A38F  1  77 20        
00A391  1  87 07 89 22        .byte $87, $07, $89, $22, $ae, $21, $4c, $82, $9f, $34
00A395  1  AE 21 4C 82  
00A399  1  9F 34        
00A39B  1  EC 01 03 E7        .byte $ec, $01, $03, $e7, $13, $67, $8d, $4a, $ad, $41
00A39F  1  13 67 8D 4A  
00A3A3  1  AD 41        
00A3A5  1  0F A6              .byte $0f, $a6
00A3A7  1  FD                 .byte $fd
00A3A8  1               
00A3A8  1               ;warp zone area used in level 4-2
00A3A8  1               L_GroundArea16:
00A3A8  1  10 51              .byte $10, $51
00A3AA  1  4C 00 C7 12        .byte $4c, $00, $c7, $12, $c6, $42, $03, $92, $02, $42
00A3AE  1  C6 42 03 92  
00A3B2  1  02 42        
00A3B4  1  29 12 63 12        .byte $29, $12, $63, $12, $62, $42, $69, $14, $a5, $12
00A3B8  1  62 42 69 14  
00A3BC  1  A5 12        
00A3BE  1  A4 42 E2 14        .byte $a4, $42, $e2, $14, $e1, $44, $f8, $16, $37, $c1
00A3C2  1  E1 44 F8 16  
00A3C6  1  37 C1        
00A3C8  1  8F 38 02 BB        .byte $8f, $38, $02, $bb, $28, $7a, $68, $7a, $a8, $7a
00A3CC  1  28 7A 68 7A  
00A3D0  1  A8 7A        
00A3D2  1  E0 6A F0 6A        .byte $e0, $6a, $f0, $6a, $6d, $c5
00A3D6  1  6D C5        
00A3D8  1  FD                 .byte $fd
00A3D9  1               
00A3D9  1               ;level 8-1
00A3D9  1               L_GroundArea17:
00A3D9  1  92 31              .byte $92, $31
00A3DB  1  0F 20 6E 40        .byte $0f, $20, $6e, $40, $0d, $02, $37, $73, $ec, $00
00A3DF  1  0D 02 37 73  
00A3E3  1  EC 00        
00A3E5  1  0C 80 3C 00        .byte $0c, $80, $3c, $00, $6c, $00, $9c, $00, $06, $c0
00A3E9  1  6C 00 9C 00  
00A3ED  1  06 C0        
00A3EF  1  C7 73 06 83        .byte $c7, $73, $06, $83, $28, $72, $96, $40, $e7, $73
00A3F3  1  28 72 96 40  
00A3F7  1  E7 73        
00A3F9  1  26 C0 87 7B        .byte $26, $c0, $87, $7b, $d2, $41, $39, $f1, $c8, $f2
00A3FD  1  D2 41 39 F1  
00A401  1  C8 F2        
00A403  1  97 E3 A3 23        .byte $97, $e3, $a3, $23, $e7, $02, $e3, $07, $f3, $22
00A407  1  E7 02 E3 07  
00A40B  1  F3 22        
00A40D  1  37 E3 9C 00        .byte $37, $e3, $9c, $00, $bc, $00, $ec, $00, $0c, $80
00A411  1  BC 00 EC 00  
00A415  1  0C 80        
00A417  1  3C 00 86 21        .byte $3c, $00, $86, $21, $a6, $06, $b6, $24, $5c, $80
00A41B  1  A6 06 B6 24  
00A41F  1  5C 80        
00A421  1  7C 00 9C 00        .byte $7c, $00, $9c, $00, $29, $e1, $dc, $05, $f6, $41
00A425  1  29 E1 DC 05  
00A429  1  F6 41        
00A42B  1  DC 80 E8 72        .byte $dc, $80, $e8, $72, $0c, $81, $27, $73, $4c, $01
00A42F  1  0C 81 27 73  
00A433  1  4C 01        
00A435  1  66 74 0D 11        .byte $66, $74, $0d, $11, $3f, $35, $b6, $41, $2c, $82
00A439  1  3F 35 B6 41  
00A43D  1  2C 82        
00A43F  1  36 40 7C 02        .byte $36, $40, $7c, $02, $86, $40, $f9, $61, $39, $e1
00A443  1  86 40 F9 61  
00A447  1  39 E1        
00A449  1  AC 04 C6 41        .byte $ac, $04, $c6, $41, $0c, $83, $16, $41, $88, $f2
00A44D  1  0C 83 16 41  
00A451  1  88 F2        
00A453  1  39 F1 7C 00        .byte $39, $f1, $7c, $00, $89, $61, $9c, $00, $a7, $63
00A457  1  89 61 9C 00  
00A45B  1  A7 63        
00A45D  1  BC 00 C5 65        .byte $bc, $00, $c5, $65, $dc, $00, $e3, $67, $f3, $67
00A461  1  DC 00 E3 67  
00A465  1  F3 67        
00A467  1  8D C1 CF 26        .byte $8d, $c1, $cf, $26
00A46B  1  FD                 .byte $fd
00A46C  1               
00A46C  1               ;level 5-2
00A46C  1               L_GroundArea18:
00A46C  1  55 B1              .byte $55, $b1
00A46E  1  0F 26 CF 33        .byte $0f, $26, $cf, $33, $07, $b2, $15, $11, $52, $42
00A472  1  07 B2 15 11  
00A476  1  52 42        
00A478  1  99 0B AC 02        .byte $99, $0b, $ac, $02, $d3, $24, $d6, $42, $d7, $25
00A47C  1  D3 24 D6 42  
00A480  1  D7 25        
00A482  1  23 84 CF 33        .byte $23, $84, $cf, $33, $07, $e3, $19, $61, $78, $7a
00A486  1  07 E3 19 61  
00A48A  1  78 7A        
00A48C  1  EF 33 2C 81        .byte $ef, $33, $2c, $81, $46, $64, $55, $65, $65, $65
00A490  1  46 64 55 65  
00A494  1  65 65        
00A496  1  EC 74 47 82        .byte $ec, $74, $47, $82, $53, $05, $63, $21, $62, $41
00A49A  1  53 05 63 21  
00A49E  1  62 41        
00A4A0  1  96 22 9A 41        .byte $96, $22, $9a, $41, $cc, $03, $b9, $91, $39, $f1
00A4A4  1  CC 03 B9 91  
00A4A8  1  39 F1        
00A4AA  1  63 26 67 27        .byte $63, $26, $67, $27, $d3, $06, $fc, $01, $18, $e2
00A4AE  1  D3 06 FC 01  
00A4B2  1  18 E2        
00A4B4  1  D9 07 E9 04        .byte $d9, $07, $e9, $04, $0c, $86, $37, $22, $93, $24
00A4B8  1  0C 86 37 22  
00A4BC  1  93 24        
00A4BE  1  87 84 AC 02        .byte $87, $84, $ac, $02, $c2, $41, $c3, $23, $d9, $71
00A4C2  1  C2 41 C3 23  
00A4C6  1  D9 71        
00A4C8  1  FC 01 7F B1        .byte $fc, $01, $7f, $b1, $9c, $00, $a7, $63, $b6, $64
00A4CC  1  9C 00 A7 63  
00A4D0  1  B6 64        
00A4D2  1  CC 00 D4 66        .byte $cc, $00, $d4, $66, $e3, $67, $f3, $67, $8d, $c1
00A4D6  1  E3 67 F3 67  
00A4DA  1  8D C1        
00A4DC  1  CF 26              .byte $cf, $26
00A4DE  1  FD                 .byte $fd
00A4DF  1               
00A4DF  1               ;level 8-2
00A4DF  1               L_GroundArea19:
00A4DF  1  50 B1              .byte $50, $b1
00A4E1  1  0F 26 FC 00        .byte $0f, $26, $fc, $00, $1f, $b3, $5c, $00, $65, $65
00A4E5  1  1F B3 5C 00  
00A4E9  1  65 65        
00A4EB  1  74 66 83 67        .byte $74, $66, $83, $67, $93, $67, $dc, $73, $4c, $80
00A4EF  1  93 67 DC 73  
00A4F3  1  4C 80        
00A4F5  1  B3 20 C9 0B        .byte $b3, $20, $c9, $0b, $c3, $08, $d3, $2f, $dc, $00
00A4F9  1  C3 08 D3 2F  
00A4FD  1  DC 00        
00A4FF  1  2C 80 4C 00        .byte $2c, $80, $4c, $00, $8c, $00, $d3, $2e, $ed, $4a
00A503  1  8C 00 D3 2E  
00A507  1  ED 4A        
00A509  1  FC 00 D7 A1        .byte $fc, $00, $d7, $a1, $ec, $01, $4c, $80, $59, $11
00A50D  1  EC 01 4C 80  
00A511  1  59 11        
00A513  1  D8 11 DA 10        .byte $d8, $11, $da, $10, $37, $a0, $47, $04, $99, $11
00A517  1  37 A0 47 04  
00A51B  1  99 11        
00A51D  1  E7 21 3A 90        .byte $e7, $21, $3a, $90, $67, $20, $76, $10, $77, $60
00A521  1  67 20 76 10  
00A525  1  77 60        
00A527  1  87 07 D8 12        .byte $87, $07, $d8, $12, $39, $f1, $ac, $00, $e9, $71
00A52B  1  39 F1 AC 00  
00A52F  1  E9 71        
00A531  1  0C 80 2C 00        .byte $0c, $80, $2c, $00, $4c, $05, $c7, $7b, $39, $f1
00A535  1  4C 05 C7 7B  
00A539  1  39 F1        
00A53B  1  EC 00 F9 11        .byte $ec, $00, $f9, $11, $0c, $82, $6f, $34, $f8, $11
00A53F  1  0C 82 6F 34  
00A543  1  F8 11        
00A545  1  FA 10 7F B2        .byte $fa, $10, $7f, $b2, $ac, $00, $b6, $64, $cc, $01
00A549  1  AC 00 B6 64  
00A54D  1  CC 01        
00A54F  1  E3 67 F3 67        .byte $e3, $67, $f3, $67, $8d, $c1, $cf, $26
00A553  1  8D C1 CF 26  
00A557  1  FD                 .byte $fd
00A558  1               
00A558  1               ;level 7-1
00A558  1               L_GroundArea20:
00A558  1  52 B1              .byte $52, $b1
00A55A  1  0F 20 6E 45        .byte $0f, $20, $6e, $45, $39, $91, $b3, $04, $c3, $21
00A55E  1  39 91 B3 04  
00A562  1  C3 21        
00A564  1  C8 11 CA 10        .byte $c8, $11, $ca, $10, $49, $91, $7c, $73, $e8, $12
00A568  1  49 91 7C 73  
00A56C  1  E8 12        
00A56E  1  88 91 8A 10        .byte $88, $91, $8a, $10, $e7, $21, $05, $91, $07, $30
00A572  1  E7 21 05 91  
00A576  1  07 30        
00A578  1  17 07 27 20        .byte $17, $07, $27, $20, $49, $11, $9c, $01, $c8, $72
00A57C  1  49 11 9C 01  
00A580  1  C8 72        
00A582  1  23 A6 27 26        .byte $23, $a6, $27, $26, $d3, $03, $d8, $7a, $89, $91
00A586  1  D3 03 D8 7A  
00A58A  1  89 91        
00A58C  1  D8 72 39 F1        .byte $d8, $72, $39, $f1, $a9, $11, $09, $f1, $63, $24
00A590  1  A9 11 09 F1  
00A594  1  63 24        
00A596  1  67 24 D8 62        .byte $67, $24, $d8, $62, $28, $91, $2a, $10, $56, $21
00A59A  1  28 91 2A 10  
00A59E  1  56 21        
00A5A0  1  70 04 79 0B        .byte $70, $04, $79, $0b, $8c, $00, $94, $21, $9f, $35
00A5A4  1  8C 00 94 21  
00A5A8  1  9F 35        
00A5AA  1  2F B8 3D C1        .byte $2f, $b8, $3d, $c1, $7f, $26
00A5AE  1  7F 26        
00A5B0  1  FD                 .byte $fd
00A5B1  1               
00A5B1  1               ;cloud level used in levels 3-1 and 6-2
00A5B1  1               L_GroundArea21:
00A5B1  1  06 C1              .byte $06, $c1
00A5B3  1  4C 00 F4 4F        .byte $4c, $00, $f4, $4f, $0d, $02, $06, $20, $24, $4f
00A5B7  1  0D 02 06 20  
00A5BB  1  24 4F        
00A5BD  1  35 A0 36 20        .byte $35, $a0, $36, $20, $53, $46, $d5, $20, $d6, $20
00A5C1  1  53 46 D5 20  
00A5C5  1  D6 20        
00A5C7  1  34 A1 73 49        .byte $34, $a1, $73, $49, $74, $20, $94, $20, $b4, $20
00A5CB  1  74 20 94 20  
00A5CF  1  B4 20        
00A5D1  1  D4 20 F4 20        .byte $d4, $20, $f4, $20, $2e, $80, $59, $42, $4d, $c7
00A5D5  1  2E 80 59 42  
00A5D9  1  4D C7        
00A5DB  1  FD                 .byte $fd
00A5DC  1               
00A5DC  1               ;level 3-2
00A5DC  1               L_GroundArea22:
00A5DC  1  96 31              .byte $96, $31
00A5DE  1  0F 26 0D 03        .byte $0f, $26, $0d, $03, $1a, $60, $77, $42, $c4, $00
00A5E2  1  1A 60 77 42  
00A5E6  1  C4 00        
00A5E8  1  C8 62 B9 E1        .byte $c8, $62, $b9, $e1, $d3, $06, $d7, $07, $f9, $61
00A5EC  1  D3 06 D7 07  
00A5F0  1  F9 61        
00A5F2  1  0C 81 4E B1        .byte $0c, $81, $4e, $b1, $8e, $b1, $bc, $01, $e4, $50
00A5F6  1  8E B1 BC 01  
00A5FA  1  E4 50        
00A5FC  1  E9 61 0C 81        .byte $e9, $61, $0c, $81, $0d, $0a, $84, $43, $98, $72
00A600  1  0D 0A 84 43  
00A604  1  98 72        
00A606  1  0D 0C 0F 38        .byte $0d, $0c, $0f, $38, $1d, $c1, $5f, $26
00A60A  1  1D C1 5F 26  
00A60E  1  FD                 .byte $fd
00A60F  1               
00A60F  1               ;level 1-2
00A60F  1               L_UndergroundArea1:
00A60F  1  48 0F              .byte $48, $0f
00A611  1  0E 01 5E 02        .byte $0e, $01, $5e, $02, $a7, $00, $bc, $73, $1a, $e0
00A615  1  A7 00 BC 73  
00A619  1  1A E0        
00A61B  1  39 61 58 62        .byte $39, $61, $58, $62, $77, $63, $97, $63, $b8, $62
00A61F  1  77 63 97 63  
00A623  1  B8 62        
00A625  1  D6 07 F8 62        .byte $d6, $07, $f8, $62, $19, $e1, $75, $52, $86, $40
00A629  1  19 E1 75 52  
00A62D  1  86 40        
00A62F  1  87 50 95 52        .byte $87, $50, $95, $52, $93, $43, $a5, $21, $c5, $52
00A633  1  93 43 A5 21  
00A637  1  C5 52        
00A639  1  D6 40 D7 20        .byte $d6, $40, $d7, $20, $e5, $06, $e6, $51, $3e, $8d
00A63D  1  E5 06 E6 51  
00A641  1  3E 8D        
00A643  1  5E 03 67 52        .byte $5e, $03, $67, $52, $77, $52, $7e, $02, $9e, $03
00A647  1  77 52 7E 02  
00A64B  1  9E 03        
00A64D  1  A6 43 A7 23        .byte $a6, $43, $a7, $23, $de, $05, $fe, $02, $1e, $83
00A651  1  DE 05 FE 02  
00A655  1  1E 83        
00A657  1  33 54 46 40        .byte $33, $54, $46, $40, $47, $21, $56, $04, $5e, $02
00A65B  1  47 21 56 04  
00A65F  1  5E 02        
00A661  1  83 54 93 52        .byte $83, $54, $93, $52, $96, $07, $97, $50, $be, $03
00A665  1  96 07 97 50  
00A669  1  BE 03        
00A66B  1  C7 23 FE 02        .byte $c7, $23, $fe, $02, $0c, $82, $43, $45, $45, $24
00A66F  1  0C 82 43 45  
00A673  1  45 24        
00A675  1  46 24 90 08        .byte $46, $24, $90, $08, $95, $51, $78, $fa, $d7, $73
00A679  1  95 51 78 FA  
00A67D  1  D7 73        
00A67F  1  39 F1 8C 01        .byte $39, $f1, $8c, $01, $a8, $52, $b8, $52, $cc, $01
00A683  1  A8 52 B8 52  
00A687  1  CC 01        
00A689  1  5F B3 97 63        .byte $5f, $b3, $97, $63, $9e, $00, $0e, $81, $16, $24
00A68D  1  9E 00 0E 81  
00A691  1  16 24        
00A693  1  66 04 8E 00        .byte $66, $04, $8e, $00, $fe, $01, $08, $d2, $0e, $06
00A697  1  FE 01 08 D2  
00A69B  1  0E 06        
00A69D  1  6F 47 9E 0F        .byte $6f, $47, $9e, $0f, $0e, $82, $2d, $47, $28, $7a
00A6A1  1  0E 82 2D 47  
00A6A5  1  28 7A        
00A6A7  1  68 7A A8 7A        .byte $68, $7a, $a8, $7a, $ae, $01, $de, $0f, $6d, $c5
00A6AB  1  AE 01 DE 0F  
00A6AF  1  6D C5        
00A6B1  1  FD                 .byte $fd
00A6B2  1               
00A6B2  1               ;level 4-2
00A6B2  1               L_UndergroundArea2:
00A6B2  1  48 0F              .byte $48, $0f
00A6B4  1  0E 01 5E 02        .byte $0e, $01, $5e, $02, $bc, $01, $fc, $01, $2c, $82
00A6B8  1  BC 01 FC 01  
00A6BC  1  2C 82        
00A6BE  1  41 52 4E 04        .byte $41, $52, $4e, $04, $67, $25, $68, $24, $69, $24
00A6C2  1  67 25 68 24  
00A6C6  1  69 24        
00A6C8  1  BA 42 C7 04        .byte $ba, $42, $c7, $04, $de, $0b, $b2, $87, $fe, $02
00A6CC  1  DE 0B B2 87  
00A6D0  1  FE 02        
00A6D2  1  2C E1 2C 71        .byte $2c, $e1, $2c, $71, $67, $01, $77, $00, $87, $01
00A6D6  1  67 01 77 00  
00A6DA  1  87 01        
00A6DC  1  8E 00 EE 01        .byte $8e, $00, $ee, $01, $f6, $02, $03, $85, $05, $02
00A6E0  1  F6 02 03 85  
00A6E4  1  05 02        
00A6E6  1  13 21 16 02        .byte $13, $21, $16, $02, $27, $02, $2e, $02, $88, $72
00A6EA  1  27 02 2E 02  
00A6EE  1  88 72        
00A6F0  1  C7 20 D7 07        .byte $c7, $20, $d7, $07, $e4, $76, $07, $a0, $17, $06
00A6F4  1  E4 76 07 A0  
00A6F8  1  17 06        
00A6FA  1  48 7A 76 20        .byte $48, $7a, $76, $20, $98, $72, $79, $e1, $88, $62
00A6FE  1  98 72 79 E1  
00A702  1  88 62        
00A704  1  9C 01 B7 73        .byte $9c, $01, $b7, $73, $dc, $01, $f8, $62, $fe, $01
00A708  1  DC 01 F8 62  
00A70C  1  FE 01        
00A70E  1  08 E2 0E 00        .byte $08, $e2, $0e, $00, $6e, $02, $73, $20, $77, $23
00A712  1  6E 02 73 20  
00A716  1  77 23        
00A718  1  83 04 93 20        .byte $83, $04, $93, $20, $ae, $00, $fe, $0a, $0e, $82
00A71C  1  AE 00 FE 0A  
00A720  1  0E 82        
00A722  1  39 71 A8 72        .byte $39, $71, $a8, $72, $e7, $73, $0c, $81, $8f, $32
00A726  1  E7 73 0C 81  
00A72A  1  8F 32        
00A72C  1  AE 00 FE 04        .byte $ae, $00, $fe, $04, $04, $d1, $17, $04, $26, $49
00A730  1  04 D1 17 04  
00A734  1  26 49        
00A736  1  27 29 DF 33        .byte $27, $29, $df, $33, $fe, $02, $44, $f6, $7c, $01
00A73A  1  FE 02 44 F6  
00A73E  1  7C 01        
00A740  1  8E 06 BF 47        .byte $8e, $06, $bf, $47, $ee, $0f, $4d, $c7, $0e, $82
00A744  1  EE 0F 4D C7  
00A748  1  0E 82        
00A74A  1  68 7A AE 01        .byte $68, $7a, $ae, $01, $de, $0f, $6d, $c5
00A74E  1  DE 0F 6D C5  
00A752  1  FD                 .byte $fd
00A753  1               
00A753  1               ;underground bonus rooms area used in many levels
00A753  1               L_UndergroundArea3:
00A753  1  48 01              .byte $48, $01
00A755  1  0E 01 00 5A        .byte $0e, $01, $00, $5a, $3e, $06, $45, $46, $47, $46
00A759  1  3E 06 45 46  
00A75D  1  47 46        
00A75F  1  53 44 AE 01        .byte $53, $44, $ae, $01, $df, $4a, $4d, $c7, $0e, $81
00A763  1  DF 4A 4D C7  
00A767  1  0E 81        
00A769  1  00 5A 2E 04        .byte $00, $5a, $2e, $04, $37, $28, $3a, $48, $46, $47
00A76D  1  37 28 3A 48  
00A771  1  46 47        
00A773  1  C7 07 CE 0F        .byte $c7, $07, $ce, $0f, $df, $4a, $4d, $c7, $0e, $81
00A777  1  DF 4A 4D C7  
00A77B  1  0E 81        
00A77D  1  00 5A 33 53        .byte $00, $5a, $33, $53, $43, $51, $46, $40, $47, $50
00A781  1  43 51 46 40  
00A785  1  47 50        
00A787  1  53 04 55 40        .byte $53, $04, $55, $40, $56, $50, $62, $43, $64, $40
00A78B  1  56 50 62 43  
00A78F  1  64 40        
00A791  1  65 50 71 41        .byte $65, $50, $71, $41, $73, $51, $83, $51, $94, $40
00A795  1  73 51 83 51  
00A799  1  94 40        
00A79B  1  95 50 A3 50        .byte $95, $50, $a3, $50, $a5, $40, $a6, $50, $b3, $51
00A79F  1  A5 40 A6 50  
00A7A3  1  B3 51        
00A7A5  1  B6 40 B7 50        .byte $b6, $40, $b7, $50, $c3, $53, $df, $4a, $4d, $c7
00A7A9  1  C3 53 DF 4A  
00A7AD  1  4D C7        
00A7AF  1  0E 81 00 5A        .byte $0e, $81, $00, $5a, $2e, $02, $36, $47, $37, $52
00A7B3  1  2E 02 36 47  
00A7B7  1  37 52        
00A7B9  1  3A 49 47 25        .byte $3a, $49, $47, $25, $a7, $52, $d7, $04, $df, $4a
00A7BD  1  A7 52 D7 04  
00A7C1  1  DF 4A        
00A7C3  1  4D C7 0E 81        .byte $4d, $c7, $0e, $81, $00, $5a, $3e, $02, $44, $51
00A7C7  1  00 5A 3E 02  
00A7CB  1  44 51        
00A7CD  1  53 44 54 44        .byte $53, $44, $54, $44, $55, $24, $a1, $54, $ae, $01
00A7D1  1  55 24 A1 54  
00A7D5  1  AE 01        
00A7D7  1  B4 21 DF 4A        .byte $b4, $21, $df, $4a, $e5, $07, $4d, $c7
00A7DB  1  E5 07 4D C7  
00A7DF  1  FD                 .byte $fd
00A7E0  1               
00A7E0  1               ;water area used in levels 5-2 and 6-2
00A7E0  1               L_WaterArea1:
00A7E0  1  41 01              .byte $41, $01
00A7E2  1  B4 34 C8 52        .byte $b4, $34, $c8, $52, $f2, $51, $47, $d3, $6c, $03
00A7E6  1  F2 51 47 D3  
00A7EA  1  6C 03        
00A7EC  1  65 49 9E 07        .byte $65, $49, $9e, $07, $be, $01, $cc, $03, $fe, $07
00A7F0  1  BE 01 CC 03  
00A7F4  1  FE 07        
00A7F6  1  0D C9 1E 01        .byte $0d, $c9, $1e, $01, $6c, $01, $62, $35, $63, $53
00A7FA  1  6C 01 62 35  
00A7FE  1  63 53        
00A800  1  8A 41 AC 01        .byte $8a, $41, $ac, $01, $b3, $53, $e9, $51, $26, $c3
00A804  1  B3 53 E9 51  
00A808  1  26 C3        
00A80A  1  27 33 63 43        .byte $27, $33, $63, $43, $64, $33, $ba, $60, $c9, $61
00A80E  1  64 33 BA 60  
00A812  1  C9 61        
00A814  1  CE 0B E5 09        .byte $ce, $0b, $e5, $09, $ee, $0f, $7d, $ca, $7d, $47
00A818  1  EE 0F 7D CA  
00A81C  1  7D 47        
00A81E  1  FD                 .byte $fd
00A81F  1               
00A81F  1               ;level 2-2/7-2
00A81F  1               L_WaterArea2:
00A81F  1  41 01              .byte $41, $01
00A821  1  B8 52 EA 41        .byte $b8, $52, $ea, $41, $27, $b2, $b3, $42, $16, $d4
00A825  1  27 B2 B3 42  
00A829  1  16 D4        
00A82B  1  4A 42 A5 51        .byte $4a, $42, $a5, $51, $a7, $31, $27, $d3, $08, $e2
00A82F  1  A7 31 27 D3  
00A833  1  08 E2        
00A835  1  16 64 2C 04        .byte $16, $64, $2c, $04, $38, $42, $76, $64, $88, $62
00A839  1  38 42 76 64  
00A83D  1  88 62        
00A83F  1  DE 07 FE 01        .byte $de, $07, $fe, $01, $0d, $c9, $23, $32, $31, $51
00A843  1  0D C9 23 32  
00A847  1  31 51        
00A849  1  98 52 0D C9        .byte $98, $52, $0d, $c9, $59, $42, $63, $53, $67, $31
00A84D  1  59 42 63 53  
00A851  1  67 31        
00A853  1  14 C2 36 31        .byte $14, $c2, $36, $31, $87, $53, $17, $e3, $29, $61
00A857  1  87 53 17 E3  
00A85B  1  29 61        
00A85D  1  30 62 3C 08        .byte $30, $62, $3c, $08, $42, $37, $59, $40, $6a, $42
00A861  1  42 37 59 40  
00A865  1  6A 42        
00A867  1  99 40 C9 61        .byte $99, $40, $c9, $61, $d7, $63, $39, $d1, $58, $52
00A86B  1  D7 63 39 D1  
00A86F  1  58 52        
00A871  1  C3 67 D3 31        .byte $c3, $67, $d3, $31, $dc, $06, $f7, $42, $fa, $42
00A875  1  DC 06 F7 42  
00A879  1  FA 42        
00A87B  1  23 B1 43 67        .byte $23, $b1, $43, $67, $c3, $34, $c7, $34, $d1, $51
00A87F  1  C3 34 C7 34  
00A883  1  D1 51        
00A885  1  43 B3 47 33        .byte $43, $b3, $47, $33, $9a, $30, $a9, $61, $b8, $62
00A889  1  9A 30 A9 61  
00A88D  1  B8 62        
00A88F  1  BE 0B D5 09        .byte $be, $0b, $d5, $09, $de, $0f, $0d, $ca, $7d, $47
00A893  1  DE 0F 0D CA  
00A897  1  7D 47        
00A899  1  FD                 .byte $fd
00A89A  1               
00A89A  1               ;water area used in level 8-4
00A89A  1               L_WaterArea3:
00A89A  1  49 0F              .byte $49, $0f
00A89C  1  1E 01 39 73        .byte $1e, $01, $39, $73, $5e, $07, $ae, $0b, $1e, $82
00A8A0  1  5E 07 AE 0B  
00A8A4  1  1E 82        
00A8A6  1  6E 88 9E 02        .byte $6e, $88, $9e, $02, $0d, $04, $2e, $0b, $45, $09
00A8AA  1  0D 04 2E 0B  
00A8AE  1  45 09        
00A8B0  1  4E 0F ED 47        .byte $4e, $0f, $ed, $47
00A8B4  1  FD                 .byte $fd
00A8B5  1               
00A8B5  1               ;-------------------------------------------------------------------------------------
00A8B5  1               
00A8B5  1               ;unused space
00A8B5  1  FF                 .byte $ff
00A8B6  1               
00A8B6  1               ;-------------------------------------------------------------------------------------
00A8B6  1               
00A8B6  1               ;indirect jump routine called when
00A8B6  1               ;$0770 is set to 1
00A8B6  1               GameMode:
00A8B6  1  AD 72 07           lda OperMode_Task
00A8B9  1  20 97 BA           jsr JumpEngine
00A8BC  1               
00A8BC  1  06 B9              .word InitializeArea
00A8BE  1  D0 84              .word ScreenRoutines
00A8C0  1  DB 8B              .word SecondaryGameSetup
00A8C2  1  C4 A8              .word GameCoreRoutine
00A8C4  1               
00A8C4  1               ;-------------------------------------------------------------------------------------
00A8C4  1               
00A8C4  1               GameCoreRoutine:
00A8C4  1  20 09 AA           jsr GameRoutines           ;execute one of many possible subs
00A8C7  1  AD 72 07           lda OperMode_Task          ;check major task of operating mode
00A8CA  1  C9 03              cmp #$03                   ;if we are supposed to be here,
00A8CC  1  B0 01              bcs GameEngine             ;branch to the game engine itself
00A8CE  1  60                 rts
00A8CF  1               
00A8CF  1               GameEngine:
00A8CF  1  20 EB AF                   jsr ProcFireball_Bubble    ;process fireballs and air bubbles
00A8D2  1  A2 00                      ldx #$00
00A8D4  1  86 08        ProcELoop:    stx ObjectOffset           ;put incremented offset in X as enemy object offset
00A8D6  1  20 07 B5                   jsr EnemiesAndLoopsCore    ;process enemy objects
00A8D9  1  20 2F 84                   jsr FloateyNumbersRoutine  ;process floatey numbers
00A8DC  1  E8                         inx
00A8DD  1  E0 06                      cpx #$06                   ;do these two subroutines until the whole buffer is done
00A8DF  1  D0 F3                      bne ProcELoop
00A8E1  1  20 F0 EC                   jsr GetPlayerOffscreenBits ;get offscreen bits for player object
00A8E4  1  20 9A EC                   jsr RelativePlayerPosition ;get relative coordinates for player object
00A8E7  1  20 79 EA                   jsr PlayerGfxHandler       ;draw the player
00A8EA  1  20 8B BF                   jsr BlockObjMT_Updater     ;replace block objects with metatiles if necessary
00A8ED  1  A2 01                      ldx #$01
00A8EF  1  86 08                      stx ObjectOffset           ;set offset for second
00A8F1  1  20 27 BF                   jsr BlockObjectsCore       ;process second block object
00A8F4  1  CA                         dex
00A8F5  1  86 08                      stx ObjectOffset           ;set offset for first
00A8F7  1  20 27 BF                   jsr BlockObjectsCore       ;process first block object
00A8FA  1  20 A1 B3                   jsr MiscObjectsCore        ;process misc objects (hammer, jumping coins)
00A8FD  1  20 5F B2                   jsr ProcessCannons         ;process bullet bill cannons
00A900  1  20 5F B1                   jsr ProcessWhirlpools      ;process whirlpools
00A903  1  20 FC B1                   jsr FlagpoleRoutine        ;process the flagpole
00A906  1  20 16 B1                   jsr RunGameTimer           ;count down the game timer
00A909  1  20 6C 88                   jsr ColorRotation          ;cycle one of the background colors
00A90C  1  A5 B5                      lda Player_Y_HighPos
00A90E  1  C9 02                      cmp #$02                   ;if player is below the screen, don't bother with the music
00A910  1  10 11                      bpl NoChgMus
00A912  1  AD 9F 07                   lda StarInvincibleTimer    ;if star mario invincibility timer at zero,
00A915  1  F0 1E                      beq ClrPlrPal              ;skip this part
00A917  1  C9 04                      cmp #$04
00A919  1  D0 08                      bne NoChgMus               ;if not yet at a certain point, continue
00A91B  1  AD 7F 07                   lda IntervalTimerControl   ;if interval timer not yet expired,
00A91E  1  D0 03                      bne NoChgMus               ;branch ahead, don't bother with the music
00A920  1  20 3F 8C                   jsr GetAreaMusic           ;to re-attain appropriate level music
00A923  1  AC 9F 07     NoChgMus:     ldy StarInvincibleTimer    ;get invincibility timer
00A926  1  A5 09                      lda FrameCounter           ;get frame counter
00A928  1  C0 08                      cpy #$08                   ;if timer still above certain point,
00A92A  1  B0 02                      bcs CycleTwo               ;branch to cycle player's palette quickly
00A92C  1  4A                         lsr                        ;otherwise, divide by 8 to cycle every eighth frame
00A92D  1  4A                         lsr
00A92E  1  4A           CycleTwo:     lsr                        ;if branched here, divide by 2 to cycle every other frame
00A92F  1  20 47 AC                   jsr CyclePlayerPalette     ;do sub to cycle the palette (note: shares fire flower code)
00A932  1  4C 38 A9                   jmp SaveAB                 ;then skip this sub to finish up the game engine
00A935  1  20 59 AC     ClrPlrPal:    jsr ResetPalStar           ;do sub to clear player's palette bits in attributes
00A938  1  A5 0A        SaveAB:       lda A_B_Buttons            ;save current A and B button
00A93A  1  85 0D                      sta PreviousA_B_Buttons    ;into temp variable to be used on next frame
00A93C  1  A9 00                      lda #$00
00A93E  1  85 0C                      sta Left_Right_Buttons     ;nullify left and right buttons temp variable
00A940  1  AD 73 07     UpdScrollVar: lda VRAM_Buffer_AddrCtrl
00A943  1  C9 06                      cmp #$06                   ;if vram address controller set to 6 (one of two $0341s)
00A945  1  F0 1C                      beq ExitEng                ;then branch to leave
00A947  1  AD 1F 07                   lda AreaParserTaskNum      ;otherwise check number of tasks
00A94A  1  D0 14                      bne RunParser
00A94C  1  AD 3D 07                   lda ScrollThirtyTwo        ;get horizontal scroll in 0-31 or $00-$20 range
00A94F  1  C9 20                      cmp #$20                   ;check to see if exceeded $21
00A951  1  30 10                      bmi ExitEng                ;branch to leave if not
00A953  1  AD 3D 07                   lda ScrollThirtyTwo
00A956  1  E9 20                      sbc #$20                   ;otherwise subtract $20 to set appropriately
00A958  1  8D 3D 07                   sta ScrollThirtyTwo        ;and store
00A95B  1  A9 00                      lda #$00                   ;reset vram buffer offset used in conjunction with
00A95D  1  8D 40 03                   sta VRAM_Buffer2_Offset    ;level graphics buffer at $0341-$035f
00A960  1  20 96 8D     RunParser:    jsr AreaParserTaskHandler  ;update the name table with more level graphics
00A963  1  60           ExitEng:      rts                        ;and after all that, we're finally done!
00A964  1               
00A964  1               ;-------------------------------------------------------------------------------------
00A964  1               
00A964  1               ScrollHandler:
00A964  1  AD FF 06                 lda Player_X_Scroll       ;load value saved here
00A967  1  18                       clc
00A968  1  6D A1 03                 adc Platform_X_Scroll     ;add value used by left/right platforms
00A96B  1  8D FF 06                 sta Player_X_Scroll       ;save as new value here to impose force on scroll
00A96E  1  AD 23 07                 lda ScrollLock            ;check scroll lock flag
00A971  1  D0 59                    bne InitScrlAmt           ;skip a bunch of code here if set
00A973  1  AD 55 07                 lda Player_Pos_ForScroll
00A976  1  C9 50                    cmp #$50                  ;check player's horizontal screen position
00A978  1  90 52                    bcc InitScrlAmt           ;if less than 80 pixels to the right, branch
00A97A  1  AD 85 07                 lda SideCollisionTimer    ;if timer related to player's side collision
00A97D  1  D0 4D                    bne InitScrlAmt           ;not expired, branch
00A97F  1  AC FF 06                 ldy Player_X_Scroll       ;get value and decrement by one
00A982  1  88                       dey                       ;if value originally set to zero or otherwise
00A983  1  30 47                    bmi InitScrlAmt           ;negative for left movement, branch
00A985  1  C8                       iny
00A986  1  C0 02                    cpy #$02                  ;if value $01, branch and do not decrement
00A988  1  90 01                    bcc ChkNearMid
00A98A  1  88                       dey                       ;otherwise decrement by one
00A98B  1  AD 55 07     ChkNearMid: lda Player_Pos_ForScroll
00A98E  1  C9 70                    cmp #$70                  ;check player's horizontal screen position
00A990  1  90 03                    bcc ScrollScreen          ;if less than 112 pixels to the right, branch
00A992  1  AC FF 06                 ldy Player_X_Scroll       ;otherwise get original value undecremented
00A995  1               
00A995  1               ScrollScreen:
00A995  1  98                         tya
00A996  1  8D 75 07                   sta ScrollAmount          ;save value here
00A999  1  18                         clc
00A99A  1  6D 3D 07                   adc ScrollThirtyTwo       ;add to value already set here
00A99D  1  8D 3D 07                   sta ScrollThirtyTwo       ;save as new value here
00A9A0  1  98                         tya
00A9A1  1  18                         clc
00A9A2  1  6D 1C 07                   adc ScreenLeft_X_Pos      ;add to left side coordinate
00A9A5  1  8D 1C 07                   sta ScreenLeft_X_Pos      ;save as new left side coordinate
00A9A8  1  8D 3F 07                   sta HorizontalScroll      ;save here also
00A9AB  1  AD 1A 07                   lda ScreenLeft_PageLoc
00A9AE  1  69 00                      adc #$00                  ;add carry to page location for left
00A9B0  1  8D 1A 07                   sta ScreenLeft_PageLoc    ;side of the screen
00A9B3  1  29 01                      and #$01                  ;get LSB of page location
00A9B5  1  85 00                      sta $00                   ;save as temp variable for PPU register 1 mirror
00A9B7  1  AD 78 07                   lda Mirror_PPU_CTRL_REG1  ;get PPU register 1 mirror
00A9BA  1  29 FE                      and #%11111110            ;save all bits except d0
00A9BC  1  05 00                      ora $00                   ;get saved bit here and save in PPU register 1
00A9BE  1  8D 78 07                   sta Mirror_PPU_CTRL_REG1  ;mirror to be used to set name table later
00A9C1  1  20 A0 BC                   jsr GetScreenPosition     ;figure out where the right side is
00A9C4  1  A9 08                      lda #$08
00A9C6  1  8D 95 07                   sta ScrollIntervalTimer   ;set scroll timer (residual, not used elsewhere)
00A9C9  1  4C D1 A9                   jmp ChkPOffscr            ;skip this part
00A9CC  1  A9 00        InitScrlAmt:  lda #$00
00A9CE  1  8D 75 07                   sta ScrollAmount          ;initialize value here
00A9D1  1  A2 00        ChkPOffscr:   ldx #$00                  ;set X for player offset
00A9D3  1  20 66 ED                   jsr GetXOffscreenBits     ;get horizontal offscreen bits for player
00A9D6  1  85 00                      sta $00                   ;save them here
00A9D8  1  A0 00                      ldy #$00                  ;load default offset (left side)
00A9DA  1  0A                         asl                       ;if d7 of offscreen bits are set,
00A9DB  1  B0 07                      bcs KeepOnscr             ;branch with default offset
00A9DD  1  C8                         iny                         ;otherwise use different offset (right side)
00A9DE  1  A5 00                      lda $00
00A9E0  1  29 20                      and #%00100000              ;check offscreen bits for d5 set
00A9E2  1  F0 1B                      beq InitPlatScrl            ;if not set, branch ahead of this part
00A9E4  1  B9 1C 07     KeepOnscr:    lda ScreenEdge_X_Pos,y      ;get left or right side coordinate based on offset
00A9E7  1  38                         sec
00A9E8  1  F9 05 AA                   sbc X_SubtracterData,y      ;subtract amount based on offset
00A9EB  1  85 86                      sta Player_X_Position       ;store as player position to prevent movement further
00A9ED  1  B9 1A 07                   lda ScreenEdge_PageLoc,y    ;get left or right page location based on offset
00A9F0  1  E9 00                      sbc #$00                    ;subtract borrow
00A9F2  1  85 6D                      sta Player_PageLoc          ;save as player's page location
00A9F4  1  A5 0C                      lda Left_Right_Buttons      ;check saved controller bits
00A9F6  1  D9 07 AA                   cmp OffscrJoypadBitsData,y  ;against bits based on offset
00A9F9  1  F0 04                      beq InitPlatScrl            ;if not equal, branch
00A9FB  1  A9 00                      lda #$00
00A9FD  1  85 57                      sta Player_X_Speed          ;otherwise nullify horizontal speed of player
00A9FF  1  A9 00        InitPlatScrl: lda #$00                    ;nullify platform force imposed on scroll
00AA01  1  8D A1 03                   sta Platform_X_Scroll
00AA04  1  60                         rts
00AA05  1               
00AA05  1               X_SubtracterData:
00AA05  1  00 10              .byte $00, $10
00AA07  1               
00AA07  1               OffscrJoypadBitsData:
00AA07  1  01 02              .byte $01, $02
00AA09  1               
00AA09  1               ;-------------------------------------------------------------------------------------
00AA09  1               
00AA09  1               GameRoutines:
00AA09  1  A5 0E              lda GameEngineSubroutine  ;run routine based on number (a few of these routines are
00AA0B  1  20 97 BA           jsr JumpEngine            ;merely placeholders as conditions for other routines)
00AA0E  1               
00AA0E  1  83 8C              .word Entrance_GameTimerSetup
00AA10  1  86 AB              .word Vine_AutoClimb
00AA12  1  C5 AB              .word SideExitPipeEntry
00AA14  1  A4 AB              .word VerticalPipeEntry
00AA16  1  63 AC              .word FlagpoleSlide
00AA18  1  89 AC              .word PlayerEndLevel
00AA1A  1  1F 8D              .word PlayerLoseLife
00AA1C  1  28 AA              .word PlayerEntrance
00AA1E  1  A8 AA              .word PlayerCtrlRoutine
00AA20  1  F2 AB              .word PlayerChangeSize
00AA22  1  04 AC              .word PlayerInjuryBlink
00AA24  1  28 AC              .word PlayerDeath
00AA26  1  3C AC              .word PlayerFireFlower
00AA28  1               
00AA28  1               ;-------------------------------------------------------------------------------------
00AA28  1               
00AA28  1               PlayerEntrance:
00AA28  1  AD 52 07                 lda AltEntranceControl    ;check for mode of alternate entry
00AA2B  1  C9 02                    cmp #$02
00AA2D  1  F0 2B                    beq EntrMode2             ;if found, branch to enter from pipe or with vine
00AA2F  1  A9 00                    lda #$00
00AA31  1  A4 CE                    ldy Player_Y_Position     ;if vertical position above a certain
00AA33  1  C0 30                    cpy #$30                  ;point, nullify controller bits and continue
00AA35  1  90 6E                    bcc AutoControlPlayer     ;with player movement code, do not return
00AA37  1  AD 10 07                 lda PlayerEntranceCtrl    ;check player entry bits from header
00AA3A  1  C9 06                    cmp #$06
00AA3C  1  F0 04                    beq ChkBehPipe            ;if set to 6 or 7, execute pipe intro code
00AA3E  1  C9 07                    cmp #$07                  ;otherwise branch to normal entry
00AA40  1  D0 50                    bne PlayerRdy
00AA42  1  AD C4 03     ChkBehPipe: lda Player_SprAttrib      ;check for sprite attributes
00AA45  1  D0 05                    bne IntroEntr             ;branch if found
00AA47  1  A9 01                    lda #$01
00AA49  1  4C A5 AA                 jmp AutoControlPlayer     ;force player to walk to the right
00AA4C  1  20 DE AB     IntroEntr:  jsr EnterSidePipe         ;execute sub to move player to the right
00AA4F  1  CE DE 06                 dec ChangeAreaTimer       ;decrement timer for change of area
00AA52  1  D0 50                    bne ExitEntr              ;branch to exit if not yet expired
00AA54  1  EE 69 07                 inc DisableIntermediate   ;set flag to skip world and lives display
00AA57  1  4C D4 AC                 jmp NextArea              ;jump to increment to next area and set modes
00AA5A  1  AD 58 07     EntrMode2:  lda JoypadOverride        ;if controller override bits set here,
00AA5D  1  D0 0C                    bne VineEntr              ;branch to enter with vine
00AA5F  1  A9 FF                    lda #$ff                  ;otherwise, set value here then execute sub
00AA61  1  20 BF AB                 jsr MovePlayerYAxis       ;to move player upwards (note $ff = -1)
00AA64  1  A5 CE                    lda Player_Y_Position     ;check to see if player is at a specific coordinate
00AA66  1  C9 91                    cmp #$91                  ;if player risen to a certain point (this requires pipes
00AA68  1  90 28                    bcc PlayerRdy             ;to be at specific height to look/function right) branch
00AA6A  1  60                       rts                       ;to the last part, otherwise leave
00AA6B  1  AD 99 03     VineEntr:   lda VineHeight
00AA6E  1  C9 60                    cmp #$60                  ;check vine height
00AA70  1  D0 32                    bne ExitEntr              ;if vine not yet reached maximum height, branch to leave
00AA72  1  A5 CE                    lda Player_Y_Position     ;get player's vertical coordinate
00AA74  1  C9 99                    cmp #$99                  ;check player's vertical coordinate against preset value
00AA76  1  A0 00                    ldy #$00                  ;load default values to be written to
00AA78  1  A9 01                    lda #$01                  ;this value moves player to the right off the vine
00AA7A  1  90 0A                    bcc OffVine               ;if vertical coordinate < preset value, use defaults
00AA7C  1  A9 03                    lda #$03
00AA7E  1  85 1D                    sta Player_State          ;otherwise set player state to climbing
00AA80  1  C8                       iny                       ;increment value in Y
00AA81  1  A9 08                    lda #$08                  ;set block in block buffer to cover hole, then
00AA83  1  8D B4 05                 sta Block_Buffer_1+$b4    ;use same value to force player to climb
00AA86  1  8C 16 07     OffVine:    sty DisableCollisionDet   ;set collision detection disable flag
00AA89  1  20 A5 AA                 jsr AutoControlPlayer     ;use contents of A to move player up or right, execute sub
00AA8C  1  A5 86                    lda Player_X_Position
00AA8E  1  C9 48                    cmp #$48                  ;check player's horizontal position
00AA90  1  90 12                    bcc ExitEntr              ;if not far enough to the right, branch to leave
00AA92  1  A9 08        PlayerRdy:  lda #$08                  ;set routine to be executed by game engine next frame
00AA94  1  85 0E                    sta GameEngineSubroutine
00AA96  1  A9 01                    lda #$01                  ;set to face player to the right
00AA98  1  85 33                    sta PlayerFacingDir
00AA9A  1  4A                       lsr                       ;init A
00AA9B  1  8D 52 07                 sta AltEntranceControl    ;init mode of entry
00AA9E  1  8D 16 07                 sta DisableCollisionDet   ;init collision detection disable flag
00AAA1  1  8D 58 07                 sta JoypadOverride        ;nullify controller override bits
00AAA4  1  60           ExitEntr:   rts                       ;leave!
00AAA5  1               
00AAA5  1               ;-------------------------------------------------------------------------------------
00AAA5  1               ;$07 - used to hold upper limit of high byte when player falls down hole
00AAA5  1               
00AAA5  1               AutoControlPlayer:
00AAA5  1  8D FC 06           sta SavedJoypadBits         ;override controller bits with contents of A if executing here
00AAA8  1               
00AAA8  1               PlayerCtrlRoutine:
00AAA8  1  A5 0E                    lda GameEngineSubroutine    ;check task here
00AAAA  1  C9 0B                    cmp #$0b                    ;if certain value is set, branch to skip controller bit loading
00AAAC  1  F0 3C                    beq SizeChk
00AAAE  1  AD 4E 07                 lda AreaType                ;are we in a water type area?
00AAB1  1  D0 10                    bne SaveJoyp                ;if not, branch
00AAB3  1  A4 B5                    ldy Player_Y_HighPos
00AAB5  1  88                       dey                         ;if not in vertical area between
00AAB6  1  D0 06                    bne DisJoyp                 ;status bar and bottom, branch
00AAB8  1  A5 CE                    lda Player_Y_Position
00AABA  1  C9 D0                    cmp #$d0                    ;if nearing the bottom of the screen or
00AABC  1  90 05                    bcc SaveJoyp                ;not in the vertical area between status bar or bottom,
00AABE  1  A9 00        DisJoyp:    lda #$00                    ;disable controller bits
00AAC0  1  8D FC 06                 sta SavedJoypadBits
00AAC3  1  AD FC 06     SaveJoyp:   lda SavedJoypadBits         ;otherwise store A and B buttons in $0a
00AAC6  1  29 C0                    and #%11000000
00AAC8  1  85 0A                    sta A_B_Buttons
00AACA  1  AD FC 06                 lda SavedJoypadBits         ;store left and right buttons in $0c
00AACD  1  29 03                    and #%00000011
00AACF  1  85 0C                    sta Left_Right_Buttons
00AAD1  1  AD FC 06                 lda SavedJoypadBits         ;store up and down buttons in $0b
00AAD4  1  29 0C                    and #%00001100
00AAD6  1  85 0B                    sta Up_Down_Buttons
00AAD8  1  29 04                    and #%00000100              ;check for pressing down
00AADA  1  F0 0E                    beq SizeChk                 ;if not, branch
00AADC  1  A5 1D                    lda Player_State            ;check player's state
00AADE  1  D0 0A                    bne SizeChk                 ;if not on the ground, branch
00AAE0  1  A4 0C                    ldy Left_Right_Buttons      ;check left and right
00AAE2  1  F0 06                    beq SizeChk                 ;if neither pressed, branch
00AAE4  1  A9 00                    lda #$00
00AAE6  1  85 0C                    sta Left_Right_Buttons      ;if pressing down while on the ground,
00AAE8  1  85 0B                    sta Up_Down_Buttons         ;nullify directional bits
00AAEA  1  20 F0 AC     SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
00AAED  1  A0 01                    ldy #$01                    ;is player small?
00AAEF  1  AD 54 07                 lda PlayerSize
00AAF2  1  D0 09                    bne ChkMoveDir
00AAF4  1  A0 00                    ldy #$00                    ;check for if crouching
00AAF6  1  AD 14 07                 lda CrouchingFlag
00AAF9  1  F0 02                    beq ChkMoveDir              ;if not, branch ahead
00AAFB  1  A0 02                    ldy #$02                    ;if big and crouching, load y with 2
00AAFD  1  8C 99 04     ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
00AB00  1  A9 01                    lda #$01                    ;set moving direction to right by default
00AB02  1  A4 57                    ldy Player_X_Speed          ;check player's horizontal speed
00AB04  1  F0 05                    beq PlayerSubs              ;if not moving at all horizontally, skip this part
00AB06  1  10 01                    bpl SetMoveDir              ;if moving to the right, use default moving direction
00AB08  1  0A                       asl                         ;otherwise change to move to the left
00AB09  1  85 45        SetMoveDir: sta Player_MovingDir        ;set moving direction
00AB0B  1  20 64 A9     PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
00AB0E  1  20 F0 EC                 jsr GetPlayerOffscreenBits  ;get player's offscreen bits
00AB11  1  20 9A EC                 jsr RelativePlayerPosition  ;get coordinates relative to the screen
00AB14  1  A2 00                    ldx #$00                    ;set offset for player object
00AB16  1  20 2C DE                 jsr BoundingBoxCore         ;get player's bounding box coordinates
00AB19  1  20 57 D8                 jsr PlayerBGCollision       ;do collision detection and process
00AB1C  1  A5 CE                    lda Player_Y_Position
00AB1E  1  C9 40                    cmp #$40                    ;check to see if player is higher than 64th pixel
00AB20  1  90 16                    bcc PlayerHole              ;if so, branch ahead
00AB22  1  A5 0E                    lda GameEngineSubroutine
00AB24  1  C9 05                    cmp #$05                    ;if running end-of-level routine, branch ahead
00AB26  1  F0 10                    beq PlayerHole
00AB28  1  C9 07                    cmp #$07                    ;if running player entrance routine, branch ahead
00AB2A  1  F0 0C                    beq PlayerHole
00AB2C  1  C9 04                    cmp #$04                    ;if running routines $00-$03, branch ahead
00AB2E  1  90 08                    bcc PlayerHole
00AB30  1  AD C4 03                 lda Player_SprAttrib
00AB33  1  29 DF                    and #%11011111              ;otherwise nullify player's
00AB35  1  8D C4 03                 sta Player_SprAttrib        ;background priority flag
00AB38  1  A5 B5        PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
00AB3A  1  C9 02                    cmp #$02                    ;for below the screen
00AB3C  1  30 3B                    bmi ExitCtrl                ;branch to leave if not that far down
00AB3E  1  A2 01                    ldx #$01
00AB40  1  8E 23 07                 stx ScrollLock              ;set scroll lock
00AB43  1  A0 04                    ldy #$04
00AB45  1  84 07                    sty $07                     ;set value here
00AB47  1  A2 00                    ldx #$00                    ;use X as flag, and clear for cloud level
00AB49  1  AC 59 07                 ldy GameTimerExpiredFlag    ;check game timer expiration flag
00AB4C  1  D0 05                    bne HoleDie                 ;if set, branch
00AB4E  1  AC 43 07                 ldy CloudTypeOverride       ;check for cloud type override
00AB51  1  D0 16                    bne ChkHoleX                ;skip to last part if found
00AB53  1  E8           HoleDie:    inx                         ;set flag in X for player death
00AB54  1  A4 0E                    ldy GameEngineSubroutine
00AB56  1  C0 0B                    cpy #$0b                    ;check for some other routine running
00AB58  1  F0 0F                    beq ChkHoleX                ;if so, branch ahead
00AB5A  1  AC 12 07                 ldy DeathMusicLoaded        ;check value here
00AB5D  1  D0 06                    bne HoleBottom              ;if already set, branch to next part
00AB5F  1  C8                       iny
00AB60  1  84 FC                    sty EventMusicQueue         ;otherwise play death music
00AB62  1  8C 12 07                 sty DeathMusicLoaded        ;and set value here
00AB65  1  A0 06        HoleBottom: ldy #$06
00AB67  1  84 07                    sty $07                     ;change value here
00AB69  1  C5 07        ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
00AB6B  1  30 0C                    bmi ExitCtrl                ;if less, branch to leave
00AB6D  1  CA                       dex                         ;otherwise decrement flag in X
00AB6E  1  30 0A                    bmi CloudExit               ;if flag was clear, branch to set modes and other values
00AB70  1  AC B1 07                 ldy EventMusicBuffer        ;check to see if music is still playing
00AB73  1  D0 04                    bne ExitCtrl                ;branch to leave if so
00AB75  1  A9 06                    lda #$06                    ;otherwise set to run lose life routine
00AB77  1  85 0E                    sta GameEngineSubroutine    ;on next frame
00AB79  1  60           ExitCtrl:   rts                         ;leave
00AB7A  1               
00AB7A  1               CloudExit:
00AB7A  1  A9 00              lda #$00
00AB7C  1  8D 58 07           sta JoypadOverride      ;clear controller override bits if any are set
00AB7F  1  20 9C AB           jsr SetEntr             ;do sub to set secondary mode
00AB82  1  EE 52 07           inc AltEntranceControl  ;set mode of entry to 3
00AB85  1  60                 rts
00AB86  1               
00AB86  1               ;-------------------------------------------------------------------------------------
00AB86  1               
00AB86  1               Vine_AutoClimb:
00AB86  1  A5 B5                   lda Player_Y_HighPos   ;check to see whether player reached position
00AB88  1  D0 06                   bne AutoClimb          ;above the status bar yet and if so, set modes
00AB8A  1  A5 CE                   lda Player_Y_Position
00AB8C  1  C9 E4                   cmp #$e4
00AB8E  1  90 0C                   bcc SetEntr
00AB90  1  A9 08        AutoClimb: lda #%00001000         ;set controller bits override to up
00AB92  1  8D 58 07                sta JoypadOverride
00AB95  1  A0 03                   ldy #$03               ;set player state to climbing
00AB97  1  84 1D                   sty Player_State
00AB99  1  4C A5 AA                jmp AutoControlPlayer
00AB9C  1  A9 02        SetEntr:   lda #$02               ;set starting position to override
00AB9E  1  8D 52 07                sta AltEntranceControl
00ABA1  1  4C D2 AB                jmp ChgAreaMode        ;set modes
00ABA4  1               
00ABA4  1               ;-------------------------------------------------------------------------------------
00ABA4  1               
00ABA4  1               VerticalPipeEntry:
00ABA4  1  A9 01              lda #$01             ;set 1 as movement amount
00ABA6  1  20 BF AB           jsr MovePlayerYAxis  ;do sub to move player downwards
00ABA9  1  20 64 A9           jsr ScrollHandler    ;do sub to scroll screen with saved force if necessary
00ABAC  1  A0 00              ldy #$00             ;load default mode of entry
00ABAE  1  AD D6 06           lda WarpZoneControl  ;check warp zone control variable/flag
00ABB1  1  D0 17              bne ChgAreaPipe      ;if set, branch to use mode 0
00ABB3  1  C8                 iny
00ABB4  1  AD 4E 07           lda AreaType         ;check for castle level type
00ABB7  1  C9 03              cmp #$03
00ABB9  1  D0 0F              bne ChgAreaPipe      ;if not castle type level, use mode 1
00ABBB  1  C8                 iny
00ABBC  1  4C CA AB           jmp ChgAreaPipe      ;otherwise use mode 2
00ABBF  1               
00ABBF  1               MovePlayerYAxis:
00ABBF  1  18                 clc
00ABC0  1  65 CE              adc Player_Y_Position ;add contents of A to player position
00ABC2  1  85 CE              sta Player_Y_Position
00ABC4  1  60                 rts
00ABC5  1               
00ABC5  1               ;-------------------------------------------------------------------------------------
00ABC5  1               
00ABC5  1               SideExitPipeEntry:
00ABC5  1  20 DE AB                  jsr EnterSidePipe         ;execute sub to move player to the right
00ABC8  1  A0 02                     ldy #$02
00ABCA  1  CE DE 06     ChgAreaPipe: dec ChangeAreaTimer       ;decrement timer for change of area
00ABCD  1  D0 0E                     bne ExitCAPipe
00ABCF  1  8C 52 07                  sty AltEntranceControl    ;when timer expires set mode of alternate entry
00ABD2  1  EE 74 07     ChgAreaMode: inc DisableScreenFlag     ;set flag to disable screen output
00ABD5  1  A9 00                     lda #$00
00ABD7  1  8D 72 07                  sta OperMode_Task         ;set secondary mode of operation
00ABDA  1  8D 22 07                  sta Sprite0HitDetectFlag  ;disable sprite 0 check
00ABDD  1  60           ExitCAPipe:  rts                       ;leave
00ABDE  1               
00ABDE  1               EnterSidePipe:
00ABDE  1  A9 08                   lda #$08               ;set player's horizontal speed
00ABE0  1  85 57                   sta Player_X_Speed
00ABE2  1  A0 01                   ldy #$01               ;set controller right button by default
00ABE4  1  A5 86                   lda Player_X_Position  ;mask out higher nybble of player's
00ABE6  1  29 0F                   and #%00001111         ;horizontal position
00ABE8  1  D0 03                   bne RightPipe
00ABEA  1  85 57                   sta Player_X_Speed     ;if lower nybble = 0, set as horizontal speed
00ABEC  1  A8                      tay                    ;and nullify controller bit override here
00ABED  1  98           RightPipe: tya                    ;use contents of Y to
00ABEE  1  20 A5 AA                jsr AutoControlPlayer  ;execute player control routine with ctrl bits nulled
00ABF1  1  60                      rts
00ABF2  1               
00ABF2  1               ;-------------------------------------------------------------------------------------
00ABF2  1               
00ABF2  1               PlayerChangeSize:
00ABF2  1  AD 47 07                  lda TimerControl    ;check master timer control
00ABF5  1  C9 F8                     cmp #$f8            ;for specific moment in time
00ABF7  1  D0 03                     bne EndChgSize      ;branch if before or after that point
00ABF9  1  4C 14 AC                  jmp InitChangeSize  ;otherwise run code to get growing/shrinking going
00ABFC  1  C9 C4        EndChgSize:  cmp #$c4            ;check again for another specific moment
00ABFE  1  D0 03                     bne ExitChgSize     ;and branch to leave if before or after that point
00AC00  1  20 32 AC                  jsr DonePlayerTask  ;otherwise do sub to init timer control and set routine
00AC03  1  60           ExitChgSize: rts                 ;and then leave
00AC04  1               
00AC04  1               ;-------------------------------------------------------------------------------------
00AC04  1               
00AC04  1               PlayerInjuryBlink:
00AC04  1  AD 47 07                lda TimerControl       ;check master timer control
00AC07  1  C9 F0                   cmp #$f0               ;for specific moment in time
00AC09  1  B0 07                   bcs ExitBlink          ;branch if before that point
00AC0B  1  C9 C8                   cmp #$c8               ;check again for another specific point
00AC0D  1  F0 23                   beq DonePlayerTask     ;branch if at that point, and not before or after
00AC0F  1  4C A8 AA                jmp PlayerCtrlRoutine  ;otherwise run player control routine
00AC12  1  D0 13        ExitBlink: bne ExitBoth           ;do unconditional branch to leave
00AC14  1               
00AC14  1               InitChangeSize:
00AC14  1  AC 0B 07               ldy PlayerChangeSizeFlag  ;if growing/shrinking flag already set
00AC17  1  D0 0E                  bne ExitBoth              ;then branch to leave
00AC19  1  8C 0D 07               sty PlayerAnimCtrl        ;otherwise initialize player's animation frame control
00AC1C  1  EE 0B 07               inc PlayerChangeSizeFlag  ;set growing/shrinking flag
00AC1F  1  AD 54 07               lda PlayerSize
00AC22  1  49 01                  eor #$01                  ;invert player's size
00AC24  1  8D 54 07               sta PlayerSize
00AC27  1  60           ExitBoth: rts                       ;leave
00AC28  1               
00AC28  1               ;-------------------------------------------------------------------------------------
00AC28  1               ;$00 - used in CyclePlayerPalette to store current palette to cycle
00AC28  1               
00AC28  1               PlayerDeath:
00AC28  1  AD 47 07           lda TimerControl       ;check master timer control
00AC2B  1  C9 F0              cmp #$f0               ;for specific moment in time
00AC2D  1  B0 33              bcs ExitDeath          ;branch to leave if before that point
00AC2F  1  4C A8 AA           jmp PlayerCtrlRoutine  ;otherwise run player control routine
00AC32  1               
00AC32  1               DonePlayerTask:
00AC32  1  A9 00              lda #$00
00AC34  1  8D 47 07           sta TimerControl          ;initialize master timer control to continue timers
00AC37  1  A9 08              lda #$08
00AC39  1  85 0E              sta GameEngineSubroutine  ;set player control routine to run next frame
00AC3B  1  60                 rts                       ;leave
00AC3C  1               
00AC3C  1               PlayerFireFlower:
00AC3C  1  AD 47 07           lda TimerControl       ;check master timer control
00AC3F  1  C9 C0              cmp #$c0               ;for specific moment in time
00AC41  1  F0 13              beq ResetPalFireFlower ;branch if at moment, not before or after
00AC43  1  A5 09              lda FrameCounter       ;get frame counter
00AC45  1  4A                 lsr
00AC46  1  4A                 lsr                    ;divide by four to change every four frames
00AC47  1               
00AC47  1               CyclePlayerPalette:
00AC47  1  29 03              and #$03              ;mask out all but d1-d0 (previously d3-d2)
00AC49  1  85 00              sta $00               ;store result here to use as palette bits
00AC4B  1  AD C4 03           lda Player_SprAttrib  ;get player attributes
00AC4E  1  29 FC              and #%11111100        ;save any other bits but palette bits
00AC50  1  05 00              ora $00               ;add palette bits
00AC52  1  8D C4 03           sta Player_SprAttrib  ;store as new player attributes
00AC55  1  60                 rts                   ;and leave
00AC56  1               
00AC56  1               ResetPalFireFlower:
00AC56  1  20 32 AC           jsr DonePlayerTask    ;do sub to init timer control and run player control routine
00AC59  1               
00AC59  1               ResetPalStar:
00AC59  1  AD C4 03           lda Player_SprAttrib  ;get player attributes
00AC5C  1  29 FC              and #%11111100        ;mask out palette bits to force palette 0
00AC5E  1  8D C4 03           sta Player_SprAttrib  ;store as new player attributes
00AC61  1  60                 rts                   ;and leave
00AC62  1               
00AC62  1               ExitDeath:
00AC62  1  60                 rts          ;leave from death routine
00AC63  1               
00AC63  1               ;-------------------------------------------------------------------------------------
00AC63  1               
00AC63  1               FlagpoleSlide:
00AC63  1  A5 1B                     lda Enemy_ID+5           ;check special use enemy slot
00AC65  1  C9 30                     cmp #FlagpoleFlagObject  ;for flagpole flag object
00AC67  1  D0 15                     bne NoFPObj              ;if not found, branch to something residual
00AC69  1  AD 13 07                  lda FlagpoleSoundQueue   ;load flagpole sound
00AC6C  1  85 FF                     sta Square1SoundQueue    ;into square 1's sfx queue
00AC6E  1  A9 00                     lda #$00
00AC70  1  8D 13 07                  sta FlagpoleSoundQueue   ;init flagpole sound queue
00AC73  1  A4 CE                     ldy Player_Y_Position
00AC75  1  C0 9E                     cpy #$9e                 ;check to see if player has slid down
00AC77  1  B0 02                     bcs SlidePlayer          ;far enough, and if so, branch with no controller bits set
00AC79  1  A9 04                     lda #$04                 ;otherwise force player to climb down (to slide)
00AC7B  1  4C A5 AA     SlidePlayer: jmp AutoControlPlayer    ;jump to player control routine
00AC7E  1  E6 0E        NoFPObj:     inc GameEngineSubroutine ;increment to next routine (this may
00AC80  1  60                        rts                      ;be residual code)
00AC81  1               
00AC81  1               ;-------------------------------------------------------------------------------------
00AC81  1               
00AC81  1               Hidden1UpCoinAmts:
00AC81  1  15 23 16 1B        .byte $15, $23, $16, $1b, $17, $18, $23, $63
00AC85  1  17 18 23 63  
00AC89  1               
00AC89  1               PlayerEndLevel:
00AC89  1                         ; jsr Enter_EndLevel
00AC89  1  A9 01                  lda #$01                  ;force player to walk to the right
00AC8B  1  20 A5 AA               jsr AutoControlPlayer
00AC8E  1  A5 CE                  lda Player_Y_Position     ;check player's vertical position
00AC90  1  C9 AE                  cmp #$ae
00AC92  1  90 0E                  bcc ChkStop               ;if player is not yet off the flagpole, skip this part
00AC94  1  AD 23 07               lda ScrollLock            ;if scroll lock not set, branch ahead to next part
00AC97  1  F0 09                  beq ChkStop               ;because we only need to do this part once
00AC99  1  A9 20                  lda #EndOfLevelMusic
00AC9B  1  85 FC                  sta EventMusicQueue       ;load win level music in event music queue
00AC9D  1  A9 00                  lda #$00
00AC9F  1  8D 23 07               sta ScrollLock            ;turn off scroll lock to skip this part later
00ACA2  1  AD 90 04     ChkStop:  lda Player_CollisionBits  ;get player collision bits
00ACA5  1  4A                     lsr                       ;check for d0 set
00ACA6  1  B0 0D                  bcs RdyNextA              ;if d0 set, skip to next part
00ACA8  1  AD 46 07               lda StarFlagTaskControl   ;if star flag task control already set,
00ACAB  1  D0 03                  bne InCastle              ;go ahead with the rest of the code
00ACAD  1  EE 46 07               inc StarFlagTaskControl   ;otherwise set task control now (this gets ball rolling!)
00ACB0  1  A9 20        InCastle: lda #%00100000            ;set player's background priority bit to
00ACB2  1  8D C4 03               sta Player_SprAttrib      ;give illusion of being inside the castle
00ACB5  1  AD 46 07     RdyNextA: lda StarFlagTaskControl
00ACB8  1  C9 05                  cmp #$05                  ;if star flag task control not yet set
00ACBA  1  D0 33                  bne ExitNA                ;beyond last valid task number, branch to leave
00ACBC  1  EE 5C 07               inc LevelNumber           ;increment level number used for game logic
00ACBF  1  AD 5C 07               lda LevelNumber
00ACC2  1  C9 03                  cmp #$03                  ;check to see if we have yet reached level -4
00ACC4  1  D0 0E                  bne NextArea              ;and skip this last part here if not
00ACC6  1  AC 5F 07               ldy WorldNumber           ;get world number as offset
00ACC9  1  AD 48 07               lda CoinTallyFor1Ups      ;check third area coin tally for bonus 1-ups
00ACCC  1  D9 81 AC               cmp Hidden1UpCoinAmts,y   ;against minimum value, if player has not collected
00ACCF  1  90 03                  bcc NextArea              ;at least this number of coins, leave flag clear
00ACD1  1  EE 5D 07               inc Hidden1UpFlag         ;otherwise set hidden 1-up box control flag
00ACD4  1  EE 60 07     NextArea: inc AreaNumber            ;increment area number used for address loader
00ACD7  1  20 4F BC               jsr LoadAreaPointer       ;get new level pointer
00ACDA  1  EE 57 07               inc FetchNewGameTimerFlag ;set flag to load new game timer
00ACDD  1  20 D2 AB               jsr ChgAreaMode           ;do sub to set secondary mode, disable screen and sprite 0
00ACE0  1  8D 5B 07               sta HalfwayPage           ;reset halfway page to 0 (beginning)
00ACE3  1  AD 05 60 29            PF_SetToLevelEnd_A
00ACE7  1  EF 8D 05 60  
00ACEB  1  A9 80                  lda #Silence
00ACED  1  85 FC                  sta EventMusicQueue       ;silence music and leave
00ACEF  1  60           ExitNA:   rts
00ACF0  1               
00ACF0  1               ;-------------------------------------------------------------------------------------
00ACF0  1               
00ACF0  1               PlayerMovementSubs:
00ACF0  1  A9 00                   lda #$00                  ;set A to init crouch flag by default
00ACF2  1  AC 54 07                ldy PlayerSize            ;is player small?
00ACF5  1  D0 08                   bne SetCrouch             ;if so, branch
00ACF7  1  A5 1D                   lda Player_State          ;check state of player
00ACF9  1  D0 07                   bne ProcMove              ;if not on the ground, branch
00ACFB  1  A5 0B                   lda Up_Down_Buttons       ;load controller bits for up and down
00ACFD  1  29 04                   and #%00000100            ;single out bit for down button
00ACFF  1  8D 14 07     SetCrouch: sta CrouchingFlag         ;store value in crouch flag
00AD02  1  20 17 AE     ProcMove:  jsr PlayerPhysicsSub      ;run sub related to jumping and swimming
00AD05  1  AD 0B 07                lda PlayerChangeSizeFlag  ;if growing/shrinking flag set,
00AD08  1  D0 16                   bne NoMoveSub             ;branch to leave
00AD0A  1  A5 1D                   lda Player_State
00AD0C  1  C9 03                   cmp #$03                  ;get player state
00AD0E  1  F0 05                   beq MoveSubs              ;if climbing, branch ahead, leave timer unset
00AD10  1  A0 18                   ldy #$18
00AD12  1  8C 89 07                sty ClimbSideTimer        ;otherwise reset timer now
00AD15  1  20 97 BA     MoveSubs:  jsr JumpEngine
00AD18  1               
00AD18  1  21 AD              .word OnGroundStateSub
00AD1A  1  3D AD              .word JumpSwimSub
00AD1C  1  34 AD              .word FallingSub
00AD1E  1  96 AD              .word ClimbingSub
00AD20  1               
00AD20  1  60           NoMoveSub: rts
00AD21  1               
00AD21  1               ;-------------------------------------------------------------------------------------
00AD21  1               ;$00 - used by ClimbingSub to store high vertical adder
00AD21  1               
00AD21  1               OnGroundStateSub:
00AD21  1  20 56 AF              jsr GetPlayerAnimSpeed     ;do a sub to set animation frame timing
00AD24  1  A5 0C                 lda Left_Right_Buttons
00AD26  1  F0 02                 beq GndMove                ;if left/right controller bits not set, skip instruction
00AD28  1  85 33                 sta PlayerFacingDir        ;otherwise set new facing direction
00AD2A  1  20 93 AF     GndMove: jsr ImposeFriction         ;do a sub to impose friction on player's walk/run
00AD2D  1  20 C0 BF              jsr MovePlayerHorizontally ;do another sub to move player horizontally
00AD30  1  8D FF 06              sta Player_X_Scroll        ;set returned value as player's movement speed for scroll
00AD33  1  60                    rts
00AD34  1               
00AD34  1               ;--------------------------------
00AD34  1               
00AD34  1               FallingSub:
00AD34  1  AD 0A 07           lda VerticalForceDown
00AD37  1  8D 09 07           sta VerticalForce      ;dump vertical movement force for falling into main one
00AD3A  1  4C 73 AD           jmp LRAir              ;movement force, then skip ahead to process left/right movement
00AD3D  1               
00AD3D  1               ;--------------------------------
00AD3D  1               
00AD3D  1               JumpSwimSub:
00AD3D  1  A4 9F                  ldy Player_Y_Speed         ;if player's vertical speed zero
00AD3F  1  10 13                  bpl DumpFall               ;or moving downwards, branch to falling
00AD41  1  A5 0A                  lda A_B_Buttons
00AD43  1  29 80                  and #A_Button              ;check to see if A button is being pressed
00AD45  1  25 0D                  and PreviousA_B_Buttons    ;and was pressed in previous frame
00AD47  1  D0 11                  bne ProcSwim               ;if so, branch elsewhere
00AD49  1  AD 08 07               lda JumpOrigin_Y_Position  ;get vertical position player jumped from
00AD4C  1  38                     sec
00AD4D  1  E5 CE                  sbc Player_Y_Position      ;subtract current from original vertical coordinate
00AD4F  1  CD 06 07               cmp DiffToHaltJump         ;compare to value set here to see if player is in mid-jump
00AD52  1  90 06                  bcc ProcSwim               ;or just starting to jump, if just starting, skip ahead
00AD54  1  AD 0A 07     DumpFall: lda VerticalForceDown      ;otherwise dump falling into main fractional
00AD57  1  8D 09 07               sta VerticalForce
00AD5A  1  AD 04 07     ProcSwim: lda SwimmingFlag           ;if swimming flag not set,
00AD5D  1  F0 14                  beq LRAir                  ;branch ahead to last part
00AD5F  1  20 56 AF               jsr GetPlayerAnimSpeed     ;do a sub to get animation frame timing
00AD62  1  A5 CE                  lda Player_Y_Position
00AD64  1  C9 14                  cmp #$14                   ;check vertical position against preset value
00AD66  1  B0 05                  bcs LRWater                ;if not yet reached a certain position, branch ahead
00AD68  1  A9 18                  lda #$18
00AD6A  1  8D 09 07               sta VerticalForce          ;otherwise set fractional
00AD6D  1  A5 0C        LRWater:  lda Left_Right_Buttons     ;check left/right controller bits (check for swimming)
00AD6F  1  F0 02                  beq LRAir                  ;if not pressing any, skip
00AD71  1  85 33                  sta PlayerFacingDir        ;otherwise set facing direction accordingly
00AD73  1  A5 0C        LRAir:    lda Left_Right_Buttons     ;check left/right controller bits (check for jumping/falling)
00AD75  1  F0 03                  beq JSMove                 ;if not pressing any, skip
00AD77  1  20 93 AF               jsr ImposeFriction         ;otherwise process horizontal movement
00AD7A  1  20 C0 BF     JSMove:   jsr MovePlayerHorizontally ;do a sub to move player horizontally
00AD7D  1  8D FF 06               sta Player_X_Scroll        ;set player's speed here, to be used for scroll later
00AD80  1  A5 0E                  lda GameEngineSubroutine
00AD82  1  C9 0B                  cmp #$0b                   ;check for specific routine selected
00AD84  1  D0 05                  bne ExitMov1               ;branch if not set to run
00AD86  1  A9 28                  lda #$28
00AD88  1  8D 09 07               sta VerticalForce          ;otherwise set fractional
00AD8B  1  4C 04 C0     ExitMov1: jmp MovePlayerVertically   ;jump to move player vertically, then leave
00AD8E  1               
00AD8E  1               ;--------------------------------
00AD8E  1               
00AD8E  1               ClimbAdderLow:
00AD8E  1  0E 04 FC F2        .byte $0e, $04, $fc, $f2
00AD92  1               ClimbAdderHigh:
00AD92  1  00 00 FF FF        .byte $00, $00, $ff, $ff
00AD96  1               
00AD96  1               ClimbingSub:
00AD96  1  AD 16 04                  lda Player_YMF_Dummy
00AD99  1  18                        clc                      ;add movement force to dummy variable
00AD9A  1  6D 33 04                  adc Player_Y_MoveForce   ;save with carry
00AD9D  1  8D 16 04                  sta Player_YMF_Dummy
00ADA0  1  A0 00                     ldy #$00                 ;set default adder here
00ADA2  1  A5 9F                     lda Player_Y_Speed       ;get player's vertical speed
00ADA4  1  10 01                     bpl MoveOnVine           ;if not moving upwards, branch
00ADA6  1  88                        dey                      ;otherwise set adder to $ff
00ADA7  1  84 00        MoveOnVine:  sty $00                  ;store adder here
00ADA9  1  65 CE                     adc Player_Y_Position    ;add carry to player's vertical position
00ADAB  1  85 CE                     sta Player_Y_Position    ;and store to move player up or down
00ADAD  1  A5 B5                     lda Player_Y_HighPos
00ADAF  1  65 00                     adc $00                  ;add carry to player's page location
00ADB1  1  85 B5                     sta Player_Y_HighPos     ;and store
00ADB3  1  A5 0C                     lda Left_Right_Buttons   ;compare left/right controller bits
00ADB5  1  2D 90 04                  and Player_CollisionBits ;to collision flag
00ADB8  1  F0 2D                     beq InitCSTimer          ;if not set, skip to end
00ADBA  1  AC 89 07                  ldy ClimbSideTimer       ;otherwise check timer
00ADBD  1  D0 27                     bne ExitCSub             ;if timer not expired, branch to leave
00ADBF  1  A0 18                     ldy #$18
00ADC1  1  8C 89 07                  sty ClimbSideTimer       ;otherwise set timer now
00ADC4  1  A2 00                     ldx #$00                 ;set default offset here
00ADC6  1  A4 33                     ldy PlayerFacingDir      ;get facing direction
00ADC8  1  4A                        lsr                      ;move right button controller bit to carry
00ADC9  1  B0 02                     bcs ClimbFD              ;if controller right pressed, branch ahead
00ADCB  1  E8                        inx
00ADCC  1  E8                        inx                      ;otherwise increment offset by 2 bytes
00ADCD  1  88           ClimbFD:     dey                      ;check to see if facing right
00ADCE  1  F0 01                     beq CSetFDir             ;if so, branch, do not increment
00ADD0  1  E8                        inx                      ;otherwise increment by 1 byte
00ADD1  1  A5 86        CSetFDir:    lda Player_X_Position
00ADD3  1  18                        clc                      ;add or subtract from player's horizontal position
00ADD4  1  7D 8E AD                  adc ClimbAdderLow,x      ;using value here as adder and X as offset
00ADD7  1  85 86                     sta Player_X_Position
00ADD9  1  A5 6D                     lda Player_PageLoc       ;add or subtract carry or borrow using value here
00ADDB  1  7D 92 AD                  adc ClimbAdderHigh,x     ;from the player's page location
00ADDE  1  85 6D                     sta Player_PageLoc
00ADE0  1  A5 0C                     lda Left_Right_Buttons   ;get left/right controller bits again
00ADE2  1  49 03                     eor #%00000011           ;invert them and store them while player
00ADE4  1  85 33                     sta PlayerFacingDir      ;is on vine to face player in opposite direction
00ADE6  1  60           ExitCSub:    rts                      ;then leave
00ADE7  1  8D 89 07     InitCSTimer: sta ClimbSideTimer       ;initialize timer here
00ADEA  1  60                        rts
00ADEB  1               
00ADEB  1               ;-------------------------------------------------------------------------------------
00ADEB  1               ;$00 - used to store offset to friction data
00ADEB  1               
00ADEB  1               JumpMForceData:
00ADEB  1  20 20 1E 28        .byte $20, $20, $1e, $28, $28, $0d, $04
00ADEF  1  28 0D 04     
00ADF2  1               
00ADF2  1               FallMForceData:
00ADF2  1  70 70 60 90        .byte $70, $70, $60, $90, $90, $0a, $09
00ADF6  1  90 0A 09     
00ADF9  1               
00ADF9  1               PlayerYSpdData:
00ADF9  1  FC FC FC FB        .byte $fc, $fc, $fc, $fb, $fb, $fe, $ff
00ADFD  1  FB FE FF     
00AE00  1               
00AE00  1               InitMForceData:
00AE00  1  00 00 00 00        .byte $00, $00, $00, $00, $00, $80, $00
00AE04  1  00 80 00     
00AE07  1               
00AE07  1               MaxLeftXSpdData:
00AE07  1  D8 E8 F0           .byte $d8, $e8, $f0
00AE0A  1               
00AE0A  1               MaxRightXSpdData:
00AE0A  1  28 18 10           .byte $28, $18, $10
00AE0D  1  0C                 .byte $0c ;used for pipe intros
00AE0E  1               
00AE0E  1               FrictionData:
00AE0E  1  E4 98 D0           .byte $e4, $98, $d0
00AE11  1               
00AE11  1               Climb_Y_SpeedData:
00AE11  1  00 FF 01           .byte $00, $ff, $01
00AE14  1               
00AE14  1               Climb_Y_MForceData:
00AE14  1  00 20 FF           .byte $00, $20, $ff
00AE17  1               
00AE17  1               PlayerPhysicsSub:
00AE17  1  A5 1D                   lda Player_State          ;check player state
00AE19  1  C9 03                   cmp #$03
00AE1B  1  D0 23                   bne CheckForJumping       ;if not climbing, branch
00AE1D  1  A0 00                   ldy #$00
00AE1F  1  A5 0B                   lda Up_Down_Buttons       ;get controller bits for up/down
00AE21  1  2D 90 04                and Player_CollisionBits  ;check against player's collision detection bits
00AE24  1  F0 06                   beq ProcClimb             ;if not pressing up or down, branch
00AE26  1  C8                      iny
00AE27  1  29 08                   and #%00001000            ;check for pressing up
00AE29  1  D0 01                   bne ProcClimb
00AE2B  1  C8                      iny
00AE2C  1  BE 14 AE     ProcClimb: ldx Climb_Y_MForceData,y  ;load value here
00AE2F  1  8E 33 04                stx Player_Y_MoveForce    ;store as vertical movement force
00AE32  1  A9 08                   lda #$08                  ;load default animation timing
00AE34  1  BE 11 AE                ldx Climb_Y_SpeedData,y   ;load some other value here
00AE37  1  86 9F                   stx Player_Y_Speed        ;store as vertical speed
00AE39  1  30 01                   bmi SetCAnim              ;if climbing down, use default animation timing value
00AE3B  1  4A                      lsr                       ;otherwise divide timer setting by 2
00AE3C  1  8D 0C 07     SetCAnim:  sta PlayerAnimTimerSet    ;store animation timer setting and leave
00AE3F  1  60                      rts
00AE40  1               
00AE40  1               CheckForJumping:
00AE40  1  AD 0E 07             lda JumpspringAnimCtrl    ;if jumpspring animating,
00AE43  1  D0 0A                bne NoJump                ;skip ahead to something else
00AE45  1  A5 0A                lda A_B_Buttons           ;check for A button press
00AE47  1  29 80                and #A_Button
00AE49  1  F0 04                beq NoJump                ;if not, branch to something else
00AE4B  1  25 0D                and PreviousA_B_Buttons   ;if button not pressed in previous frame, branch
00AE4D  1  F0 03                beq ProcJumping
00AE4F  1  4C E3 AE     NoJump: jmp X_Physics             ;otherwise, jump to something else
00AE52  1               
00AE52  1               ProcJumping:
00AE52  1  A5 1D                   lda Player_State           ;check player state
00AE54  1  F0 11                   beq InitJS                 ;if on the ground, branch
00AE56  1  AD 04 07                lda SwimmingFlag           ;if swimming flag not set, jump to do something else
00AE59  1  F0 F4                   beq NoJump                 ;to prevent midair jumping, otherwise continue
00AE5B  1  AD 82 07                lda JumpSwimTimer          ;if jump/swim timer nonzero, branch
00AE5E  1  D0 07                   bne InitJS
00AE60  1  A5 9F                   lda Player_Y_Speed         ;check player's vertical speed
00AE62  1  10 03                   bpl InitJS                 ;if player's vertical speed motionless or down, branch
00AE64  1  4C E3 AE                jmp X_Physics              ;if timer at zero and player still rising, do not swim
00AE67  1               InitJS:
00AE67  1  A9 20                   lda #$20                   ;set jump/swim timer
00AE69  1  8D 82 07                sta JumpSwimTimer
00AE6C  1  A0 00                   ldy #$00                   ;initialize vertical force and dummy variable
00AE6E  1  8C 16 04                sty Player_YMF_Dummy
00AE71  1  8C 33 04                sty Player_Y_MoveForce
00AE74  1  A5 B5                   lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
00AE76  1  8D 07 07                sta JumpOrigin_Y_HighPos   ;and store them next to each other here
00AE79  1  A5 CE                   lda Player_Y_Position
00AE7B  1  8D 08 07                sta JumpOrigin_Y_Position
00AE7E  1  A9 01                   lda #$01                   ;set player state to jumping/swimming
00AE80  1  85 1D                   sta Player_State
00AE82  1  AD 00 07                lda Player_XSpeedAbsolute  ;check value related to walking/running speed
00AE85  1  C9 09                   cmp #$09
00AE87  1  90 10                   bcc ChkWtr                 ;branch if below certain values, increment Y
00AE89  1  C8                      iny                        ;for each amount equal or exceeded
00AE8A  1  C9 10                   cmp #$10
00AE8C  1  90 0B                   bcc ChkWtr
00AE8E  1  C8                      iny
00AE8F  1  C9 19                   cmp #$19
00AE91  1  90 06                   bcc ChkWtr
00AE93  1  C8                      iny
00AE94  1  C9 1C                   cmp #$1c
00AE96  1  90 01                   bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
00AE98  1  C8                      iny
00AE99  1  A9 01        ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
00AE9B  1  8D 06 07                sta DiffToHaltJump
00AE9E  1  AD 04 07                lda SwimmingFlag           ;if swimming flag disabled, branch
00AEA1  1  F0 08                   beq GetYPhy
00AEA3  1  A0 05                   ldy #$05                   ;otherwise set Y to 5, range is 5-6
00AEA5  1  AD 7D 04                lda Whirlpool_Flag         ;if whirlpool flag not set, branch
00AEA8  1  F0 01                   beq GetYPhy
00AEAA  1  C8                      iny                        ;otherwise increment to 6
00AEAB  1  B9 EB AD     GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
00AEAE  1  8D 09 07                sta VerticalForce          ;data here
00AEB1  1  B9 F2 AD                lda FallMForceData,y
00AEB4  1  8D 0A 07                sta VerticalForceDown
00AEB7  1  B9 00 AE                lda InitMForceData,y
00AEBA  1  8D 33 04                sta Player_Y_MoveForce
00AEBD  1  B9 F9 AD                lda PlayerYSpdData,y
00AEC0  1  85 9F                   sta Player_Y_Speed
00AEC2  1  AD 04 07                lda SwimmingFlag           ;if swimming flag disabled, branch
00AEC5  1  F0 11                   beq PJumpSnd
00AEC7  1  A9 04                   lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
00AEC9  1  85 FF                   sta Square1SoundQueue      ;square 1's sfx queue
00AECB  1  A5 CE                   lda Player_Y_Position
00AECD  1  C9 14                   cmp #$14                   ;check vertical low byte of player position
00AECF  1  B0 12                   bcs X_Physics              ;if below a certain point, branch
00AED1  1  A9 00                   lda #$00                   ;otherwise reset player's vertical speed
00AED3  1  85 9F                   sta Player_Y_Speed         ;and jump to something else to keep player
00AED5  1  4C E3 AE                jmp X_Physics              ;from swimming above water level
00AED8  1  A9 01        PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
00AEDA  1  AC 54 07                ldy PlayerSize             ;is mario big?
00AEDD  1  F0 02                   beq SJumpSnd
00AEDF  1  A9 80                   lda #Sfx_SmallJump         ;if not, load small mario's jump sound
00AEE1  1  85 FF        SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
00AEE3  1  A0 00        X_Physics: ldy #$00
00AEE5  1  84 00                   sty $00                    ;init value here
00AEE7  1  A5 1D                   lda Player_State           ;if mario is on the ground, branch
00AEE9  1  F0 09                   beq ProcPRun
00AEEB  1  AD 00 07                lda Player_XSpeedAbsolute  ;check something that seems to be related
00AEEE  1  C9 19                   cmp #$19                   ;to mario's speed
00AEF0  1  B0 33                   bcs GetXPhy                ;if =>$19 branch here
00AEF2  1  90 18                   bcc ChkRFast               ;if not branch elsewhere
00AEF4  1  C8           ProcPRun:  iny                        ;if mario on the ground, increment Y
00AEF5  1  AD 4E 07                lda AreaType               ;check area type
00AEF8  1  F0 12                   beq ChkRFast               ;if water type, branch
00AEFA  1  88                      dey                        ;decrement Y by default for non-water type area
00AEFB  1  A5 0C                   lda Left_Right_Buttons     ;get left/right controller bits
00AEFD  1  C5 45                   cmp Player_MovingDir       ;check against moving direction
00AEFF  1  D0 0B                   bne ChkRFast               ;if controller bits <> moving direction, skip this part
00AF01  1  A5 0A                   lda A_B_Buttons            ;check for b button pressed
00AF03  1  29 40                   and #B_Button
00AF05  1  D0 19                   bne SetRTmr                ;if pressed, skip ahead to set timer
00AF07  1  AD 83 07                lda RunningTimer           ;check for running timer set
00AF0A  1  D0 19                   bne GetXPhy                ;if set, branch
00AF0C  1  C8           ChkRFast:  iny                        ;if running timer not set or level type is water,
00AF0D  1  E6 00                   inc $00                    ;increment Y again and temp variable in memory
00AF0F  1  AD 03 07                lda RunningSpeed
00AF12  1  D0 07                   bne FastXSp                ;if running speed set here, branch
00AF14  1  AD 00 07                lda Player_XSpeedAbsolute
00AF17  1  C9 21                   cmp #$21                   ;otherwise check player's walking/running speed
00AF19  1  90 0A                   bcc GetXPhy                ;if less than a certain amount, branch ahead
00AF1B  1  E6 00        FastXSp:   inc $00                    ;if running speed set or speed => $21 increment $00
00AF1D  1  4C 25 AF                jmp GetXPhy                ;and jump ahead
00AF20  1  A9 0A        SetRTmr:   lda #$0a                   ;if b button pressed, set running timer
00AF22  1  8D 83 07                sta RunningTimer
00AF25  1  B9 07 AE     GetXPhy:   lda MaxLeftXSpdData,y      ;get maximum speed to the left
00AF28  1  8D 50 04                sta MaximumLeftSpeed
00AF2B  1  A5 0E                   lda GameEngineSubroutine   ;check for specific routine running
00AF2D  1  C9 07                   cmp #$07                   ;(player entrance)
00AF2F  1  D0 02                   bne GetXPhy2               ;if not running, skip and use old value of Y
00AF31  1  A0 03                   ldy #$03                   ;otherwise set Y to 3
00AF33  1  B9 0A AE     GetXPhy2:  lda MaxRightXSpdData,y     ;get maximum speed to the right
00AF36  1  8D 56 04                sta MaximumRightSpeed
00AF39  1  A4 00                   ldy $00                    ;get other value in memory
00AF3B  1  B9 0E AE                lda FrictionData,y         ;get value using value in memory as offset
00AF3E  1  8D 02 07                sta FrictionAdderLow
00AF41  1  A9 00                   lda #$00
00AF43  1  8D 01 07                sta FrictionAdderHigh      ;init something here
00AF46  1  A5 33                   lda PlayerFacingDir
00AF48  1  C5 45                   cmp Player_MovingDir       ;check facing direction against moving direction
00AF4A  1  F0 06                   beq ExitPhy                ;if the same, branch to leave
00AF4C  1  0E 02 07                asl FrictionAdderLow       ;otherwise shift d7 of friction adder low into carry
00AF4F  1  2E 01 07                rol FrictionAdderHigh      ;then rotate carry onto d0 of friction adder high
00AF52  1  60           ExitPhy:   rts                        ;and then leave
00AF53  1               
00AF53  1               ;-------------------------------------------------------------------------------------
00AF53  1               
00AF53  1               PlayerAnimTmrData:
00AF53  1  02 04 07           .byte $02, $04, $07
00AF56  1               
00AF56  1               GetPlayerAnimSpeed:
00AF56  1  A0 00                    ldy #$00                   ;initialize offset in Y
00AF58  1  AD 00 07                 lda Player_XSpeedAbsolute  ;check player's walking/running speed
00AF5B  1  C9 1C                    cmp #$1c                   ;against preset amount
00AF5D  1  B0 15                    bcs SetRunSpd              ;if greater than a certain amount, branch ahead
00AF5F  1  C8                       iny                        ;otherwise increment Y
00AF60  1  C9 0E                    cmp #$0e                   ;compare against lower amount
00AF62  1  B0 01                    bcs ChkSkid                ;if greater than this but not greater than first, skip increment
00AF64  1  C8                       iny                        ;otherwise increment Y again
00AF65  1  AD FC 06     ChkSkid:    lda SavedJoypadBits        ;get controller bits
00AF68  1  29 7F                    and #%01111111             ;mask out A button
00AF6A  1  F0 20                    beq SetAnimSpd             ;if no other buttons pressed, branch ahead of all this
00AF6C  1  29 03                    and #$03                   ;mask out all others except left and right
00AF6E  1  C5 45                    cmp Player_MovingDir       ;check against moving direction
00AF70  1  D0 08                    bne ProcSkid               ;if left/right controller bits <> moving direction, branch
00AF72  1  A9 00                    lda #$00                   ;otherwise set zero value here
00AF74  1  8D 03 07     SetRunSpd:  sta RunningSpeed           ;store zero or running speed here
00AF77  1  4C 8C AF                 jmp SetAnimSpd
00AF7A  1  AD 00 07     ProcSkid:   lda Player_XSpeedAbsolute  ;check player's walking/running speed
00AF7D  1  C9 0B                    cmp #$0b                   ;against one last amount
00AF7F  1  B0 0B                    bcs SetAnimSpd             ;if greater than this amount, branch
00AF81  1  A5 33                    lda PlayerFacingDir
00AF83  1  85 45                    sta Player_MovingDir       ;otherwise use facing direction to set moving direction
00AF85  1  A9 00                    lda #$00
00AF87  1  85 57                    sta Player_X_Speed         ;nullify player's horizontal speed
00AF89  1  8D 05 07                 sta Player_X_MoveForce     ;and dummy variable for player
00AF8C  1  B9 53 AF     SetAnimSpd: lda PlayerAnimTmrData,y    ;get animation timer setting using Y as offset
00AF8F  1  8D 0C 07                 sta PlayerAnimTimerSet
00AF92  1  60                       rts
00AF93  1               
00AF93  1               ;-------------------------------------------------------------------------------------
00AF93  1               
00AF93  1               ImposeFriction:
00AF93  1  2D 90 04                and Player_CollisionBits  ;perform AND between left/right controller bits and collision flag
00AF96  1  C9 00                   cmp #$00                  ;then compare to zero (this instruction is redundant)
00AF98  1  D0 08                   bne JoypFrict             ;if any bits set, branch to next part
00AF9A  1  A5 57                   lda Player_X_Speed
00AF9C  1  F0 49                   beq SetAbsSpd             ;if player has no horizontal speed, branch ahead to last part
00AF9E  1  10 23                   bpl RghtFrict             ;if player moving to the right, branch to slow
00AFA0  1  30 03                   bmi LeftFrict             ;otherwise logic dictates player moving left, branch to slow
00AFA2  1  4A           JoypFrict: lsr                       ;put right controller bit into carry
00AFA3  1  90 1E                   bcc RghtFrict             ;if left button pressed, carry = 0, thus branch
00AFA5  1  AD 05 07     LeftFrict: lda Player_X_MoveForce    ;load value set here
00AFA8  1  18                      clc
00AFA9  1  6D 02 07                adc FrictionAdderLow      ;add to it another value set here
00AFAC  1  8D 05 07                sta Player_X_MoveForce    ;store here
00AFAF  1  A5 57                   lda Player_X_Speed
00AFB1  1  6D 01 07                adc FrictionAdderHigh     ;add value plus carry to horizontal speed
00AFB4  1  85 57                   sta Player_X_Speed        ;set as new horizontal speed
00AFB6  1  CD 56 04                cmp MaximumRightSpeed     ;compare against maximum value for right movement
00AFB9  1  30 23                   bmi XSpdSign              ;if horizontal speed greater negatively, branch
00AFBB  1  AD 56 04                lda MaximumRightSpeed     ;otherwise set preset value as horizontal speed
00AFBE  1  85 57                   sta Player_X_Speed        ;thus slowing the player's left movement down
00AFC0  1  4C E7 AF                jmp SetAbsSpd             ;skip to the end
00AFC3  1  AD 05 07     RghtFrict: lda Player_X_MoveForce    ;load value set here
00AFC6  1  38                      sec
00AFC7  1  ED 02 07                sbc FrictionAdderLow      ;subtract from it another value set here
00AFCA  1  8D 05 07                sta Player_X_MoveForce    ;store here
00AFCD  1  A5 57                   lda Player_X_Speed
00AFCF  1  ED 01 07                sbc FrictionAdderHigh     ;subtract value plus borrow from horizontal speed
00AFD2  1  85 57                   sta Player_X_Speed        ;set as new horizontal speed
00AFD4  1  CD 50 04                cmp MaximumLeftSpeed      ;compare against maximum value for left movement
00AFD7  1  10 05                   bpl XSpdSign              ;if horizontal speed greater positively, branch
00AFD9  1  AD 50 04                lda MaximumLeftSpeed      ;otherwise set preset value as horizontal speed
00AFDC  1  85 57                   sta Player_X_Speed        ;thus slowing the player's right movement down
00AFDE  1  C9 00        XSpdSign:  cmp #$00                  ;if player not moving or moving to the right,
00AFE0  1  10 05                   bpl SetAbsSpd             ;branch and leave horizontal speed value unmodified
00AFE2  1  49 FF                   eor #$ff
00AFE4  1  18                      clc                       ;otherwise get two's compliment to get absolute
00AFE5  1  69 01                   adc #$01                  ;unsigned walking/running speed
00AFE7  1  8D 00 07     SetAbsSpd: sta Player_XSpeedAbsolute ;store walking/running speed here and leave
00AFEA  1  60                      rts
00AFEB  1               
00AFEB  1               ;-------------------------------------------------------------------------------------
00AFEB  1               ;$00 - used to store downward movement force in FireballObjCore
00AFEB  1               ;$02 - used to store maximum vertical speed in FireballObjCore
00AFEB  1               ;$07 - used to store pseudorandom bit in BubbleCheck
00AFEB  1               
00AFEB  1               ProcFireball_Bubble:
00AFEB  1  AD 56 07           lda PlayerStatus           ;check player's status
00AFEE  1  C9 02              cmp #$02
00AFF0  1  90 43              bcc ProcAirBubbles         ;if not fiery, branch
00AFF2  1  A5 0A              lda A_B_Buttons
00AFF4  1  29 40              and #B_Button              ;check for b button pressed
00AFF6  1  F0 33              beq ProcFireballs          ;branch if not pressed
00AFF8  1  25 0D              and PreviousA_B_Buttons
00AFFA  1  D0 2F              bne ProcFireballs          ;if button pressed in previous frame, branch
00AFFC  1  AD CE 06           lda FireballCounter        ;load fireball counter
00AFFF  1  29 01              and #%00000001             ;get LSB and use as offset for buffer
00B001  1  AA                 tax
00B002  1  B5 24              lda Fireball_State,x       ;load fireball state
00B004  1  D0 25              bne ProcFireballs          ;if not inactive, branch
00B006  1  A4 B5              ldy Player_Y_HighPos       ;if player too high or too low, branch
00B008  1  88                 dey
00B009  1  D0 20              bne ProcFireballs
00B00B  1  AD 14 07           lda CrouchingFlag          ;if player crouching, branch
00B00E  1  D0 1B              bne ProcFireballs
00B010  1  A5 1D              lda Player_State           ;if player's state = climbing, branch
00B012  1  C9 03              cmp #$03
00B014  1  F0 15              beq ProcFireballs
00B016  1  A9 20              lda #Sfx_Fireball          ;play fireball sound effect
00B018  1  85 FF              sta Square1SoundQueue
00B01A  1  A9 02              lda #$02                   ;load state
00B01C  1  95 24              sta Fireball_State,x
00B01E  1  AC 0C 07           ldy PlayerAnimTimerSet     ;copy animation frame timer setting
00B021  1  8C 11 07           sty FireballThrowingTimer  ;into fireball throwing timer
00B024  1  88                 dey
00B025  1  8C 81 07           sty PlayerAnimTimer        ;decrement and store in player's animation timer
00B028  1  EE CE 06           inc FireballCounter        ;increment fireball counter
00B02B  1               
00B02B  1               ProcFireballs:
00B02B  1  A2 00              ldx #$00
00B02D  1  20 50 B0           jsr FireballObjCore  ;process first fireball object
00B030  1  A2 01              ldx #$01
00B032  1  20 50 B0           jsr FireballObjCore  ;process second fireball object, then do air bubbles
00B035  1               
00B035  1               ProcAirBubbles:
00B035  1  AD 4E 07               lda AreaType                ;if not water type level, skip the rest of this
00B038  1  D0 13                  bne BublExit
00B03A  1  A2 02                  ldx #$02                    ;otherwise load counter and use as offset
00B03C  1  86 08        BublLoop: stx ObjectOffset            ;store offset
00B03E  1  20 C0 B0               jsr BubbleCheck             ;check timers and coordinates, create air bubble
00B041  1  20 A1 EC               jsr RelativeBubblePosition  ;get relative coordinates
00B044  1  20 01 ED               jsr GetBubbleOffscreenBits  ;get offscreen information
00B047  1  20 71 E9               jsr DrawBubble              ;draw the air bubble
00B04A  1  CA                     dex
00B04B  1  10 EF                  bpl BublLoop                ;do this until all three are handled
00B04D  1  60           BublExit: rts                         ;then leave
00B04E  1               
00B04E  1               FireballXSpdData:
00B04E  1  40 C0              .byte $40, $c0
00B050  1               
00B050  1               FireballObjCore:
00B050  1  86 08                 stx ObjectOffset             ;store offset as current object
00B052  1  B5 24                 lda Fireball_State,x         ;check for d7 = 1
00B054  1  0A                    asl
00B055  1  B0 63                 bcs FireballExplosion        ;if so, branch to get relative coordinates and draw explosion
00B057  1  B4 24                 ldy Fireball_State,x         ;if fireball inactive, branch to leave
00B059  1  F0 5E                 beq NoFBall
00B05B  1  88                    dey                          ;if fireball state set to 1, skip this part and just run it
00B05C  1  F0 27                 beq RunFB
00B05E  1  A5 86                 lda Player_X_Position        ;get player's horizontal position
00B060  1  69 04                 adc #$04                     ;add four pixels and store as fireball's horizontal position
00B062  1  95 8D                 sta Fireball_X_Position,x
00B064  1  A5 6D                 lda Player_PageLoc           ;get player's page location
00B066  1  69 00                 adc #$00                     ;add carry and store as fireball's page location
00B068  1  95 74                 sta Fireball_PageLoc,x
00B06A  1  A5 CE                 lda Player_Y_Position        ;get player's vertical position and store
00B06C  1  95 D5                 sta Fireball_Y_Position,x
00B06E  1  A9 01                 lda #$01                     ;set high byte of vertical position
00B070  1  95 BC                 sta Fireball_Y_HighPos,x
00B072  1  A4 33                 ldy PlayerFacingDir          ;get player's facing direction
00B074  1  88                    dey                          ;decrement to use as offset here
00B075  1  B9 4E B0              lda FireballXSpdData,y       ;set horizontal speed of fireball accordingly
00B078  1  95 5E                 sta Fireball_X_Speed,x
00B07A  1  A9 04                 lda #$04                     ;set vertical speed of fireball
00B07C  1  95 A6                 sta Fireball_Y_Speed,x
00B07E  1  A9 07                 lda #$07
00B080  1  9D A0 04              sta Fireball_BoundBoxCtrl,x  ;set bounding box size control for fireball
00B083  1  D6 24                 dec Fireball_State,x         ;decrement state to 1 to skip this part from now on
00B085  1  8A           RunFB:   txa                          ;add 7 to offset to use
00B086  1  18                    clc                          ;as fireball offset for next routines
00B087  1  69 07                 adc #$07
00B089  1  AA                    tax
00B08A  1  A9 50                 lda #$50                     ;set downward movement force here
00B08C  1  85 00                 sta $00
00B08E  1  A9 03                 lda #$03                     ;set maximum speed here
00B090  1  85 02                 sta $02
00B092  1  A9 00                 lda #$00
00B094  1  20 8E C0              jsr ImposeGravity            ;do sub here to impose gravity on fireball and move vertically
00B097  1  20 C6 BF              jsr MoveObjectHorizontally   ;do another sub to move it horizontally
00B09A  1  A6 08                 ldx ObjectOffset             ;return fireball offset to X
00B09C  1  20 AB EC              jsr RelativeFireballPosition ;get relative coordinates
00B09F  1  20 F7 EC              jsr GetFireballOffscreenBits ;get offscreen information
00B0A2  1  20 BD DD              jsr GetFireballBoundBox      ;get bounding box coordinates
00B0A5  1  20 58 DD              jsr FireballBGCollision      ;do fireball to background collision detection
00B0A8  1  AD D2 03              lda FBall_OffscreenBits      ;get fireball offscreen bits
00B0AB  1  29 CC                 and #%11001100               ;mask out certain bits
00B0AD  1  D0 06                 bne EraseFB                  ;if any bits still set, branch to kill fireball
00B0AF  1  20 CC D2              jsr FireballEnemyCollision   ;do fireball to enemy collision detection and deal with collisions
00B0B2  1  4C 6E E8              jmp DrawFireball             ;draw fireball appropriately and leave
00B0B5  1  A9 00        EraseFB: lda #$00                     ;erase fireball state
00B0B7  1  95 24                 sta Fireball_State,x
00B0B9  1  60           NoFBall: rts                          ;leave
00B0BA  1               
00B0BA  1               FireballExplosion:
00B0BA  1  20 AB EC           jsr RelativeFireballPosition
00B0BD  1  4C 99 E8           jmp DrawExplosion_Fireball
00B0C0  1               
00B0C0  1               BubbleCheck:
00B0C0  1  BD A8 07           lda PseudoRandomBitReg+1,x  ;get part of LSFR
00B0C3  1  29 01              and #$01
00B0C5  1  85 07              sta $07                     ;store pseudorandom bit here
00B0C7  1  B5 E4              lda Bubble_Y_Position,x     ;get vertical coordinate for air bubble
00B0C9  1  C9 F8              cmp #$f8                    ;if offscreen coordinate not set,
00B0CB  1  D0 2C              bne MoveBubl                ;branch to move air bubble
00B0CD  1  AD 92 07           lda AirBubbleTimer          ;if air bubble timer not expired,
00B0D0  1  D0 3F              bne ExitBubl                ;branch to leave, otherwise create new air bubble
00B0D2  1               
00B0D2  1               SetupBubble:
00B0D2  1  A0 00                  ldy #$00                 ;load default value here
00B0D4  1  A5 33                  lda PlayerFacingDir      ;get player's facing direction
00B0D6  1  4A                     lsr                      ;move d0 to carry
00B0D7  1  90 02                  bcc PosBubl              ;branch to use default value if facing left
00B0D9  1  A0 08                  ldy #$08                 ;otherwise load alternate value here
00B0DB  1  98           PosBubl:  tya                      ;use value loaded as adder
00B0DC  1  65 86                  adc Player_X_Position    ;add to player's horizontal position
00B0DE  1  95 9C                  sta Bubble_X_Position,x  ;save as horizontal position for airbubble
00B0E0  1  A5 6D                  lda Player_PageLoc
00B0E2  1  69 00                  adc #$00                 ;add carry to player's page location
00B0E4  1  95 83                  sta Bubble_PageLoc,x     ;save as page location for airbubble
00B0E6  1  A5 CE                  lda Player_Y_Position
00B0E8  1  18                     clc                      ;add eight pixels to player's vertical position
00B0E9  1  69 08                  adc #$08
00B0EB  1  95 E4                  sta Bubble_Y_Position,x  ;save as vertical position for air bubble
00B0ED  1  A9 01                  lda #$01
00B0EF  1  95 CB                  sta Bubble_Y_HighPos,x   ;set vertical high byte for air bubble
00B0F1  1  A4 07                  ldy $07                  ;get pseudorandom bit, use as offset
00B0F3  1  B9 14 B1               lda BubbleTimerData,y    ;get data for air bubble timer
00B0F6  1  8D 92 07               sta AirBubbleTimer       ;set air bubble timer
00B0F9  1  A4 07        MoveBubl: ldy $07                  ;get pseudorandom bit again, use as offset
00B0FB  1  BD 2C 04               lda Bubble_YMF_Dummy,x
00B0FE  1  38                     sec                      ;subtract pseudorandom amount from dummy variable
00B0FF  1  F9 12 B1               sbc Bubble_MForceData,y
00B102  1  9D 2C 04               sta Bubble_YMF_Dummy,x   ;save dummy variable
00B105  1  B5 E4                  lda Bubble_Y_Position,x
00B107  1  E9 00                  sbc #$00                 ;subtract borrow from airbubble's vertical coordinate
00B109  1  C9 20                  cmp #$20                 ;if below the status bar,
00B10B  1  B0 02                  bcs Y_Bubl               ;branch to go ahead and use to move air bubble upwards
00B10D  1  A9 F8                  lda #$f8                 ;otherwise set offscreen coordinate
00B10F  1  95 E4        Y_Bubl:   sta Bubble_Y_Position,x  ;store as new vertical coordinate for air bubble
00B111  1  60           ExitBubl: rts                      ;leave
00B112  1               
00B112  1               Bubble_MForceData:
00B112  1  FF 50              .byte $ff, $50
00B114  1               
00B114  1               BubbleTimerData:
00B114  1  40 20              .byte $40, $20
00B116  1               
00B116  1               ;-------------------------------------------------------------------------------------
00B116  1               
00B116  1               RunGameTimer:
00B116  1  AD 70 07                lda OperMode               ;get primary mode of operation
00B119  1  F0 43                   beq ExGTimer               ;branch to leave if in title screen mode
00B11B  1  A5 0E                   lda GameEngineSubroutine
00B11D  1  C9 08                   cmp #$08                   ;if routine number less than eight running,
00B11F  1  90 3D                   bcc ExGTimer               ;branch to leave
00B121  1  C9 0B                   cmp #$0b                   ;if running death routine,
00B123  1  F0 39                   beq ExGTimer               ;branch to leave
00B125  1  A5 B5                   lda Player_Y_HighPos
00B127  1  C9 02                   cmp #$02                   ;if player below the screen,
00B129  1  B0 33                   bcs ExGTimer               ;branch to leave regardless of level type
00B12B  1  AD 87 07                lda GameTimerCtrlTimer     ;if game timer control not yet expired,
00B12E  1  D0 2E                   bne ExGTimer               ;branch to leave
00B130  1  AD F8 07                lda GameTimerDisplay
00B133  1  0D F9 07                ora GameTimerDisplay+1     ;otherwise check game timer digits
00B136  1  0D FA 07                ora GameTimerDisplay+2
00B139  1  F0 1A                   beq TimeUpOn               ;if game timer digits at 000, branch to time-up code
00B13B  1  AC F8 07                ldy GameTimerDisplay       ;otherwise check first digit
00B13E  1  88                      dey                        ;if first digit not on 1,
00B13F  1  D0 0C                   bne ResGTCtrl              ;branch to reset game timer control
00B141  1  AD F9 07                lda GameTimerDisplay+1     ;otherwise check second and third digits
00B144  1  0D FA 07                ora GameTimerDisplay+2
00B147  1  D0 04                   bne ResGTCtrl              ;if timer not at 100, branch to reset game timer control
00B149  1  A9 40                   lda #TimeRunningOutMusic
00B14B  1  85 FC                   sta EventMusicQueue        ;otherwise load time running out music
00B14D  1  A9 18        ResGTCtrl: lda #$18                   ;reset game timer control
00B14F  1  8D 87 07                sta GameTimerCtrlTimer
00B152  1  4C 18 FE                jmp Enter_UpdateGameTimer  ;do sub to update the display
00B155  1  8D 56 07     TimeUpOn:  sta PlayerStatus           ;init player status (note A will always be zero here)
00B158  1  20 24 D5                jsr ForceInjury            ;do sub to kill the player (note player is small here)
00B15B  1  EE 59 07                inc GameTimerExpiredFlag   ;set game timer expiration flag
00B15E  1  60           ExGTimer:  rts                        ;leave
00B15F  1               
00B15F  1               ;-------------------------------------------------------------------------------------
00B15F  1               ;$00 - used in WhirlpoolActivate to store whirlpool length / 2, page location of center of whirlpool
00B15F  1               ;and also to store movement force exerted on player
00B15F  1               ;$01 - used in ProcessWhirlpools to store page location of right extent of whirlpool
00B15F  1               ;and in WhirlpoolActivate to store center of whirlpool
00B15F  1               ;$02 - used in ProcessWhirlpools to store right extent of whirlpool and in
00B15F  1               ;WhirlpoolActivate to store maximum vertical speed
00B15F  1               
00B15F  1               ProcessWhirlpools:
00B15F  1  AD 4E 07             lda AreaType                ;check for water type level
00B162  1  D0 37                bne ExitWh                  ;branch to leave if not found
00B164  1  8D 7D 04             sta Whirlpool_Flag          ;otherwise initialize whirlpool flag
00B167  1  AD 47 07             lda TimerControl            ;if master timer control set,
00B16A  1  D0 2F                bne ExitWh                  ;branch to leave
00B16C  1  A0 04                ldy #$04                    ;otherwise start with last whirlpool data
00B16E  1  B9 71 04     WhLoop: lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
00B171  1  18                   clc
00B172  1  79 77 04             adc Whirlpool_Length,y      ;add length of whirlpool
00B175  1  85 02                sta $02                     ;store result as right extent here
00B177  1  B9 6B 04             lda Whirlpool_PageLoc,y     ;get page location
00B17A  1  F0 1C                beq NextWh                  ;if none or page 0, branch to get next data
00B17C  1  69 00                adc #$00                    ;add carry
00B17E  1  85 01                sta $01                     ;store result as page location of right extent here
00B180  1  A5 86                lda Player_X_Position       ;get player's horizontal position
00B182  1  38                   sec
00B183  1  F9 71 04             sbc Whirlpool_LeftExtent,y  ;subtract left extent
00B186  1  A5 6D                lda Player_PageLoc          ;get player's page location
00B188  1  F9 6B 04             sbc Whirlpool_PageLoc,y     ;subtract borrow
00B18B  1  30 0B                bmi NextWh                  ;if player too far left, branch to get next data
00B18D  1  A5 02                lda $02                     ;otherwise get right extent
00B18F  1  38                   sec
00B190  1  E5 86                sbc Player_X_Position       ;subtract player's horizontal coordinate
00B192  1  A5 01                lda $01                     ;get right extent's page location
00B194  1  E5 6D                sbc Player_PageLoc          ;subtract borrow
00B196  1  10 04                bpl WhirlpoolActivate       ;if player within right extent, branch to whirlpool code
00B198  1  88           NextWh: dey                         ;move onto next whirlpool data
00B199  1  10 D3                bpl WhLoop                  ;do this until all whirlpools are checked
00B19B  1  60           ExitWh: rts                         ;leave
00B19C  1               
00B19C  1               WhirlpoolActivate:
00B19C  1  B9 77 04             lda Whirlpool_Length,y      ;get length of whirlpool
00B19F  1  4A                   lsr                         ;divide by 2
00B1A0  1  85 00                sta $00                     ;save here
00B1A2  1  B9 71 04             lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
00B1A5  1  18                   clc
00B1A6  1  65 00                adc $00                     ;add length divided by 2
00B1A8  1  85 01                sta $01                     ;save as center of whirlpool
00B1AA  1  B9 6B 04             lda Whirlpool_PageLoc,y     ;get page location
00B1AD  1  69 00                adc #$00                    ;add carry
00B1AF  1  85 00                sta $00                     ;save as page location of whirlpool center
00B1B1  1  A5 09                lda FrameCounter            ;get frame counter
00B1B3  1  4A                   lsr                         ;shift d0 into carry (to run on every other frame)
00B1B4  1  90 2C                bcc WhPull                  ;if d0 not set, branch to last part of code
00B1B6  1  A5 01                lda $01                     ;get center
00B1B8  1  38                   sec
00B1B9  1  E5 86                sbc Player_X_Position       ;subtract player's horizontal coordinate
00B1BB  1  A5 00                lda $00                     ;get page location of center
00B1BD  1  E5 6D                sbc Player_PageLoc          ;subtract borrow
00B1BF  1  10 0E                bpl LeftWh                  ;if player to the left of center, branch
00B1C1  1  A5 86                lda Player_X_Position       ;otherwise slowly pull player left, towards the center
00B1C3  1  38                   sec
00B1C4  1  E9 01                sbc #$01                    ;subtract one pixel
00B1C6  1  85 86                sta Player_X_Position       ;set player's new horizontal coordinate
00B1C8  1  A5 6D                lda Player_PageLoc
00B1CA  1  E9 00                sbc #$00                    ;subtract borrow
00B1CC  1  4C E0 B1             jmp SetPWh                  ;jump to set player's new page location
00B1CF  1  AD 90 04     LeftWh: lda Player_CollisionBits    ;get player's collision bits
00B1D2  1  4A                   lsr                         ;shift d0 into carry
00B1D3  1  90 0D                bcc WhPull                  ;if d0 not set, branch
00B1D5  1  A5 86                lda Player_X_Position       ;otherwise slowly pull player right, towards the center
00B1D7  1  18                   clc
00B1D8  1  69 01                adc #$01                    ;add one pixel
00B1DA  1  85 86                sta Player_X_Position       ;set player's new horizontal coordinate
00B1DC  1  A5 6D                lda Player_PageLoc
00B1DE  1  69 00                adc #$00                    ;add carry
00B1E0  1  85 6D        SetPWh: sta Player_PageLoc          ;set player's new page location
00B1E2  1  A9 10        WhPull: lda #$10
00B1E4  1  85 00                sta $00                     ;set vertical movement force
00B1E6  1  A9 01                lda #$01
00B1E8  1  8D 7D 04             sta Whirlpool_Flag          ;set whirlpool flag to be used later
00B1EB  1  85 02                sta $02                     ;also set maximum vertical speed
00B1ED  1  4A                   lsr
00B1EE  1  AA                   tax                         ;set X for player offset
00B1EF  1  4C 8E C0             jmp ImposeGravity           ;jump to put whirlpool effect on player vertically, do not return
00B1F2  1               
00B1F2  1               ;-------------------------------------------------------------------------------------
00B1F2  1               
00B1F2  1               FlagpoleScoreMods:
00B1F2  1  05 02 08 04        .byte $05, $02, $08, $04, $01
00B1F6  1  01           
00B1F7  1               
00B1F7  1               FlagpoleScoreDigits:
00B1F7  1  03 03 04 04        .byte $03, $03, $04, $04, $04
00B1FB  1  04           
00B1FC  1               
00B1FC  1               FlagpoleRoutine:
00B1FC  1  A2 05                   ldx #$05                  ;set enemy object offset
00B1FE  1  86 08                   stx ObjectOffset          ;to special use slot
00B200  1  B5 16                   lda Enemy_ID,x
00B202  1  C9 30                   cmp #FlagpoleFlagObject   ;if flagpole flag not found,
00B204  1  D0 56                   bne ExitFlagP             ;branch to leave
00B206  1  A5 0E                   lda GameEngineSubroutine
00B208  1  C9 04                   cmp #$04                  ;if flagpole slide routine not running,
00B20A  1  D0 31                   bne SkipScore             ;branch to near the end of code
00B20C  1  A5 1D                   lda Player_State
00B20E  1  C9 03                   cmp #$03                  ;if player state not climbing,
00B210  1  D0 2B                   bne SkipScore             ;branch to near the end of code
00B212  1  B5 CF                   lda Enemy_Y_Position,x    ;check flagpole flag's vertical coordinate
00B214  1  C9 AA                   cmp #$aa                  ;if flagpole flag down to a certain point,
00B216  1  B0 28                   bcs GiveFPScr             ;branch to end the level
00B218  1  A5 CE                   lda Player_Y_Position     ;check player's vertical coordinate
00B21A  1  C9 A2                   cmp #$a2                  ;if player down to a certain point,
00B21C  1  B0 22                   bcs GiveFPScr             ;branch to end the level
00B21E  1  BD 17 04                lda Enemy_YMF_Dummy,x
00B221  1  69 FF                   adc #$ff                  ;add movement amount to dummy variable
00B223  1  9D 17 04                sta Enemy_YMF_Dummy,x     ;save dummy variable
00B226  1  B5 CF                   lda Enemy_Y_Position,x    ;get flag's vertical coordinate
00B228  1  69 01                   adc #$01                  ;add 1 plus carry to move flag, and
00B22A  1  95 CF                   sta Enemy_Y_Position,x    ;store vertical coordinate
00B22C  1  AD 0E 01                lda FlagpoleFNum_YMFDummy
00B22F  1  38                      sec                       ;subtract movement amount from dummy variable
00B230  1  E9 FF                   sbc #$ff
00B232  1  8D 0E 01                sta FlagpoleFNum_YMFDummy ;save dummy variable
00B235  1  AD 0D 01                lda FlagpoleFNum_Y_Pos
00B238  1  E9 01                   sbc #$01                  ;subtract one plus borrow to move floatey number,
00B23A  1  8D 0D 01                sta FlagpoleFNum_Y_Pos    ;and store vertical coordinate here
00B23D  1  4C 53 B2     SkipScore: jmp FPGfx                 ;jump to skip ahead and draw flag and floatey number
00B240  1  AC 0F 01     GiveFPScr: ldy FlagpoleScore         ;get score offset from earlier (when player touched flagpole)
00B243  1  B9 F2 B1                lda FlagpoleScoreMods,y   ;get amount to award player points
00B246  1  BE F7 B1                ldx FlagpoleScoreDigits,y ;get digit with which to award points
00B249  1  9D 34 01                sta DigitModifier,x       ;store in digit modifier
00B24C  1  20 DE BC                jsr AddToScore            ;do sub to award player points depending on height of collision
00B24F  1  A9 05                   lda #$05
00B251  1  85 0E                   sta GameEngineSubroutine  ;set to run end-of-level subroutine on next frame
00B253  1  20 1F ED     FPGfx:     jsr GetEnemyOffscreenBits ;get offscreen information
00B256  1  20 C2 EC                jsr RelativeEnemyPosition ;get relative coordinates
00B259  1  20 DB E0                jsr FlagpoleGfxHandler    ;draw flagpole flag and floatey number
00B25C  1  60           ExitFlagP: rts
00B25D  1               
00B25D  1               ;-------------------------------------------------------------------------------------
00B25D  1               
00B25D  1               CannonBitmasks:
00B25D  1  0F 07              .byte %00001111, %00000111
00B25F  1               
00B25F  1               ProcessCannons:
00B25F  1  AD 4E 07                lda AreaType                ;get area type
00B262  1  F0 6F                   beq ExCannon                ;if water type area, branch to leave
00B264  1  A2 02                   ldx #$02
00B266  1  86 08        ThreeSChk: stx ObjectOffset            ;start at third enemy slot
00B268  1  B5 0F                   lda Enemy_Flag,x            ;check enemy buffer flag
00B26A  1  D0 51                   bne Chk_BB                  ;if set, branch to check enemy
00B26C  1  BD A8 07                lda PseudoRandomBitReg+1,x  ;otherwise get part of LSFR
00B26F  1  AC CC 06                ldy SecondaryHardMode       ;get secondary hard mode flag, use as offset
00B272  1  39 5D B2                and CannonBitmasks,y        ;mask out bits of LSFR as decided by flag
00B275  1  C9 06                   cmp #$06                    ;check to see if lower nybble is above certain value
00B277  1  B0 44                   bcs Chk_BB                  ;if so, branch to check enemy
00B279  1  A8                      tay                         ;transfer masked contents of LSFR to Y as pseudorandom offset
00B27A  1  B9 6B 04                lda Cannon_PageLoc,y        ;get page location
00B27D  1  F0 3E                   beq Chk_BB                  ;if not set or on page 0, branch to check enemy
00B27F  1  B9 7D 04                lda Cannon_Timer,y          ;get cannon timer
00B282  1  F0 08                   beq FireCannon              ;if expired, branch to fire cannon
00B284  1  E9 00                   sbc #$00                    ;otherwise subtract borrow (note carry will always be clear here)
00B286  1  99 7D 04                sta Cannon_Timer,y          ;to count timer down
00B289  1  4C BD B2                jmp Chk_BB                  ;then jump ahead to check enemy
00B28C  1               
00B28C  1               FireCannon:
00B28C  1  AD 47 07               lda TimerControl           ;if master timer control set,
00B28F  1  D0 2C                  bne Chk_BB                 ;branch to check enemy
00B291  1  A9 0E                  lda #$0e                   ;otherwise we start creating one
00B293  1  99 7D 04               sta Cannon_Timer,y         ;first, reset cannon timer
00B296  1  B9 6B 04               lda Cannon_PageLoc,y       ;get page location of cannon
00B299  1  95 6E                  sta Enemy_PageLoc,x        ;save as page location of bullet bill
00B29B  1  B9 71 04               lda Cannon_X_Position,y    ;get horizontal coordinate of cannon
00B29E  1  95 87                  sta Enemy_X_Position,x     ;save as horizontal coordinate of bullet bill
00B2A0  1  B9 77 04               lda Cannon_Y_Position,y    ;get vertical coordinate of cannon
00B2A3  1  38                     sec
00B2A4  1  E9 08                  sbc #$08                   ;subtract eight pixels (because enemies are 24 pixels tall)
00B2A6  1  95 CF                  sta Enemy_Y_Position,x     ;save as vertical coordinate of bullet bill
00B2A8  1  A9 01                  lda #$01
00B2AA  1  95 B6                  sta Enemy_Y_HighPos,x      ;set vertical high byte of bullet bill
00B2AC  1  95 0F                  sta Enemy_Flag,x           ;set buffer flag
00B2AE  1  4A                     lsr                        ;shift right once to init A
00B2AF  1  95 1E                  sta Enemy_State,x          ;then initialize enemy's state
00B2B1  1  A9 09                  lda #$09
00B2B3  1  9D 9A 04               sta Enemy_BoundBoxCtrl,x   ;set bounding box size control for bullet bill
00B2B6  1  A9 33                  lda #BulletBill_CannonVar
00B2B8  1  95 16                  sta Enemy_ID,x             ;load identifier for bullet bill (cannon variant)
00B2BA  1  4C D0 B2               jmp Next3Slt               ;move onto next slot
00B2BD  1  B5 16        Chk_BB:   lda Enemy_ID,x             ;check enemy identifier for bullet bill (cannon variant)
00B2BF  1  C9 33                  cmp #BulletBill_CannonVar
00B2C1  1  D0 0D                  bne Next3Slt               ;if not found, branch to get next slot
00B2C3  1  20 6D D2               jsr OffscreenBoundsCheck   ;otherwise, check to see if it went offscreen
00B2C6  1  B5 0F                  lda Enemy_Flag,x           ;check enemy buffer flag
00B2C8  1  F0 06                  beq Next3Slt               ;if not set, branch to get next slot
00B2CA  1  20 1F ED               jsr GetEnemyOffscreenBits  ;otherwise, get offscreen information
00B2CD  1  20 D6 B2               jsr BulletBillHandler      ;then do sub to handle bullet bill
00B2D0  1  CA           Next3Slt: dex                        ;move onto next slot
00B2D1  1  10 93                  bpl ThreeSChk              ;do this until first three slots are checked
00B2D3  1  60           ExCannon: rts                        ;then leave
00B2D4  1               
00B2D4  1               ;--------------------------------
00B2D4  1               
00B2D4  1               BulletBillXSpdData:
00B2D4  1  18 E8              .byte $18, $e8
00B2D6  1               
00B2D6  1               BulletBillHandler:
00B2D6  1  AD 47 07                lda TimerControl          ;if master timer control set,
00B2D9  1  D0 3E                   bne RunBBSubs             ;branch to run subroutines except movement sub
00B2DB  1  B5 1E                   lda Enemy_State,x
00B2DD  1  D0 2E                   bne ChkDSte               ;if bullet bill's state set, branch to check defeated state
00B2DF  1  AD D1 03                lda Enemy_OffscreenBits   ;otherwise load offscreen bits
00B2E2  1  29 0C                   and #%00001100            ;mask out bits
00B2E4  1  C9 0C                   cmp #%00001100            ;check to see if all bits are set
00B2E6  1  F0 40                   beq KillBB                ;if so, branch to kill this object
00B2E8  1  A0 01                   ldy #$01                  ;set to move right by default
00B2EA  1  20 D3 DC                jsr PlayerEnemyDiff       ;get horizontal difference between player and bullet bill
00B2ED  1  30 01                   bmi SetupBB               ;if enemy to the left of player, branch
00B2EF  1  C8                      iny                       ;otherwise increment to move left
00B2F0  1  94 46        SetupBB:   sty Enemy_MovingDir,x     ;set bullet bill's moving direction
00B2F2  1  88                      dey                       ;decrement to use as offset
00B2F3  1  B9 D4 B2                lda BulletBillXSpdData,y  ;get horizontal speed based on moving direction
00B2F6  1  95 58                   sta Enemy_X_Speed,x       ;and store it
00B2F8  1  A5 00                   lda $00                   ;get horizontal difference
00B2FA  1  69 28                   adc #$28                  ;add 40 pixels
00B2FC  1  C9 50                   cmp #$50                  ;if less than a certain amount, player is too close
00B2FE  1  90 28                   bcc KillBB                ;to cannon either on left or right side, thus branch
00B300  1  A9 01                   lda #$01
00B302  1  95 1E                   sta Enemy_State,x         ;otherwise set bullet bill's state
00B304  1  A9 0A                   lda #$0a
00B306  1  9D 8A 07                sta EnemyFrameTimer,x     ;set enemy frame timer
00B309  1  A9 08                   lda #Sfx_Blast
00B30B  1  85 FE                   sta Square2SoundQueue     ;play fireworks/gunfire sound
00B30D  1  B5 1E        ChkDSte:   lda Enemy_State,x         ;check enemy state for d5 set
00B30F  1  29 20                   and #%00100000
00B311  1  F0 03                   beq BBFly                 ;if not set, skip to move horizontally
00B313  1  20 1A C0                jsr MoveD_EnemyVertically ;otherwise do sub to move bullet bill vertically
00B316  1  20 B9 BF     BBFly:     jsr MoveEnemyHorizontally ;do sub to move bullet bill horizontally
00B319  1  20 1F ED     RunBBSubs: jsr GetEnemyOffscreenBits ;get offscreen information
00B31C  1  20 C2 EC                jsr RelativeEnemyPosition ;get relative coordinates
00B31F  1  20 D3 DD                jsr GetEnemyBoundBox      ;get bounding box coordinates
00B322  1  20 46 D4                jsr PlayerEnemyCollision  ;handle player to enemy collisions
00B325  1  4C 0D E4                jmp EnemyGfxHandler       ;draw the bullet bill and leave
00B328  1  20 A3 C6     KillBB:    jsr EraseEnemyObject      ;kill bullet bill and leave
00B32B  1  60                      rts
00B32C  1               
00B32C  1               ;--------------------------------
00B32C  1               ;$00 - used to set downward force
00B32C  1               ;$01 - used to set upward force (residual)
00B32C  1               ;$02 - used to set maximum speed
00B32C  1               
00B32C  1               ProcHammerObj:
00B32C  1  AD 47 07               lda TimerControl           ;if master timer control set
00B32F  1  D0 63                  bne RunHSubs               ;skip all of this code and go to last subs at the end
00B331  1  B5 2A                  lda Misc_State,x           ;otherwise get hammer's state
00B333  1  29 7F                  and #%01111111             ;mask out d7
00B335  1  BC AE 06               ldy HammerEnemyOffset,x    ;get enemy object offset that spawned this hammer
00B338  1  C9 02                  cmp #$02                   ;check hammer's state
00B33A  1  F0 20                  beq SetHSpd                ;if currently at 2, branch
00B33C  1  B0 34                  bcs SetHPos                ;if greater than 2, branch elsewhere
00B33E  1  8A                     txa
00B33F  1  18                     clc                        ;add 13 bytes to use
00B340  1  69 0D                  adc #$0d                   ;proper misc object
00B342  1  AA                     tax                        ;return offset to X
00B343  1  A9 10                  lda #$10
00B345  1  85 00                  sta $00                    ;set downward movement force
00B347  1  A9 0F                  lda #$0f
00B349  1  85 01                  sta $01                    ;set upward movement force (not used)
00B34B  1  A9 04                  lda #$04
00B34D  1  85 02                  sta $02                    ;set maximum vertical speed
00B34F  1  A9 00                  lda #$00                   ;set A to impose gravity on hammer
00B351  1  20 8E C0               jsr ImposeGravity          ;do sub to impose gravity on hammer and move vertically
00B354  1  20 C6 BF               jsr MoveObjectHorizontally ;do sub to move it horizontally
00B357  1  A6 08                  ldx ObjectOffset           ;get original misc object offset
00B359  1  4C 91 B3               jmp RunAllH                ;branch to essential subroutines
00B35C  1  A9 FE        SetHSpd:  lda #$fe
00B35E  1  95 AC                  sta Misc_Y_Speed,x         ;set hammer's vertical speed
00B360  1  B9 1E 00               lda Enemy_State,y          ;get enemy object state
00B363  1  29 F7                  and #%11110111             ;mask out d3
00B365  1  99 1E 00               sta Enemy_State,y          ;store new state
00B368  1  B6 46                  ldx Enemy_MovingDir,y      ;get enemy's moving direction
00B36A  1  CA                     dex                        ;decrement to use as offset
00B36B  1  BD 4F F1               lda HammerXSpdData,x       ;get proper speed to use based on moving direction
00B36E  1  A6 08                  ldx ObjectOffset           ;reobtain hammer's buffer offset
00B370  1  95 64                  sta Misc_X_Speed,x         ;set hammer's horizontal speed
00B372  1  D6 2A        SetHPos:  dec Misc_State,x           ;decrement hammer's state
00B374  1  B9 87 00               lda Enemy_X_Position,y     ;get enemy's horizontal position
00B377  1  18                     clc
00B378  1  69 02                  adc #$02                   ;set position 2 pixels to the right
00B37A  1  95 93                  sta Misc_X_Position,x      ;store as hammer's horizontal position
00B37C  1  B9 6E 00               lda Enemy_PageLoc,y        ;get enemy's page location
00B37F  1  69 00                  adc #$00                   ;add carry
00B381  1  95 7A                  sta Misc_PageLoc,x         ;store as hammer's page location
00B383  1  B9 CF 00               lda Enemy_Y_Position,y     ;get enemy's vertical position
00B386  1  38                     sec
00B387  1  E9 0A                  sbc #$0a                   ;move position 10 pixels upward
00B389  1  95 DB                  sta Misc_Y_Position,x      ;store as hammer's vertical position
00B38B  1  A9 01                  lda #$01
00B38D  1  95 C2                  sta Misc_Y_HighPos,x       ;set hammer's vertical high byte
00B38F  1  D0 03                  bne RunHSubs               ;unconditional branch to skip first routine
00B391  1  20 B7 D3     RunAllH:  jsr PlayerHammerCollision  ;handle collisions
00B394  1  20 0B ED     RunHSubs: jsr GetMiscOffscreenBits   ;get offscreen information
00B397  1  20 B8 EC               jsr RelativeMiscPosition   ;get relative coordinates
00B39A  1  20 C6 DD               jsr GetMiscBoundBox        ;get bounding box coordinates
00B39D  1  20 6C E0               jsr DrawHammer             ;draw the hammer
00B3A0  1  60                     rts                        ;and we are done here
00B3A1  1               
00B3A1  1               ;-------------------------------------------------------------------------------------
00B3A1  1               
00B3A1  1               MiscObjectsCore:
00B3A1  1  A2 08                  ldx #$08          ;set at end of misc object buffer
00B3A3  1  86 08        MiscLoop: stx ObjectOffset  ;store misc object offset here
00B3A5  1  B5 2A                  lda Misc_State,x  ;check misc object state
00B3A7  1  F0 56                  beq MiscLoopBack  ;branch to check next slot
00B3A9  1  0A                     asl               ;otherwise shift d7 into carry
00B3AA  1  90 06                  bcc ProcJumpCoin  ;if d7 not set, jumping coin, thus skip to rest of code here
00B3AC  1  20 2C B3               jsr ProcHammerObj ;otherwise go to process hammer,
00B3AF  1  4C FF B3               jmp MiscLoopBack  ;then check next slot
00B3B2  1               
00B3B2  1               ;--------------------------------
00B3B2  1               ;$00 - used to set downward force
00B3B2  1               ;$01 - used to set upward force (residual)
00B3B2  1               ;$02 - used to set maximum speed
00B3B2  1               
00B3B2  1               ProcJumpCoin:
00B3B2  1  B4 2A                   ldy Misc_State,x          ;check misc object state
00B3B4  1  88                      dey                       ;decrement to see if it's set to 1
00B3B5  1  F0 1D                   beq JCoinRun              ;if so, branch to handle jumping coin
00B3B7  1  F6 2A                   inc Misc_State,x          ;otherwise increment state to either start off or as timer
00B3B9  1  B5 93                   lda Misc_X_Position,x     ;get horizontal coordinate for misc object
00B3BB  1  18                      clc                       ;whether its jumping coin (state 0 only) or floatey number
00B3BC  1  6D 75 07                adc ScrollAmount          ;add current scroll speed
00B3BF  1  95 93                   sta Misc_X_Position,x     ;store as new horizontal coordinate
00B3C1  1  B5 7A                   lda Misc_PageLoc,x        ;get page location
00B3C3  1  69 00                   adc #$00                  ;add carry
00B3C5  1  95 7A                   sta Misc_PageLoc,x        ;store as new page location
00B3C7  1  B5 2A                   lda Misc_State,x
00B3C9  1  C9 30                   cmp #$30                  ;check state of object for preset value
00B3CB  1  D0 26                   bne RunJCSubs             ;if not yet reached, branch to subroutines
00B3CD  1  A9 00                   lda #$00
00B3CF  1  95 2A                   sta Misc_State,x          ;otherwise nullify object state
00B3D1  1  4C FF B3                jmp MiscLoopBack          ;and move onto next slot
00B3D4  1  8A           JCoinRun:  txa
00B3D5  1  18                      clc                       ;add 13 bytes to offset for next subroutine
00B3D6  1  69 0D                   adc #$0d
00B3D8  1  AA                      tax
00B3D9  1  A9 50                   lda #$50                  ;set downward movement amount
00B3DB  1  85 00                   sta $00
00B3DD  1  A9 06                   lda #$06                  ;set maximum vertical speed
00B3DF  1  85 02                   sta $02
00B3E1  1  4A                      lsr                       ;divide by 2 and set
00B3E2  1  85 01                   sta $01                   ;as upward movement amount (apparently residual)
00B3E4  1  A9 00                   lda #$00                  ;set A to impose gravity on jumping coin
00B3E6  1  20 8E C0                jsr ImposeGravity         ;do sub to move coin vertically and impose gravity on it
00B3E9  1  A6 08                   ldx ObjectOffset          ;get original misc object offset
00B3EB  1  B5 AC                   lda Misc_Y_Speed,x        ;check vertical speed
00B3ED  1  C9 05                   cmp #$05
00B3EF  1  D0 02                   bne RunJCSubs             ;if not moving downward fast enough, keep state as-is
00B3F1  1  F6 2A                   inc Misc_State,x          ;otherwise increment state to change to floatey number
00B3F3  1  20 B8 EC     RunJCSubs: jsr RelativeMiscPosition  ;get relative coordinates
00B3F6  1  20 0B ED                jsr GetMiscOffscreenBits  ;get offscreen information
00B3F9  1  20 C6 DD                jsr GetMiscBoundBox       ;get bounding box coordinates (why?)
00B3FC  1  20 16 E2                jsr JCoinGfxHandler       ;draw the coin or floatey number
00B3FF  1               
00B3FF  1               MiscLoopBack:
00B3FF  1  CA                      dex                       ;decrement misc object offset
00B400  1  10 A1                   bpl MiscLoop              ;loop back until all misc objects handled
00B402  1  60                      rts                       ;then leave
00B403  1               
00B403  1               ;-------------------------------------------------------------------------------------
00B403  1               
00B403  1               EnemyAddrHOffsets:
00B403  1  1F 06 1C 00        .byte $1f, $06, $1c, $00
00B407  1               
00B407  1               GetAreaDataAddrs:
00B407  1  AD 50 07                 lda AreaPointer          ;use 2 MSB for Y
00B40A  1  20 58 BC                 jsr GetAreaType
00B40D  1  A8                       tay
00B40E  1  AD 50 07                 lda AreaPointer          ;mask out all but 5 LSB
00B411  1  29 1F                    and #%00011111
00B413  1  8D 4F 07                 sta AreaAddrsLOffset     ;save as low offset
00B416  1  B9 03 B4                 lda EnemyAddrHOffsets,y  ;load base value with 2 altered MSB,
00B419  1  18                       clc                      ;then add base value to 5 LSB, result
00B41A  1  6D 4F 07                 adc AreaAddrsLOffset     ;becomes offset for level data
00B41D  1  A8                       tay
00B41E  1  B9 BE 96                 lda EnemyDataAddrLow,y   ;use offset to load pointer
00B421  1  85 E9                    sta EnemyDataLow
00B423  1  B9 E0 96                 lda EnemyDataAddrHigh,y
00B426  1  85 EA                    sta EnemyDataHigh
00B428  1  AC 4E 07                 ldy AreaType             ;use area type as offset
00B42B  1  B9 02 97                 lda AreaDataHOffsets,y   ;do the same thing but with different base value
00B42E  1  18                       clc
00B42F  1  6D 4F 07                 adc AreaAddrsLOffset
00B432  1  A8                       tay
00B433  1  B9 06 97                 lda AreaDataAddrLow,y    ;use this offset to load another pointer
00B436  1  85 E7                    sta AreaDataLow
00B438  1  B9 28 97                 lda AreaDataAddrHigh,y
00B43B  1  85 E8                    sta AreaDataHigh
00B43D  1  A0 00                    ldy #$00                 ;load first byte of header
00B43F  1  B1 E7                    lda (AreaData),y
00B441  1  48                       pha                      ;save it to the stack for now
00B442  1  29 07                    and #%00000111           ;save 3 LSB for foreground scenery or bg color control
00B444  1  C9 04                    cmp #$04
00B446  1  90 05                    bcc StoreFore
00B448  1  8D 44 07                 sta BackgroundColorCtrl  ;if 4 or greater, save value here as bg color control
00B44B  1  A9 00                    lda #$00
00B44D  1  8D 41 07     StoreFore:  sta ForegroundScenery    ;if less, save value here as foreground scenery
00B450  1  68                       pla                      ;pull byte from stack and push it back
00B451  1  48                       pha
00B452  1  29 38                    and #%00111000           ;save player entrance control bits
00B454  1  4A                       lsr                      ;shift bits over to LSBs
00B455  1  4A                       lsr
00B456  1  4A                       lsr
00B457  1  8D 10 07                 sta PlayerEntranceCtrl       ;save value here as player entrance control
00B45A  1  68                       pla                      ;pull byte again but do not push it back
00B45B  1  29 C0                    and #%11000000           ;save 2 MSB for game timer setting
00B45D  1  18                       clc
00B45E  1  2A                       rol                      ;rotate bits over to LSBs
00B45F  1  2A                       rol
00B460  1  2A                       rol
00B461  1  8D 15 07                 sta GameTimerSetting     ;save value here as game timer setting
00B464  1  C8                       iny
00B465  1  B1 E7                    lda (AreaData),y         ;load second byte of header
00B467  1  48                       pha                      ;save to stack
00B468  1  29 0F                    and #%00001111           ;mask out all but lower nybble
00B46A  1  8D 27 07                 sta TerrainControl
00B46D  1  68                       pla                      ;pull and push byte to copy it to A
00B46E  1  48                       pha
00B46F  1  29 30                    and #%00110000           ;save 2 MSB for background scenery type
00B471  1  4A                       lsr
00B472  1  4A                       lsr                      ;shift bits to LSBs
00B473  1  4A                       lsr
00B474  1  4A                       lsr
00B475  1  8D 42 07                 sta BackgroundScenery    ;save as background scenery
00B478  1  68                       pla
00B479  1  29 C0                    and #%11000000
00B47B  1  18                       clc
00B47C  1  2A                       rol                      ;rotate bits over to LSBs
00B47D  1  2A                       rol
00B47E  1  2A                       rol
00B47F  1  C9 03                    cmp #%00000011           ;if set to 3, store here
00B481  1  D0 05                    bne StoreStyle           ;and nullify other value
00B483  1  8D 43 07                 sta CloudTypeOverride    ;otherwise store value in other place
00B486  1  A9 00                    lda #$00
00B488  1  8D 33 07     StoreStyle: sta AreaStyle
00B48B  1  A5 E7                    lda AreaDataLow          ;increment area data address by 2 bytes
00B48D  1  18                       clc
00B48E  1  69 02                    adc #$02
00B490  1  85 E7                    sta AreaDataLow
00B492  1  A5 E8                    lda AreaDataHigh
00B494  1  69 00                    adc #$00
00B496  1  85 E8                    sta AreaDataHigh
00B498  1  60                       rts
00B499  1               
00B499  1               HandlePipeEntry:
00B499  1  A5 0B                 lda Up_Down_Buttons       ;check saved controller bits from earlier
00B49B  1  29 04                 and #%00000100            ;for pressing down
00B49D  1  F0 67                 beq ExPipeE               ;if not pressing down, branch to leave
00B49F  1  A5 00                 lda $00
00B4A1  1  C9 11                 cmp #$11                  ;check right foot metatile for warp pipe right metatile
00B4A3  1  D0 61                 bne ExPipeE               ;branch to leave if not found
00B4A5  1  A5 01                 lda $01
00B4A7  1  C9 10                 cmp #$10                  ;check left foot metatile for warp pipe left metatile
00B4A9  1  D0 5B                 bne ExPipeE               ;branch to leave if not found
00B4AB  1  A9 30                 lda #$30
00B4AD  1  8D DE 06              sta ChangeAreaTimer       ;set timer for change of area
00B4B0  1  A9 03                 lda #$03
00B4B2  1  85 0E                 sta GameEngineSubroutine  ;set to run vertical pipe entry routine on next frame
00B4B4  1  A9 10                 lda #Sfx_PipeDown_Injury
00B4B6  1  85 FF                 sta Square1SoundQueue     ;load pipedown/injury sound
00B4B8  1  A9 20                 lda #%00100000
00B4BA  1  8D C4 03              sta Player_SprAttrib      ;set background priority bit in player's attributes
00B4BD  1  AD D6 06              lda WarpZoneControl       ;check warp zone control
00B4C0  1  F0 44                 beq ExPipeE               ;branch to leave if none found
00B4C2  1  29 03                 and #%00000011            ;mask out all but 2 LSB
00B4C4  1  0A                    asl
00B4C5  1  0A                    asl                       ;multiply by four
00B4C6  1  AA                    tax                       ;save as offset to warp zone numbers (starts at left pipe)
00B4C7  1  A5 86                 lda Player_X_Position     ;get player's horizontal position
00B4C9  1  C9 60                 cmp #$60
00B4CB  1  90 06                 bcc GetWNum               ;if player at left, not near middle, use offset and skip ahead
00B4CD  1  E8                    inx                       ;otherwise increment for middle pipe
00B4CE  1  C9 A0                 cmp #$a0
00B4D0  1  90 01                 bcc GetWNum               ;if player at middle, but not too far right, use offset and skip
00B4D2  1  E8                    inx                       ;otherwise increment for last pipe
00B4D3  1  BC 95 86     GetWNum: ldy WarpZoneNumbers,x     ;get warp zone numbers
00B4D6  1  88                    dey                       ;decrement for use as world number
00B4D7  1  8C 5F 07              sty WorldNumber           ;store as world number and offset
00B4DA  1  BE 74 BC              ldx WorldAddrOffsets,y    ;get offset to where this world's area offsets are
00B4DD  1  BD 7C BC              lda AreaAddrOffsets,x     ;get area offset based on world offset
00B4E0  1  8D 50 07              sta AreaPointer           ;store area offset here to be used to change areas
00B4E3  1  8D 16 60              sta WRAM_LevelAreaPointer
00B4E6  1  AD 05 60 29           PF_SetToLevelEnd_A
00B4EA  1  EF 8D 05 60  
00B4EE  1  A9 80                 lda #Silence
00B4F0  1  85 FC                 sta EventMusicQueue       ;silence music
00B4F2  1  A9 00                 lda #$00
00B4F4  1  8D 51 07              sta EntrancePage          ;initialize starting page number
00B4F7  1  8D 60 07              sta AreaNumber            ;initialize area number used for area address offset
00B4FA  1  8D 5C 07              sta LevelNumber           ;initialize level number used for world display
00B4FD  1  8D 52 07              sta AltEntranceControl    ;initialize mode of entry
00B500  1  EE 5D 07              inc Hidden1UpFlag         ;set flag for hidden 1-up blocks
00B503  1  EE 57 07              inc FetchNewGameTimerFlag ;set flag to load new game timer
00B506  1  60           ExPipeE: rts                       ;leave!!!
00B507  1               
00B507  1               ;-------------------------------------------------------------------------------------
00B507  1               
00B507  1               EnemiesAndLoopsCore:
00B507  1  B5 0F                    lda Enemy_Flag,x         ;check data here for MSB set
00B509  1  48                       pha                      ;save in stack
00B50A  1  0A                       asl
00B50B  1  B0 12                    bcs ChkBowserF           ;if MSB set in enemy flag, branch ahead of jumps
00B50D  1  68                       pla                      ;get from stack
00B50E  1  F0 03                    beq ChkAreaTsk           ;if data zero, branch
00B510  1  4C 7C C5                 jmp RunEnemyObjectsCore  ;otherwise, jump to run enemy subroutines
00B513  1  AD 1F 07     ChkAreaTsk: lda AreaParserTaskNum    ;check number of tasks to perform
00B516  1  29 07                    and #$07
00B518  1  C9 07                    cmp #$07                 ;if at a specific task, jump and leave
00B51A  1  F0 0E                    beq ExitELCore
00B51C  1  4C 8C B5                 jmp ProcLoopCommand      ;otherwise, jump to process loop command/load enemies
00B51F  1  68           ChkBowserF: pla                      ;get data from stack
00B520  1  29 0F                    and #%00001111           ;mask out high nybble
00B522  1  A8                       tay
00B523  1  B9 0F 00                 lda Enemy_Flag,y         ;use as pointer and load same place with different offset
00B526  1  D0 02                    bne ExitELCore
00B528  1  95 0F                    sta Enemy_Flag,x         ;if second enemy flag not set, also clear first one
00B52A  1  60           ExitELCore: rts
00B52B  1               
00B52B  1               ;--------------------------------
00B52B  1               
00B52B  1               ;loop command data
00B52B  1               LoopCmdWorldNumber:
00B52B  1  03 03 06 06        .byte $03, $03, $06, $06, $06, $06, $06, $06, $07, $07, $07
00B52F  1  06 06 06 06  
00B533  1  07 07 07     
00B536  1               
00B536  1               LoopCmdPageNumber:
00B536  1  05 09 04 05        .byte $05, $09, $04, $05, $06, $08, $09, $0a, $06, $0b, $10
00B53A  1  06 08 09 0A  
00B53E  1  06 0B 10     
00B541  1               
00B541  1               LoopCmdYPosition:
00B541  1  40 B0 B0 80        .byte $40, $b0, $b0, $80, $40, $40, $80, $40, $f0, $f0, $f0
00B545  1  40 40 80 40  
00B549  1  F0 F0 F0     
00B54C  1               
00B54C  1               ExecGameLoopback:
00B54C  1  A5 6D              lda Player_PageLoc        ;send player back four pages
00B54E  1  38                 sec
00B54F  1  E9 04              sbc #$04
00B551  1  85 6D              sta Player_PageLoc
00B553  1  AD 25 07           lda CurrentPageLoc        ;send current page back four pages
00B556  1  38                 sec
00B557  1  E9 04              sbc #$04
00B559  1  8D 25 07           sta CurrentPageLoc
00B55C  1  AD 1A 07           lda ScreenLeft_PageLoc    ;subtract four from page location
00B55F  1  38                 sec                       ;of screen's left border
00B560  1  E9 04              sbc #$04
00B562  1  8D 1A 07           sta ScreenLeft_PageLoc
00B565  1  AD 1B 07           lda ScreenRight_PageLoc   ;do the same for the page location
00B568  1  38                 sec                       ;of screen's right border
00B569  1  E9 04              sbc #$04
00B56B  1  8D 1B 07           sta ScreenRight_PageLoc
00B56E  1  AD 2A 07           lda AreaObjectPageLoc     ;subtract four from page control
00B571  1  38                 sec                       ;for area objects
00B572  1  E9 04              sbc #$04
00B574  1  8D 2A 07           sta AreaObjectPageLoc
00B577  1  A9 00              lda #$00                  ;initialize page select for both
00B579  1  8D 3B 07           sta EnemyObjectPageSel    ;area and enemy objects
00B57C  1  8D 2B 07           sta AreaObjectPageSel
00B57F  1  8D 39 07           sta EnemyDataOffset       ;initialize enemy object data offset
00B582  1  8D 3A 07           sta EnemyObjectPageLoc    ;and enemy object page control
00B585  1  B9 B3 96           lda AreaDataOfsLoopback,y ;adjust area object offset based on
00B588  1  8D 2C 07           sta AreaDataOffset        ;which loop command we encountered
00B58B  1  60                 rts
00B58C  1               
00B58C  1               ProcLoopCommand:
00B58C  1  AD 45 07               lda LoopCommand           ;check if loop command was found
00B58F  1  F0 66                  beq ChkEnemyFrenzy
00B591  1  AD 26 07               lda CurrentColumnPos      ;check to see if we're still on the first page
00B594  1  D0 61                  bne ChkEnemyFrenzy        ;if not, do not loop yet
00B596  1  A0 0B                  ldy #$0b                  ;start at the end of each set of loop data
00B598  1  88           FindLoop: dey
00B599  1  30 5C                  bmi ChkEnemyFrenzy        ;if all data is checked and not match, do not loop
00B59B  1  AD 5F 07               lda WorldNumber           ;check to see if one of the world numbers
00B59E  1  D9 2B B5               cmp LoopCmdWorldNumber,y  ;matches our current world number
00B5A1  1  D0 F5                  bne FindLoop
00B5A3  1  AD 25 07               lda CurrentPageLoc        ;check to see if one of the page numbers
00B5A6  1  D9 36 B5               cmp LoopCmdPageNumber,y   ;matches the page we're currently on
00B5A9  1  D0 ED                  bne FindLoop
00B5AB  1  A5 CE                  lda Player_Y_Position     ;check to see if the player is at the correct position
00B5AD  1  D9 41 B5               cmp LoopCmdYPosition,y    ;if not, branch to check for world 7
00B5B0  1  D0 27                  bne WrongChk
00B5B2  1  A5 1D                  lda Player_State          ;check to see if the player is
00B5B4  1  C9 00                  cmp #$00                  ;on solid ground (i.e. not jumping or falling)
00B5B6  1  D0 21                  bne WrongChk              ;if not, player fails to pass loop, and loopback
00B5B8  1  A9 01                  lda #Sfx_CoinGrab
00B5BA  1  85 FE                  sta Square2SoundQueue
00B5BC  1  AD 5F 07               lda WorldNumber           ;are we in world 7? (check performed on correct
00B5BF  1  C9 06                  cmp #World7               ;vertical position and on solid ground)
00B5C1  1  D0 27                  bne InitMLp               ;if not, initialize flags used there, otherwise
00B5C3  1  EE D9 06               inc MultiLoopCorrectCntr  ;increment counter for correct progression
00B5C6  1  EE DA 06     IncMLoop: inc MultiLoopPassCntr     ;increment master multi-part counter
00B5C9  1  AD DA 06               lda MultiLoopPassCntr     ;have we done all three parts?
00B5CC  1  C9 03                  cmp #$03
00B5CE  1  D0 22                  bne InitLCmd              ;if not, skip this part
00B5D0  1  AD D9 06               lda MultiLoopCorrectCntr  ;if so, have we done them all correctly?
00B5D3  1  C9 03                  cmp #$03
00B5D5  1  F0 13                  beq InitMLp               ;if so, branch past unnecessary check here
00B5D7  1  D0 0B                  bne DoLpBack              ;unconditional branch if previous branch fails
00B5D9  1  A9 10        WrongChk: lda #Sfx_TimerTick
00B5DB  1  85 FE                  sta Square2SoundQueue
00B5DD  1  AD 5F 07               lda WorldNumber           ;are we in world 7? (check performed on
00B5E0  1  C9 06                  cmp #World7               ;incorrect vertical position or not on solid ground)
00B5E2  1  F0 E2                  beq IncMLoop
00B5E4  1  20 4C B5     DoLpBack: jsr ExecGameLoopback      ;if player is not in right place, loop back
00B5E7  1  20 7F CD               jsr KillAllEnemies
00B5EA  1  A9 00        InitMLp:  lda #$00                  ;initialize counters used for multi-part loop commands
00B5EC  1  8D DA 06               sta MultiLoopPassCntr
00B5EF  1  8D D9 06               sta MultiLoopCorrectCntr
00B5F2  1  A9 00        InitLCmd: lda #$00                  ;initialize loop command flag
00B5F4  1  8D 45 07               sta LoopCommand
00B5F7  1               
00B5F7  1               ;--------------------------------
00B5F7  1               
00B5F7  1               ChkEnemyFrenzy:
00B5F7  1  AD CD 06           lda EnemyFrenzyQueue  ;check for enemy object in frenzy queue
00B5FA  1  F0 10              beq ProcessEnemyData  ;if not, skip this part
00B5FC  1  95 16              sta Enemy_ID,x        ;store as enemy object identifier here
00B5FE  1  A9 01              lda #$01
00B600  1  95 0F              sta Enemy_Flag,x      ;activate enemy object flag
00B602  1  A9 00              lda #$00
00B604  1  95 1E              sta Enemy_State,x     ;initialize state and frenzy queue
00B606  1  8D CD 06           sta EnemyFrenzyQueue
00B609  1  4C EE B6           jmp InitEnemyObject   ;and then jump to deal with this enemy
00B60C  1               
00B60C  1               ;--------------------------------
00B60C  1               ;$06 - used to hold page location of extended right boundary
00B60C  1               ;$07 - used to hold high nybble of position of extended right boundary
00B60C  1               
00B60C  1               ProcessEnemyData:
00B60C  1  AC 39 07             ldy EnemyDataOffset      ;get offset of enemy object data
00B60F  1  B1 E9                lda (EnemyData),y        ;load first byte
00B611  1  C9 FF                cmp #$ff                 ;check for EOD terminator
00B613  1  D0 03                bne CheckEndofBuffer
00B615  1  4C DE B6             jmp CheckFrenzyBuffer    ;if found, jump to check frenzy buffer, otherwise
00B618  1               
00B618  1               CheckEndofBuffer:
00B618  1  29 0F                and #%00001111           ;check for special row $0e
00B61A  1  C9 0E                cmp #$0e
00B61C  1  F0 0E                beq CheckRightBounds     ;if found, branch, otherwise
00B61E  1  E0 05                cpx #$05                 ;check for end of buffer
00B620  1  90 0A                bcc CheckRightBounds     ;if not at end of buffer, branch
00B622  1  C8                   iny
00B623  1  B1 E9                lda (EnemyData),y        ;check for specific value here
00B625  1  29 3F                and #%00111111           ;not sure what this was intended for, exactly
00B627  1  C9 2E                cmp #$2e                 ;this part is quite possibly residual code
00B629  1  F0 01                beq CheckRightBounds     ;but it has the effect of keeping enemies out of
00B62B  1  60                   rts                      ;the sixth slot
00B62C  1               
00B62C  1               CheckRightBounds:
00B62C  1  AD 1D 07             lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
00B62F  1  18                   clc
00B630  1  69 30                adc #$30
00B632  1  29 F0                and #%11110000           ;store high nybble
00B634  1  85 07                sta $07
00B636  1  AD 1B 07             lda ScreenRight_PageLoc  ;add carry to page location of right boundary
00B639  1  69 00                adc #$00
00B63B  1  85 06                sta $06                  ;store page location + carry
00B63D  1  AC 39 07             ldy EnemyDataOffset
00B640  1  C8                   iny
00B641  1  B1 E9                lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
00B643  1  0A                   asl
00B644  1  90 0B                bcc CheckPageCtrlRow
00B646  1  AD 3B 07             lda EnemyObjectPageSel   ;if page select already set, do not set again
00B649  1  D0 06                bne CheckPageCtrlRow
00B64B  1  EE 3B 07             inc EnemyObjectPageSel   ;otherwise, if MSB is set, set page select
00B64E  1  EE 3A 07             inc EnemyObjectPageLoc   ;and increment page control
00B651  1               
00B651  1               CheckPageCtrlRow:
00B651  1  88                   dey
00B652  1  B1 E9                lda (EnemyData),y        ;reread first byte
00B654  1  29 0F                and #$0f
00B656  1  C9 0F                cmp #$0f                 ;check for special row $0f
00B658  1  D0 19                bne PositionEnemyObj     ;if not found, branch to position enemy object
00B65A  1  AD 3B 07             lda EnemyObjectPageSel   ;if page select set,
00B65D  1  D0 14                bne PositionEnemyObj     ;branch without reading second byte
00B65F  1  C8                   iny
00B660  1  B1 E9                lda (EnemyData),y        ;otherwise, get second byte, mask out 2 MSB
00B662  1  29 3F                and #%00111111
00B664  1  8D 3A 07             sta EnemyObjectPageLoc   ;store as page control for enemy object data
00B667  1  EE 39 07             inc EnemyDataOffset      ;increment enemy object data offset 2 bytes
00B66A  1  EE 39 07             inc EnemyDataOffset
00B66D  1  EE 3B 07             inc EnemyObjectPageSel   ;set page select for enemy object data and
00B670  1  4C 8C B5             jmp ProcLoopCommand      ;jump back to process loop commands again
00B673  1               
00B673  1               PositionEnemyObj:
00B673  1  AD 3A 07             lda EnemyObjectPageLoc   ;store page control as page location
00B676  1  95 6E                sta Enemy_PageLoc,x      ;for enemy object
00B678  1  B1 E9                lda (EnemyData),y        ;get first byte of enemy object
00B67A  1  29 F0                and #%11110000
00B67C  1  95 87                sta Enemy_X_Position,x   ;store column position
00B67E  1  CD 1D 07             cmp ScreenRight_X_Pos    ;check column position against right boundary
00B681  1  B5 6E                lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
00B683  1  ED 1B 07             sbc ScreenRight_PageLoc  ;from page location
00B686  1  B0 0B                bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
00B688  1  B1 E9                lda (EnemyData),y
00B68A  1  29 0F                and #%00001111           ;check for special row $0e
00B68C  1  C9 0E                cmp #$0e                 ;if found, jump elsewhere
00B68E  1  F0 69                beq ParseRow0e
00B690  1  4C 18 B7             jmp CheckThreeBytes      ;if not found, unconditional jump
00B693  1               
00B693  1               CheckRightExtBounds:
00B693  1  A5 07                lda $07                  ;check right boundary + 48 against
00B695  1  D5 87                cmp Enemy_X_Position,x   ;column position without subtracting,
00B697  1  A5 06                lda $06                  ;then subtract borrow from page control temp
00B699  1  F5 6E                sbc Enemy_PageLoc,x      ;plus carry
00B69B  1  90 41                bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
00B69D  1  A9 01                lda #$01                 ;store value in vertical high byte
00B69F  1  95 B6                sta Enemy_Y_HighPos,x
00B6A1  1  B1 E9                lda (EnemyData),y        ;get first byte again
00B6A3  1  0A                   asl                      ;multiply by four to get the vertical
00B6A4  1  0A                   asl                      ;coordinate
00B6A5  1  0A                   asl
00B6A6  1  0A                   asl
00B6A7  1  95 CF                sta Enemy_Y_Position,x
00B6A9  1  C9 E0                cmp #$e0                 ;do one last check for special row $0e
00B6AB  1  F0 4C                beq ParseRow0e           ;(necessary if branched to $c1cb)
00B6AD  1  C8                   iny
00B6AE  1  B1 E9                lda (EnemyData),y        ;get second byte of object
00B6B0  1  29 40                and #%01000000           ;check to see if hard mode bit is set
00B6B2  1  F0 05                beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
00B6B4  1  AD CC 06             lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
00B6B7  1  F0 6D                beq Inc2B                ;is on, and if not, branch to skip this object completely
00B6B9  1               
00B6B9  1               CheckForEnemyGroup:
00B6B9  1  B1 E9                lda (EnemyData),y      ;get second byte and mask out 2 MSB
00B6BB  1  29 3F                and #%00111111
00B6BD  1  C9 37                cmp #$37               ;check for value below $37
00B6BF  1  90 04                bcc BuzzyBeetleMutate
00B6C1  1  C9 3F                cmp #$3f               ;if $37 or greater, check for value
00B6C3  1  90 31                bcc DoGroup            ;below $3f, branch if below $3f
00B6C5  1               
00B6C5  1               BuzzyBeetleMutate:
00B6C5  1  C9 06                cmp #Goomba          ;if below $37, check for goomba
00B6C7  1  D0 07                bne StrID            ;value ($3f or more always fails)
00B6C9  1  AC 6A 07             ldy PrimaryHardMode  ;check if primary hard mode flag is set
00B6CC  1  F0 02                beq StrID            ;and if so, change goomba to buzzy beetle
00B6CE  1  A9 02                lda #BuzzyBeetle
00B6D0  1  95 16        StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
00B6D2  1  A9 01                lda #$01
00B6D4  1  95 0F                sta Enemy_Flag,x     ;set flag for enemy in buffer
00B6D6  1  20 EE B6             jsr InitEnemyObject
00B6D9  1  B5 0F                lda Enemy_Flag,x     ;check to see if flag is set
00B6DB  1  D0 49                bne Inc2B            ;if not, leave, otherwise branch
00B6DD  1  60                   rts
00B6DE  1               
00B6DE  1               CheckFrenzyBuffer:
00B6DE  1  AD CB 06             lda EnemyFrenzyBuffer    ;if enemy object stored in frenzy buffer
00B6E1  1  D0 09                bne StrFre               ;then branch ahead to store in enemy object buffer
00B6E3  1  AD 98 03             lda VineFlagOffset       ;otherwise check vine flag offset
00B6E6  1  C9 01                cmp #$01
00B6E8  1  D0 0B                bne ExEPar               ;if other value <> 1, leave
00B6EA  1  A9 2F                lda #VineObject          ;otherwise put vine in enemy identifier
00B6EC  1  95 16        StrFre: sta Enemy_ID,x           ;store contents of frenzy buffer into enemy identifier value
00B6EE  1               
00B6EE  1               InitEnemyObject:
00B6EE  1  A9 00                lda #$00                 ;initialize enemy state
00B6F0  1  95 1E                sta Enemy_State,x
00B6F2  1  20 31 B8             jsr CheckpointEnemyID    ;jump ahead to run jump engine and subroutines
00B6F5  1  60           ExEPar: rts                      ;then leave
00B6F6  1               
00B6F6  1               DoGroup:
00B6F6  1  4C C5 B7             jmp HandleGroupEnemies   ;handle enemy group objects
00B6F9  1               
00B6F9  1               ParseRow0e:
00B6F9  1  C8                   iny                      ;increment Y to load third byte of object
00B6FA  1  C8                   iny
00B6FB  1  B1 E9                lda (EnemyData),y
00B6FD  1  4A                   lsr                      ;move 3 MSB to the bottom, effectively
00B6FE  1  4A                   lsr                      ;making %xxx00000 into %00000xxx
00B6FF  1  4A                   lsr
00B700  1  4A                   lsr
00B701  1  4A                   lsr
00B702  1  CD 5F 07             cmp WorldNumber          ;is it the same world number as we're on?
00B705  1  D0 0E                bne NotUse               ;if not, do not use (this allows multiple uses
00B707  1  88                   dey                      ;of the same area, like the underground bonus areas)
00B708  1  B1 E9                lda (EnemyData),y        ;otherwise, get second byte and use as offset
00B70A  1  8D 50 07             sta AreaPointer          ;to addresses for level and enemy object data
00B70D  1  C8                   iny
00B70E  1  B1 E9                lda (EnemyData),y        ;get third byte again, and this time mask out
00B710  1  29 1F                and #%00011111           ;the 3 MSB from before, save as page number to be
00B712  1  8D 51 07             sta EntrancePage         ;used upon entry to area, if area is entered
00B715  1  4C 23 B7     NotUse: jmp Inc3B
00B718  1               
00B718  1               CheckThreeBytes:
00B718  1  AC 39 07             ldy EnemyDataOffset      ;load current offset for enemy object data
00B71B  1  B1 E9                lda (EnemyData),y        ;get first byte
00B71D  1  29 0F                and #%00001111           ;check for special row $0e
00B71F  1  C9 0E                cmp #$0e
00B721  1  D0 03                bne Inc2B
00B723  1  EE 39 07     Inc3B:  inc EnemyDataOffset      ;if row = $0e, increment three bytes
00B726  1  EE 39 07     Inc2B:  inc EnemyDataOffset      ;otherwise increment two bytes
00B729  1  EE 39 07             inc EnemyDataOffset
00B72C  1  A9 00                lda #$00                 ;init page select for enemy objects
00B72E  1  8D 3B 07             sta EnemyObjectPageSel
00B731  1  A6 08                ldx ObjectOffset         ;reload current offset in enemy buffers
00B733  1  60                   rts                      ;and leave
00B734  1               ;--------------------------------
00B734  1               
00B734  1               Bitmasks:
00B734  1  01 02 04 08        .byte %00000001, %00000010, %00000100, %00001000, %00010000, %00100000, %01000000, %10000000
00B738  1  10 20 40 80  
00B73C  1               
00B73C  1               Enemy17YPosData:
00B73C  1  40 30 90 50        .byte $40, $30, $90, $50, $20, $60, $a0, $70
00B740  1  20 60 A0 70  
00B744  1               
00B744  1               SwimCC_IDData:
00B744  1  0A 0B              .byte $0a, $0b
00B746  1               
00B746  1               BulletBillCheepCheep:
00B746  1  AD 8F 07              lda FrenzyEnemyTimer      ;if timer not expired yet, branch to leave
00B749  1  D0 6F                 bne ExF17
00B74B  1  AD 4E 07              lda AreaType              ;are we in a water-type level?
00B74E  1  D0 57                 bne DoBulletBills         ;if not, branch elsewhere
00B750  1  E0 03                 cpx #$03                  ;are we past third enemy slot?
00B752  1  B0 66                 bcs ExF17                 ;if so, branch to leave
00B754  1  A0 00                 ldy #$00                  ;load default offset
00B756  1  BD A7 07              lda PseudoRandomBitReg,x
00B759  1  C9 AA                 cmp #$aa                  ;check first part of LSFR against preset value
00B75B  1  90 01                 bcc ChkW2                 ;if less than preset, do not increment offset
00B75D  1  C8                    iny                       ;otherwise increment
00B75E  1  AD 5F 07     ChkW2:   lda WorldNumber           ;check world number
00B761  1  C9 01                 cmp #World2
00B763  1  F0 01                 beq Get17ID               ;if we're on world 2, do not increment offset
00B765  1  C8                    iny                       ;otherwise increment
00B766  1  98           Get17ID: tya
00B767  1  29 01                 and #%00000001            ;mask out all but last bit of offset
00B769  1  A8                    tay
00B76A  1  B9 44 B7              lda SwimCC_IDData,y       ;load identifier for cheep-cheeps
00B76D  1  95 16        Set17ID: sta Enemy_ID,x            ;store whatever's in A as enemy identifier
00B76F  1  AD DD 06              lda BitMFilter
00B772  1  C9 FF                 cmp #$ff                  ;if not all bits set, skip init part and compare bits
00B774  1  D0 05                 bne GetRBit
00B776  1  A9 00                 lda #$00                  ;initialize vertical position filter
00B778  1  8D DD 06              sta BitMFilter
00B77B  1  BD A7 07     GetRBit: lda PseudoRandomBitReg,x  ;get first part of LSFR
00B77E  1  29 07                 and #%00000111            ;mask out all but 3 LSB
00B780  1  A8           ChkRBit: tay                       ;use as offset
00B781  1  B9 34 B7              lda Bitmasks,y            ;load bitmask
00B784  1  2C DD 06              bit BitMFilter            ;perform AND on filter without changing it
00B787  1  F0 07                 beq AddFBit
00B789  1  C8                    iny                       ;increment offset
00B78A  1  98                    tya
00B78B  1  29 07                 and #%00000111            ;mask out all but 3 LSB thus keeping it 0-7
00B78D  1  4C 80 B7              jmp ChkRBit               ;do another check
00B790  1  0D DD 06     AddFBit: ora BitMFilter            ;add bit to already set bits in filter
00B793  1  8D DD 06              sta BitMFilter            ;and store
00B796  1  B9 3C B7              lda Enemy17YPosData,y     ;load vertical position using offset
00B799  1  20 E6 C3              jsr PutAtRightExtent      ;set vertical position and other values
00B79C  1  9D 17 04              sta Enemy_YMF_Dummy,x     ;initialize dummy variable
00B79F  1  A9 20                 lda #$20                  ;set timer
00B7A1  1  8D 8F 07              sta FrenzyEnemyTimer
00B7A4  1  4C 31 B8              jmp CheckpointEnemyID     ;process our new enemy object
00B7A7  1               
00B7A7  1               
00B7A7  1               DoBulletBills:
00B7A7  1  A0 FF                  ldy #$ff                   ;start at beginning of enemy slots
00B7A9  1  C8           BB_SLoop: iny                        ;move onto the next slot
00B7AA  1  C0 05                  cpy #$05                   ;branch to play sound if we've done all slots
00B7AC  1  B0 0D                  bcs FireBulletBill
00B7AE  1  B9 0F 00               lda Enemy_Flag,y           ;if enemy buffer flag not set,
00B7B1  1  F0 F6                  beq BB_SLoop               ;loop back and check another slot
00B7B3  1  B9 16 00               lda Enemy_ID,y
00B7B6  1  C9 08                  cmp #BulletBill_FrenzyVar  ;check enemy identifier for
00B7B8  1  D0 EF                  bne BB_SLoop               ;bullet bill object (frenzy variant)
00B7BA  1  60           ExF17:    rts                        ;if found, leave
00B7BB  1               
00B7BB  1               FireBulletBill:
00B7BB  1  A5 FE              lda Square2SoundQueue
00B7BD  1  09 08              ora #Sfx_Blast            ;play fireworks/gunfire sound
00B7BF  1  85 FE              sta Square2SoundQueue
00B7C1  1  A9 08              lda #BulletBill_FrenzyVar ;load identifier for bullet bill object
00B7C3  1  D0 A8              bne Set17ID               ;unconditional branch
00B7C5  1               
00B7C5  1               ;--------------------------------
00B7C5  1               ;$00 - used to store Y position of group enemies
00B7C5  1               ;$01 - used to store enemy ID
00B7C5  1               ;$02 - used to store page location of right side of screen
00B7C5  1               ;$03 - used to store X position of right side of screen
00B7C5  1               
00B7C5  1               HandleGroupEnemies:
00B7C5  1  A0 00                ldy #$00                  ;load value for green koopa troopa
00B7C7  1  38                   sec
00B7C8  1  E9 37                sbc #$37                  ;subtract $37 from second byte read
00B7CA  1  48                   pha                       ;save result in stack for now
00B7CB  1  C9 04                cmp #$04                  ;was byte in $3b-$3e range?
00B7CD  1  B0 0B                bcs SnglID                ;if so, branch
00B7CF  1  48                   pha                       ;save another copy to stack
00B7D0  1  A0 06                ldy #Goomba               ;load value for goomba enemy
00B7D2  1  AD 6A 07             lda PrimaryHardMode       ;if primary hard mode flag not set,
00B7D5  1  F0 02                beq PullID                ;branch, otherwise change to value
00B7D7  1  A0 02                ldy #BuzzyBeetle          ;for buzzy beetle
00B7D9  1  68           PullID: pla                       ;get second copy from stack
00B7DA  1  84 01        SnglID: sty $01                   ;save enemy id here
00B7DC  1  A0 B0                ldy #$b0                  ;load default y coordinate
00B7DE  1  29 02                and #$02                  ;check to see if d1 was set
00B7E0  1  F0 02                beq SetYGp                ;if so, move y coordinate up,
00B7E2  1  A0 70                ldy #$70                  ;otherwise branch and use default
00B7E4  1  84 00        SetYGp: sty $00                   ;save y coordinate here
00B7E6  1  AD 1B 07             lda ScreenRight_PageLoc   ;get page number of right edge of screen
00B7E9  1  85 02                sta $02                   ;save here
00B7EB  1  AD 1D 07             lda ScreenRight_X_Pos     ;get pixel coordinate of right edge
00B7EE  1  85 03                sta $03                   ;save here
00B7F0  1  A0 02                ldy #$02                  ;load two enemies by default
00B7F2  1  68                   pla                       ;get first copy from stack
00B7F3  1  4A                   lsr                       ;check to see if d0 was set
00B7F4  1  90 01                bcc CntGrp                ;if not, use default value
00B7F6  1  C8                   iny                       ;otherwise increment to three enemies
00B7F7  1  8C D3 06     CntGrp: sty NumberofGroupEnemies  ;save number of enemies here
00B7FA  1  A2 FF        GrLoop: ldx #$ff                  ;start at beginning of enemy buffers
00B7FC  1  E8           GSltLp: inx                       ;increment and branch if past
00B7FD  1  E0 05                cpx #$05                  ;end of buffers
00B7FF  1  B0 2D                bcs NextED
00B801  1  B5 0F                lda Enemy_Flag,x          ;check to see if enemy is already
00B803  1  D0 F7                bne GSltLp                ;stored in buffer, and branch if so
00B805  1  A5 01                lda $01
00B807  1  95 16                sta Enemy_ID,x            ;store enemy object identifier
00B809  1  A5 02                lda $02
00B80B  1  95 6E                sta Enemy_PageLoc,x       ;store page location for enemy object
00B80D  1  A5 03                lda $03
00B80F  1  95 87                sta Enemy_X_Position,x    ;store x coordinate for enemy object
00B811  1  18                   clc
00B812  1  69 18                adc #$18                  ;add 24 pixels for next enemy
00B814  1  85 03                sta $03
00B816  1  A5 02                lda $02                   ;add carry to page location for
00B818  1  69 00                adc #$00                  ;next enemy
00B81A  1  85 02                sta $02
00B81C  1  A5 00                lda $00                   ;store y coordinate for enemy object
00B81E  1  95 CF                sta Enemy_Y_Position,x
00B820  1  A9 01                lda #$01                  ;activate flag for buffer, and
00B822  1  95 B6                sta Enemy_Y_HighPos,x     ;put enemy within the screen vertically
00B824  1  95 0F                sta Enemy_Flag,x
00B826  1  20 31 B8             jsr CheckpointEnemyID     ;process each enemy object separately
00B829  1  CE D3 06             dec NumberofGroupEnemies  ;do this until we run out of enemy objects
00B82C  1  D0 CC                bne GrLoop
00B82E  1  4C 26 B7     NextED: jmp Inc2B                 ;jump to increment data offset and leave
00B831  1               
00B831  1               ; ------------------
00B831  1               
00B831  1               CheckpointEnemyID:
00B831  1  B5 16                lda Enemy_ID,x
00B833  1  C9 15                cmp #$15                     ;check enemy object identifier for $15 or greater
00B835  1  B0 0D                bcs InitEnemyRoutines        ;and branch straight to the jump engine if found
00B837  1  A8                   tay                          ;save identifier in Y register for now
00B838  1  B5 CF                lda Enemy_Y_Position,x
00B83A  1  69 08                adc #$08                     ;add eight pixels to what will eventually be the
00B83C  1  95 CF                sta Enemy_Y_Position,x       ;enemy object's vertical coordinate ($00-$14 only)
00B83E  1  A9 01                lda #$01
00B840  1  9D D8 03             sta EnemyOffscrBitsMasked,x  ;set offscreen masked bit
00B843  1  98                   tya                          ;get identifier back and use as offset for jump engine
00B844  1               
00B844  1               InitEnemyRoutines:
00B844  1  20 97 BA             jsr JumpEngine
00B847  1               
00B847  1               ;jump engine table for newly loaded enemy objects
00B847  1               
00B847  1  1C C1              .word InitNormalEnemy  ;for objects $00-$0f
00B849  1  1C C1              .word InitNormalEnemy
00B84B  1  1C C1              .word InitNormalEnemy
00B84D  1  2C C1              .word InitRedKoopa
00B84F  1  FE C0              .word NoInitCode
00B851  1  36 C1              .word InitHammerBro
00B853  1  FF C0              .word InitGoomba
00B855  1  50 C1              .word InitBloober
00B857  1  79 C1              .word InitBulletBill
00B859  1  FE C0              .word NoInitCode
00B85B  1  83 C1              .word InitCheepCheep
00B85D  1  83 C1              .word InitCheepCheep
00B85F  1  05 C1              .word InitPodoboo
00B861  1  98 C4              .word InitPiranhaPlant
00B863  1  CB C4              .word InitJumpGPTroopa
00B865  1  58 C1              .word InitRedPTroopa
00B867  1               
00B867  1  4B C1              .word InitHorizFlySwimEnemy  ;for objects $10-$1f
00B869  1  93 C1              .word InitLakitu
00B86B  1  B5 B8              .word InitEnemyFrenzy
00B86D  1  FE C0              .word NoInitCode
00B86F  1  B5 B8              .word InitEnemyFrenzy
00B871  1  B5 B8              .word InitEnemyFrenzy
00B873  1  B5 B8              .word InitEnemyFrenzy
00B875  1  B5 B8              .word InitEnemyFrenzy
00B877  1  B2 C4              .word EndFrenzy
00B879  1  FE C0              .word NoInitCode
00B87B  1  FE C0              .word NoInitCode
00B87D  1  6A C2              .word InitShortFirebar
00B87F  1  6A C2              .word InitShortFirebar
00B881  1  6A C2              .word InitShortFirebar
00B883  1  6A C2              .word InitShortFirebar
00B885  1  67 C2              .word InitLongFirebar
00B887  1               
00B887  1  FE C0              .word NoInitCode ;for objects $20-$2f
00B889  1  FE C0              .word NoInitCode
00B88B  1  FE C0              .word NoInitCode
00B88D  1  FE C0              .word NoInitCode
00B88F  1  D9 C4              .word InitBalPlatform
00B891  1  0C C5              .word InitVertPlatform
00B893  1  39 C5              .word LargeLiftUp
00B895  1  3F C5              .word LargeLiftDown
00B897  1  05 C5              .word InitHoriPlatform
00B899  1  FD C4              .word InitDropPlatform
00B89B  1  05 C5              .word InitHoriPlatform
00B89D  1  45 C5              .word PlatLiftUp
00B89F  1  51 C5              .word PlatLiftDown
00B8A1  1  57 C3              .word InitBowser
00B8A3  1  17 BD              .word PwrUpJmp   ;possibly dummy value
00B8A5  1  53 EE              .word Setup_Vine
00B8A7  1               
00B8A7  1  FE C0              .word NoInitCode ;for objects $30-$36
00B8A9  1  FE C0              .word NoInitCode
00B8AB  1  FE C0              .word NoInitCode
00B8AD  1  FE C0              .word NoInitCode
00B8AF  1  FE C0              .word NoInitCode
00B8B1  1  15 C1              .word InitRetainerObj
00B8B3  1  7B C5              .word EndOfEnemyInitCode
00B8B5  1               
00B8B5  1               ;--------------------------------
00B8B5  1               
00B8B5  1               InitEnemyFrenzy:
00B8B5  1  B5 16              lda Enemy_ID,x        ;load enemy identifier
00B8B7  1  8D CB 06           sta EnemyFrenzyBuffer ;save in enemy frenzy buffer
00B8BA  1  38                 sec
00B8BB  1  E9 12              sbc #$12              ;subtract 12 and use as offset for jump engine
00B8BD  1  20 97 BA           jsr JumpEngine
00B8C0  1               
00B8C0  1               ;frenzy object jump table
00B8C0  1  B2 C1              .word LakituAndSpinyHandler
00B8C2  1  B1 C4              .word NoFrenzyCode
00B8C4  1  B6 C2              .word InitFlyingCheepCheep
00B8C6  1  B1 C3              .word InitBowserFlame
00B8C8  1  4B C4              .word InitFireworks
00B8CA  1  46 B7              .word BulletBillCheepCheep
00B8CC  1               
00B8CC  1               ;--------------------------------
00B8CC  1               
00B8CC  1               IntermediatePlayerData:
00B8CC  1  58 01 00 60          .byte $58, $01, $00, $60, $ff, $04
00B8D0  1  FF 04        
00B8D2  1               
00B8D2  1               DrawPlayer_Intermediate:
00B8D2  1  AD CC B8               lda IntermediatePlayerData
00B8D5  1  84 02                  sty $02
00B8D7  1  18                     clc
00B8D8  1  65 02                  adc $02
00B8DA  1  85 02                  sta $02
00B8DC  1  A2 04                  ldx #$04                       ;store data into zero page memory
00B8DE  1  BD CD B8     PIntLoop: lda IntermediatePlayerData+1,x   ;load data to display player as he always
00B8E1  1  95 03                  sta $03,x                      ;appears on world/lives display
00B8E3  1  CA                     dex
00B8E4  1  10 F8                  bpl PIntLoop                   ;do this until all data is loaded
00B8E6  1  A2 B8                  ldx #$b8                       ;load offset for small standing
00B8E8  1  A0 04                  ldy #$04                       ;load sprite data offset
00B8EA  1  20 4C EB               jsr DrawPlayerLoop             ;draw player accordingly
00B8ED  1  AD 26 02               lda Sprite_Attributes+36       ;get empty sprite attributes
00B8F0  1  09 40                  ora #%01000000                 ;set horizontal flip bit for bottom-right sprite
00B8F2  1  8D 22 02               sta Sprite_Attributes+32       ;store and leave
00B8F5  1  60                     rts
00B8F6  1               
00B8F6  1               ;-------------------------------------------------------------------------------------
00B8F6  1               
00B8F6  1               InitializeGame:
00B8F6  1  A0 6F                     ldy #$6f              ;clear all memory as in initialization procedure,
00B8F8  1  20 AC BA                  jsr InitializeMemory  ;but this time, clear only as far as $076f
00B8FB  1  A0 1F                     ldy #$1f
00B8FD  1  99 B0 07     ClrSndLoop:  sta SoundMemory,y     ;clear out memory used
00B900  1  88                        dey                   ;by the sound engines
00B901  1  10 FA                     bpl ClrSndLoop
00B903  1  20 4F BC                  jsr LoadAreaPointer
00B906  1               
00B906  1               InitializeArea:
00B906  1  A0 4B                       ldy #$4b                 ;clear all memory again, only as far as $074b
00B908  1  20 AC BA                    jsr InitializeMemory     ;this is only necessary if branching from
00B90B  1  A2 21                       ldx #$21
00B90D  1  A9 00                       lda #$00
00B90F  1  9D 80 07     ClrTimersLoop: sta Timers,x             ;clear out memory between
00B912  1  CA                          dex                      ;$0780 and $07a1
00B913  1  10 FA                       bpl ClrTimersLoop
00B915  1  AD 5B 07                    lda HalfwayPage
00B918  1  AC 52 07                    ldy AltEntranceControl   ;if AltEntranceControl not set, use halfway page, if any found
00B91B  1  F0 03                       beq StartPage
00B91D  1  AD 51 07                    lda EntrancePage         ;otherwise use saved entry page number here
00B920  1  8D 1A 07     StartPage:     sta ScreenLeft_PageLoc   ;set as value here
00B923  1  8D 25 07                    sta CurrentPageLoc       ;also set as current page
00B926  1  8D 28 07                    sta BackloadingFlag      ;set flag here if halfway page or saved entry page number found
00B929  1  20 A0 BC                    jsr GetScreenPosition    ;get pixel coordinates for screen borders
00B92C  1  A0 20                       ldy #$20                 ;if on odd numbered page, use $2480 as start of rendering
00B92E  1  29 01                       and #%00000001           ;otherwise use $2080, this address used later as name table
00B930  1  F0 02                       beq SetInitNTHigh        ;address for rendering of game area
00B932  1  A0 24                       ldy #$24
00B934  1  8C 20 07     SetInitNTHigh: sty CurrentNTAddr_High   ;store name table address
00B937  1  A0 80                       ldy #$80
00B939  1  8C 21 07                    sty CurrentNTAddr_Low
00B93C  1  0A                          asl                      ;store LSB of page number in high nybble
00B93D  1  0A                          asl                      ;of block buffer column position
00B93E  1  0A                          asl
00B93F  1  0A                          asl
00B940  1  8D A0 06                    sta BlockBufferColumnPos
00B943  1  CE 30 07                    dec AreaObjectLength     ;set area object lengths for all empty
00B946  1  CE 31 07                    dec AreaObjectLength+1
00B949  1  CE 32 07                    dec AreaObjectLength+2
00B94C  1  A9 0B                       lda #$0b                 ;set value for renderer to update 12 column sets
00B94E  1  8D 1E 07                    sta ColumnSets           ;12 column sets = 24 metatile columns = 1 1/2 screens
00B951  1  20 07 B4                    jsr GetAreaDataAddrs     ;get enemy and level addresses and load header
00B954  1  AD 6A 07                    lda PrimaryHardMode      ;check to see if primary hard mode has been activated
00B957  1  D0 10                       bne SetSecHard           ;if so, activate the secondary no matter where we're at
00B959  1  AD 5F 07                    lda WorldNumber          ;otherwise check world number
00B95C  1  C9 04                       cmp #World5              ;if less than 5, do not activate secondary
00B95E  1  90 0C                       bcc CheckHalfway
00B960  1  D0 07                       bne SetSecHard           ;if not equal to, then world > 5, thus activate
00B962  1  AD 5C 07                    lda LevelNumber          ;otherwise, world 5, so check level number
00B965  1  C9 02                       cmp #Level3              ;if 1 or 2, do not set secondary hard mode flag
00B967  1  90 03                       bcc CheckHalfway
00B969  1  EE CC 06     SetSecHard:    inc SecondaryHardMode    ;set secondary hard mode flag for areas 5-3 and beyond
00B96C  1  AD 5B 07     CheckHalfway:  lda HalfwayPage
00B96F  1  F0 05                       beq DoneInitArea
00B971  1  A9 02                       lda #$02                 ;if halfway page set, overwrite start position from header
00B973  1  8D 10 07                    sta PlayerEntranceCtrl
00B976  1  A9 80        DoneInitArea:  lda #Silence             ;silence music
00B978  1  85 FB                       sta AreaMusicQueue
00B97A  1  A9 01                       lda #$01                 ;disable screen output
00B97C  1  8D 74 07                    sta DisableScreenFlag
00B97F  1  EE 72 07                    inc OperMode_Task        ;increment one of the modes
00B982  1  60                          rts
00B983  1               ;--------------------------------
00B983  1               
00B983  1               RunFireworks:
00B983  1  D6 A0                   dec ExplosionTimerCounter,x ;decrement explosion timing counter here
00B985  1  D0 0C                   bne SetupExpl               ;if not expired, skip this part
00B987  1  A9 08                   lda #$08
00B989  1  95 A0                   sta ExplosionTimerCounter,x ;reset counter
00B98B  1  F6 58                   inc ExplosionGfxCounter,x   ;increment explosion graphics counter
00B98D  1  B5 58                   lda ExplosionGfxCounter,x
00B98F  1  C9 03                   cmp #$03                    ;check explosion graphics counter
00B991  1  B0 18                   bcs FireworksSoundScore     ;if at a certain point, branch to kill this object
00B993  1  20 C2 EC     SetupExpl: jsr RelativeEnemyPosition   ;get relative coordinates of explosion
00B996  1  AD B9 03                lda Enemy_Rel_YPos          ;copy relative coordinates
00B999  1  8D BA 03                sta Fireball_Rel_YPos       ;from the enemy object to the fireball object
00B99C  1  AD AE 03                lda Enemy_Rel_XPos          ;first vertical, then horizontal
00B99F  1  8D AF 03                sta Fireball_Rel_XPos
00B9A2  1  BC E5 06                ldy Enemy_SprDataOffset,x   ;get OAM data offset
00B9A5  1  B5 58                   lda ExplosionGfxCounter,x   ;get explosion graphics counter
00B9A7  1  20 A7 E8                jsr DrawExplosion_Fireworks ;do a sub to draw the explosion then leave
00B9AA  1  60                      rts
00B9AB  1               
00B9AB  1               FireworksSoundScore:
00B9AB  1  A9 00              lda #$00               ;disable enemy buffer flag
00B9AD  1  95 0F              sta Enemy_Flag,x
00B9AF  1  A9 08              lda #Sfx_Blast         ;play fireworks/gunfire sound
00B9B1  1  85 FE              sta Square2SoundQueue
00B9B3  1  60                 rts
00B9B4  1               
00B9B4  1               ;--------------------------------
00B9B4  1               
00B9B4  1               StarFlagYPosAdder:
00B9B4  1  00 00 08 08        .byte $00, $00, $08, $08
00B9B8  1               
00B9B8  1               StarFlagXPosAdder:
00B9B8  1  00 08 00 08        .byte $00, $08, $00, $08
00B9BC  1               
00B9BC  1               StarFlagTileData:
00B9BC  1  54 55 56 57        .byte $54, $55, $56, $57
00B9C0  1               
00B9C0  1               RunStarFlagObj:
00B9C0  1  A9 00              lda #$00                 ;initialize enemy frenzy buffer
00B9C2  1  8D CB 06           sta EnemyFrenzyBuffer
00B9C5  1  AD 46 07           lda StarFlagTaskControl  ;check star flag object task number here
00B9C8  1  C9 05              cmp #$05                 ;if greater than 5, branch to exit
00B9CA  1  B0 2C              bcs StarFlagExit
00B9CC  1  20 97 BA           jsr JumpEngine           ;otherwise jump to appropriate sub
00B9CF  1               
00B9CF  1  F8 B9              .word StarFlagExit
00B9D1  1  D9 B9              .word GameTimerFireworks
00B9D3  1  F9 B9              .word AwardGameTimerPoints
00B9D5  1  35 BA              .word RaiseFlagSetoffFWorks
00B9D7  1  89 BA              .word DelayToAreaEnd
00B9D9  1               
00B9D9  1               GameTimerFireworks:
00B9D9  1  A0 05                ldy #$05               ;set default state for star flag object
00B9DB  1  AD FA 07             lda GameTimerDisplay+2 ;get game timer's last digit
00B9DE  1  C9 01                cmp #$01
00B9E0  1  F0 0E                beq SetFWC             ;if last digit of game timer set to 1, skip ahead
00B9E2  1  A0 03                ldy #$03               ;otherwise load new value for state
00B9E4  1  C9 03                cmp #$03
00B9E6  1  F0 08                beq SetFWC             ;if last digit of game timer set to 3, skip ahead
00B9E8  1  A0 00                ldy #$00               ;otherwise load one more potential value for state
00B9EA  1  C9 06                cmp #$06
00B9EC  1  F0 02                beq SetFWC             ;if last digit of game timer set to 6, skip ahead
00B9EE  1  A9 FF                lda #$ff               ;otherwise set value for no fireworks
00B9F0  1  8D D7 06     SetFWC: sta FireworksCounter   ;set fireworks counter here
00B9F3  1  94 1E                sty Enemy_State,x      ;set whatever state we have in star flag object
00B9F5  1               
00B9F5  1               IncrementSFTask1:
00B9F5  1  EE 46 07           inc StarFlagTaskControl  ;increment star flag object task number
00B9F8  1               
00B9F8  1               StarFlagExit:
00B9F8  1  60                 rts                      ;leave
00B9F9  1               
00B9F9  1               AwardGameTimerPoints:
00B9F9  1  AD F8 07              lda GameTimerDisplay   ;check all game timer digits for any intervals left
00B9FC  1  0D F9 07              ora GameTimerDisplay+1
00B9FF  1  0D FA 07              ora GameTimerDisplay+2
00BA02  1  F0 F1                 beq IncrementSFTask1   ;if no time left on game timer at all, branch to next task
00BA04  1  A5 09                 lda FrameCounter
00BA06  1  29 04                 and #%00000100         ;check frame counter for d2 set (skip ahead
00BA08  1  F0 04                 beq NoTTick            ;for four frames every four frames) branch if not set
00BA0A  1  A9 10                 lda #Sfx_TimerTick
00BA0C  1  85 FE                 sta Square2SoundQueue  ;load timer tick sound
00BA0E  1  A0 23        NoTTick: ldy #$23               ;set offset here to subtract from game timer's last digit
00BA10  1  A9 FF                 lda #$ff               ;set adder here to $ff, or -1, to subtract one
00BA12  1  8D 39 01              sta DigitModifier+5    ;from the last digit of the game timer
00BA15  1  20 9E BB              jsr DigitsMathRoutine  ;subtract digit
00BA18  1  A9 05                 lda #$05               ;set now to add 50 points
00BA1A  1  8D 39 01              sta DigitModifier+5    ;per game timer interval subtracted
00BA1D  1               
00BA1D  1               EndAreaPoints:
00BA1D  1  A0 0B                 ldy #$0b               ;load offset for mario's score by default
00BA1F  1  AD 53 07              lda CurrentPlayer      ;check player on the screen
00BA22  1  F0 02                 beq ELPGive            ;if mario, do not change
00BA24  1  A0 11                 ldy #$11               ;otherwise load offset for luigi's score
00BA26  1  20 9E BB     ELPGive: jsr DigitsMathRoutine  ;award 50 points per game timer interval
00BA29  1  AD 53 07              lda CurrentPlayer      ;get player on the screen (or 500 points per
00BA2C  1  0A                    asl                    ;fireworks explosion if branched here from there)
00BA2D  1  0A                    asl                    ;shift to high nybble
00BA2E  1  0A                    asl
00BA2F  1  0A                    asl
00BA30  1  09 04                 ora #%00000100         ;add four to set nybble for game timer
00BA32  1  4C ED BC              jmp UpdateNumber       ;jump to print the new score and game timer
00BA35  1               
00BA35  1               RaiseFlagSetoffFWorks:
00BA35  1  B5 CF                 lda Enemy_Y_Position,x  ;check star flag's vertical position
00BA37  1  C9 72                 cmp #$72                ;against preset value
00BA39  1  90 05                 bcc SetoffF             ;if star flag higher vertically, branch to other code
00BA3B  1  D6 CF                 dec Enemy_Y_Position,x  ;otherwise, raise star flag by one pixel
00BA3D  1  4C 4C BA              jmp DrawStarFlag        ;and skip this part here
00BA40  1  AD D7 06     SetoffF: lda FireworksCounter    ;check fireworks counter
00BA43  1  F0 38                 beq DrawFlagSetTimer    ;if no fireworks left to go off, skip this part
00BA45  1  30 36                 bmi DrawFlagSetTimer    ;if no fireworks set to go off, skip this part
00BA47  1  A9 16                 lda #Fireworks
00BA49  1  8D CB 06              sta EnemyFrenzyBuffer   ;otherwise set fireworks object in frenzy queue
00BA4C  1               
00BA4C  1               DrawStarFlag:
00BA4C  1  20 C2 EC              jsr RelativeEnemyPosition  ;get relative coordinates of star flag
00BA4F  1  BC E5 06              ldy Enemy_SprDataOffset,x  ;get OAM data offset
00BA52  1  A2 03                 ldx #$03                   ;do four sprites
00BA54  1  AD B9 03     DSFLoop: lda Enemy_Rel_YPos         ;get relative vertical coordinate
00BA57  1  18                    clc
00BA58  1  7D B4 B9              adc StarFlagYPosAdder,x    ;add Y coordinate adder data
00BA5B  1  99 00 02              sta Sprite_Y_Position,y    ;store as Y coordinate
00BA5E  1  BD BC B9              lda StarFlagTileData,x     ;get tile number
00BA61  1  99 01 02              sta Sprite_Tilenumber,y    ;store as tile number
00BA64  1  A9 22                 lda #$22                   ;set palette and background priority bits
00BA66  1  99 02 02              sta Sprite_Attributes,y    ;store as attributes
00BA69  1  AD AE 03              lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00BA6C  1  18                    clc
00BA6D  1  7D B8 B9              adc StarFlagXPosAdder,x    ;add X coordinate adder data
00BA70  1  99 03 02              sta Sprite_X_Position,y    ;store as X coordinate
00BA73  1  C8                    iny
00BA74  1  C8                    iny                        ;increment OAM data offset four bytes
00BA75  1  C8                    iny                        ;for next sprite
00BA76  1  C8                    iny
00BA77  1  CA                    dex                        ;move onto next sprite
00BA78  1  10 DA                 bpl DSFLoop                ;do this until all sprites are done
00BA7A  1  A6 08                 ldx ObjectOffset           ;get enemy object offset and leave
00BA7C  1  60                    rts
00BA7D  1               
00BA7D  1               DrawFlagSetTimer:
00BA7D  1  20 4C BA           jsr DrawStarFlag          ;do sub to draw star flag
00BA80  1  A9 06              lda #$06
00BA82  1  9D 96 07           sta EnemyIntervalTimer,x  ;set interval timer here
00BA85  1               
00BA85  1               IncrementSFTask2:
00BA85  1  EE 46 07           inc StarFlagTaskControl   ;move onto next task
00BA88  1  60           	  rts
00BA89  1               
00BA89  1               DelayToAreaEnd:
00BA89  1  20 4C BA           jsr DrawStarFlag          ;do sub to draw star flag
00BA8C  1  BD 96 07           lda EnemyIntervalTimer,x  ;if interval timer set in previous task
00BA8F  1  D0 05              bne StarFlagExit2         ;not yet expired, branch to leave
00BA91  1  AD B1 07           lda EventMusicBuffer      ;if event music buffer empty,
00BA94  1  F0 EF              beq IncrementSFTask2      ;branch to increment task
00BA96  1               
00BA96  1               StarFlagExit2:
00BA96  1  60                 rts                       ;otherwise leave
00BA97  1               
00BA97  1               ;-------------------------------------------------------------------------------------
00BA97  1               ;$04 - address low to jump address
00BA97  1               ;$05 - address high to jump address
00BA97  1               ;$06 - jump address low
00BA97  1               ;$07 - jump address high
00BA97  1               
00BA97  1               JumpEngine:
00BA97  1  0A                  asl          ;shift bit from contents of A
00BA98  1  A8                  tay
00BA99  1  68                  pla          ;pull saved return address from stack
00BA9A  1  85 04               sta $04      ;save to indirect
00BA9C  1  68                  pla
00BA9D  1  85 05               sta $05
00BA9F  1  C8                  iny
00BAA0  1  B1 04               lda ($04),y  ;load pointer from indirect
00BAA2  1  85 06               sta $06      ;note that if an RTS is performed in next routine
00BAA4  1  C8                  iny          ;it will return to the execution before the sub
00BAA5  1  B1 04               lda ($04),y  ;that called this routine
00BAA7  1  85 07               sta $07
00BAA9  1  6C 06 00            jmp ($06)    ;jump to the address we loaded
00BAAC  1               
00BAAC  1               ;-------------------------------------------------------------------------------------
00BAAC  1               
00BAAC  1               ;$06 - RAM address low
00BAAC  1               ;$07 - RAM address high
00BAAC  1               
00BAAC  1               InitializeMemory:
00BAAC  1  AD FF 07                   lda BANK_SELECTED
00BAAF  1  48                         pha
00BAB0  1  A2 07                      ldx #$07          ;set initial high byte to $0700-$07ff
00BAB2  1  A9 00                      lda #$00          ;set initial low byte to start of page (at $00 of page)
00BAB4  1  85 06                      sta $06
00BAB6  1  86 07        InitPageLoop: stx $07
00BAB8  1  E0 01        InitByteLoop: cpx #$01          ;check to see if we're on the stack ($0100-$01ff)
00BABA  1  D0 04                      bne InitByte      ;if not, go ahead anyway
00BABC  1  C0 60                      cpy #$60          ;otherwise, check to see if we're at $0160-$01ff
00BABE  1  B0 02                      bcs SkipByte      ;if so, skip write
00BAC0  1  91 06        InitByte:     sta ($06),y       ;otherwise, initialize byte with current low byte in Y
00BAC2  1  88           SkipByte:     dey
00BAC3  1  C0 FF                      cpy #$ff          ;do this until all bytes in page have been erased
00BAC5  1  D0 F1                      bne InitByteLoop
00BAC7  1  CA                         dex               ;go onto the next page
00BAC8  1  10 EC                      bpl InitPageLoop  ;do this until all pages of memory have been erased
00BACA  1  68                         pla
00BACB  1  8D FF 07                   sta BANK_SELECTED
00BACE  1  A9 00                      lda #00
00BAD0  1  60                         rts
00BAD1  1               
00BAD1  1               ;-------------------------------------------------------------------------------------
00BAD1  1               ;$00 - vram buffer address table low
00BAD1  1               ;$01 - vram buffer address table high
00BAD1  1               
00BAD1  1               WriteBufferToScreen:
00BAD1  1  8D 06 20                    sta PPU_ADDRESS           ;store high byte of vram address
00BAD4  1  C8                          iny
00BAD5  1  B1 00                       lda ($00),y               ;load next byte (second)
00BAD7  1  8D 06 20                    sta PPU_ADDRESS           ;store low byte of vram address
00BADA  1  C8                          iny
00BADB  1  B1 00                       lda ($00),y               ;load next byte (third)
00BADD  1  0A                          asl                       ;shift to left and save in stack
00BADE  1  48                          pha
00BADF  1  AD 78 07                    lda Mirror_PPU_CTRL_REG1  ;load mirror of $2000,
00BAE2  1  09 04                       ora #%00000100            ;set ppu to increment by 32 by default
00BAE4  1  B0 02                       bcs SetupWrites           ;if d7 of third byte was clear, ppu will
00BAE6  1  29 FB                       and #%11111011            ;only increment by 1
00BAE8  1  20 2C BB     SetupWrites:   jsr WritePPUReg1          ;write to register
00BAEB  1  68                          pla                       ;pull from stack and shift to left again
00BAEC  1  0A                          asl
00BAED  1  90 03                       bcc GetLength             ;if d6 of third byte was clear, do not repeat byte
00BAEF  1  09 02                       ora #%00000010            ;otherwise set d1 and increment Y
00BAF1  1  C8                          iny
00BAF2  1  4A           GetLength:     lsr                       ;shift back to the right to get proper length
00BAF3  1  4A                          lsr                       ;note that d1 will now be in carry
00BAF4  1  AA                          tax
00BAF5  1  B0 01        OutputToVRAM:  bcs RepeatByte            ;if carry set, repeat loading the same byte
00BAF7  1  C8                          iny                       ;otherwise increment Y to load next byte
00BAF8  1  B1 00        RepeatByte:    lda ($00),y               ;load more data from buffer and write to vram
00BAFA  1  8D 07 20                    sta PPU_DATA
00BAFD  1  CA                          dex                       ;done writing?
00BAFE  1  D0 F5                       bne OutputToVRAM
00BB00  1  38                          sec
00BB01  1  98                          tya
00BB02  1  65 00                       adc $00                   ;add end length plus one to the indirect at $00
00BB04  1  85 00                       sta $00                   ;to allow this routine to read another set of updates
00BB06  1  A9 00                       lda #$00
00BB08  1  65 01                       adc $01
00BB0A  1  85 01                       sta $01
00BB0C  1  A9 3F                       lda #$3f                  ;sets vram address to $3f00
00BB0E  1  8D 06 20                    sta PPU_ADDRESS
00BB11  1  A9 00                       lda #$00
00BB13  1  8D 06 20                    sta PPU_ADDRESS
00BB16  1  8D 06 20                    sta PPU_ADDRESS           ;then reinitializes it for some reason
00BB19  1  8D 06 20                    sta PPU_ADDRESS
00BB1C  1  AE 02 20     UpdateScreen:  ldx PPU_STATUS            ;reset flip-flop
00BB1F  1  A0 00                       ldy #$00                  ;load first byte from indirect as a pointer
00BB21  1  B1 00                       lda ($00),y
00BB23  1  D0 AC                       bne WriteBufferToScreen   ;if byte is zero we have no further updates to make here
00BB25  1  8D 05 20     InitScroll:    sta PPU_SCROLL_REG        ;store contents of A into scroll registers
00BB28  1  8D 05 20                    sta PPU_SCROLL_REG        ;and end whatever subroutine led us here
00BB2B  1  60                          rts
00BB2C  1               
00BB2C  1               ;-------------------------------------------------------------------------------------
00BB2C  1               
00BB2C  1               WritePPUReg1:
00BB2C  1  8D 00 20                    sta PPU_CTRL_REG1         ;write contents of A to PPU register 1
00BB2F  1  8D 78 07                    sta Mirror_PPU_CTRL_REG1  ;and its mirror
00BB32  1  60                          rts
00BB33  1               
00BB33  1               ;-------------------------------------------------------------------------------------
00BB33  1               ;$00 - used to store status bar nybbles
00BB33  1               ;$02 - used as temp vram offset
00BB33  1               ;$03 - used to store length of status bar number
00BB33  1               
00BB33  1               ;status bar name table offset and length data
00BB33  1               StatusBarData:
00BB33  1  F0 06              .byte $f0, $06 ; top score display on title screen
00BB35  1  62 06              .byte $62, $06 ; player score
00BB37  1  62 06              .byte $62, $06
00BB39  1  6D 02              .byte $6d, $02 ; coin tally
00BB3B  1  6D 02              .byte $6d, $02
00BB3D  1  7A 03              .byte $7a, $03 ; game timer
00BB3F  1               
00BB3F  1               StatusBarOffset:
00BB3F  1  06 0C 12 18        .byte $06, $0c, $12, $18, $1e, $24
00BB43  1  1E 24        
00BB45  1               
00BB45  1               PrintStatusBarNumbers:
00BB45  1  85 00              sta $00            ;store player-specific offset
00BB47  1  20 50 BB           jsr OutputNumbers  ;use first nybble to print the coin display
00BB4A  1  A5 00              lda $00            ;move high nybble to low
00BB4C  1  4A                 lsr                ;and print to score display
00BB4D  1  4A                 lsr
00BB4E  1  4A                 lsr
00BB4F  1  4A                 lsr
00BB50  1               
00BB50  1               OutputNumbers:
00BB50  1  18                        clc                      ;add 1 to low nybble
00BB51  1  69 01                     adc #$01
00BB53  1  29 0F                     and #%00001111           ;mask out high nybble
00BB55  1  C9 06                     cmp #$06
00BB57  1  B0 44                     bcs ExitOutputN
00BB59  1  48                        pha                      ;save incremented value to stack for now and
00BB5A  1  0A                        asl                      ;shift to left and use as offset
00BB5B  1  A8                        tay
00BB5C  1  AE 00 03                  ldx VRAM_Buffer1_Offset  ;get current buffer pointer
00BB5F  1  A9 20                     lda #$20                 ;put at top of screen by default
00BB61  1  C0 00                     cpy #$00                 ;are we writing top score on title screen?
00BB63  1  D0 02                     bne SetupNums
00BB65  1  A9 22                     lda #$22                 ;if so, put further down on the screen
00BB67  1  9D 01 03     SetupNums:   sta VRAM_Buffer1,x
00BB6A  1  B9 33 BB                  lda StatusBarData,y      ;write low vram address and length of thing
00BB6D  1  9D 02 03                  sta VRAM_Buffer1+1,x     ;we're printing to the buffer
00BB70  1  B9 34 BB                  lda StatusBarData+1,y
00BB73  1  9D 03 03                  sta VRAM_Buffer1+2,x
00BB76  1  85 03                     sta $03                  ;save length byte in counter
00BB78  1  86 02                     stx $02                  ;and buffer pointer elsewhere for now
00BB7A  1  68                        pla                      ;pull original incremented value from stack
00BB7B  1  AA                        tax
00BB7C  1  BD 3F BB                  lda StatusBarOffset,x    ;load offset to value we want to write
00BB7F  1  38                        sec
00BB80  1  F9 34 BB                  sbc StatusBarData+1,y    ;subtract from length byte we read before
00BB83  1  A8                        tay                      ;use value as offset to display digits
00BB84  1  A6 02                     ldx $02
00BB86  1  B9 D7 07     DigitPLoop:  lda DisplayDigits,y      ;write digits to the buffer
00BB89  1  9D 04 03                  sta VRAM_Buffer1+3,x
00BB8C  1  E8                        inx
00BB8D  1  C8                        iny
00BB8E  1  C6 03                     dec $03                  ;do this until all the digits are written
00BB90  1  D0 F4                     bne DigitPLoop
00BB92  1  A9 00                     lda #$00                 ;put null terminator at end
00BB94  1  9D 04 03                  sta VRAM_Buffer1+3,x
00BB97  1  E8                        inx                      ;increment buffer pointer by 3
00BB98  1  E8                        inx
00BB99  1  E8                        inx
00BB9A  1  8E 00 03                  stx VRAM_Buffer1_Offset  ;store it in case we want to use it again
00BB9D  1  60           ExitOutputN: rts
00BB9E  1               
00BB9E  1               ;-------------------------------------------------------------------------------------
00BB9E  1               
00BB9E  1               DigitsMathRoutine:
00BB9E  1  AD 70 07                 lda OperMode              ;check mode of operation
00BBA1  1  C9 00                    cmp #TitleScreenModeValue
00BBA3  1  F0 16                    beq EraseDMods            ;if in title screen mode, branch to lock score
00BBA5  1  A2 05                    ldx #$05
00BBA7  1  BD 34 01     AddModLoop: lda DigitModifier,x       ;load digit amount to increment
00BBAA  1  18                       clc
00BBAB  1  79 D7 07                 adc DisplayDigits,y       ;add to current digit
00BBAE  1  30 16                    bmi BorrowOne             ;if result is a negative number, branch to subtract
00BBB0  1  C9 0A                    cmp #10
00BBB2  1  B0 19                    bcs CarryOne              ;if digit greater than $09, branch to add
00BBB4  1  99 D7 07     StoreNewD:  sta DisplayDigits,y       ;store as new score or game timer digit
00BBB7  1  88                       dey                       ;move onto next digits in score or game timer
00BBB8  1  CA                       dex                       ;and digit amounts to increment
00BBB9  1  10 EC                    bpl AddModLoop            ;loop back if we're not done yet
00BBBB  1  A9 00        EraseDMods: lda #$00                  ;store zero here
00BBBD  1  A2 06                    ldx #$06                  ;start with the last digit
00BBBF  1  9D 33 01     EraseMLoop: sta DigitModifier-1,x     ;initialize the digit amounts to increment
00BBC2  1  CA                       dex
00BBC3  1  10 FA                    bpl EraseMLoop            ;do this until they're all reset, then leave
00BBC5  1  60                       rts
00BBC6  1  DE 33 01     BorrowOne:  dec DigitModifier-1,x     ;decrement the previous digit, then put $09 in
00BBC9  1  A9 09                    lda #$09                  ;the game timer digit we're currently on to "borrow
00BBCB  1  D0 E7                    bne StoreNewD             ;the one", then do an unconditional branch back
00BBCD  1  38           CarryOne:   sec                       ;subtract ten from our digit to make it a
00BBCE  1  E9 0A                    sbc #10                   ;proper BCD number, then increment the digit
00BBD0  1  FE 33 01                 inc DigitModifier-1,x     ;preceding current digit to "carry the one" properly
00BBD3  1  4C B4 BB                 jmp StoreNewD             ;go back to just after we branched here
00BBD6  1               
00BBD6  1               ;-------------------------------------------------------------------------------------
00BBD6  1               
00BBD6  1               UpdateTopScore:
00BBD6  1  A2 05              ldx #$05          ;start with mario's score
00BBD8  1  20 DD BB           jsr TopScoreCheck
00BBDB  1  A2 0B              ldx #$0b          ;now do luigi's score
00BBDD  1               
00BBDD  1               TopScoreCheck:
00BBDD  1  A0 05                      ldy #$05                 ;start with the lowest digit
00BBDF  1  38                         sec
00BBE0  1  BD DD 07     GetScoreDiff: lda PlayerScoreDisplay,x ;subtract each player digit from each high score digit
00BBE3  1  F9 D7 07                   sbc TopScoreDisplay,y    ;from lowest to highest, if any top score digit exceeds
00BBE6  1  CA                         dex                      ;any player digit, borrow will be set until a subsequent
00BBE7  1  88                         dey                      ;subtraction clears it (player digit is higher than top)
00BBE8  1  10 F6                      bpl GetScoreDiff
00BBEA  1  90 0E                      bcc NoTopSc              ;check to see if borrow is still set, if so, no new high score
00BBEC  1  E8                         inx                      ;increment X and Y once to the start of the score
00BBED  1  C8                         iny
00BBEE  1  BD DD 07     CopyScore:    lda PlayerScoreDisplay,x ;store player's score digits into high score memory area
00BBF1  1  99 D7 07                   sta TopScoreDisplay,y
00BBF4  1  E8                         inx
00BBF5  1  C8                         iny
00BBF6  1  C0 06                      cpy #$06                 ;do this until we have stored them all
00BBF8  1  90 F4                      bcc CopyScore
00BBFA  1  60           NoTopSc:      rts
00BBFB  1               
00BBFB  1               ;-------------------------------------------------------------------------------------
00BBFB  1               
00BBFB  1               InitializeNameTables:
00BBFB  1  AD 02 20                   lda PPU_STATUS            ;reset flip-flop
00BBFE  1  AD 78 07                   lda Mirror_PPU_CTRL_REG1  ;load mirror of ppu reg $2000
00BC01  1  09 10                      ora #%00010000            ;set sprites for first 4k and background for second 4k
00BC03  1  29 F0                      and #%11110000            ;clear rest of lower nybble, leave higher alone
00BC05  1  20 2C BB                   jsr WritePPUReg1
00BC08  1  A9 24                      lda #$24                  ;set vram address to start of name table 1
00BC0A  1  20 0F BC                   jsr WriteNTAddr
00BC0D  1  A9 20                      lda #$20                  ;and then set it to name table 0
00BC0F  1  8D 06 20     WriteNTAddr:  sta PPU_ADDRESS
00BC12  1  A9 00                      lda #$00
00BC14  1  8D 06 20                   sta PPU_ADDRESS
00BC17  1  A2 04                      ldx #$04                  ;clear name table with blank tile #24
00BC19  1  A0 C0                      ldy #$c0
00BC1B  1  A9 24                      lda #$24
00BC1D  1  8D 07 20     InitNTLoop:   sta PPU_DATA              ;count out exactly 768 tiles
00BC20  1  88                         dey
00BC21  1  D0 FA                      bne InitNTLoop
00BC23  1  CA                         dex
00BC24  1  D0 F7                      bne InitNTLoop
00BC26  1  A0 40                      ldy #64                   ;now to clear the attribute table (with zero this time)
00BC28  1  8A                         txa
00BC29  1  8D 00 03                   sta VRAM_Buffer1_Offset   ;init vram buffer 1 offset
00BC2C  1  8D 01 03                   sta VRAM_Buffer1          ;init vram buffer 1
00BC2F  1  8D 07 20     InitATLoop:   sta PPU_DATA
00BC32  1  88                         dey
00BC33  1  D0 FA                      bne InitATLoop
00BC35  1  8D 3F 07                   sta HorizontalScroll      ;reset scroll variables
00BC38  1  8D 40 07                   sta VerticalScroll
00BC3B  1  4C 25 BB                   jmp InitScroll            ;initialize scroll registers to zero
00BC3E  1               
00BC3E  1               ;-------------------------------------------------------------------------------------
00BC3E  1               
00BC3E  1               MoveAllSpritesOffscreen:
00BC3E  1  A0 00                      ldy #$00                ;this routine moves all sprites off the screen
00BC40  1  2C                         .byte $2c                 ;BIT instruction opcode
00BC41  1               
00BC41  1               MoveSpritesOffscreen:
00BC41  1  A0 04                      ldy #$04                ;this routine moves all but sprite 0
00BC43  1  A9 F8                      lda #$f8                ;off the screen
00BC45  1  99 00 02     SprInitLoop:  sta Sprite_Y_Position,y ;write 248 into OAM data's Y coordinate
00BC48  1  C8                         iny                     ;which will move it off the screen
00BC49  1  C8                         iny
00BC4A  1  C8                         iny
00BC4B  1  C8                         iny
00BC4C  1  D0 F7                      bne SprInitLoop
00BC4E  1  60                         rts
00BC4F  1               
00BC4F  1               ;-------------------------------------------------------------------------------------
00BC4F  1               
00BC4F  1               LoadAreaPointer:
00BC4F  1  20 65 BC                  jsr FindAreaPointer  ;find it and store it here
00BC52  1  8D 50 07                  sta AreaPointer
00BC55  1  8D 16 60                  sta WRAM_LevelAreaPointer
00BC58  1  29 60        GetAreaType: and #%01100000       ;mask out all but d6 and d5
00BC5A  1  0A                        asl
00BC5B  1  2A                        rol
00BC5C  1  2A                        rol
00BC5D  1  2A                        rol                  ;make %0xx00000 into %000000xx
00BC5E  1  8D 4E 07                  sta AreaType         ;save 2 MSB as area type
00BC61  1  8D 17 60                  sta WRAM_LevelAreaType
00BC64  1  60                        rts
00BC65  1               
00BC65  1               FindAreaPointer:
00BC65  1  AC 5F 07           ldy WorldNumber        ;load offset from world variable
00BC68  1  B9 74 BC           lda WorldAddrOffsets,y
00BC6B  1  18                 clc                    ;add area number used to find data
00BC6C  1  6D 60 07           adc AreaNumber
00BC6F  1  A8                 tay
00BC70  1  B9 7C BC           lda AreaAddrOffsets,y  ;from there we have our area pointer
00BC73  1  60                 rts
00BC74  1               
00BC74  1               ;-------------------------------------------------------------------------------------
00BC74  1               ;GAME LEVELS DATA
00BC74  1               
00BC74  1               WorldAddrOffsets:
00BC74  1  00 05              .byte World1Areas-AreaAddrOffsets, World2Areas-AreaAddrOffsets
00BC76  1  0A 0E              .byte World3Areas-AreaAddrOffsets, World4Areas-AreaAddrOffsets
00BC78  1  13 17              .byte World5Areas-AreaAddrOffsets, World6Areas-AreaAddrOffsets
00BC7A  1  1B 20              .byte World7Areas-AreaAddrOffsets, World8Areas-AreaAddrOffsets
00BC7C  1               
00BC7C  1               AreaAddrOffsets:
00BC7C  1  25 29 C0 26  World1Areas: .byte $25, $29, $c0, $26, $60
00BC80  1  60           
00BC81  1  28 29 01 27  World2Areas: .byte $28, $29, $01, $27, $62
00BC85  1  62           
00BC86  1  24 35 20 63  World3Areas: .byte $24, $35, $20, $63
00BC8A  1  22 29 41 2C  World4Areas: .byte $22, $29, $41, $2c, $61
00BC8E  1  61           
00BC8F  1  2A 31 26 62  World5Areas: .byte $2a, $31, $26, $62
00BC93  1  2E 23 2D 60  World6Areas: .byte $2e, $23, $2d, $60
00BC97  1  33 29 01 27  World7Areas: .byte $33, $29, $01, $27, $64
00BC9B  1  64           
00BC9C  1  30 32 21 65  World8Areas: .byte $30, $32, $21, $65
00BCA0  1               
00BCA0  1               ;-------------------------------------------------------------------------------------
00BCA0  1               
00BCA0  1               GetScreenPosition:
00BCA0  1  AD 1C 07           lda ScreenLeft_X_Pos    ;get coordinate of screen's left boundary
00BCA3  1  18                 clc
00BCA4  1  69 FF              adc #$ff                ;add 255 pixels
00BCA6  1  8D 1D 07           sta ScreenRight_X_Pos   ;store as coordinate of screen's right boundary
00BCA9  1  AD 1A 07           lda ScreenLeft_PageLoc  ;get page number where left boundary is
00BCAC  1  69 00              adc #$00                ;add carry from before
00BCAE  1  8D 1B 07           sta ScreenRight_PageLoc ;store as page number where right boundary is
00BCB1  1  60                 rts
00BCB2  1               
00BCB2  1               ;-------------------------------------------------------------------------------------
00BCB2  1               
00BCB2  1               CoinTallyOffsets:
00BCB2  1  17 1D              .byte $17, $1d
00BCB4  1               
00BCB4  1               ScoreOffsets:
00BCB4  1  0B 11              .byte $0b, $11
00BCB6  1               
00BCB6  1               StatusBarNybbles:
00BCB6  1  02 13              .byte $02, $13
00BCB8  1               
00BCB8  1               GiveOneCoin:
00BCB8  1  A9 01              lda #$01               ;set digit modifier to add 1 coin
00BCBA  1  8D 39 01           sta DigitModifier+5    ;to the current player's coin tally
00BCBD  1  AE 53 07           ldx CurrentPlayer      ;get current player on the screen
00BCC0  1  BC B2 BC           ldy CoinTallyOffsets,x ;get offset for player's coin tally
00BCC3  1  20 9E BB           jsr DigitsMathRoutine  ;update the coin tally
00BCC6  1  EE 5E 07           inc CoinTally          ;increment onscreen player's coin amount
00BCC9  1  AD 5E 07           lda CoinTally
00BCCC  1  C9 64              cmp #100               ;does player have 100 coins yet?
00BCCE  1  D0 09              bne CoinPoints         ;if not, skip all of this
00BCD0  1  A9 00              lda #$00
00BCD2  1  8D 5E 07           sta CoinTally          ;otherwise, reinitialize coin amount
00BCD5  1  A9 40              lda #Sfx_ExtraLife
00BCD7  1  85 FE              sta Square2SoundQueue  ;play 1-up sound
00BCD9  1               
00BCD9  1               CoinPoints:
00BCD9  1  A9 02              lda #$02               ;set digit modifier to award
00BCDB  1  8D 38 01           sta DigitModifier+4    ;200 points to the player
00BCDE  1               
00BCDE  1               AddToScore:
00BCDE  1  AE 53 07           ldx CurrentPlayer      ;get current player
00BCE1  1  BC B4 BC           ldy ScoreOffsets,x     ;get offset for player's score
00BCE4  1  20 9E BB           jsr DigitsMathRoutine  ;update the score internally with value in digit modifier
00BCE7  1               
00BCE7  1               GetSBNybbles:
00BCE7  1  AC 53 07           ldy CurrentPlayer      ;get current player
00BCEA  1  B9 B6 BC           lda StatusBarNybbles,y ;get nybbles based on player, use to update score and coins
00BCED  1               
00BCED  1               UpdateNumber:
00BCED  1  20 45 BB             jsr PrintStatusBarNumbers ;print status bar numbers based on nybbles, whatever they be
00BCF0  1  AC 00 03             ldy VRAM_Buffer1_Offset
00BCF3  1  B9 FB 02             lda VRAM_Buffer1-6,y      ;check highest digit of score
00BCF6  1  D0 05                bne NoZSup                ;if zero, overwrite with space tile for zero suppression
00BCF8  1  A9 24                lda #$24
00BCFA  1  99 FB 02             sta VRAM_Buffer1-6,y
00BCFD  1  A6 08        NoZSup: ldx ObjectOffset          ;get enemy object buffer offset
00BCFF  1  60                   rts
00BD00  1               
00BD00  1               ;-------------------------------------------------------------------------------------
00BD00  1               
00BD00  1               SetupPowerUp:
00BD00  1  A9 2E                   lda #PowerUpObject        ;load power-up identifier into
00BD02  1  85 1B                   sta Enemy_ID+5            ;special use slot of enemy object buffer
00BD04  1  B5 76                   lda Block_PageLoc,x       ;store page location of block object
00BD06  1  85 73                   sta Enemy_PageLoc+5       ;as page location of power-up object
00BD08  1  B5 8F                   lda Block_X_Position,x    ;store horizontal coordinate of block object
00BD0A  1  85 8C                   sta Enemy_X_Position+5    ;as horizontal coordinate of power-up object
00BD0C  1  A9 01                   lda #$01
00BD0E  1  85 BB                   sta Enemy_Y_HighPos+5     ;set vertical high byte of power-up object
00BD10  1  B5 D7                   lda Block_Y_Position,x    ;get vertical coordinate of block object
00BD12  1  38                      sec
00BD13  1  E9 08                   sbc #$08                  ;subtract 8 pixels
00BD15  1  85 D4                   sta Enemy_Y_Position+5    ;and use as vertical coordinate of power-up object
00BD17  1  A9 01        PwrUpJmp:  lda #$01                  ;this is a residual jump point in enemy object jump table
00BD19  1  85 23                   sta Enemy_State+5         ;set power-up object's state
00BD1B  1  85 14                   sta Enemy_Flag+5          ;set buffer flag
00BD1D  1  A9 03                   lda #$03
00BD1F  1  8D 9F 04                sta Enemy_BoundBoxCtrl+5  ;set bounding box size control for power-up object
00BD22  1  A5 39                   lda PowerUpType
00BD24  1  C9 02                   cmp #$02                  ;check currently loaded power-up type
00BD26  1  B0 0A                   bcs PutBehind             ;if star or 1-up, branch ahead
00BD28  1  AD 56 07                lda PlayerStatus          ;otherwise check player's current status
00BD2B  1  C9 02                   cmp #$02
00BD2D  1  90 01                   bcc StrType               ;if player not fiery, use status as power-up type
00BD2F  1  4A                      lsr                       ;otherwise shift right to force fire flower type
00BD30  1  85 39        StrType:   sta PowerUpType           ;store type here
00BD32  1  A9 20        PutBehind: lda #%00100000
00BD34  1  8D CA 03                sta Enemy_SprAttrib+5     ;set background priority bit
00BD37  1  A9 02                   lda #Sfx_GrowPowerUp
00BD39  1  85 FE                   sta Square2SoundQueue     ;load power-up reveal sound and leave
00BD3B  1  60                      rts
00BD3C  1               
00BD3C  1               ;-------------------------------------------------------------------------------------
00BD3C  1               
00BD3C  1               PowerUpObjHandler:
00BD3C  1  A2 05                 ldx #$05                   ;set object offset for last slot in enemy object buffer
00BD3E  1  86 08                 stx ObjectOffset
00BD40  1  A5 23                 lda Enemy_State+5          ;check power-up object's state
00BD42  1  F0 5D                 beq ExitPUp                ;if not set, branch to leave
00BD44  1  0A                    asl                        ;shift to check if d7 was set in object state
00BD45  1  90 23                 bcc GrowThePowerUp         ;if not set, branch ahead to skip this part
00BD47  1  AD 47 07              lda TimerControl           ;if master timer control set,
00BD4A  1  D0 43                 bne RunPUSubs              ;branch ahead to enemy object routines
00BD4C  1  A5 39                 lda PowerUpType            ;check power-up type
00BD4E  1  F0 11                 beq ShroomM                ;if normal mushroom, branch ahead to move it
00BD50  1  C9 03                 cmp #$03
00BD52  1  F0 0D                 beq ShroomM                ;if 1-up mushroom, branch ahead to move it
00BD54  1  C9 02                 cmp #$02
00BD56  1  D0 37                 bne RunPUSubs              ;if not star, branch elsewhere to skip movement
00BD58  1  20 04 C8              jsr MoveJumpingEnemy       ;otherwise impose gravity on star power-up and make it jump
00BD5B  1  20 F3 DC              jsr EnemyJump              ;note that green paratroopa shares the same code here
00BD5E  1  4C 8F BD              jmp RunPUSubs              ;then jump to other power-up subroutines
00BD61  1  20 82 C7     ShroomM: jsr MoveNormalEnemy        ;do sub to make mushrooms move
00BD64  1  20 51 DB              jsr EnemyToBGCollisionDet  ;deal with collisions
00BD67  1  4C 8F BD              jmp RunPUSubs              ;run the other subroutines
00BD6A  1               
00BD6A  1               GrowThePowerUp:
00BD6A  1  A5 09                   lda FrameCounter           ;get frame counter
00BD6C  1  29 03                   and #$03                   ;mask out all but 2 LSB
00BD6E  1  D0 19                   bne ChkPUSte               ;if any bits set here, branch
00BD70  1  C6 D4                   dec Enemy_Y_Position+5     ;otherwise decrement vertical coordinate slowly
00BD72  1  A5 23                   lda Enemy_State+5          ;load power-up object state
00BD74  1  E6 23                   inc Enemy_State+5          ;increment state for next frame (to make power-up rise)
00BD76  1  C9 11                   cmp #$11                   ;if power-up object state not yet past 16th pixel,
00BD78  1  90 0F                   bcc ChkPUSte               ;branch ahead to last part here
00BD7A  1  A9 10                   lda #$10
00BD7C  1  95 58                   sta Enemy_X_Speed,x        ;otherwise set horizontal speed
00BD7E  1  A9 80                   lda #%10000000
00BD80  1  85 23                   sta Enemy_State+5          ;and then set d7 in power-up object's state
00BD82  1  0A                      asl                        ;shift once to init A
00BD83  1  8D CA 03                sta Enemy_SprAttrib+5      ;initialize background priority bit set here
00BD86  1  2A                      rol                        ;rotate A to set right moving direction
00BD87  1  95 46                   sta Enemy_MovingDir,x      ;set moving direction
00BD89  1  A5 23        ChkPUSte:  lda Enemy_State+5          ;check power-up object's state
00BD8B  1  C9 06                   cmp #$06                   ;for if power-up has risen enough
00BD8D  1  90 12                   bcc ExitPUp                ;if not, don't even bother running these routines
00BD8F  1  20 C2 EC     RunPUSubs: jsr RelativeEnemyPosition  ;get coordinates relative to screen
00BD92  1  20 1F ED                jsr GetEnemyOffscreenBits  ;get offscreen bits
00BD95  1  20 D3 DD                jsr GetEnemyBoundBox       ;get bounding box coordinates
00BD98  1  20 62 E2                jsr DrawPowerUp            ;draw the power-up object
00BD9B  1  20 46 D4                jsr PlayerEnemyCollision   ;check for collision with player
00BD9E  1  20 6D D2                jsr OffscreenBoundsCheck   ;check to see if it went offscreen
00BDA1  1  60           ExitPUp:   rts                        ;and we're done
00BDA2  1               
00BDA2  1               ;-------------------------------------------------------------------------------------
00BDA2  1               ;These apply to all routines in this section unless otherwise noted:
00BDA2  1               ;$00 - used to store metatile from block buffer routine
00BDA2  1               ;$02 - used to store vertical high nybble offset from block buffer routine
00BDA2  1               ;$05 - used to store metatile stored in A at beginning of PlayerHeadCollision
00BDA2  1               ;$06-$07 - used as block buffer address indirect
00BDA2  1               
00BDA2  1               BlockYPosAdderData:
00BDA2  1  04 12              .byte $04, $12
00BDA4  1               
00BDA4  1               PlayerHeadCollision:
00BDA4  1  48                      pha                      ;store metatile number to stack
00BDA5  1  A9 11                   lda #$11                 ;load unbreakable block object state by default
00BDA7  1  AE EE 03                ldx SprDataOffset_Ctrl   ;load offset control bit here
00BDAA  1  AC 54 07                ldy PlayerSize           ;check player's size
00BDAD  1  D0 02                   bne DBlockSte            ;if small, branch
00BDAF  1  A9 12                   lda #$12                 ;otherwise load breakable block object state
00BDB1  1  95 26        DBlockSte: sta Block_State,x        ;store into block object buffer
00BDB3  1  20 38 F0                jsr DestroyBlockMetatile ;store blank metatile in vram buffer to write to name table
00BDB6  1  AE EE 03                ldx SprDataOffset_Ctrl   ;load offset control bit
00BDB9  1  A5 02                   lda $02                  ;get vertical high nybble offset used in block buffer routine
00BDBB  1  9D E4 03                sta Block_Orig_YPos,x    ;set as vertical coordinate for block object
00BDBE  1  A8                      tay
00BDBF  1  A5 06                   lda $06                  ;get low byte of block buffer address used in same routine
00BDC1  1  9D E6 03                sta Block_BBuf_Low,x     ;save as offset here to be used later
00BDC4  1  B1 06                   lda ($06),y              ;get contents of block buffer at old address at $06, $07
00BDC6  1  20 AD BE                jsr BlockBumpedChk       ;do a sub to check which block player bumped head on
00BDC9  1  85 00                   sta $00                  ;store metatile here
00BDCB  1  AC 54 07                ldy PlayerSize           ;check player's size
00BDCE  1  D0 01                   bne ChkBrick             ;if small, use metatile itself as contents of A
00BDD0  1  98                      tya                      ;otherwise init A (note: big = 0)
00BDD1  1  90 25        ChkBrick:  bcc PutMTileB            ;if no match was found in previous sub, skip ahead
00BDD3  1  A0 11                   ldy #$11                 ;otherwise load unbreakable state into block object buffer
00BDD5  1  94 26                   sty Block_State,x        ;note this applies to both player sizes
00BDD7  1  A9 C4                   lda #$c4                 ;load empty block metatile into A for now
00BDD9  1  A4 00                   ldy $00                  ;get metatile from before
00BDDB  1  C0 58                   cpy #$58                 ;is it brick with coins (with line)?
00BDDD  1  F0 04                   beq StartBTmr            ;if so, branch
00BDDF  1  C0 5D                   cpy #$5d                 ;is it brick with coins (without line)?
00BDE1  1  D0 15                   bne PutMTileB            ;if not, branch ahead to store empty block metatile
00BDE3  1  AD BC 06     StartBTmr: lda BrickCoinTimerFlag   ;check brick coin timer flag
00BDE6  1  D0 08                   bne ContBTmr             ;if set, timer expired or counting down, thus branch
00BDE8  1  A9 0B                   lda #$0b
00BDEA  1  8D 9D 07                sta BrickCoinTimer       ;if not set, set brick coin timer
00BDED  1  EE BC 06                inc BrickCoinTimerFlag   ;and set flag linked to it
00BDF0  1  AD 9D 07     ContBTmr:  lda BrickCoinTimer       ;check brick coin timer
00BDF3  1  D0 02                   bne PutOldMT             ;if not yet expired, branch to use current metatile
00BDF5  1  A0 C4                   ldy #$c4                 ;otherwise use empty block metatile
00BDF7  1  98           PutOldMT:  tya                      ;put metatile into A
00BDF8  1  9D E8 03     PutMTileB: sta Block_Metatile,x     ;store whatever metatile be appropriate here
00BDFB  1  20 3B BE                jsr InitBlock_XY_Pos     ;get block object horizontal coordinates saved
00BDFE  1  A4 02                   ldy $02                  ;get vertical high nybble offset
00BE00  1  A9 23                   lda #$23
00BE02  1  91 06                   sta ($06),y              ;write blank metatile $23 to block buffer
00BE04  1  A9 10                   lda #$10
00BE06  1  8D 84 07                sta BlockBounceTimer     ;set block bounce timer
00BE09  1  68                      pla                      ;pull original metatile from stack
00BE0A  1  85 05                   sta $05                  ;and save here
00BE0C  1  A0 00                   ldy #$00                 ;set default offset
00BE0E  1  AD 14 07                lda CrouchingFlag        ;is player crouching?
00BE11  1  D0 05                   bne SmallBP              ;if so, branch to increment offset
00BE13  1  AD 54 07                lda PlayerSize           ;is player big?
00BE16  1  F0 01                   beq BigBP                ;if so, branch to use default offset
00BE18  1  C8           SmallBP:   iny                      ;increment for small or big and crouching
00BE19  1  A5 CE        BigBP:     lda Player_Y_Position    ;get player's vertical coordinate
00BE1B  1  18                      clc
00BE1C  1  79 A2 BD                adc BlockYPosAdderData,y ;add value determined by size
00BE1F  1  29 F0                   and #$f0                 ;mask out low nybble to get 16-pixel correspondence
00BE21  1  95 D7                   sta Block_Y_Position,x   ;save as vertical coordinate for block object
00BE23  1  B4 26                   ldy Block_State,x        ;get block object state
00BE25  1  C0 11                   cpy #$11
00BE27  1  F0 06                   beq Unbreak              ;if set to value loaded for unbreakable, branch
00BE29  1  20 B9 BE                jsr BrickShatter         ;execute code for breakable brick
00BE2C  1  4C 32 BE                jmp InvOBit              ;skip subroutine to do last part of code here
00BE2F  1  20 52 BE     Unbreak:   jsr BumpBlock            ;execute code for unbreakable brick or question block
00BE32  1  AD EE 03     InvOBit:   lda SprDataOffset_Ctrl   ;invert control bit used by block objects
00BE35  1  49 01                   eor #$01                 ;and floatey numbers
00BE37  1  8D EE 03                sta SprDataOffset_Ctrl
00BE3A  1  60                      rts                      ;leave!
00BE3B  1               
00BE3B  1               ;--------------------------------
00BE3B  1               
00BE3B  1               InitBlock_XY_Pos:
00BE3B  1  A5 86              lda Player_X_Position   ;get player's horizontal coordinate
00BE3D  1  18                 clc
00BE3E  1  69 08              adc #$08                ;add eight pixels
00BE40  1  29 F0              and #$f0                ;mask out low nybble to give 16-pixel correspondence
00BE42  1  95 8F              sta Block_X_Position,x  ;save as horizontal coordinate for block object
00BE44  1  A5 6D              lda Player_PageLoc
00BE46  1  69 00              adc #$00                ;add carry to page location of player
00BE48  1  95 76              sta Block_PageLoc,x     ;save as page location of block object
00BE4A  1  9D EA 03           sta Block_PageLoc2,x    ;save elsewhere to be used later
00BE4D  1  A5 B5              lda Player_Y_HighPos
00BE4F  1  95 BE              sta Block_Y_HighPos,x   ;save vertical high byte of player into
00BE51  1  60                 rts                     ;vertical high byte of block object and leave
00BE52  1               
00BE52  1               ;--------------------------------
00BE52  1               
00BE52  1               BumpBlock:
00BE52  1  20 D6 BE                jsr CheckTopOfBlock     ;check to see if there's a coin directly above this block
00BE55  1  A9 02                   lda #Sfx_Bump
00BE57  1  85 FF                   sta Square1SoundQueue   ;play bump sound
00BE59  1  A9 00                   lda #$00
00BE5B  1  95 60                   sta Block_X_Speed,x     ;initialize horizontal speed for block object
00BE5D  1  9D 3C 04                sta Block_Y_MoveForce,x ;init fractional movement force
00BE60  1  85 9F                   sta Player_Y_Speed      ;init player's vertical speed
00BE62  1  A9 FE                   lda #$fe
00BE64  1  95 A8                   sta Block_Y_Speed,x     ;set vertical speed for block object
00BE66  1  A5 05                   lda $05                 ;get original metatile from stack
00BE68  1  20 AD BE                jsr BlockBumpedChk      ;do a sub to check which block player bumped head on
00BE6B  1  90 31                   bcc ExitBlockChk        ;if no match was found, branch to leave
00BE6D  1  98                      tya                     ;move block number to A
00BE6E  1  C9 09                   cmp #$09                ;if block number was within 0-8 range,
00BE70  1  90 02                   bcc BlockCode           ;branch to use current number
00BE72  1  E9 05                   sbc #$05                ;otherwise subtract 5 for second set to get proper number
00BE74  1  20 97 BA     BlockCode: jsr JumpEngine          ;run appropriate subroutine depending on block number
00BE77  1               
00BE77  1  89 BE              .word MushFlowerBlock
00BE79  1  A8 EF              .word CoinBlock
00BE7B  1  A8 EF              .word CoinBlock
00BE7D  1  8F BE              .word ExtraLifeMushBlock
00BE7F  1  89 BE              .word MushFlowerBlock
00BE81  1  96 BE              .word VineBlock
00BE83  1  8C BE              .word StarBlock
00BE85  1  A8 EF              .word CoinBlock
00BE87  1  8F BE              .word ExtraLifeMushBlock
00BE89  1               
00BE89  1               ;--------------------------------
00BE89  1               
00BE89  1               MushFlowerBlock:
00BE89  1  A9 00              lda #$00       ;load mushroom/fire flower into power-up type
00BE8B  1  2C                 .byte $2c        ;BIT instruction opcode
00BE8C  1               
00BE8C  1               StarBlock:
00BE8C  1  A9 02              lda #$02       ;load star into power-up type
00BE8E  1  2C                 .byte $2c        ;BIT instruction opcode
00BE8F  1               
00BE8F  1               ExtraLifeMushBlock:
00BE8F  1  A9 03              lda #$03         ;load 1-up mushroom into power-up type
00BE91  1  85 39              sta $39          ;store correct power-up type
00BE93  1  4C 00 BD           jmp SetupPowerUp
00BE96  1               
00BE96  1               VineBlock:
00BE96  1  A2 05              ldx #$05                ;load last slot for enemy object buffer
00BE98  1  AC EE 03           ldy SprDataOffset_Ctrl  ;get control bit
00BE9B  1  20 53 EE           jsr Setup_Vine          ;set up vine object
00BE9E  1               
00BE9E  1               ExitBlockChk:
00BE9E  1  60                 rts                     ;leave
00BE9F  1               
00BE9F  1               ;--------------------------------
00BE9F  1               
00BE9F  1               BrickQBlockMetatiles:
00BE9F  1  C1 C0 5F 60        .byte $c1, $c0, $5f, $60 ;used by question blocks
00BEA3  1               
00BEA3  1                     ;these two sets are functionally identical, but look different
00BEA3  1  55 56 57 58        .byte $55, $56, $57, $58, $59 ;used by ground level types
00BEA7  1  59           
00BEA8  1  5A 5B 5C 5D        .byte $5a, $5b, $5c, $5d, $5e ;used by other level types
00BEAC  1  5E           
00BEAD  1               
00BEAD  1               BlockBumpedChk:
00BEAD  1  A0 0D                     ldy #$0d                    ;start at end of metatile data
00BEAF  1  D9 9F BE     BumpChkLoop: cmp BrickQBlockMetatiles,y  ;check to see if current metatile matches
00BEB2  1  F0 04                     beq MatchBump               ;metatile found in block buffer, branch if so
00BEB4  1  88                        dey                         ;otherwise move onto next metatile
00BEB5  1  10 F8                     bpl BumpChkLoop             ;do this until all metatiles are checked
00BEB7  1  18                        clc                         ;if none match, return with carry clear
00BEB8  1  60           MatchBump:   rts                         ;note carry is set if found match
00BEB9  1               
00BEB9  1               ;--------------------------------
00BEB9  1               
00BEB9  1               BrickShatter:
00BEB9  1  20 D6 BE           jsr CheckTopOfBlock    ;check to see if there's a coin directly above this block
00BEBC  1  A9 01              lda #Sfx_BrickShatter
00BEBE  1  9D EC 03           sta Block_RepFlag,x    ;set flag for block object to immediately replace metatile
00BEC1  1  85 FD              sta NoiseSoundQueue    ;load brick shatter sound
00BEC3  1  20 F8 BE           jsr SpawnBrickChunks   ;create brick chunk objects
00BEC6  1  A9 FE              lda #$fe
00BEC8  1  85 9F              sta Player_Y_Speed     ;set vertical speed for player
00BECA  1  A9 05              lda #$05
00BECC  1  8D 39 01           sta DigitModifier+5    ;set digit modifier to give player 50 points
00BECF  1  20 DE BC           jsr AddToScore         ;do sub to update the score
00BED2  1  AE EE 03           ldx SprDataOffset_Ctrl ;load control bit and leave
00BED5  1  60                 rts
00BED6  1               
00BED6  1               ;--------------------------------
00BED6  1               
00BED6  1               CheckTopOfBlock:
00BED6  1  AE EE 03            ldx SprDataOffset_Ctrl  ;load control bit
00BED9  1  A4 02               ldy $02                 ;get vertical high nybble offset used in block buffer
00BEDB  1  F0 1A               beq TopEx               ;branch to leave if set to zero, because we're at the top
00BEDD  1  98                  tya                     ;otherwise set to A
00BEDE  1  38                  sec
00BEDF  1  E9 10               sbc #$10                ;subtract $10 to move up one row in the block buffer
00BEE1  1  85 02               sta $02                 ;store as new vertical high nybble offset
00BEE3  1  A8                  tay
00BEE4  1  B1 06               lda ($06),y             ;get contents of block buffer in same column, one row up
00BEE6  1  C9 C2               cmp #$c2                ;is it a coin? (not underwater)
00BEE8  1  D0 0D               bne TopEx               ;if not, branch to leave
00BEEA  1  A9 00               lda #$00
00BEEC  1  91 06               sta ($06),y             ;otherwise put blank metatile where coin was
00BEEE  1  20 1A F0            jsr RemoveCoin_Axe      ;write blank metatile to vram buffer
00BEF1  1  AE EE 03            ldx SprDataOffset_Ctrl  ;get control bit
00BEF4  1  20 C1 EF            jsr SetupJumpCoin       ;create jumping coin object and update coin variables
00BEF7  1  60           TopEx: rts                     ;leave!
00BEF8  1               
00BEF8  1               ;--------------------------------
00BEF8  1               
00BEF8  1               SpawnBrickChunks:
00BEF8  1  B5 8F              lda Block_X_Position,x     ;set horizontal coordinate of block object
00BEFA  1  9D F1 03           sta Block_Orig_XPos,x      ;as original horizontal coordinate here
00BEFD  1  A9 F0              lda #$f0
00BEFF  1  95 60              sta Block_X_Speed,x        ;set horizontal speed for brick chunk objects
00BF01  1  95 62              sta Block_X_Speed+2,x
00BF03  1  A9 FA              lda #$fa
00BF05  1  95 A8              sta Block_Y_Speed,x        ;set vertical speed for one
00BF07  1  A9 FC              lda #$fc
00BF09  1  95 AA              sta Block_Y_Speed+2,x      ;set lower vertical speed for the other
00BF0B  1  A9 00              lda #$00
00BF0D  1  9D 3C 04           sta Block_Y_MoveForce,x    ;init fractional movement force for both
00BF10  1  9D 3E 04           sta Block_Y_MoveForce+2,x
00BF13  1  B5 76              lda Block_PageLoc,x
00BF15  1  95 78              sta Block_PageLoc+2,x      ;copy page location
00BF17  1  B5 8F              lda Block_X_Position,x
00BF19  1  95 91              sta Block_X_Position+2,x   ;copy horizontal coordinate
00BF1B  1  B5 D7              lda Block_Y_Position,x
00BF1D  1  18                 clc                        ;add 8 pixels to vertical coordinate
00BF1E  1  69 08              adc #$08                   ;and save as vertical coordinate for one of them
00BF20  1  95 D9              sta Block_Y_Position+2,x
00BF22  1  A9 FA              lda #$fa
00BF24  1  95 A8              sta Block_Y_Speed,x        ;set vertical speed...again??? (redundant)
00BF26  1  60                 rts
00BF27  1               
00BF27  1               ;-------------------------------------------------------------------------------------
00BF27  1               
00BF27  1               BlockObjectsCore:
00BF27  1  B5 26                lda Block_State,x           ;get state of block object
00BF29  1  F0 5D                beq UpdSte                  ;if not set, branch to leave
00BF2B  1  29 0F                and #$0f                    ;mask out high nybble
00BF2D  1  48                   pha                         ;push to stack
00BF2E  1  A8                   tay                         ;put in Y for now
00BF2F  1  8A                   txa
00BF30  1  18                   clc
00BF31  1  69 09                adc #$09                    ;add 9 bytes to offset (note two block objects are created
00BF33  1  AA                   tax                         ;when using brick chunks, but only one offset for both)
00BF34  1  88                   dey                         ;decrement Y to check for solid block state
00BF35  1  F0 33                beq BouncingBlockHandler    ;branch if found, otherwise continue for brick chunks
00BF37  1  20 5B C0             jsr ImposeGravityBlock      ;do sub to impose gravity on one block object object
00BF3A  1  20 C6 BF             jsr MoveObjectHorizontally  ;do another sub to move horizontally
00BF3D  1  8A                   txa
00BF3E  1  18                   clc                         ;move onto next block object
00BF3F  1  69 02                adc #$02
00BF41  1  AA                   tax
00BF42  1  20 5B C0             jsr ImposeGravityBlock      ;do sub to impose gravity on other block object
00BF45  1  20 C6 BF             jsr MoveObjectHorizontally  ;do another sub to move horizontally
00BF48  1  A6 08                ldx ObjectOffset            ;get block object offset used for both
00BF4A  1  20 C9 EC             jsr RelativeBlockPosition   ;get relative coordinates
00BF4D  1  20 26 ED             jsr GetBlockOffscreenBits   ;get offscreen information
00BF50  1  20 E3 E7             jsr DrawBrickChunks         ;draw the brick chunks
00BF53  1  68                   pla                         ;get lower nybble of saved state
00BF54  1  B4 BE                ldy Block_Y_HighPos,x       ;check vertical high byte of block object
00BF56  1  F0 30                beq UpdSte                  ;if above the screen, branch to kill it
00BF58  1  48                   pha                         ;otherwise save state back into stack
00BF59  1  A9 F0                lda #$f0
00BF5B  1  D5 D9                cmp Block_Y_Position+2,x    ;check to see if bottom block object went
00BF5D  1  B0 02                bcs ChkTop                  ;to the bottom of the screen, and branch if not
00BF5F  1  95 D9                sta Block_Y_Position+2,x    ;otherwise set offscreen coordinate
00BF61  1  B5 D7        ChkTop: lda Block_Y_Position,x      ;get top block object's vertical coordinate
00BF63  1  C9 F0                cmp #$f0                    ;see if it went to the bottom of the screen
00BF65  1  68                   pla                         ;pull block object state from stack
00BF66  1  90 20                bcc UpdSte                  ;if not, branch to save state
00BF68  1  B0 1C                bcs KillBlock               ;otherwise do unconditional branch to kill it
00BF6A  1               
00BF6A  1               BouncingBlockHandler:
00BF6A  1  20 5B C0                jsr ImposeGravityBlock     ;do sub to impose gravity on block object
00BF6D  1  A6 08                   ldx ObjectOffset           ;get block object offset
00BF6F  1  20 C9 EC                jsr RelativeBlockPosition  ;get relative coordinates
00BF72  1  20 26 ED                jsr GetBlockOffscreenBits  ;get offscreen information
00BF75  1  20 61 E7                jsr DrawBlock              ;draw the block
00BF78  1  B5 D7                   lda Block_Y_Position,x     ;get vertical coordinate
00BF7A  1  29 0F                   and #$0f                   ;mask out high nybble
00BF7C  1  C9 05                   cmp #$05                   ;check to see if low nybble wrapped around
00BF7E  1  68                      pla                        ;pull state from stack
00BF7F  1  B0 07                   bcs UpdSte                 ;if still above amount, not time to kill block yet, thus branch
00BF81  1  A9 01                   lda #$01
00BF83  1  9D EC 03                sta Block_RepFlag,x        ;otherwise set flag to replace metatile
00BF86  1  A9 00        KillBlock: lda #$00                   ;if branched here, nullify object state
00BF88  1  95 26        UpdSte:    sta Block_State,x          ;store contents of A in block object state
00BF8A  1  60                      rts
00BF8B  1               
00BF8B  1               ;-------------------------------------------------------------------------------------
00BF8B  1               ;$02 - used to store offset to block buffer
00BF8B  1               ;$06-$07 - used to store block buffer address
00BF8B  1               
00BF8B  1               BlockObjMT_Updater:
00BF8B  1  A2 01                    ldx #$01                  ;set offset to start with second block object
00BF8D  1  86 08        UpdateLoop: stx ObjectOffset          ;set offset here
00BF8F  1  AD 01 03                 lda VRAM_Buffer1          ;if vram buffer already being used here,
00BF92  1  D0 21                    bne NextBUpd              ;branch to move onto next block object
00BF94  1  BD EC 03                 lda Block_RepFlag,x       ;if flag for block object already clear,
00BF97  1  F0 1C                    beq NextBUpd              ;branch to move onto next block object
00BF99  1  BD E6 03                 lda Block_BBuf_Low,x      ;get low byte of block buffer
00BF9C  1  85 06                    sta $06                   ;store into block buffer address
00BF9E  1  A9 05                    lda #$05
00BFA0  1  85 07                    sta $07                   ;set high byte of block buffer address
00BFA2  1  BD E4 03                 lda Block_Orig_YPos,x     ;get original vertical coordinate of block object
00BFA5  1  85 02                    sta $02                   ;store here and use as offset to block buffer
00BFA7  1  A8                       tay
00BFA8  1  BD E8 03                 lda Block_Metatile,x      ;get metatile to be written
00BFAB  1  91 06                    sta ($06),y               ;write it to the block buffer
00BFAD  1  20 2E F0                 jsr ReplaceBlockMetatile  ;do sub to replace metatile where block object is
00BFB0  1  A9 00                    lda #$00
00BFB2  1  9D EC 03                 sta Block_RepFlag,x       ;clear block object flag
00BFB5  1  CA           NextBUpd:   dex                       ;decrement block object offset
00BFB6  1  10 D5                    bpl UpdateLoop            ;do this until both block objects are dealt with
00BFB8  1  60                       rts                       ;then leave
00BFB9  1               
00BFB9  1               ;-------------------------------------------------------------------------------------
00BFB9  1               ;$00 - used to store high nybble of horizontal speed as adder
00BFB9  1               ;$01 - used to store low nybble of horizontal speed
00BFB9  1               ;$02 - used to store adder to page location
00BFB9  1               
00BFB9  1               MoveEnemyHorizontally:
00BFB9  1  E8                 inx                         ;increment offset for enemy offset
00BFBA  1  20 C6 BF           jsr MoveObjectHorizontally  ;position object horizontally according to
00BFBD  1  A6 08              ldx ObjectOffset            ;counters, return with saved value in A,
00BFBF  1  60                 rts                         ;put enemy offset back in X and leave
00BFC0  1               
00BFC0  1               MovePlayerHorizontally:
00BFC0  1  AD 0E 07           lda JumpspringAnimCtrl  ;if jumpspring currently animating,
00BFC3  1  D0 3E              bne ExXMove             ;branch to leave
00BFC5  1  AA                 tax                     ;otherwise set zero for offset to use player's stuff
00BFC6  1               
00BFC6  1               MoveObjectHorizontally:
00BFC6  1  B5 57                  lda SprObject_X_Speed,x     ;get currently saved value (horizontal
00BFC8  1  0A                     asl                         ;speed, secondary counter, whatever)
00BFC9  1  0A                     asl                         ;and move low nybble to high
00BFCA  1  0A                     asl
00BFCB  1  0A                     asl
00BFCC  1  85 01                  sta $01                     ;store result here
00BFCE  1  B5 57                  lda SprObject_X_Speed,x     ;get saved value again
00BFD0  1  4A                     lsr                         ;move high nybble to low
00BFD1  1  4A                     lsr
00BFD2  1  4A                     lsr
00BFD3  1  4A                     lsr
00BFD4  1  C9 08                  cmp #$08                    ;if < 8, branch, do not change
00BFD6  1  90 02                  bcc SaveXSpd
00BFD8  1  09 F0                  ora #%11110000              ;otherwise alter high nybble
00BFDA  1  85 00        SaveXSpd: sta $00                     ;save result here
00BFDC  1  A0 00                  ldy #$00                    ;load default Y value here
00BFDE  1  C9 00                  cmp #$00                    ;if result positive, leave Y alone
00BFE0  1  10 01                  bpl UseAdder
00BFE2  1  88                     dey                         ;otherwise decrement Y
00BFE3  1  84 02        UseAdder: sty $02                     ;save Y here
00BFE5  1  BD 00 04               lda SprObject_X_MoveForce,x ;get whatever number's here
00BFE8  1  18                     clc
00BFE9  1  65 01                  adc $01                     ;add low nybble moved to high
00BFEB  1  9D 00 04               sta SprObject_X_MoveForce,x ;store result here
00BFEE  1  A9 00                  lda #$00                    ;init A
00BFF0  1  2A                     rol                         ;rotate carry into d0
00BFF1  1  48                     pha                         ;push onto stack
00BFF2  1  6A                     ror                         ;rotate d0 back onto carry
00BFF3  1  B5 86                  lda SprObject_X_Position,x
00BFF5  1  65 00                  adc $00                     ;add carry plus saved value (high nybble moved to low
00BFF7  1  95 86                  sta SprObject_X_Position,x  ;plus $f0 if necessary) to object's horizontal position
00BFF9  1  B5 6D                  lda SprObject_PageLoc,x
00BFFB  1  65 02                  adc $02                     ;add carry plus other saved value to the
00BFFD  1  95 6D                  sta SprObject_PageLoc,x     ;object's page location and save
00BFFF  1  68                     pla
00C000  1  18                     clc                         ;pull old carry from stack and add
00C001  1  65 00                  adc $00                     ;to high nybble moved to low
00C003  1  60           ExXMove:  rts                         ;and leave
00C004  1               
00C004  1               ;-------------------------------------------------------------------------------------
00C004  1               ;$00 - used for downward force
00C004  1               ;$01 - used for upward force
00C004  1               ;$02 - used for maximum vertical speed
00C004  1               
00C004  1               MovePlayerVertically:
00C004  1  A2 00                 ldx #$00                ;set X for player offset
00C006  1  AD 47 07              lda TimerControl
00C009  1  D0 05                 bne NoJSChk             ;if master timer control set, branch ahead
00C00B  1  AD 0E 07              lda JumpspringAnimCtrl  ;otherwise check to see if jumpspring is animating
00C00E  1  D0 F3                 bne ExXMove             ;branch to leave if so
00C010  1  AD 09 07     NoJSChk: lda VerticalForce       ;dump vertical force
00C013  1  85 00                 sta $00
00C015  1  A9 04                 lda #$04                ;set maximum vertical speed here
00C017  1  4C 64 C0              jmp ImposeGravitySprObj ;then jump to move player vertically
00C01A  1               
00C01A  1               ;--------------------------------
00C01A  1               
00C01A  1               MoveD_EnemyVertically:
00C01A  1  A0 3D              ldy #$3d           ;set quick movement amount downwards
00C01C  1  B5 1E              lda Enemy_State,x  ;then check enemy state
00C01E  1  C9 05              cmp #$05           ;if not set to unique state for spiny's egg, go ahead
00C020  1  D0 02              bne ContVMove      ;and use, otherwise set different movement amount, continue on
00C022  1               
00C022  1               MoveFallingPlatform:
00C022  1  A0 20                   ldy #$20       ;set movement amount
00C024  1  4C 4B C0     ContVMove: jmp SetHiMax   ;jump to skip the rest of this
00C027  1               
00C027  1               ;--------------------------------
00C027  1               
00C027  1               MoveRedPTroopaDown:
00C027  1  A0 00              ldy #$00            ;set Y to move downwards
00C029  1  4C 2E C0           jmp MoveRedPTroopa  ;skip to movement routine
00C02C  1               
00C02C  1               MoveRedPTroopaUp:
00C02C  1  A0 01              ldy #$01            ;set Y to move upwards
00C02E  1               
00C02E  1               MoveRedPTroopa:
00C02E  1  E8                 inx                 ;increment X for enemy offset
00C02F  1  A9 03              lda #$03
00C031  1  85 00              sta $00             ;set downward movement amount here
00C033  1  A9 06              lda #$06
00C035  1  85 01              sta $01             ;set upward movement amount here
00C037  1  A9 02              lda #$02
00C039  1  85 02              sta $02             ;set maximum speed here
00C03B  1  98                 tya                 ;set movement direction in A, and
00C03C  1  4C 88 C0           jmp RedPTroopaGrav  ;jump to move this thing
00C03F  1               
00C03F  1               ;--------------------------------
00C03F  1               
00C03F  1               MoveDropPlatform:
00C03F  1  A0 7F              ldy #$7f      ;set movement amount for drop platform
00C041  1  D0 02              bne SetMdMax  ;skip ahead of other value set here
00C043  1               
00C043  1               MoveEnemySlowVert:
00C043  1  A0 0F                  ldy #$0f         ;set movement amount for bowser/other objects
00C045  1  A9 02        SetMdMax: lda #$02         ;set maximum speed in A
00C047  1  D0 04                  bne SetXMoveAmt  ;unconditional branch
00C049  1               
00C049  1               ;--------------------------------
00C049  1               
00C049  1               MoveJ_EnemyVertically:
00C049  1  A0 1C                     ldy #$1c                ;set movement amount for podoboo/other objects
00C04B  1  A9 03        SetHiMax:    lda #$03                ;set maximum speed in A
00C04D  1  84 00        SetXMoveAmt: sty $00                 ;set movement amount here
00C04F  1  E8                        inx                     ;increment X for enemy offset
00C050  1  20 64 C0                  jsr ImposeGravitySprObj ;do a sub to move enemy object downwards
00C053  1  A6 08                     ldx ObjectOffset        ;get enemy object buffer offset and leave
00C055  1  60                        rts
00C056  1               
00C056  1               ;--------------------------------
00C056  1               
00C056  1               MaxSpdBlockData:
00C056  1  06 08              .byte $06, $08
00C058  1               
00C058  1               ResidualGravityCode:
00C058  1  A0 00              ldy #$00       ;this part appears to be residual,
00C05A  1  2C                 .byte $2c        ;no code branches or jumps to it...
00C05B  1               
00C05B  1               ImposeGravityBlock:
00C05B  1  A0 01              ldy #$01       ;set offset for maximum speed
00C05D  1  A9 50              lda #$50       ;set movement amount here
00C05F  1  85 00              sta $00
00C061  1  B9 56 C0           lda MaxSpdBlockData,y    ;get maximum speed
00C064  1               
00C064  1               ImposeGravitySprObj:
00C064  1  85 02              sta $02            ;set maximum speed here
00C066  1  A9 00              lda #$00           ;set value to move downwards
00C068  1  4C 8E C0           jmp ImposeGravity  ;jump to the code that actually moves it
00C06B  1               
00C06B  1               ;--------------------------------
00C06B  1               
00C06B  1               MovePlatformDown:
00C06B  1  A9 00              lda #$00    ;save value to stack (if branching here, execute next
00C06D  1  2C                 .byte $2c     ;part as BIT instruction)
00C06E  1               
00C06E  1               MovePlatformUp:
00C06E  1  A9 01                   lda #$01        ;save value to stack
00C070  1  48                      pha
00C071  1  B4 16                   ldy Enemy_ID,x  ;get enemy object identifier
00C073  1  E8                      inx             ;increment offset for enemy object
00C074  1  A9 05                   lda #$05        ;load default value here
00C076  1  C0 29                   cpy #$29        ;residual comparison, object #29 never executes
00C078  1  D0 02                   bne SetDplSpd   ;this code, thus unconditional branch here
00C07A  1  A9 09                   lda #$09        ;residual code
00C07C  1  85 00        SetDplSpd: sta $00         ;save downward movement amount here
00C07E  1  A9 0A                   lda #$0a        ;save upward movement amount here
00C080  1  85 01                   sta $01
00C082  1  A9 03                   lda #$03        ;save maximum vertical speed here
00C084  1  85 02                   sta $02
00C086  1  68                      pla             ;get value from stack
00C087  1  A8                      tay             ;use as Y, then move onto code shared by red koopa
00C088  1               
00C088  1               RedPTroopaGrav:
00C088  1  20 8E C0           jsr ImposeGravity  ;do a sub to move object gradually
00C08B  1  A6 08              ldx ObjectOffset   ;get enemy object offset and leave
00C08D  1  60                 rts
00C08E  1               
00C08E  1               ;-------------------------------------------------------------------------------------
00C08E  1               ;$00 - used for downward force
00C08E  1               ;$01 - used for upward force
00C08E  1               ;$07 - used as adder for vertical position
00C08E  1               
00C08E  1               ImposeGravity:
00C08E  1  48                    pha                          ;push value to stack
00C08F  1  BD 16 04              lda SprObject_YMF_Dummy,x
00C092  1  18                    clc                          ;add value in movement force to contents of dummy variable
00C093  1  7D 33 04              adc SprObject_Y_MoveForce,x
00C096  1  9D 16 04              sta SprObject_YMF_Dummy,x
00C099  1  A0 00                 ldy #$00                     ;set Y to zero by default
00C09B  1  B5 9F                 lda SprObject_Y_Speed,x      ;get current vertical speed
00C09D  1  10 01                 bpl AlterYP                  ;if currently moving downwards, do not decrement Y
00C09F  1  88                    dey                          ;otherwise decrement Y
00C0A0  1  84 07        AlterYP: sty $07                      ;store Y here
00C0A2  1  75 CE                 adc SprObject_Y_Position,x   ;add vertical position to vertical speed plus carry
00C0A4  1  95 CE                 sta SprObject_Y_Position,x   ;store as new vertical position
00C0A6  1  B5 B5                 lda SprObject_Y_HighPos,x
00C0A8  1  65 07                 adc $07                      ;add carry plus contents of $07 to vertical high byte
00C0AA  1  95 B5                 sta SprObject_Y_HighPos,x    ;store as new vertical high byte
00C0AC  1  BD 33 04              lda SprObject_Y_MoveForce,x
00C0AF  1  18                    clc
00C0B0  1  65 00                 adc $00                      ;add downward movement amount to contents of $0433
00C0B2  1  9D 33 04              sta SprObject_Y_MoveForce,x
00C0B5  1  B5 9F                 lda SprObject_Y_Speed,x      ;add carry to vertical speed and store
00C0B7  1  69 00                 adc #$00
00C0B9  1  95 9F                 sta SprObject_Y_Speed,x
00C0BB  1  C5 02                 cmp $02                      ;compare to maximum speed
00C0BD  1  30 10                 bmi ChkUpM                   ;if less than preset value, skip this part
00C0BF  1  BD 33 04              lda SprObject_Y_MoveForce,x
00C0C2  1  C9 80                 cmp #$80                     ;if less positively than preset maximum, skip this part
00C0C4  1  90 09                 bcc ChkUpM
00C0C6  1  A5 02                 lda $02
00C0C8  1  95 9F                 sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
00C0CA  1  A9 00                 lda #$00
00C0CC  1  9D 33 04              sta SprObject_Y_MoveForce,x  ;clear fractional
00C0CF  1  68           ChkUpM:  pla                          ;get value from stack
00C0D0  1  F0 2B                 beq ExVMove                  ;if set to zero, branch to leave
00C0D2  1  A5 02                 lda $02
00C0D4  1  49 FF                 eor #%11111111               ;otherwise get two's compliment of maximum speed
00C0D6  1  A8                    tay
00C0D7  1  C8                    iny
00C0D8  1  84 07                 sty $07                      ;store two's compliment here
00C0DA  1  BD 33 04              lda SprObject_Y_MoveForce,x
00C0DD  1  38                    sec                          ;subtract upward movement amount from contents
00C0DE  1  E5 01                 sbc $01                      ;of movement force, note that $01 is twice as large as $00,
00C0E0  1  9D 33 04              sta SprObject_Y_MoveForce,x  ;thus it effectively undoes add we did earlier
00C0E3  1  B5 9F                 lda SprObject_Y_Speed,x
00C0E5  1  E9 00                 sbc #$00                     ;subtract borrow from vertical speed and store
00C0E7  1  95 9F                 sta SprObject_Y_Speed,x
00C0E9  1  C5 07                 cmp $07                      ;compare vertical speed to two's compliment
00C0EB  1  10 10                 bpl ExVMove                  ;if less negatively than preset maximum, skip this part
00C0ED  1  BD 33 04              lda SprObject_Y_MoveForce,x
00C0F0  1  C9 80                 cmp #$80                     ;check if fractional part is above certain amount,
00C0F2  1  B0 09                 bcs ExVMove                  ;and if so, branch to leave
00C0F4  1  A5 07                 lda $07
00C0F6  1  95 9F                 sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
00C0F8  1  A9 FF                 lda #$ff
00C0FA  1  9D 33 04              sta SprObject_Y_MoveForce,x  ;clear fractional
00C0FD  1  60           ExVMove: rts                          ;leave!
00C0FE  1               
00C0FE  1               ;-------------------------------------------------------------------------------------
00C0FE  1               
00C0FE  1               NoInitCode:
00C0FE  1  60                 rts               ;this executed when enemy object has no init code
00C0FF  1               
00C0FF  1               ;--------------------------------
00C0FF  1               
00C0FF  1               InitGoomba:
00C0FF  1  20 1C C1           jsr InitNormalEnemy  ;set appropriate horizontal speed
00C102  1  4C 54 C1           jmp SmallBBox        ;set $09 as bounding box control, set other values
00C105  1               
00C105  1               
00C105  1               ;-------------------------------------------------------------------------------------
00C105  1               
00C105  1               InitPodoboo:
00C105  1  A9 02              lda #$02                  ;set enemy position to below
00C107  1  95 B6              sta Enemy_Y_HighPos,x     ;the bottom of the screen
00C109  1  95 CF              sta Enemy_Y_Position,x
00C10B  1  4A                 lsr
00C10C  1  9D 96 07           sta EnemyIntervalTimer,x  ;set timer for enemy
00C10F  1  4A                 lsr
00C110  1  95 1E              sta Enemy_State,x         ;initialize enemy state, then jump to use
00C112  1  4C 54 C1           jmp SmallBBox             ;$09 as bounding box size and set other things
00C115  1               
00C115  1               ;--------------------------------
00C115  1               
00C115  1               InitRetainerObj:
00C115  1  A9 B8              lda #$b8                ;set fixed vertical position for
00C117  1  95 CF              sta Enemy_Y_Position,x  ;princess/mushroom retainer object
00C119  1  60                 rts
00C11A  1               
00C11A  1               ;--------------------------------
00C11A  1               
00C11A  1               NormalXSpdData:
00C11A  1  F8 F4              .byte $f8, $f4
00C11C  1               
00C11C  1               InitNormalEnemy:
00C11C  1  A0 01                 ldy #$01              ;load offset of 1 by default
00C11E  1  AD 6A 07              lda PrimaryHardMode   ;check for primary hard mode flag set
00C121  1  D0 01                 bne GetESpd
00C123  1  88                    dey                   ;if not set, decrement offset
00C124  1  B9 1A C1     GetESpd: lda NormalXSpdData,y  ;get appropriate horizontal speed
00C127  1  95 58        SetESpd: sta Enemy_X_Speed,x   ;store as speed for enemy object
00C129  1  4C 68 C1              jmp TallBBox          ;branch to set bounding box control and other data
00C12C  1               
00C12C  1               ;--------------------------------
00C12C  1               
00C12C  1               InitRedKoopa:
00C12C  1  20 1C C1           jsr InitNormalEnemy   ;load appropriate horizontal speed
00C12F  1  A9 01              lda #$01              ;set enemy state for red koopa troopa $03
00C131  1  95 1E              sta Enemy_State,x
00C133  1  60                 rts
00C134  1               
00C134  1               ;--------------------------------
00C134  1               
00C134  1               HBroWalkingTimerData:
00C134  1  80 50              .byte $80, $50
00C136  1               
00C136  1               InitHammerBro:
00C136  1  A9 00              lda #$00                    ;init horizontal speed and timer used by hammer bro
00C138  1  9D A2 03           sta HammerThrowingTimer,x   ;apparently to time hammer throwing
00C13B  1  95 58              sta Enemy_X_Speed,x
00C13D  1  AC CC 06           ldy SecondaryHardMode       ;get secondary hard mode flag
00C140  1  B9 34 C1           lda HBroWalkingTimerData,y
00C143  1  9D 96 07           sta EnemyIntervalTimer,x    ;set value as delay for hammer bro to walk left
00C146  1  A9 0B              lda #$0b                    ;set specific value for bounding box size control
00C148  1  4C 6A C1           jmp SetBBox
00C14B  1               
00C14B  1               ;--------------------------------
00C14B  1               
00C14B  1               InitHorizFlySwimEnemy:
00C14B  1  A9 00              lda #$00        ;initialize horizontal speed
00C14D  1  4C 27 C1           jmp SetESpd
00C150  1               
00C150  1               ;--------------------------------
00C150  1               
00C150  1               InitBloober:
00C150  1  A9 00                   lda #$00               ;initialize horizontal speed
00C152  1  95 58                   sta BlooperMoveSpeed,x
00C154  1  A9 09        SmallBBox: lda #$09               ;set specific bounding box size control
00C156  1  D0 12                   bne SetBBox            ;unconditional branch
00C158  1               
00C158  1               ;--------------------------------
00C158  1               
00C158  1               InitRedPTroopa:
00C158  1  A0 30                  ldy #$30                    ;load central position adder for 48 pixels down
00C15A  1  B5 CF                  lda Enemy_Y_Position,x      ;set vertical coordinate into location to
00C15C  1  9D 01 04               sta RedPTroopaOrigXPos,x    ;be used as original vertical coordinate
00C15F  1  10 02                  bpl GetCent                 ;if vertical coordinate < $80
00C161  1  A0 E0                  ldy #$e0                    ;if => $80, load position adder for 32 pixels up
00C163  1  98           GetCent:  tya                         ;send central position adder to A
00C164  1  75 CF                  adc Enemy_Y_Position,x      ;add to current vertical coordinate
00C166  1  95 58                  sta RedPTroopaCenterYPos,x  ;store as central vertical coordinate
00C168  1  A9 03        TallBBox: lda #$03                    ;set specific bounding box size control
00C16A  1  9D 9A 04     SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
00C16D  1  A9 02                  lda #$02                    ;set moving direction for left
00C16F  1  95 46                  sta Enemy_MovingDir,x
00C171  1  A9 00        InitVStf: lda #$00                    ;initialize vertical speed
00C173  1  95 A0                  sta Enemy_Y_Speed,x         ;and movement force
00C175  1  9D 34 04               sta Enemy_Y_MoveForce,x
00C178  1  60                     rts
00C179  1               
00C179  1               ;--------------------------------
00C179  1               
00C179  1               InitBulletBill:
00C179  1  A9 02              lda #$02                  ;set moving direction for left
00C17B  1  95 46              sta Enemy_MovingDir,x
00C17D  1  A9 09              lda #$09                  ;set bounding box control for $09
00C17F  1  9D 9A 04           sta Enemy_BoundBoxCtrl,x
00C182  1  60                 rts
00C183  1               
00C183  1               ;--------------------------------
00C183  1               
00C183  1               InitCheepCheep:
00C183  1  20 54 C1           jsr SmallBBox              ;set vertical bounding box, speed, init others
00C186  1  BD A7 07           lda PseudoRandomBitReg,x   ;check one portion of LSFR
00C189  1  29 10              and #%00010000             ;get d4 from it
00C18B  1  95 58              sta CheepCheepMoveMFlag,x  ;save as movement flag of some sort
00C18D  1  B5 CF              lda Enemy_Y_Position,x
00C18F  1  9D 34 04           sta CheepCheepOrigYPos,x   ;save original vertical coordinate here
00C192  1  60                 rts
00C193  1               
00C193  1               ;--------------------------------
00C193  1               
00C193  1               InitLakitu:
00C193  1  AD CB 06           lda EnemyFrenzyBuffer      ;check to see if an enemy is already in
00C196  1  D0 0B              bne KillLakitu             ;the frenzy buffer, and branch to kill lakitu if so
00C198  1               
00C198  1               SetupLakitu:
00C198  1  A9 00              lda #$00                   ;erase counter for lakitu's reappearance
00C19A  1  8D D1 06           sta LakituReappearTimer
00C19D  1  20 4B C1           jsr InitHorizFlySwimEnemy  ;set $03 as bounding box, set other attributes
00C1A0  1  4C D3 C4           jmp TallBBox2              ;set $03 as bounding box again (not necessary) and leave
00C1A3  1               
00C1A3  1               KillLakitu:
00C1A3  1  4C A3 C6           jmp EraseEnemyObject
00C1A6  1               
00C1A6  1               ;--------------------------------
00C1A6  1               ;$01-$03 - used to hold pseudorandom difference adjusters
00C1A6  1               
00C1A6  1               PRDiffAdjustData:
00C1A6  1  26 2C 32 38        .byte $26, $2c, $32, $38
00C1AA  1  20 22 24 26        .byte $20, $22, $24, $26
00C1AE  1  13 14 15 16        .byte $13, $14, $15, $16
00C1B2  1               
00C1B2  1               LakituAndSpinyHandler:
00C1B2  1  AD 8F 07               lda FrenzyEnemyTimer    ;if timer here not expired, leave
00C1B5  1  D0 3C                  bne ExLSHand
00C1B7  1  E0 05                  cpx #$05                ;if we are on the special use slot, leave
00C1B9  1  B0 38                  bcs ExLSHand
00C1BB  1  A9 80                  lda #$80                ;set timer
00C1BD  1  8D 8F 07               sta FrenzyEnemyTimer
00C1C0  1  A0 04                  ldy #$04                ;start with the last enemy slot
00C1C2  1  B9 16 00     ChkLak:   lda Enemy_ID,y          ;check all enemy slots to see
00C1C5  1  C9 11                  cmp #Lakitu             ;if lakitu is on one of them
00C1C7  1  F0 2B                  beq CreateSpiny         ;if so, branch out of this loop
00C1C9  1  88                     dey                     ;otherwise check another slot
00C1CA  1  10 F6                  bpl ChkLak              ;loop until all slots are checked
00C1CC  1  EE D1 06               inc LakituReappearTimer ;increment reappearance timer
00C1CF  1  AD D1 06               lda LakituReappearTimer
00C1D2  1  C9 07                  cmp #$07                ;check to see if we're up to a certain value yet
00C1D4  1  90 1D                  bcc ExLSHand            ;if not, leave
00C1D6  1  A2 04                  ldx #$04                ;start with the last enemy slot again
00C1D8  1  B5 0F        ChkNoEn:  lda Enemy_Flag,x        ;check enemy buffer flag for non-active enemy slot
00C1DA  1  F0 05                  beq CreateL             ;branch out of loop if found
00C1DC  1  CA                     dex                     ;otherwise check next slot
00C1DD  1  10 F9                  bpl ChkNoEn             ;branch until all slots are checked
00C1DF  1  30 10                  bmi RetEOfs             ;if no empty slots were found, branch to leave
00C1E1  1  A9 00        CreateL:  lda #$00                ;initialize enemy state
00C1E3  1  95 1E                  sta Enemy_State,x
00C1E5  1  A9 11                  lda #Lakitu             ;create lakitu enemy object
00C1E7  1  95 16                  sta Enemy_ID,x
00C1E9  1  20 98 C1               jsr SetupLakitu         ;do a sub to set up lakitu
00C1EC  1  A9 20                  lda #$20
00C1EE  1  20 E6 C3               jsr PutAtRightExtent    ;finish setting up lakitu
00C1F1  1  A6 08        RetEOfs:  ldx ObjectOffset        ;get enemy object buffer offset again and leave
00C1F3  1  60           ExLSHand: rts
00C1F4  1               
00C1F4  1               ;--------------------------------
00C1F4  1               
00C1F4  1               CreateSpiny:
00C1F4  1  A5 CE                  lda Player_Y_Position      ;if player above a certain point, branch to leave
00C1F6  1  C9 2C                  cmp #$2c
00C1F8  1  90 F9                  bcc ExLSHand
00C1FA  1  B9 1E 00               lda Enemy_State,y          ;if lakitu is not in normal state, branch to leave
00C1FD  1  D0 F4                  bne ExLSHand
00C1FF  1  B9 6E 00               lda Enemy_PageLoc,y        ;store horizontal coordinates (high and low) of lakitu
00C202  1  95 6E                  sta Enemy_PageLoc,x        ;into the coordinates of the spiny we're going to create
00C204  1  B9 87 00               lda Enemy_X_Position,y
00C207  1  95 87                  sta Enemy_X_Position,x
00C209  1  A9 01                  lda #$01                   ;put spiny within vertical screen unit
00C20B  1  95 B6                  sta Enemy_Y_HighPos,x
00C20D  1  B9 CF 00               lda Enemy_Y_Position,y     ;put spiny eight pixels above where lakitu is
00C210  1  38                     sec
00C211  1  E9 08                  sbc #$08
00C213  1  95 CF                  sta Enemy_Y_Position,x
00C215  1  BD A7 07               lda PseudoRandomBitReg,x   ;get 2 LSB of LSFR and save to Y
00C218  1  29 03                  and #%00000011
00C21A  1  A8                     tay
00C21B  1  A2 02                  ldx #$02
00C21D  1  B9 A6 C1     DifLoop:  lda PRDiffAdjustData,y     ;get three values and save them
00C220  1  95 01                  sta $01,x                  ;to $01-$03
00C222  1  C8                     iny
00C223  1  C8                     iny                        ;increment Y four bytes for each value
00C224  1  C8                     iny
00C225  1  C8                     iny
00C226  1  CA                     dex                        ;decrement X for each one
00C227  1  10 F4                  bpl DifLoop                ;loop until all three are written
00C229  1  A6 08                  ldx ObjectOffset           ;get enemy object buffer offset
00C22B  1  20 77 CC               jsr PlayerLakituDiff       ;move enemy, change direction, get value - difference
00C22E  1  A4 57                  ldy Player_X_Speed         ;check player's horizontal speed
00C230  1  C0 08                  cpy #$08
00C232  1  B0 0E                  bcs SetSpSpd               ;if moving faster than a certain amount, branch elsewhere
00C234  1  A8                     tay                        ;otherwise save value in A to Y for now
00C235  1  BD A8 07               lda PseudoRandomBitReg+1,x
00C238  1  29 03                  and #%00000011             ;get one of the LSFR parts and save the 2 LSB
00C23A  1  F0 05                  beq UsePosv                ;branch if neither bits are set
00C23C  1  98                     tya
00C23D  1  49 FF                  eor #%11111111             ;otherwise get two's compliment of Y
00C23F  1  A8                     tay
00C240  1  C8                     iny
00C241  1  98           UsePosv:  tya                        ;put value from A in Y back to A (they will be lost anyway)
00C242  1  20 54 C1     SetSpSpd: jsr SmallBBox              ;set bounding box control, init attributes, lose contents of A
00C245  1  A0 02                  ldy #$02
00C247  1  95 58                  sta Enemy_X_Speed,x        ;set horizontal speed to zero because previous contents
00C249  1  C9 00                  cmp #$00                   ;of A were lost...branch here will never be taken for
00C24B  1  30 01                  bmi SpinyRte               ;the same reason
00C24D  1  88                     dey
00C24E  1  94 46        SpinyRte: sty Enemy_MovingDir,x      ;set moving direction to the right
00C250  1  A9 FD                  lda #$fd
00C252  1  95 A0                  sta Enemy_Y_Speed,x        ;set vertical speed to move upwards
00C254  1  A9 01                  lda #$01
00C256  1  95 0F                  sta Enemy_Flag,x           ;enable enemy object by setting flag
00C258  1  A9 05                  lda #$05
00C25A  1  95 1E                  sta Enemy_State,x          ;put spiny in egg state and leave
00C25C  1  60           ChpChpEx: rts
00C25D  1               
00C25D  1               ;--------------------------------
00C25D  1               
00C25D  1               FirebarSpinSpdData:
00C25D  1  28 38 28 38        .byte $28, $38, $28, $38, $28
00C261  1  28           
00C262  1               
00C262  1               FirebarSpinDirData:
00C262  1  00 00 10 10        .byte $00, $00, $10, $10, $00
00C266  1  00           
00C267  1               
00C267  1               InitLongFirebar:
00C267  1  20 83 C3           jsr DuplicateEnemyObj       ;create enemy object for long firebar
00C26A  1               
00C26A  1               InitShortFirebar:
00C26A  1  A9 00              lda #$00                    ;initialize low byte of spin state
00C26C  1  95 58              sta FirebarSpinState_Low,x
00C26E  1  B5 16              lda Enemy_ID,x              ;subtract $1b from enemy identifier
00C270  1  38                 sec                         ;to get proper offset for firebar data
00C271  1  E9 1B              sbc #$1b
00C273  1  A8                 tay
00C274  1  B9 5D C2           lda FirebarSpinSpdData,y    ;get spinning speed of firebar
00C277  1  9D 88 03           sta FirebarSpinSpeed,x
00C27A  1  B9 62 C2           lda FirebarSpinDirData,y    ;get spinning direction of firebar
00C27D  1  95 34              sta FirebarSpinDirection,x
00C27F  1  B5 CF              lda Enemy_Y_Position,x
00C281  1  18                 clc                         ;add four pixels to vertical coordinate
00C282  1  69 04              adc #$04
00C284  1  95 CF              sta Enemy_Y_Position,x
00C286  1  B5 87              lda Enemy_X_Position,x
00C288  1  18                 clc                         ;add four pixels to horizontal coordinate
00C289  1  69 04              adc #$04
00C28B  1  95 87              sta Enemy_X_Position,x
00C28D  1  B5 6E              lda Enemy_PageLoc,x
00C28F  1  69 00              adc #$00                    ;add carry to page location
00C291  1  95 6E              sta Enemy_PageLoc,x
00C293  1  4C D3 C4           jmp TallBBox2               ;set bounding box control (not used) and leave
00C296  1               
00C296  1               ;--------------------------------
00C296  1               ;$00-$01 - used to hold pseudorandom bits
00C296  1               
00C296  1               FlyCCXPositionData:
00C296  1  80 30 40 80        .byte $80, $30, $40, $80
00C29A  1  30 50 50 70        .byte $30, $50, $50, $70
00C29E  1  20 40 80 A0        .byte $20, $40, $80, $a0
00C2A2  1  70 40 90 68        .byte $70, $40, $90, $68
00C2A6  1               
00C2A6  1               FlyCCXSpeedData:
00C2A6  1  0E 05 06 0E        .byte $0e, $05, $06, $0e
00C2AA  1  1C 20 10 0C        .byte $1c, $20, $10, $0c
00C2AE  1  1E 22 18 14        .byte $1e, $22, $18, $14
00C2B2  1               
00C2B2  1               FlyCCTimerData:
00C2B2  1  10 60 20 48        .byte $10, $60, $20, $48
00C2B6  1               
00C2B6  1               InitFlyingCheepCheep:
00C2B6  1  AD 8F 07              lda FrenzyEnemyTimer       ;if timer here not expired yet, branch to leave
00C2B9  1  D0 A1                 bne ChpChpEx
00C2BB  1  20 54 C1              jsr SmallBBox              ;jump to set bounding box size $09 and init other values
00C2BE  1  BD A8 07              lda PseudoRandomBitReg+1,x
00C2C1  1  29 03                 and #%00000011             ;set pseudorandom offset here
00C2C3  1  A8                    tay
00C2C4  1  B9 B2 C2              lda FlyCCTimerData,y       ;load timer with pseudorandom offset
00C2C7  1  8D 8F 07              sta FrenzyEnemyTimer
00C2CA  1  A0 03                 ldy #$03                   ;load Y with default value
00C2CC  1  AD CC 06              lda SecondaryHardMode
00C2CF  1  F0 01                 beq MaxCC                  ;if secondary hard mode flag not set, do not increment Y
00C2D1  1  C8                    iny                        ;otherwise, increment Y to allow as many as four onscreen
00C2D2  1  84 00        MaxCC:   sty $00                    ;store whatever pseudorandom bits are in Y
00C2D4  1  E4 00                 cpx $00                    ;compare enemy object buffer offset with Y
00C2D6  1  B0 84                 bcs ChpChpEx               ;if X => Y, branch to leave
00C2D8  1  BD A7 07              lda PseudoRandomBitReg,x
00C2DB  1  29 03                 and #%00000011             ;get last two bits of LSFR, first part
00C2DD  1  85 00                 sta $00                    ;and store in two places
00C2DF  1  85 01                 sta $01
00C2E1  1  A9 FB                 lda #$fb                   ;set vertical speed for cheep-cheep
00C2E3  1  95 A0                 sta Enemy_Y_Speed,x
00C2E5  1  A9 00                 lda #$00                   ;load default value
00C2E7  1  A4 57                 ldy Player_X_Speed         ;check player's horizontal speed
00C2E9  1  F0 07                 beq GSeed                  ;if player not moving left or right, skip this part
00C2EB  1  A9 04                 lda #$04
00C2ED  1  C0 19                 cpy #$19                   ;if moving to the right but not very quickly,
00C2EF  1  90 01                 bcc GSeed                  ;do not change A
00C2F1  1  0A                    asl                        ;otherwise, multiply A by 2
00C2F2  1  48           GSeed:   pha                        ;save to stack
00C2F3  1  18                    clc
00C2F4  1  65 00                 adc $00                    ;add to last two bits of LSFR we saved earlier
00C2F6  1  85 00                 sta $00                    ;save it there
00C2F8  1  BD A8 07              lda PseudoRandomBitReg+1,x
00C2FB  1  29 03                 and #%00000011             ;if neither of the last two bits of second LSFR set,
00C2FD  1  F0 07                 beq RSeed                  ;skip this part and save contents of $00
00C2FF  1  BD A9 07              lda PseudoRandomBitReg+2,x
00C302  1  29 0F                 and #%00001111             ;otherwise overwrite with lower nybble of
00C304  1  85 00                 sta $00                    ;third LSFR part
00C306  1  68           RSeed:   pla                        ;get value from stack we saved earlier
00C307  1  18                    clc
00C308  1  65 01                 adc $01                    ;add to last two bits of LSFR we saved in other place
00C30A  1  A8                    tay                        ;use as pseudorandom offset here
00C30B  1  B9 A6 C2              lda FlyCCXSpeedData,y      ;get horizontal speed using pseudorandom offset
00C30E  1  95 58                 sta Enemy_X_Speed,x
00C310  1  A9 01                 lda #$01                   ;set to move towards the right
00C312  1  95 46                 sta Enemy_MovingDir,x
00C314  1  A5 57                 lda Player_X_Speed         ;if player moving left or right, branch ahead of this part
00C316  1  D0 12                 bne D2XPos1
00C318  1  A4 00                 ldy $00                    ;get first LSFR or third LSFR lower nybble
00C31A  1  98                    tya                        ;and check for d1 set
00C31B  1  29 02                 and #%00000010
00C31D  1  F0 0B                 beq D2XPos1                ;if d1 not set, branch
00C31F  1  B5 58                 lda Enemy_X_Speed,x
00C321  1  49 FF                 eor #$ff                   ;if d1 set, change horizontal speed
00C323  1  18                    clc                        ;into two's compliment, thus moving in the opposite
00C324  1  69 01                 adc #$01                   ;direction
00C326  1  95 58                 sta Enemy_X_Speed,x
00C328  1  F6 46                 inc Enemy_MovingDir,x      ;increment to move towards the left
00C32A  1  98           D2XPos1: tya                        ;get first LSFR or third LSFR lower nybble again
00C32B  1  29 02                 and #%00000010
00C32D  1  F0 0F                 beq D2XPos2                ;check for d1 set again, branch again if not set
00C32F  1  A5 86                 lda Player_X_Position      ;get player's horizontal position
00C331  1  18                    clc
00C332  1  79 96 C2              adc FlyCCXPositionData,y   ;if d1 set, add value obtained from pseudorandom offset
00C335  1  95 87                 sta Enemy_X_Position,x     ;and save as enemy's horizontal position
00C337  1  A5 6D                 lda Player_PageLoc         ;get player's page location
00C339  1  69 00                 adc #$00                   ;add carry and jump past this part
00C33B  1  4C 4A C3              jmp FinCCSt
00C33E  1  A5 86        D2XPos2: lda Player_X_Position      ;get player's horizontal position
00C340  1  38                    sec
00C341  1  F9 96 C2              sbc FlyCCXPositionData,y   ;if d1 not set, subtract value obtained from pseudorandom
00C344  1  95 87                 sta Enemy_X_Position,x     ;offset and save as enemy's horizontal position
00C346  1  A5 6D                 lda Player_PageLoc         ;get player's page location
00C348  1  E9 00                 sbc #$00                   ;subtract borrow
00C34A  1  95 6E        FinCCSt: sta Enemy_PageLoc,x        ;save as enemy's page location
00C34C  1  A9 01                 lda #$01
00C34E  1  95 0F                 sta Enemy_Flag,x           ;set enemy's buffer flag
00C350  1  95 B6                 sta Enemy_Y_HighPos,x      ;set enemy's high vertical byte
00C352  1  A9 F8                 lda #$f8
00C354  1  95 CF                 sta Enemy_Y_Position,x     ;put enemy below the screen, and we are done
00C356  1  60                    rts
00C357  1               
00C357  1               ;--------------------------------
00C357  1               
00C357  1               InitBowser:
00C357  1  20 83 C3           jsr DuplicateEnemyObj     ;jump to create another bowser object
00C35A  1  8E 68 03           stx BowserFront_Offset    ;save offset of first here
00C35D  1  A9 00              lda #$00
00C35F  1  8D 63 03           sta BowserBodyControls    ;initialize bowser's body controls
00C362  1  8D 69 03           sta BridgeCollapseOffset  ;and bridge collapse offset
00C365  1  B5 87              lda Enemy_X_Position,x
00C367  1  8D 66 03           sta BowserOrigXPos        ;store original horizontal position here
00C36A  1  A9 DF              lda #$df
00C36C  1  8D 90 07           sta BowserFireBreathTimer ;store something here
00C36F  1  95 46              sta Enemy_MovingDir,x     ;and in moving direction
00C371  1  A9 20              lda #$20
00C373  1  8D 64 03           sta BowserFeetCounter     ;set bowser's feet timer and in enemy timer
00C376  1  9D 8A 07           sta EnemyFrameTimer,x
00C379  1  A9 05              lda #$05
00C37B  1  8D 83 04           sta BowserHitPoints       ;give bowser 5 hit points
00C37E  1  4A                 lsr
00C37F  1  8D 65 03           sta BowserMovementSpeed   ;set default movement speed here
00C382  1  60                 rts
00C383  1               
00C383  1               ;--------------------------------
00C383  1               
00C383  1               DuplicateEnemyObj:
00C383  1  A0 FF                ldy #$ff                ;start at beginning of enemy slots
00C385  1  C8           FSLoop: iny                     ;increment one slot
00C386  1  B9 0F 00             lda Enemy_Flag,y        ;check enemy buffer flag for empty slot
00C389  1  D0 FA                bne FSLoop              ;if set, branch and keep checking
00C38B  1  8C CF 06             sty DuplicateObj_Offset ;otherwise set offset here
00C38E  1  8A                   txa                     ;transfer original enemy buffer offset
00C38F  1  09 80                ora #%10000000          ;store with d7 set as flag in new enemy
00C391  1  99 0F 00             sta Enemy_Flag,y        ;slot as well as enemy offset
00C394  1  B5 6E                lda Enemy_PageLoc,x
00C396  1  99 6E 00             sta Enemy_PageLoc,y     ;copy page location and horizontal coordinates
00C399  1  B5 87                lda Enemy_X_Position,x  ;from original enemy to new enemy
00C39B  1  99 87 00             sta Enemy_X_Position,y
00C39E  1  A9 01                lda #$01
00C3A0  1  95 0F                sta Enemy_Flag,x        ;set flag as normal for original enemy
00C3A2  1  99 B6 00             sta Enemy_Y_HighPos,y   ;set high vertical byte for new enemy
00C3A5  1  B5 CF                lda Enemy_Y_Position,x
00C3A7  1  99 CF 00             sta Enemy_Y_Position,y  ;copy vertical coordinate from original to new
00C3AA  1  60           FlmEx:  rts                     ;and then leave
00C3AB  1               
00C3AB  1               ;--------------------------------
00C3AB  1               
00C3AB  1               FlameYPosData:
00C3AB  1  90 80 70 90        .byte $90, $80, $70, $90
00C3AF  1               
00C3AF  1               FlameYMFAdderData:
00C3AF  1  FF 01              .byte $ff, $01
00C3B1  1               
00C3B1  1               InitBowserFlame:
00C3B1  1  AD 8F 07             lda FrenzyEnemyTimer        ;if timer not expired yet, branch to leave
00C3B4  1  D0 F4                bne FlmEx
00C3B6  1  9D 34 04             sta Enemy_Y_MoveForce,x     ;reset something here
00C3B9  1  A5 FD                lda NoiseSoundQueue
00C3BB  1  09 02                ora #Sfx_BowserFlame        ;load bowser's flame sound into queue
00C3BD  1  85 FD                sta NoiseSoundQueue
00C3BF  1  AC 68 03             ldy BowserFront_Offset      ;get bowser's buffer offset
00C3C2  1  B9 16 00             lda Enemy_ID,y              ;check for bowser
00C3C5  1  C9 2D                cmp #Bowser
00C3C7  1  F0 31                beq SpawnFromMouth          ;branch if found
00C3C9  1  20 E7 CE             jsr SetFlameTimer           ;get timer data based on flame counter
00C3CC  1  18                   clc
00C3CD  1  69 20                adc #$20                    ;add 32 frames by default
00C3CF  1  AC CC 06             ldy SecondaryHardMode
00C3D2  1  F0 03                beq SetFrT                  ;if secondary mode flag not set, use as timer setting
00C3D4  1  38                   sec
00C3D5  1  E9 10                sbc #$10                    ;otherwise subtract 16 frames for secondary hard mode
00C3D7  1  8D 8F 07     SetFrT: sta FrenzyEnemyTimer        ;set timer accordingly
00C3DA  1  BD A7 07             lda PseudoRandomBitReg,x
00C3DD  1  29 03                and #%00000011              ;get 2 LSB from first part of LSFR
00C3DF  1  9D 17 04             sta BowserFlamePRandomOfs,x ;set here
00C3E2  1  A8                   tay                         ;use as offset
00C3E3  1  B9 AB C3             lda FlameYPosData,y         ;load vertical position based on pseudorandom offset
00C3E6  1               
00C3E6  1               PutAtRightExtent:
00C3E6  1  95 CF              sta Enemy_Y_Position,x    ;set vertical position
00C3E8  1  AD 1D 07           lda ScreenRight_X_Pos
00C3EB  1  18                 clc
00C3EC  1  69 20              adc #$20                  ;place enemy 32 pixels beyond right side of screen
00C3EE  1  95 87              sta Enemy_X_Position,x
00C3F0  1  AD 1B 07           lda ScreenRight_PageLoc
00C3F3  1  69 00              adc #$00                  ;add carry
00C3F5  1  95 6E              sta Enemy_PageLoc,x
00C3F7  1  4C 2D C4           jmp FinishFlame           ;skip this part to finish setting values
00C3FA  1               
00C3FA  1               SpawnFromMouth:
00C3FA  1  B9 87 00            lda Enemy_X_Position,y    ;get bowser's horizontal position
00C3FD  1  38                  sec
00C3FE  1  E9 0E               sbc #$0e                  ;subtract 14 pixels
00C400  1  95 87               sta Enemy_X_Position,x    ;save as flame's horizontal position
00C402  1  B9 6E 00            lda Enemy_PageLoc,y
00C405  1  95 6E               sta Enemy_PageLoc,x       ;copy page location from bowser to flame
00C407  1  B9 CF 00            lda Enemy_Y_Position,y
00C40A  1  18                  clc                       ;add 8 pixels to bowser's vertical position
00C40B  1  69 08               adc #$08
00C40D  1  95 CF               sta Enemy_Y_Position,x    ;save as flame's vertical position
00C40F  1  BD A7 07            lda PseudoRandomBitReg,x
00C412  1  29 03               and #%00000011            ;get 2 LSB from first part of LSFR
00C414  1  9D 17 04            sta Enemy_YMF_Dummy,x     ;save here
00C417  1  A8                  tay                       ;use as offset
00C418  1  B9 AB C3            lda FlameYPosData,y       ;get value here using bits as offset
00C41B  1  A0 00               ldy #$00                  ;load default offset
00C41D  1  D5 CF               cmp Enemy_Y_Position,x    ;compare value to flame's current vertical position
00C41F  1  90 01               bcc SetMF                 ;if less, do not increment offset
00C421  1  C8                  iny                       ;otherwise increment now
00C422  1  B9 AF C3     SetMF: lda FlameYMFAdderData,y   ;get value here and save
00C425  1  9D 34 04            sta Enemy_Y_MoveForce,x   ;to vertical movement force
00C428  1  A9 00               lda #$00
00C42A  1  8D CB 06            sta EnemyFrenzyBuffer     ;clear enemy frenzy buffer
00C42D  1               
00C42D  1               FinishFlame:
00C42D  1  A9 08              lda #$08                 ;set $08 for bounding box control
00C42F  1  9D 9A 04           sta Enemy_BoundBoxCtrl,x
00C432  1  A9 01              lda #$01                 ;set high byte of vertical and
00C434  1  95 B6              sta Enemy_Y_HighPos,x    ;enemy buffer flag
00C436  1  95 0F              sta Enemy_Flag,x
00C438  1  4A                 lsr
00C439  1  9D 01 04           sta Enemy_X_MoveForce,x  ;initialize horizontal movement force, and
00C43C  1  95 1E              sta Enemy_State,x        ;enemy state
00C43E  1  60                 rts
00C43F  1               
00C43F  1               ;--------------------------------
00C43F  1               
00C43F  1               FireworksXPosData:
00C43F  1  00 30 60 60        .byte $00, $30, $60, $60, $00, $20
00C443  1  00 20        
00C445  1               
00C445  1               FireworksYPosData:
00C445  1  60 40 70 40        .byte $60, $40, $70, $40, $60, $30
00C449  1  60 30        
00C44B  1               
00C44B  1               InitFireworks:
00C44B  1  AD 8F 07               lda FrenzyEnemyTimer         ;if timer not expired yet, branch to leave
00C44E  1  D0 47                  bne ExitFWk
00C450  1  A9 20                  lda #$20                     ;otherwise reset timer
00C452  1  8D 8F 07               sta FrenzyEnemyTimer
00C455  1  CE D7 06               dec FireworksCounter         ;decrement for each explosion
00C458  1  A0 06                  ldy #$06                     ;start at last slot
00C45A  1  88           StarFChk: dey
00C45B  1  B9 16 00               lda Enemy_ID,y               ;check for presence of star flag object
00C45E  1  C9 31                  cmp #StarFlagObject          ;if there isn't a star flag object,
00C460  1  D0 F8                  bne StarFChk                 ;routine goes into infinite loop = crash
00C462  1  B9 87 00               lda Enemy_X_Position,y
00C465  1  38                     sec                          ;get horizontal coordinate of star flag object, then
00C466  1  E9 30                  sbc #$30                     ;subtract 48 pixels from it and save to
00C468  1  48                     pha                          ;the stack
00C469  1  B9 6E 00               lda Enemy_PageLoc,y
00C46C  1  E9 00                  sbc #$00                     ;subtract the carry from the page location
00C46E  1  85 00                  sta $00                      ;of the star flag object
00C470  1  AD D7 06               lda FireworksCounter         ;get fireworks counter
00C473  1  18                     clc
00C474  1  79 1E 00               adc Enemy_State,y            ;add state of star flag object (possibly not necessary)
00C477  1  A8                     tay                          ;use as offset
00C478  1  68                     pla                          ;get saved horizontal coordinate of star flag - 48 pixels
00C479  1  18                     clc
00C47A  1  79 3F C4               adc FireworksXPosData,y      ;add number based on offset of fireworks counter
00C47D  1  95 87                  sta Enemy_X_Position,x       ;store as the fireworks object horizontal coordinate
00C47F  1  A5 00                  lda $00
00C481  1  69 00                  adc #$00                     ;add carry and store as page location for
00C483  1  95 6E                  sta Enemy_PageLoc,x          ;the fireworks object
00C485  1  B9 45 C4               lda FireworksYPosData,y      ;get vertical position using same offset
00C488  1  95 CF                  sta Enemy_Y_Position,x       ;and store as vertical coordinate for fireworks object
00C48A  1  A9 01                  lda #$01
00C48C  1  95 B6                  sta Enemy_Y_HighPos,x        ;store in vertical high byte
00C48E  1  95 0F                  sta Enemy_Flag,x             ;and activate enemy buffer flag
00C490  1  4A                     lsr
00C491  1  95 58                  sta ExplosionGfxCounter,x    ;initialize explosion counter
00C493  1  A9 08                  lda #$08
00C495  1  95 A0                  sta ExplosionTimerCounter,x  ;set explosion timing counter
00C497  1  60           ExitFWk:  rts
00C498  1               
00C498  1               InitPiranhaPlant:
00C498  1  A9 01              lda #$01                     ;set initial speed
00C49A  1  95 58              sta PiranhaPlant_Y_Speed,x
00C49C  1  4A                 lsr
00C49D  1  95 1E              sta Enemy_State,x            ;initialize enemy state and what would normally
00C49F  1  95 A0              sta PiranhaPlant_MoveFlag,x  ;be used as vertical speed, but not in this case
00C4A1  1  B5 CF              lda Enemy_Y_Position,x
00C4A3  1  9D 34 04           sta PiranhaPlantDownYPos,x   ;save original vertical coordinate here
00C4A6  1  38                 sec
00C4A7  1  E9 18              sbc #$18
00C4A9  1  9D 17 04           sta PiranhaPlantUpYPos,x     ;save original vertical coordinate - 24 pixels here
00C4AC  1  A9 09              lda #$09
00C4AE  1  4C D5 C4           jmp SetBBox2                 ;set specific value for bounding box control
00C4B1  1               
00C4B1  1               ;--------------------------------
00C4B1  1               
00C4B1  1               NoFrenzyCode:
00C4B1  1  60                 rts
00C4B2  1               
00C4B2  1               ;--------------------------------
00C4B2  1               
00C4B2  1               EndFrenzy:
00C4B2  1  A0 05                   ldy #$05               ;start at last slot
00C4B4  1  B9 16 00     LakituChk: lda Enemy_ID,y         ;check enemy identifiers
00C4B7  1  C9 11                   cmp #Lakitu            ;for lakitu
00C4B9  1  D0 05                   bne NextFSlot
00C4BB  1  A9 01                   lda #$01               ;if found, set state
00C4BD  1  99 1E 00                sta Enemy_State,y
00C4C0  1  88           NextFSlot: dey                    ;move onto the next slot
00C4C1  1  10 F1                   bpl LakituChk          ;do this until all slots are checked
00C4C3  1  A9 00                   lda #$00
00C4C5  1  8D CB 06                sta EnemyFrenzyBuffer  ;empty enemy frenzy buffer
00C4C8  1  95 0F                   sta Enemy_Flag,x       ;disable enemy buffer flag for this object
00C4CA  1  60                      rts
00C4CB  1               
00C4CB  1               ;--------------------------------
00C4CB  1               
00C4CB  1               InitJumpGPTroopa:
00C4CB  1  A9 02                   lda #$02                  ;set for movement to the left
00C4CD  1  95 46                   sta Enemy_MovingDir,x
00C4CF  1  A9 F8                   lda #$f8                  ;set horizontal speed
00C4D1  1  95 58                   sta Enemy_X_Speed,x
00C4D3  1  A9 03        TallBBox2: lda #$03                  ;set specific value for bounding box control
00C4D5  1  9D 9A 04     SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
00C4D8  1  60                      rts
00C4D9  1               
00C4D9  1               ;--------------------------------
00C4D9  1               
00C4D9  1               InitBalPlatform:
00C4D9  1  D6 CF                dec Enemy_Y_Position,x    ;raise vertical position by two pixels
00C4DB  1  D6 CF                dec Enemy_Y_Position,x
00C4DD  1  AC CC 06             ldy SecondaryHardMode     ;if secondary hard mode flag not set,
00C4E0  1  D0 05                bne AlignP                ;branch ahead
00C4E2  1  A0 02                ldy #$02                  ;otherwise set value here
00C4E4  1  20 6B C5             jsr PosPlatform           ;do a sub to add or subtract pixels
00C4E7  1  A0 FF        AlignP: ldy #$ff                  ;set default value here for now
00C4E9  1  AD A0 03             lda BalPlatformAlignment  ;get current balance platform alignment
00C4EC  1  95 1E                sta Enemy_State,x         ;set platform alignment to object state here
00C4EE  1  10 02                bpl SetBPA                ;if old alignment $ff, put $ff as alignment for negative
00C4F0  1  8A                   txa                       ;if old contents already $ff, put
00C4F1  1  A8                   tay                       ;object offset as alignment to make next positive
00C4F2  1  8C A0 03     SetBPA: sty BalPlatformAlignment  ;store whatever value's in Y here
00C4F5  1  A9 00                lda #$00
00C4F7  1  95 46                sta Enemy_MovingDir,x     ;init moving direction
00C4F9  1  A8                   tay                       ;init Y
00C4FA  1  20 6B C5             jsr PosPlatform           ;do a sub to add 8 pixels, then run shared code here
00C4FD  1               
00C4FD  1               ;--------------------------------
00C4FD  1               
00C4FD  1               InitDropPlatform:
00C4FD  1  A9 FF              lda #$ff
00C4FF  1  9D A2 03           sta PlatformCollisionFlag,x  ;set some value here
00C502  1  4C 22 C5           jmp CommonPlatCode           ;then jump ahead to execute more code
00C505  1               
00C505  1               ;--------------------------------
00C505  1               
00C505  1               InitHoriPlatform:
00C505  1  A9 00              lda #$00
00C507  1  95 58              sta XMoveSecondaryCounter,x  ;init one of the moving counters
00C509  1  4C 22 C5           jmp CommonPlatCode           ;jump ahead to execute more code
00C50C  1               
00C50C  1               ;--------------------------------
00C50C  1               
00C50C  1               InitVertPlatform:
00C50C  1  A0 40               ldy #$40                    ;set default value here
00C50E  1  B5 CF               lda Enemy_Y_Position,x      ;check vertical position
00C510  1  10 07               bpl SetYO                   ;if above a certain point, skip this part
00C512  1  49 FF               eor #$ff
00C514  1  18                  clc                         ;otherwise get two's compliment
00C515  1  69 01               adc #$01
00C517  1  A0 C0               ldy #$c0                    ;get alternate value to add to vertical position
00C519  1  9D 01 04     SetYO: sta YPlatformTopYPos,x      ;save as top vertical position
00C51C  1  98                  tya
00C51D  1  18                  clc                         ;load value from earlier, add number of pixels
00C51E  1  75 CF               adc Enemy_Y_Position,x      ;to vertical position
00C520  1  95 58               sta YPlatformCenterYPos,x   ;save result as central vertical position
00C522  1               
00C522  1               ;--------------------------------
00C522  1               
00C522  1               CommonPlatCode:
00C522  1  20 71 C1             jsr InitVStf              ;do a sub to init certain other values
00C525  1  A9 05        SPBBox: lda #$05                  ;set default bounding box size control
00C527  1  AC 4E 07             ldy AreaType
00C52A  1  C0 03                cpy #$03                  ;check for castle-type level
00C52C  1  F0 07                beq CasPBB                ;use default value if found
00C52E  1  AC CC 06             ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
00C531  1  D0 02                bne CasPBB                ;if set, use default value
00C533  1  A9 06                lda #$06                  ;use alternate value if not castle or secondary not set
00C535  1  9D 9A 04     CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
00C538  1  60                   rts
00C539  1               
00C539  1               ;--------------------------------
00C539  1               
00C539  1               LargeLiftUp:
00C539  1  20 45 C5           jsr PlatLiftUp       ;execute code for platforms going up
00C53C  1  4C 42 C5           jmp LargeLiftBBox    ;overwrite bounding box for large platforms
00C53F  1               
00C53F  1               LargeLiftDown:
00C53F  1  20 51 C5           jsr PlatLiftDown     ;execute code for platforms going down
00C542  1               
00C542  1               LargeLiftBBox:
00C542  1  4C 25 C5           jmp SPBBox           ;jump to overwrite bounding box size control
00C545  1               
00C545  1               ;--------------------------------
00C545  1               
00C545  1               PlatLiftUp:
00C545  1  A9 10              lda #$10                 ;set movement amount here
00C547  1  9D 34 04           sta Enemy_Y_MoveForce,x
00C54A  1  A9 FF              lda #$ff                 ;set moving speed for platforms going up
00C54C  1  95 A0              sta Enemy_Y_Speed,x
00C54E  1  4C 5A C5           jmp CommonSmallLift      ;skip ahead to part we should be executing
00C551  1               
00C551  1               ;--------------------------------
00C551  1               
00C551  1               PlatLiftDown:
00C551  1  A9 F0              lda #$f0                 ;set movement amount here
00C553  1  9D 34 04           sta Enemy_Y_MoveForce,x
00C556  1  A9 00              lda #$00                 ;set moving speed for platforms going down
00C558  1  95 A0              sta Enemy_Y_Speed,x
00C55A  1               
00C55A  1               ;--------------------------------
00C55A  1               
00C55A  1               CommonSmallLift:
00C55A  1  A0 01              ldy #$01
00C55C  1  20 6B C5           jsr PosPlatform           ;do a sub to add 12 pixels due to preset value
00C55F  1  A9 04              lda #$04
00C561  1  9D 9A 04           sta Enemy_BoundBoxCtrl,x  ;set bounding box control for small platforms
00C564  1  60                 rts
00C565  1               
00C565  1               ;--------------------------------
00C565  1               
00C565  1               PlatPosDataLow:
00C565  1  08 0C F8           .byte $08,$0c,$f8
00C568  1               
00C568  1               PlatPosDataHigh:
00C568  1  00 00 FF           .byte $00,$00,$ff
00C56B  1               
00C56B  1               PosPlatform:
00C56B  1  B5 87              lda Enemy_X_Position,x  ;get horizontal coordinate
00C56D  1  18                 clc
00C56E  1  79 65 C5           adc PlatPosDataLow,y    ;add or subtract pixels depending on offset
00C571  1  95 87              sta Enemy_X_Position,x  ;store as new horizontal coordinate
00C573  1  B5 6E              lda Enemy_PageLoc,x
00C575  1  79 68 C5           adc PlatPosDataHigh,y   ;add or subtract page location depending on offset
00C578  1  95 6E              sta Enemy_PageLoc,x     ;store as new page location
00C57A  1  60                 rts                     ;and go back
00C57B  1               
00C57B  1               ;--------------------------------
00C57B  1               
00C57B  1               EndOfEnemyInitCode:
00C57B  1  60                 rts
00C57C  1               
00C57C  1               ;-------------------------------------------------------------------------------------
00C57C  1               
00C57C  1               RunEnemyObjectsCore:
00C57C  1  A6 08               ldx ObjectOffset  ;get offset for enemy object buffer
00C57E  1  A9 00               lda #$00          ;load value 0 for jump engine by default
00C580  1  B4 16               ldy Enemy_ID,x
00C582  1  C0 15               cpy #$15          ;if enemy object < $15, use default value
00C584  1  90 03               bcc JmpEO
00C586  1  98                  tya               ;otherwise subtract $14 from the value and use
00C587  1  E9 14               sbc #$14          ;as value for jump engine
00C589  1  20 97 BA     JmpEO: jsr JumpEngine
00C58C  1               
00C58C  1  DA C5              .word RunNormalEnemies  ;for objects $00-$14
00C58E  1               
00C58E  1  2F C6              .word RunBowserFlame    ;for objects $15-$1f
00C590  1  83 B9              .word RunFireworks
00C592  1  D0 C5              .word NoRunCode
00C594  1  D0 C5              .word NoRunCode
00C596  1  D0 C5              .word NoRunCode
00C598  1  D0 C5              .word NoRunCode
00C59A  1  41 C6              .word RunFirebarObj
00C59C  1  41 C6              .word RunFirebarObj
00C59E  1  41 C6              .word RunFirebarObj
00C5A0  1  41 C6              .word RunFirebarObj
00C5A2  1  41 C6              .word RunFirebarObj
00C5A4  1               
00C5A4  1  41 C6              .word RunFirebarObj     ;for objects $20-$2f
00C5A6  1  41 C6              .word RunFirebarObj
00C5A8  1  41 C6              .word RunFirebarObj
00C5AA  1  D0 C5              .word NoRunCode
00C5AC  1  5F C6              .word RunLargePlatform
00C5AE  1  5F C6              .word RunLargePlatform
00C5B0  1  5F C6              .word RunLargePlatform
00C5B2  1  5F C6              .word RunLargePlatform
00C5B4  1  5F C6              .word RunLargePlatform
00C5B6  1  5F C6              .word RunLargePlatform
00C5B8  1  5F C6              .word RunLargePlatform
00C5BA  1  47 C6              .word RunSmallPlatform
00C5BC  1  47 C6              .word RunSmallPlatform
00C5BE  1  73 CD              .word RunBowser
00C5C0  1  3C BD              .word PowerUpObjHandler
00C5C2  1  D7 F0              .word VineObjectHandler
00C5C4  1               
00C5C4  1  D0 C5              .word NoRunCode         ;for objects $30-$35
00C5C6  1  C0 B9              .word RunStarFlagObj
00C5C8  1  44 EF              .word JumpspringHandler
00C5CA  1  D0 C5              .word NoRunCode
00C5CC  1  92 C6              .word WarpZoneObject
00C5CE  1  D1 C5              .word RunRetainerObj
00C5D0  1               
00C5D0  1               ;--------------------------------
00C5D0  1               
00C5D0  1               NoRunCode:
00C5D0  1  60                 rts
00C5D1  1               
00C5D1  1               ;--------------------------------
00C5D1  1               
00C5D1  1               RunRetainerObj:
00C5D1  1  20 1F ED           jsr GetEnemyOffscreenBits
00C5D4  1  20 C2 EC           jsr RelativeEnemyPosition
00C5D7  1  4C 0D E4           jmp EnemyGfxHandler
00C5DA  1               
00C5DA  1               ;--------------------------------
00C5DA  1               
00C5DA  1               RunNormalEnemies:
00C5DA  1  A9 00                  lda #$00                  ;init sprite attributes
00C5DC  1  9D C5 03               sta Enemy_SprAttrib,x
00C5DF  1  20 1F ED               jsr GetEnemyOffscreenBits
00C5E2  1  20 C2 EC               jsr RelativeEnemyPosition
00C5E5  1  20 0D E4               jsr EnemyGfxHandler
00C5E8  1  20 D3 DD               jsr GetEnemyBoundBox
00C5EB  1  20 51 DB               jsr EnemyToBGCollisionDet
00C5EE  1  20 26 D6               jsr EnemiesCollision
00C5F1  1  20 46 D4               jsr PlayerEnemyCollision
00C5F4  1  AC 47 07               ldy TimerControl          ;if master timer control set, skip to last routine
00C5F7  1  D0 03                  bne SkipMove
00C5F9  1  20 FF C5               jsr EnemyMovementSubs
00C5FC  1  4C 6D D2     SkipMove: jmp OffscreenBoundsCheck
00C5FF  1               
00C5FF  1               EnemyMovementSubs:
00C5FF  1  B5 16              lda Enemy_ID,x
00C601  1  20 97 BA           jsr JumpEngine
00C604  1               
00C604  1  82 C7              .word MoveNormalEnemy      ;only objects $00-$14 use this table
00C606  1  82 C7              .word MoveNormalEnemy
00C608  1  82 C7              .word MoveNormalEnemy
00C60A  1  82 C7              .word MoveNormalEnemy
00C60C  1  82 C7              .word MoveNormalEnemy
00C60E  1  E3 C6              .word ProcHammerBro
00C610  1  82 C7              .word MoveNormalEnemy
00C612  1  94 C8              .word MoveBloober
00C614  1  41 C9              .word MoveBulletBill
00C616  1  2E C6              .word NoMoveCode
00C618  1  55 C9              .word MoveSwimmingCheepCheep
00C61A  1  55 C9              .word MoveSwimmingCheepCheep
00C61C  1  BB C6              .word MovePodoboo
00C61E  1  A3 CF              .word MovePiranhaPlant
00C620  1  04 C8              .word MoveJumpingEnemy
00C622  1  0A C8              .word ProcMoveRedPTroopa
00C624  1  30 C8              .word MoveFlyGreenPTroopa
00C626  1  33 CC              .word MoveLakitu
00C628  1  82 C7              .word MoveNormalEnemy
00C62A  1  2E C6              .word NoMoveCode   ;dummy
00C62C  1  EA CB              .word MoveFlyingCheepCheep
00C62E  1               
00C62E  1               ;--------------------------------
00C62E  1               
00C62E  1               NoMoveCode:
00C62E  1  60                 rts
00C62F  1               
00C62F  1               ;--------------------------------
00C62F  1               
00C62F  1               RunBowserFlame:
00C62F  1  20 F9 CE           jsr ProcBowserFlame
00C632  1  20 1F ED           jsr GetEnemyOffscreenBits
00C635  1  20 C2 EC           jsr RelativeEnemyPosition
00C638  1  20 D3 DD           jsr GetEnemyBoundBox
00C63B  1  20 46 D4           jsr PlayerEnemyCollision
00C63E  1  4C 6D D2           jmp OffscreenBoundsCheck
00C641  1               
00C641  1               ;--------------------------------
00C641  1               
00C641  1               RunFirebarObj:
00C641  1  20 47 CA           jsr ProcFirebar
00C644  1  4C 6D D2           jmp OffscreenBoundsCheck
00C647  1               
00C647  1               ;--------------------------------
00C647  1               
00C647  1               RunSmallPlatform:
00C647  1  20 1F ED           jsr GetEnemyOffscreenBits
00C64A  1  20 C2 EC           jsr RelativeEnemyPosition
00C64D  1  20 DC DD           jsr SmallPlatformBoundBox
00C650  1  20 6E D7           jsr SmallPlatformCollision
00C653  1  20 C2 EC           jsr RelativeEnemyPosition
00C656  1  20 F6 E8           jsr DrawSmallPlatform
00C659  1  20 48 D2           jsr MoveSmallPlatform
00C65C  1  4C 6D D2           jmp OffscreenBoundsCheck
00C65F  1               
00C65F  1               ;--------------------------------
00C65F  1               
00C65F  1               RunLargePlatform:
00C65F  1  20 1F ED             jsr GetEnemyOffscreenBits
00C662  1  20 C2 EC             jsr RelativeEnemyPosition
00C665  1  20 03 DE             jsr LargePlatformBoundBox
00C668  1  20 38 D7             jsr LargePlatformCollision
00C66B  1  AD 47 07             lda TimerControl             ;if master timer control set,
00C66E  1  D0 03                bne SkipPT                   ;skip subroutine tree
00C670  1  20 7C C6             jsr LargePlatformSubroutines
00C673  1  20 C2 EC     SkipPT: jsr RelativeEnemyPosition
00C676  1  20 58 E1             jsr DrawLargePlatform
00C679  1  4C 6D D2             jmp OffscreenBoundsCheck
00C67C  1               
00C67C  1               ;--------------------------------
00C67C  1               
00C67C  1               LargePlatformSubroutines:
00C67C  1  B5 16              lda Enemy_ID,x  ;subtract $24 to get proper offset for jump table
00C67E  1  38                 sec
00C67F  1  E9 24              sbc #$24
00C681  1  20 97 BA           jsr JumpEngine
00C684  1               
00C684  1  25 D0              .word BalancePlatform   ;table used by objects $24-$2a
00C686  1  C6 D1              .word YMovingPlatform
00C688  1  42 D2              .word MoveLargeLiftPlat
00C68A  1  42 D2              .word MoveLargeLiftPlat
00C68C  1  FA D1              .word XMovingPlatform
00C68E  1  24 D2              .word DropPlatform
00C690  1  30 D2              .word RightPlatform
00C692  1               
00C692  1               ;-------------------------------------------------------------------------------------
00C692  1               
00C692  1               WarpZoneObject:
00C692  1  AD 23 07           lda ScrollLock         ;check for scroll lock flag
00C695  1  F0 23              beq ExitWarpObject           ;branch if not set to leave
00C697  1  A5 CE              lda Player_Y_Position  ;check to see if player's vertical coordinate has
00C699  1  25 B5              and Player_Y_HighPos   ;same bits set as in vertical high byte (why?)
00C69B  1  D0 1D              bne ExitWarpObject           ;if so, branch to leave
00C69D  1  8D 23 07           sta ScrollLock         ;otherwise nullify scroll lock flag
00C6A0  1  EE D6 06           inc WarpZoneControl    ;increment warp zone flag to make warp pipes for warp zone
00C6A3  1                     ; jmp EraseEnemyObject   ;kill this object
00C6A3  1               EraseEnemyObject:
00C6A3  1  A9 00              lda #$00                 ;clear all enemy object variables
00C6A5  1  95 0F              sta Enemy_Flag,x
00C6A7  1  95 16              sta Enemy_ID,x
00C6A9  1  95 1E              sta Enemy_State,x
00C6AB  1  9D 10 01           sta FloateyNum_Control,x
00C6AE  1  9D 96 07           sta EnemyIntervalTimer,x
00C6B1  1  9D 25 01           sta ShellChainCounter,x
00C6B4  1  9D C5 03           sta Enemy_SprAttrib,x
00C6B7  1  9D 8A 07           sta EnemyFrameTimer,x
00C6BA  1               ExitWarpObject:
00C6BA  1  60                 rts
00C6BB  1               
00C6BB  1               ;-------------------------------------------------------------------------------------
00C6BB  1               
00C6BB  1               MovePodoboo:
00C6BB  1  BD 96 07           lda EnemyIntervalTimer,x   ;check enemy timer
00C6BE  1  D0 16              bne PdbM                   ;branch to move enemy if not expired
00C6C0  1  20 05 C1           jsr InitPodoboo            ;otherwise set up podoboo again
00C6C3  1  BD A8 07           lda PseudoRandomBitReg+1,x ;get part of LSFR
00C6C6  1  09 80              ora #%10000000             ;set d7
00C6C8  1  9D 34 04           sta Enemy_Y_MoveForce,x    ;store as movement force
00C6CB  1  29 0F              and #%00001111             ;mask out high nybble
00C6CD  1  09 06              ora #$06                   ;set for at least six intervals
00C6CF  1  9D 96 07           sta EnemyIntervalTimer,x   ;store as new enemy timer
00C6D2  1  A9 F9              lda #$f9
00C6D4  1  95 A0              sta Enemy_Y_Speed,x        ;set vertical speed to move podoboo upwards
00C6D6  1  4C 49 C0     PdbM: jmp MoveJ_EnemyVertically  ;branch to impose gravity on podoboo
00C6D9  1               
00C6D9  1               ;--------------------------------
00C6D9  1               ;$00 - used in HammerBroJumpCode as bitmask
00C6D9  1               
00C6D9  1               HammerThrowTmrData:
00C6D9  1  30 1C              .byte $30, $1c
00C6DB  1               
00C6DB  1               XSpeedAdderData:
00C6DB  1  00 E8 00 18        .byte $00, $e8, $00, $18
00C6DF  1               
00C6DF  1               RevivedXSpeed:
00C6DF  1  08 F8 0C F4        .byte $08, $f8, $0c, $f4
00C6E3  1               
00C6E3  1               ProcHammerBro:
00C6E3  1  B5 1E               lda Enemy_State,x          ;check hammer bro's enemy state for d5 set
00C6E5  1  29 20               and #%00100000
00C6E7  1  F0 03               beq ChkJH                  ;if not set, go ahead with code
00C6E9  1  4C F0 C7            jmp MoveDefeatedEnemy      ;otherwise jump to something else
00C6EC  1  B5 3C        ChkJH: lda HammerBroJumpTimer,x   ;check jump timer
00C6EE  1  F0 2D               beq HammerBroJumpCode      ;if expired, branch to jump
00C6F0  1  D6 3C               dec HammerBroJumpTimer,x   ;otherwise decrement jump timer
00C6F2  1  AD D1 03            lda Enemy_OffscreenBits
00C6F5  1  29 0C               and #%00001100             ;check offscreen bits
00C6F7  1  D0 6A               bne MoveHammerBroXDir      ;if hammer bro a little offscreen, skip to movement code
00C6F9  1  BD A2 03            lda HammerThrowingTimer,x  ;check hammer throwing timer
00C6FC  1  D0 17               bne DecHT                  ;if not expired, skip ahead, do not throw hammer
00C6FE  1  AC CC 06            ldy SecondaryHardMode      ;otherwise get secondary hard mode flag
00C701  1  B9 D9 C6            lda HammerThrowTmrData,y   ;get timer data using flag as offset
00C704  1  9D A2 03            sta HammerThrowingTimer,x  ;set as new timer
00C707  1  20 51 F1            jsr SpawnHammerObj         ;do a sub here to spawn hammer object
00C70A  1  90 09               bcc DecHT                  ;if carry clear, hammer not spawned, skip to decrement timer
00C70C  1  B5 1E               lda Enemy_State,x
00C70E  1  09 08               ora #%00001000             ;set d3 in enemy state for hammer throw
00C710  1  95 1E               sta Enemy_State,x
00C712  1  4C 63 C7            jmp MoveHammerBroXDir      ;jump to move hammer bro
00C715  1  DE A2 03     DecHT: dec HammerThrowingTimer,x  ;decrement timer
00C718  1  4C 63 C7            jmp MoveHammerBroXDir      ;jump to move hammer bro
00C71B  1               
00C71B  1               HammerBroJumpLData:
00C71B  1  20 37              .byte $20, $37
00C71D  1               
00C71D  1               HammerBroJumpCode:
00C71D  1  B5 1E               lda Enemy_State,x           ;get hammer bro's enemy state
00C71F  1  29 07               and #%00000111              ;mask out all but 3 LSB
00C721  1  C9 01               cmp #$01                    ;check for d0 set (for jumping)
00C723  1  F0 3E               beq MoveHammerBroXDir       ;if set, branch ahead to moving code
00C725  1  A9 00               lda #$00                    ;load default value here
00C727  1  85 00               sta $00                     ;save into temp variable for now
00C729  1  A0 FA               ldy #$fa                    ;set default vertical speed
00C72B  1  B5 CF               lda Enemy_Y_Position,x      ;check hammer bro's vertical coordinate
00C72D  1  30 13               bmi SetHJ                   ;if on the bottom half of the screen, use current speed
00C72F  1  A0 FD               ldy #$fd                    ;otherwise set alternate vertical speed
00C731  1  C9 70               cmp #$70                    ;check to see if hammer bro is above the middle of screen
00C733  1  E6 00               inc $00                     ;increment preset value to $01
00C735  1  90 0B               bcc SetHJ                   ;if above the middle of the screen, use current speed and $01
00C737  1  C6 00               dec $00                     ;otherwise return value to $00
00C739  1  BD A8 07            lda PseudoRandomBitReg+1,x  ;get part of LSFR, mask out all but LSB
00C73C  1  29 01               and #$01
00C73E  1  D0 02               bne SetHJ                   ;if d0 of LSFR set, branch and use current speed and $00
00C740  1  A0 FA               ldy #$fa                    ;otherwise reset to default vertical speed
00C742  1  94 A0        SetHJ: sty Enemy_Y_Speed,x         ;set vertical speed for jumping
00C744  1  B5 1E               lda Enemy_State,x           ;set d0 in enemy state for jumping
00C746  1  09 01               ora #$01
00C748  1  95 1E               sta Enemy_State,x
00C74A  1  A5 00               lda $00                     ;load preset value here to use as bitmask
00C74C  1  3D A9 07            and PseudoRandomBitReg+2,x  ;and do bit-wise comparison with part of LSFR
00C74F  1  A8                  tay                         ;then use as offset
00C750  1  AD CC 06            lda SecondaryHardMode       ;check secondary hard mode flag
00C753  1  D0 01               bne HJump
00C755  1  A8                  tay                         ;if secondary hard mode flag clear, set offset to 0
00C756  1  B9 1B C7     HJump: lda HammerBroJumpLData,y    ;get jump length timer data using offset from before
00C759  1  9D 8A 07            sta EnemyFrameTimer,x       ;save in enemy timer
00C75C  1  BD A8 07            lda PseudoRandomBitReg+1,x
00C75F  1  09 C0               ora #%11000000              ;get contents of part of LSFR, set d7 and d6, then
00C761  1  95 3C               sta HammerBroJumpTimer,x    ;store in jump timer
00C763  1               
00C763  1               MoveHammerBroXDir:
00C763  1  A0 FC                 ldy #$fc                  ;move hammer bro a little to the left
00C765  1  A5 09                 lda FrameCounter
00C767  1  29 40                 and #%01000000            ;change hammer bro's direction every 64 frames
00C769  1  D0 02                 bne Shimmy
00C76B  1  A0 04                 ldy #$04                  ;if d6 set in counter, move him a little to the right
00C76D  1  94 58        Shimmy:  sty Enemy_X_Speed,x       ;store horizontal speed
00C76F  1  A0 01                 ldy #$01                  ;set to face right by default
00C771  1  20 D3 DC              jsr PlayerEnemyDiff       ;get horizontal difference between player and hammer bro
00C774  1  30 0A                 bmi SetShim               ;if enemy to the left of player, skip this part
00C776  1  C8                    iny                       ;set to face left
00C777  1  BD 96 07              lda EnemyIntervalTimer,x  ;check walking timer
00C77A  1  D0 04                 bne SetShim               ;if not yet expired, skip to set moving direction
00C77C  1  A9 F8                 lda #$f8
00C77E  1  95 58                 sta Enemy_X_Speed,x       ;otherwise, make the hammer bro walk left towards player
00C780  1  94 46        SetShim: sty Enemy_MovingDir,x     ;set moving direction
00C782  1               
00C782  1               MoveNormalEnemy:
00C782  1  A0 00               ldy #$00                   ;init Y to leave horizontal movement as-is
00C784  1  B5 1E               lda Enemy_State,x
00C786  1  29 40               and #%01000000             ;check enemy state for d6 set, if set skip
00C788  1  D0 19               bne FallE                  ;to move enemy vertically, then horizontally if necessary
00C78A  1  B5 1E               lda Enemy_State,x
00C78C  1  0A                  asl                        ;check enemy state for d7 set
00C78D  1  B0 30               bcs SteadM                 ;if set, branch to move enemy horizontally
00C78F  1  B5 1E               lda Enemy_State,x
00C791  1  29 20               and #%00100000             ;check enemy state for d5 set
00C793  1  D0 5B               bne MoveDefeatedEnemy      ;if set, branch to move defeated enemy object
00C795  1  B5 1E               lda Enemy_State,x
00C797  1  29 07               and #%00000111             ;check d2-d0 of enemy state for any set bits
00C799  1  F0 24               beq SteadM                 ;if enemy in normal state, branch to move enemy horizontally
00C79B  1  C9 05               cmp #$05
00C79D  1  F0 04               beq FallE                  ;if enemy in state used by spiny's egg, go ahead here
00C79F  1  C9 03               cmp #$03
00C7A1  1  B0 30               bcs ReviveStunned          ;if enemy in states $03 or $04, skip ahead to yet another part
00C7A3  1  20 1A C0     FallE: jsr MoveD_EnemyVertically  ;do a sub here to move enemy downwards
00C7A6  1  A0 00               ldy #$00
00C7A8  1  B5 1E               lda Enemy_State,x          ;check for enemy state $02
00C7AA  1  C9 02               cmp #$02
00C7AC  1  F0 0C               beq MEHor                  ;if found, branch to move enemy horizontally
00C7AE  1  29 40               and #%01000000             ;check for d6 set
00C7B0  1  F0 0D               beq SteadM                 ;if not set, branch to something else
00C7B2  1  B5 16               lda Enemy_ID,x
00C7B4  1  C9 2E               cmp #PowerUpObject         ;check for power-up object
00C7B6  1  F0 07               beq SteadM
00C7B8  1  D0 03               bne SlowM                  ;if any other object where d6 set, jump to set Y
00C7BA  1  4C B9 BF     MEHor: jmp MoveEnemyHorizontally  ;jump here to move enemy horizontally for <> $2e and d6 set
00C7BD  1               
00C7BD  1  A0 01        SlowM:  ldy #$01                  ;if branched here, increment Y to slow horizontal movement
00C7BF  1  B5 58        SteadM: lda Enemy_X_Speed,x       ;get current horizontal speed
00C7C1  1  48                   pha                       ;save to stack
00C7C2  1  10 02                bpl AddHS                 ;if not moving or moving right, skip, leave Y alone
00C7C4  1  C8                   iny
00C7C5  1  C8                   iny                       ;otherwise increment Y to next data
00C7C6  1  18           AddHS:  clc
00C7C7  1  79 DB C6             adc XSpeedAdderData,y     ;add value here to slow enemy down if necessary
00C7CA  1  95 58                sta Enemy_X_Speed,x       ;save as horizontal speed temporarily
00C7CC  1  20 B9 BF             jsr MoveEnemyHorizontally ;then do a sub to move horizontally
00C7CF  1  68                   pla
00C7D0  1  95 58                sta Enemy_X_Speed,x       ;get old horizontal speed from stack and return to
00C7D2  1  60                   rts                       ;original memory location, then leave
00C7D3  1               
00C7D3  1               ReviveStunned:
00C7D3  1  BD 96 07              lda EnemyIntervalTimer,x  ;if enemy timer not expired yet,
00C7D6  1  D0 1E                 bne ChkKillGoomba         ;skip ahead to something else
00C7D8  1  95 1E                 sta Enemy_State,x         ;otherwise initialize enemy state to normal
00C7DA  1  A5 09                 lda FrameCounter
00C7DC  1  29 01                 and #$01                  ;get d0 of frame counter
00C7DE  1  A8                    tay                       ;use as Y and increment for movement direction
00C7DF  1  C8                    iny
00C7E0  1  94 46                 sty Enemy_MovingDir,x     ;store as pseudorandom movement direction
00C7E2  1  88                    dey                       ;decrement for use as pointer
00C7E3  1  AD 6A 07              lda PrimaryHardMode       ;check primary hard mode flag
00C7E6  1  F0 02                 beq SetRSpd               ;if not set, use pointer as-is
00C7E8  1  C8                    iny
00C7E9  1  C8                    iny                       ;otherwise increment 2 bytes to next data
00C7EA  1  B9 DF C6     SetRSpd: lda RevivedXSpeed,y       ;load and store new horizontal speed
00C7ED  1  95 58                 sta Enemy_X_Speed,x       ;and leave
00C7EF  1  60                    rts
00C7F0  1               
00C7F0  1               MoveDefeatedEnemy:
00C7F0  1  20 1A C0           jsr MoveD_EnemyVertically      ;execute sub to move defeated enemy downwards
00C7F3  1  4C B9 BF           jmp MoveEnemyHorizontally      ;now move defeated enemy horizontally
00C7F6  1               
00C7F6  1               ChkKillGoomba:
00C7F6  1  C9 0E                cmp #$0e              ;check to see if enemy timer has reached
00C7F8  1  D0 09                bne NKGmba            ;a certain point, and branch to leave if not
00C7FA  1  B5 16                lda Enemy_ID,x
00C7FC  1  C9 06                cmp #Goomba           ;check for goomba object
00C7FE  1  D0 03                bne NKGmba            ;branch if not found
00C800  1  20 A3 C6             jsr EraseEnemyObject  ;otherwise, kill this goomba object
00C803  1  60           NKGmba: rts                   ;leave!
00C804  1               
00C804  1               ;--------------------------------
00C804  1               
00C804  1               MoveJumpingEnemy:
00C804  1  20 49 C0           jsr MoveJ_EnemyVertically  ;do a sub to impose gravity on green paratroopa
00C807  1  4C B9 BF           jmp MoveEnemyHorizontally  ;jump to move enemy horizontally
00C80A  1               
00C80A  1               ;--------------------------------
00C80A  1               
00C80A  1               ProcMoveRedPTroopa:
00C80A  1  B5 A0                  lda Enemy_Y_Speed,x
00C80C  1  1D 34 04               ora Enemy_Y_MoveForce,x     ;check for any vertical force or speed
00C80F  1  D0 13                  bne MoveRedPTUpOrDown       ;branch if any found
00C811  1  9D 17 04               sta Enemy_YMF_Dummy,x       ;initialize something here
00C814  1  B5 CF                  lda Enemy_Y_Position,x      ;check current vs. original vertical coordinate
00C816  1  DD 01 04               cmp RedPTroopaOrigXPos,x
00C819  1  B0 09                  bcs MoveRedPTUpOrDown       ;if current => original, skip ahead to more code
00C81B  1  A5 09                  lda FrameCounter            ;get frame counter
00C81D  1  29 07                  and #%00000111              ;mask out all but 3 LSB
00C81F  1  D0 02                  bne NoIncPT                 ;if any bits set, branch to leave
00C821  1  F6 CF                  inc Enemy_Y_Position,x      ;otherwise increment red paratroopa's vertical position
00C823  1  60           NoIncPT:  rts                         ;leave
00C824  1               
00C824  1               MoveRedPTUpOrDown:
00C824  1  B5 CF                  lda Enemy_Y_Position,x      ;check current vs. central vertical coordinate
00C826  1  D5 58                  cmp RedPTroopaCenterYPos,x
00C828  1  90 03                  bcc MovPTDwn                ;if current < central, jump to move downwards
00C82A  1  4C 2C C0               jmp MoveRedPTroopaUp        ;otherwise jump to move upwards
00C82D  1  4C 27 C0     MovPTDwn: jmp MoveRedPTroopaDown      ;move downwards
00C830  1               
00C830  1               ;--------------------------------
00C830  1               ;$00 - used to store adder for movement, also used as adder for platform
00C830  1               ;$01 - used to store maximum value for secondary counter
00C830  1               
00C830  1               MoveFlyGreenPTroopa:
00C830  1  20 50 C8             jsr XMoveCntr_GreenPTroopa ;do sub to increment primary and secondary counters
00C833  1  20 71 C8             jsr MoveWithXMCntrs        ;do sub to move green paratroopa accordingly, and horizontally
00C836  1  A0 01                ldy #$01                   ;set Y to move green paratroopa down
00C838  1  A5 09                lda FrameCounter
00C83A  1  29 03                and #%00000011             ;check frame counter 2 LSB for any bits set
00C83C  1  D0 11                bne NoMGPT                 ;branch to leave if set to move up/down every fourth frame
00C83E  1  A5 09                lda FrameCounter
00C840  1  29 40                and #%01000000             ;check frame counter for d6 set
00C842  1  D0 02                bne YSway                  ;branch to move green paratroopa down if set
00C844  1  A0 FF                ldy #$ff                   ;otherwise set Y to move green paratroopa up
00C846  1  84 00        YSway:  sty $00                    ;store adder here
00C848  1  B5 CF                lda Enemy_Y_Position,x
00C84A  1  18                   clc                        ;add or subtract from vertical position
00C84B  1  65 00                adc $00                    ;to give green paratroopa a wavy flight
00C84D  1  95 CF                sta Enemy_Y_Position,x
00C84F  1  60           NoMGPT: rts                        ;leave!
00C850  1               
00C850  1               XMoveCntr_GreenPTroopa:
00C850  1  A9 13                 lda #$13                    ;load preset maximum value for secondary counter
00C852  1               
00C852  1               XMoveCntr_Platform:
00C852  1  85 01                 sta $01                     ;store value here
00C854  1  A5 09                 lda FrameCounter
00C856  1  29 03                 and #%00000011              ;branch to leave if not on
00C858  1  D0 0D                 bne NoIncXM                 ;every fourth frame
00C85A  1  B4 58                 ldy XMoveSecondaryCounter,x ;get secondary counter
00C85C  1  B5 A0                 lda XMovePrimaryCounter,x   ;get primary counter
00C85E  1  4A                    lsr
00C85F  1  B0 0A                 bcs DecSeXM                 ;if d0 of primary counter set, branch elsewhere
00C861  1  C4 01                 cpy $01                     ;compare secondary counter to preset maximum value
00C863  1  F0 03                 beq IncPXM                  ;if equal, branch ahead of this part
00C865  1  F6 58                 inc XMoveSecondaryCounter,x ;increment secondary counter and leave
00C867  1  60           NoIncXM: rts
00C868  1  F6 A0        IncPXM:  inc XMovePrimaryCounter,x   ;increment primary counter and leave
00C86A  1  60                    rts
00C86B  1  98           DecSeXM: tya                         ;put secondary counter in A
00C86C  1  F0 FA                 beq IncPXM                  ;if secondary counter at zero, branch back
00C86E  1  D6 58                 dec XMoveSecondaryCounter,x ;otherwise decrement secondary counter and leave
00C870  1  60                    rts
00C871  1               
00C871  1               MoveWithXMCntrs:
00C871  1  B5 58                 lda XMoveSecondaryCounter,x  ;save secondary counter to stack
00C873  1  48                    pha
00C874  1  A0 01                 ldy #$01                     ;set value here by default
00C876  1  B5 A0                 lda XMovePrimaryCounter,x
00C878  1  29 02                 and #%00000010               ;if d1 of primary counter is
00C87A  1  D0 0B                 bne XMRight                  ;set, branch ahead of this part here
00C87C  1  B5 58                 lda XMoveSecondaryCounter,x
00C87E  1  49 FF                 eor #$ff                     ;otherwise change secondary
00C880  1  18                    clc                          ;counter to two's compliment
00C881  1  69 01                 adc #$01
00C883  1  95 58                 sta XMoveSecondaryCounter,x
00C885  1  A0 02                 ldy #$02                     ;load alternate value here
00C887  1  94 46        XMRight: sty Enemy_MovingDir,x        ;store as moving direction
00C889  1  20 B9 BF              jsr MoveEnemyHorizontally
00C88C  1  85 00                 sta $00                      ;save value obtained from sub here
00C88E  1  68                    pla                          ;get secondary counter from stack
00C88F  1  95 58                 sta XMoveSecondaryCounter,x  ;and return to original place
00C891  1  60                    rts
00C892  1               
00C892  1               ;--------------------------------
00C892  1               
00C892  1               BlooberBitmasks:
00C892  1  3F 03              .byte %00111111, %00000011
00C894  1               
00C894  1               MoveBloober:
00C894  1  B5 1E                lda Enemy_State,x
00C896  1  29 20                and #%00100000             ;check enemy state for d5 set
00C898  1  D0 4D                bne MoveDefeatedBloober    ;branch if set to move defeated bloober
00C89A  1  AC CC 06             ldy SecondaryHardMode      ;use secondary hard mode flag as offset
00C89D  1  BD A8 07             lda PseudoRandomBitReg+1,x ;get LSFR
00C8A0  1  39 92 C8             and BlooberBitmasks,y      ;mask out bits in LSFR using bitmask loaded with offset
00C8A3  1  D0 12                bne BlooberSwim            ;if any bits set, skip ahead to make swim
00C8A5  1  8A                   txa
00C8A6  1  4A                   lsr                        ;check to see if on second or fourth slot (1 or 3)
00C8A7  1  90 04                bcc FBLeft                 ;if not, branch to figure out moving direction
00C8A9  1  A4 45                ldy Player_MovingDir       ;otherwise, load player's moving direction and
00C8AB  1  B0 08                bcs SBMDir                 ;do an unconditional branch to set
00C8AD  1  A0 02        FBLeft: ldy #$02                   ;set left moving direction by default
00C8AF  1  20 D3 DC             jsr PlayerEnemyDiff        ;get horizontal difference between player and bloober
00C8B2  1  10 01                bpl SBMDir                 ;if enemy to the right of player, keep left
00C8B4  1  88                   dey                        ;otherwise decrement to set right moving direction
00C8B5  1  94 46        SBMDir: sty Enemy_MovingDir,x      ;set moving direction of bloober, then continue on here
00C8B7  1               
00C8B7  1               BlooberSwim:
00C8B7  1  20 EA C8            jsr ProcSwimmingB        ;execute sub to make bloober swim characteristically
00C8BA  1  B5 CF               lda Enemy_Y_Position,x   ;get vertical coordinate
00C8BC  1  38                  sec
00C8BD  1  FD 34 04            sbc Enemy_Y_MoveForce,x  ;subtract movement force
00C8C0  1  C9 20               cmp #$20                 ;check to see if position is above edge of status bar
00C8C2  1  90 02               bcc SwimX                ;if so, don't do it
00C8C4  1  95 CF               sta Enemy_Y_Position,x   ;otherwise, set new vertical position, make bloober swim
00C8C6  1  B4 46        SwimX: ldy Enemy_MovingDir,x    ;check moving direction
00C8C8  1  88                  dey
00C8C9  1  D0 0E               bne LeftSwim             ;if moving to the left, branch to second part
00C8CB  1  B5 87               lda Enemy_X_Position,x
00C8CD  1  18                  clc                      ;add movement speed to horizontal coordinate
00C8CE  1  75 58               adc BlooperMoveSpeed,x
00C8D0  1  95 87               sta Enemy_X_Position,x   ;store result as new horizontal coordinate
00C8D2  1  B5 6E               lda Enemy_PageLoc,x
00C8D4  1  69 00               adc #$00                 ;add carry to page location
00C8D6  1  95 6E               sta Enemy_PageLoc,x      ;store as new page location and leave
00C8D8  1  60                  rts
00C8D9  1               
00C8D9  1               LeftSwim:
00C8D9  1  B5 87              lda Enemy_X_Position,x
00C8DB  1  38                 sec                      ;subtract movement speed from horizontal coordinate
00C8DC  1  F5 58              sbc BlooperMoveSpeed,x
00C8DE  1  95 87              sta Enemy_X_Position,x   ;store result as new horizontal coordinate
00C8E0  1  B5 6E              lda Enemy_PageLoc,x
00C8E2  1  E9 00              sbc #$00                 ;subtract borrow from page location
00C8E4  1  95 6E              sta Enemy_PageLoc,x      ;store as new page location and leave
00C8E6  1  60                 rts
00C8E7  1               
00C8E7  1               MoveDefeatedBloober:
00C8E7  1  4C 43 C0           jmp MoveEnemySlowVert    ;jump to move defeated bloober downwards
00C8EA  1               
00C8EA  1               ProcSwimmingB:
00C8EA  1  B5 A0                lda BlooperMoveCounter,x  ;get enemy's movement counter
00C8EC  1  29 02                and #%00000010            ;check for d1 set
00C8EE  1  D0 37                bne ChkForFloatdown       ;branch if set
00C8F0  1  A5 09                lda FrameCounter
00C8F2  1  29 07                and #%00000111            ;get 3 LSB of frame counter
00C8F4  1  48                   pha                       ;and save it to the stack
00C8F5  1  B5 A0                lda BlooperMoveCounter,x  ;get enemy's movement counter
00C8F7  1  4A                   lsr                       ;check for d0 set
00C8F8  1  B0 15                bcs SlowSwim              ;branch if set
00C8FA  1  68                   pla                       ;pull 3 LSB of frame counter from the stack
00C8FB  1  D0 11                bne BSwimE                ;branch to leave, execute code only every eighth frame
00C8FD  1  BD 34 04             lda Enemy_Y_MoveForce,x
00C900  1  18                   clc                       ;add to movement force to speed up swim
00C901  1  69 01                adc #$01
00C903  1  9D 34 04             sta Enemy_Y_MoveForce,x   ;set movement force
00C906  1  95 58                sta BlooperMoveSpeed,x    ;set as movement speed
00C908  1  C9 02                cmp #$02
00C90A  1  D0 02                bne BSwimE                ;if certain horizontal speed, branch to leave
00C90C  1  F6 A0                inc BlooperMoveCounter,x  ;otherwise increment movement counter
00C90E  1  60           BSwimE: rts
00C90F  1               
00C90F  1               SlowSwim:
00C90F  1  68                  pla                      ;pull 3 LSB of frame counter from the stack
00C910  1  D0 14               bne NoSSw                ;branch to leave, execute code only every eighth frame
00C912  1  BD 34 04            lda Enemy_Y_MoveForce,x
00C915  1  38                  sec                      ;subtract from movement force to slow swim
00C916  1  E9 01               sbc #$01
00C918  1  9D 34 04            sta Enemy_Y_MoveForce,x  ;set movement force
00C91B  1  95 58               sta BlooperMoveSpeed,x   ;set as movement speed
00C91D  1  D0 07               bne NoSSw                ;if any speed, branch to leave
00C91F  1  F6 A0               inc BlooperMoveCounter,x ;otherwise increment movement counter
00C921  1  A9 02               lda #$02
00C923  1  9D 96 07            sta EnemyIntervalTimer,x ;set enemy's timer
00C926  1  60           NoSSw: rts                      ;leave
00C927  1               
00C927  1               ChkForFloatdown:
00C927  1  BD 96 07           lda EnemyIntervalTimer,x ;get enemy timer
00C92A  1  F0 08              beq ChkNearPlayer        ;branch if expired
00C92C  1               
00C92C  1               Floatdown:
00C92C  1  A5 09              lda FrameCounter        ;get frame counter
00C92E  1  4A                 lsr                     ;check for d0 set
00C92F  1  B0 02              bcs NoFD                ;branch to leave on every other frame
00C931  1  F6 CF              inc Enemy_Y_Position,x  ;otherwise increment vertical coordinate
00C933  1  60           NoFD: rts                     ;leave
00C934  1               
00C934  1               ChkNearPlayer:
00C934  1  B5 CF              lda Enemy_Y_Position,x    ;get vertical coordinate
00C936  1  69 10              adc #$10                  ;add sixteen pixels
00C938  1  C5 CE              cmp Player_Y_Position     ;compare result with player's vertical coordinate
00C93A  1  90 F0              bcc Floatdown             ;if modified vertical less than player's, branch
00C93C  1  A9 00              lda #$00
00C93E  1  95 A0              sta BlooperMoveCounter,x  ;otherwise nullify movement counter
00C940  1  60                 rts
00C941  1               
00C941  1               ;--------------------------------
00C941  1               
00C941  1               MoveBulletBill:
00C941  1  B5 1E                 lda Enemy_State,x          ;check bullet bill's enemy object state for d5 set
00C943  1  29 20                 and #%00100000
00C945  1  F0 03                 beq NotDefB                ;if not set, continue with movement code
00C947  1  4C 49 C0              jmp MoveJ_EnemyVertically  ;otherwise jump to move defeated bullet bill downwards
00C94A  1  A9 E8        NotDefB: lda #$e8                   ;set bullet bill's horizontal speed
00C94C  1  95 58                 sta Enemy_X_Speed,x        ;and move it accordingly (note: this bullet bill
00C94E  1  4C B9 BF              jmp MoveEnemyHorizontally  ;object occurs in frenzy object $17, not from cannons)
00C951  1               
00C951  1               ;--------------------------------
00C951  1               ;$02 - used to hold preset values
00C951  1               ;$03 - used to hold enemy state
00C951  1               
00C951  1               SwimCCXMoveData:
00C951  1  40 80              .byte $40, $80
00C953  1  04 04              .byte $04, $04 ;residual data, not used
00C955  1               
00C955  1               MoveSwimmingCheepCheep:
00C955  1  B5 1E                lda Enemy_State,x         ;check cheep-cheep's enemy object state
00C957  1  29 20                and #%00100000            ;for d5 set
00C959  1  F0 03                beq CCSwim                ;if not set, continue with movement code
00C95B  1  4C 43 C0             jmp MoveEnemySlowVert     ;otherwise jump to move defeated cheep-cheep downwards
00C95E  1  85 03        CCSwim: sta $03                   ;save enemy state in $03
00C960  1  B5 16                lda Enemy_ID,x            ;get enemy identifier
00C962  1  38                   sec
00C963  1  E9 0A                sbc #$0a                  ;subtract ten for cheep-cheep identifiers
00C965  1  A8                   tay                       ;use as offset
00C966  1  B9 51 C9             lda SwimCCXMoveData,y     ;load value here
00C969  1  85 02                sta $02
00C96B  1  BD 01 04             lda Enemy_X_MoveForce,x   ;load horizontal force
00C96E  1  38                   sec
00C96F  1  E5 02                sbc $02                   ;subtract preset value from horizontal force
00C971  1  9D 01 04             sta Enemy_X_MoveForce,x   ;store as new horizontal force
00C974  1  B5 87                lda Enemy_X_Position,x    ;get horizontal coordinate
00C976  1  E9 00                sbc #$00                  ;subtract borrow (thus moving it slowly)
00C978  1  95 87                sta Enemy_X_Position,x    ;and save as new horizontal coordinate
00C97A  1  B5 6E                lda Enemy_PageLoc,x
00C97C  1  E9 00                sbc #$00                  ;subtract borrow again, this time from the
00C97E  1  95 6E                sta Enemy_PageLoc,x       ;page location, then save
00C980  1  A9 20                lda #$20
00C982  1  85 02                sta $02                   ;save new value here
00C984  1  E0 02                cpx #$02                  ;check enemy object offset
00C986  1  90 49                bcc ExSwCC                ;if in first or second slot, branch to leave
00C988  1  B5 58                lda CheepCheepMoveMFlag,x ;check movement flag
00C98A  1  C9 10                cmp #$10                  ;if movement speed set to $00,
00C98C  1  90 16                bcc CCSwimUpwards         ;branch to move upwards
00C98E  1  BD 17 04             lda Enemy_YMF_Dummy,x
00C991  1  18                   clc
00C992  1  65 02                adc $02                   ;add preset value to dummy variable to get carry
00C994  1  9D 17 04             sta Enemy_YMF_Dummy,x     ;and save dummy
00C997  1  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
00C999  1  65 03                adc $03                   ;add carry to it plus enemy state to slowly move it downwards
00C99B  1  95 CF                sta Enemy_Y_Position,x    ;save as new vertical coordinate
00C99D  1  B5 B6                lda Enemy_Y_HighPos,x
00C99F  1  69 00                adc #$00                  ;add carry to page location and
00C9A1  1  4C B7 C9             jmp ChkSwimYPos           ;jump to end of movement code
00C9A4  1               
00C9A4  1               CCSwimUpwards:
00C9A4  1  BD 17 04             lda Enemy_YMF_Dummy,x
00C9A7  1  38                   sec
00C9A8  1  E5 02                sbc $02                   ;subtract preset value to dummy variable to get borrow
00C9AA  1  9D 17 04             sta Enemy_YMF_Dummy,x     ;and save dummy
00C9AD  1  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
00C9AF  1  E5 03                sbc $03                   ;subtract borrow to it plus enemy state to slowly move it upwards
00C9B1  1  95 CF                sta Enemy_Y_Position,x    ;save as new vertical coordinate
00C9B3  1  B5 B6                lda Enemy_Y_HighPos,x
00C9B5  1  E9 00                sbc #$00                  ;subtract borrow from page location
00C9B7  1               
00C9B7  1               ChkSwimYPos:
00C9B7  1  95 B6                sta Enemy_Y_HighPos,x     ;save new page location here
00C9B9  1  A0 00                ldy #$00                  ;load movement speed to upwards by default
00C9BB  1  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
00C9BD  1  38                   sec
00C9BE  1  FD 34 04             sbc CheepCheepOrigYPos,x  ;subtract original coordinate from current
00C9C1  1  10 07                bpl YPDiff                ;if result positive, skip to next part
00C9C3  1  A0 10                ldy #$10                  ;otherwise load movement speed to downwards
00C9C5  1  49 FF                eor #$ff
00C9C7  1  18                   clc                       ;get two's compliment of result
00C9C8  1  69 01                adc #$01                  ;to obtain total difference of original vs. current
00C9CA  1  C9 0F        YPDiff: cmp #$0f                  ;if difference between original vs. current vertical
00C9CC  1  90 03                bcc ExSwCC                ;coordinates < 15 pixels, leave movement speed alone
00C9CE  1  98                   tya
00C9CF  1  95 58                sta CheepCheepMoveMFlag,x ;otherwise change movement speed
00C9D1  1  60           ExSwCC: rts                       ;leave
00C9D2  1               
00C9D2  1               ;--------------------------------
00C9D2  1               ;$00 - used as counter for firebar parts
00C9D2  1               ;$01 - used for oscillated high byte of spin state or to hold horizontal adder
00C9D2  1               ;$02 - used for oscillated high byte of spin state or to hold vertical adder
00C9D2  1               ;$03 - used for mirror data
00C9D2  1               ;$04 - used to store player's sprite 1 X coordinate
00C9D2  1               ;$05 - used to evaluate mirror data
00C9D2  1               ;$06 - used to store either screen X coordinate or sprite data offset
00C9D2  1               ;$07 - used to store screen Y coordinate
00C9D2  1               ;$ed - used to hold maximum length of firebar
00C9D2  1               ;$ef - used to hold high byte of spinstate
00C9D2  1               
00C9D2  1               ;horizontal adder is at first byte + high byte of spinstate,
00C9D2  1               ;vertical adder is same + 8 bytes, two's compliment
00C9D2  1               ;if greater than $08 for proper oscillation
00C9D2  1               FirebarPosLookupTbl:
00C9D2  1  00 01 03 04        .byte $00, $01, $03, $04, $05, $06, $07, $07, $08
00C9D6  1  05 06 07 07  
00C9DA  1  08           
00C9DB  1  00 03 06 09        .byte $00, $03, $06, $09, $0b, $0d, $0e, $0f, $10
00C9DF  1  0B 0D 0E 0F  
00C9E3  1  10           
00C9E4  1  00 04 09 0D        .byte $00, $04, $09, $0d, $10, $13, $16, $17, $18
00C9E8  1  10 13 16 17  
00C9EC  1  18           
00C9ED  1  00 06 0C 12        .byte $00, $06, $0c, $12, $16, $1a, $1d, $1f, $20
00C9F1  1  16 1A 1D 1F  
00C9F5  1  20           
00C9F6  1  00 07 0F 16        .byte $00, $07, $0f, $16, $1c, $21, $25, $27, $28
00C9FA  1  1C 21 25 27  
00C9FE  1  28           
00C9FF  1  00 09 12 1B        .byte $00, $09, $12, $1b, $21, $27, $2c, $2f, $30
00CA03  1  21 27 2C 2F  
00CA07  1  30           
00CA08  1  00 0B 15 1F        .byte $00, $0b, $15, $1f, $27, $2e, $33, $37, $38
00CA0C  1  27 2E 33 37  
00CA10  1  38           
00CA11  1  00 0C 18 24        .byte $00, $0c, $18, $24, $2d, $35, $3b, $3e, $40
00CA15  1  2D 35 3B 3E  
00CA19  1  40           
00CA1A  1  00 0E 1B 28        .byte $00, $0e, $1b, $28, $32, $3b, $42, $46, $48
00CA1E  1  32 3B 42 46  
00CA22  1  48           
00CA23  1  00 0F 1F 2D        .byte $00, $0f, $1f, $2d, $38, $42, $4a, $4e, $50
00CA27  1  38 42 4A 4E  
00CA2B  1  50           
00CA2C  1  00 11 22 31        .byte $00, $11, $22, $31, $3e, $49, $51, $56, $58
00CA30  1  3E 49 51 56  
00CA34  1  58           
00CA35  1               
00CA35  1               FirebarMirrorData:
00CA35  1  01 03 02 00        .byte $01, $03, $02, $00
00CA39  1               
00CA39  1               FirebarTblOffsets:
00CA39  1  00 09 12 1B        .byte $00, $09, $12, $1b, $24, $2d
00CA3D  1  24 2D        
00CA3F  1  36 3F 48 51        .byte $36, $3f, $48, $51, $5a, $63
00CA43  1  5A 63        
00CA45  1               
00CA45  1               FirebarYPos:
00CA45  1  0C 18              .byte $0c, $18
00CA47  1               
00CA47  1               ProcFirebar:
00CA47  1  20 1F ED               jsr GetEnemyOffscreenBits   ;get offscreen information
00CA4A  1  AD D1 03               lda Enemy_OffscreenBits     ;check for d3 set
00CA4D  1  29 08                  and #%00001000              ;if so, branch to leave
00CA4F  1  D0 74                  bne SkipFBar
00CA51  1  AD 47 07               lda TimerControl            ;if master timer control set, branch
00CA54  1  D0 0A                  bne SusFbar                 ;ahead of this part
00CA56  1  BD 88 03               lda FirebarSpinSpeed,x      ;load spinning speed of firebar
00CA59  1  20 03 D0               jsr FirebarSpin             ;modify current spinstate
00CA5C  1  29 1F                  and #%00011111              ;mask out all but 5 LSB
00CA5E  1  95 A0                  sta FirebarSpinState_High,x ;and store as new high byte of spinstate
00CA60  1  B5 A0        SusFbar:  lda FirebarSpinState_High,x ;get high byte of spinstate
00CA62  1  B4 16                  ldy Enemy_ID,x              ;check enemy identifier
00CA64  1  C0 1F                  cpy #$1f
00CA66  1  90 0D                  bcc SetupGFB                ;if < $1f (long firebar), branch
00CA68  1  C9 08                  cmp #$08                    ;check high byte of spinstate
00CA6A  1  F0 04                  beq SkpFSte                 ;if eight, branch to change
00CA6C  1  C9 18                  cmp #$18
00CA6E  1  D0 05                  bne SetupGFB                ;if not at twenty-four branch to not change
00CA70  1  18           SkpFSte:  clc
00CA71  1  69 01                  adc #$01                    ;add one to spinning thing to avoid horizontal state
00CA73  1  95 A0                  sta FirebarSpinState_High,x
00CA75  1  85 EF        SetupGFB: sta $ef                     ;save high byte of spinning thing, modified or otherwise
00CA77  1  20 C2 EC               jsr RelativeEnemyPosition   ;get relative coordinates to screen
00CA7A  1  20 99 CB               jsr GetFirebarPosition      ;do a sub here (residual, too early to be used now)
00CA7D  1  BC E5 06               ldy Enemy_SprDataOffset,x   ;get OAM data offset
00CA80  1  AD B9 03               lda Enemy_Rel_YPos          ;get relative vertical coordinate
00CA83  1  99 00 02               sta Sprite_Y_Position,y     ;store as Y in OAM data
00CA86  1  85 07                  sta $07                     ;also save here
00CA88  1  AD AE 03               lda Enemy_Rel_XPos          ;get relative horizontal coordinate
00CA8B  1  99 03 02               sta Sprite_X_Position,y     ;store as X in OAM data
00CA8E  1  85 06                  sta $06                     ;also save here
00CA90  1  A9 01                  lda #$01
00CA92  1  85 00                  sta $00                     ;set $01 value here (not necessary)
00CA94  1  20 13 CB               jsr FirebarCollision        ;draw fireball part and do collision detection
00CA97  1  A0 05                  ldy #$05                    ;load value for short firebars by default
00CA99  1  B5 16                  lda Enemy_ID,x
00CA9B  1  C9 1F                  cmp #$1f                    ;are we doing a long firebar?
00CA9D  1  90 02                  bcc SetMFbar                ;no, branch then
00CA9F  1  A0 0B                  ldy #$0b                    ;otherwise load value for long firebars
00CAA1  1  84 ED        SetMFbar: sty $ed                     ;store maximum value for length of firebars
00CAA3  1  A9 00                  lda #$00
00CAA5  1  85 00                  sta $00                     ;initialize counter here
00CAA7  1  A5 EF        DrawFbar: lda $ef                     ;load high byte of spinstate
00CAA9  1  20 99 CB               jsr GetFirebarPosition      ;get fireball position data depending on firebar part
00CAAC  1  20 C6 CA               jsr DrawFirebar_Collision   ;position it properly, draw it and do collision detection
00CAAF  1  A5 00                  lda $00                     ;check which firebar part
00CAB1  1  C9 04                  cmp #$04
00CAB3  1  D0 08                  bne NextFbar
00CAB5  1  AC CF 06               ldy DuplicateObj_Offset     ;if we arrive at fifth firebar part,
00CAB8  1  B9 E5 06               lda Enemy_SprDataOffset,y   ;get offset from long firebar and load OAM data offset
00CABB  1  85 06                  sta $06                     ;using long firebar offset, then store as new one here
00CABD  1  E6 00        NextFbar: inc $00                     ;move onto the next firebar part
00CABF  1  A5 00                  lda $00
00CAC1  1  C5 ED                  cmp $ed                     ;if we end up at the maximum part, go on and leave
00CAC3  1  90 E2                  bcc DrawFbar                ;otherwise go back and do another
00CAC5  1  60           SkipFBar: rts
00CAC6  1               
00CAC6  1               DrawFirebar_Collision:
00CAC6  1  A5 03                 lda $03                  ;store mirror data elsewhere
00CAC8  1  85 05                 sta $05
00CACA  1  A4 06                 ldy $06                  ;load OAM data offset for firebar
00CACC  1  A5 01                 lda $01                  ;load horizontal adder we got from position loader
00CACE  1  46 05                 lsr $05                  ;shift LSB of mirror data
00CAD0  1  B0 04                 bcs AddHA                ;if carry was set, skip this part
00CAD2  1  49 FF                 eor #$ff
00CAD4  1  69 01                 adc #$01                 ;otherwise get two's compliment of horizontal adder
00CAD6  1  18           AddHA:   clc                      ;add horizontal coordinate relative to screen to
00CAD7  1  6D AE 03              adc Enemy_Rel_XPos       ;horizontal adder, modified or otherwise
00CADA  1  99 03 02              sta Sprite_X_Position,y  ;store as X coordinate here
00CADD  1  85 06                 sta $06                  ;store here for now, note offset is saved in Y still
00CADF  1  CD AE 03              cmp Enemy_Rel_XPos       ;compare X coordinate of sprite to original X of firebar
00CAE2  1  B0 09                 bcs SubtR1               ;if sprite coordinate => original coordinate, branch
00CAE4  1  AD AE 03              lda Enemy_Rel_XPos
00CAE7  1  38                    sec                      ;otherwise subtract sprite X from the
00CAE8  1  E5 06                 sbc $06                  ;original one and skip this part
00CAEA  1  4C F1 CA              jmp ChkFOfs
00CAED  1  38           SubtR1:  sec                      ;subtract original X from the
00CAEE  1  ED AE 03              sbc Enemy_Rel_XPos       ;current sprite X
00CAF1  1  C9 59        ChkFOfs: cmp #$59                 ;if difference of coordinates within a certain range,
00CAF3  1  90 04                 bcc VAHandl              ;continue by handling vertical adder
00CAF5  1  A9 F8                 lda #$f8                 ;otherwise, load offscreen Y coordinate
00CAF7  1  D0 15                 bne SetVFbr              ;and unconditionally branch to move sprite offscreen
00CAF9  1  AD B9 03     VAHandl: lda Enemy_Rel_YPos       ;if vertical relative coordinate offscreen,
00CAFC  1  C9 F8                 cmp #$f8                 ;skip ahead of this part and write into sprite Y coordinate
00CAFE  1  F0 0E                 beq SetVFbr
00CB00  1  A5 02                 lda $02                  ;load vertical adder we got from position loader
00CB02  1  46 05                 lsr $05                  ;shift LSB of mirror data one more time
00CB04  1  B0 04                 bcs AddVA                ;if carry was set, skip this part
00CB06  1  49 FF                 eor #$ff
00CB08  1  69 01                 adc #$01                 ;otherwise get two's compliment of second part
00CB0A  1  18           AddVA:   clc                      ;add vertical coordinate relative to screen to
00CB0B  1  6D B9 03              adc Enemy_Rel_YPos       ;the second data, modified or otherwise
00CB0E  1  99 00 02     SetVFbr: sta Sprite_Y_Position,y  ;store as Y coordinate here
00CB11  1  85 07                 sta $07                  ;also store here for now
00CB13  1               
00CB13  1               FirebarCollision:
00CB13  1  20 7D E8              jsr DrawFirebar          ;run sub here to draw current tile of firebar
00CB16  1  98                    tya                      ;return OAM data offset and save
00CB17  1  48                    pha                      ;to the stack for now
00CB18  1  AD 9F 07              lda StarInvincibleTimer  ;if star mario invincibility timer
00CB1B  1  0D 47 07              ora TimerControl         ;or master timer controls set
00CB1E  1  D0 70                 bne NoColFB              ;then skip all of this
00CB20  1  85 05                 sta $05                  ;otherwise initialize counter
00CB22  1  A4 B5                 ldy Player_Y_HighPos
00CB24  1  88                    dey                      ;if player's vertical high byte offscreen,
00CB25  1  D0 69                 bne NoColFB              ;skip all of this
00CB27  1  A4 CE                 ldy Player_Y_Position    ;get player's vertical position
00CB29  1  AD 54 07              lda PlayerSize           ;get player's size
00CB2C  1  D0 05                 bne AdjSm                ;if player small, branch to alter variables
00CB2E  1  AD 14 07              lda CrouchingFlag
00CB31  1  F0 09                 beq BigJp                ;if player big and not crouching, jump ahead
00CB33  1  E6 05        AdjSm:   inc $05                  ;if small or big but crouching, execute this part
00CB35  1  E6 05                 inc $05                  ;first increment our counter twice (setting $02 as flag)
00CB37  1  98                    tya
00CB38  1  18                    clc                      ;then add 24 pixels to the player's
00CB39  1  69 18                 adc #$18                 ;vertical coordinate
00CB3B  1  A8                    tay
00CB3C  1  98           BigJp:   tya                      ;get vertical coordinate, altered or otherwise, from Y
00CB3D  1  38           FBCLoop: sec                      ;subtract vertical position of firebar
00CB3E  1  E5 07                 sbc $07                  ;from the vertical coordinate of the player
00CB40  1  10 05                 bpl ChkVFBD              ;if player lower on the screen than firebar,
00CB42  1  49 FF                 eor #$ff                 ;skip two's compliment part
00CB44  1  18                    clc                      ;otherwise get two's compliment
00CB45  1  69 01                 adc #$01
00CB47  1  C9 08        ChkVFBD: cmp #$08                 ;if difference => 8 pixels, skip ahead of this part
00CB49  1  B0 1C                 bcs Chk2Ofs
00CB4B  1  A5 06                 lda $06                  ;if firebar on far right on the screen, skip this,
00CB4D  1  C9 F0                 cmp #$f0                 ;because, really, what's the point?
00CB4F  1  B0 16                 bcs Chk2Ofs
00CB51  1  AD 07 02              lda Sprite_X_Position+4  ;get OAM X coordinate for sprite #1
00CB54  1  18                    clc
00CB55  1  69 04                 adc #$04                 ;add four pixels
00CB57  1  85 04                 sta $04                  ;store here
00CB59  1  38                    sec                      ;subtract horizontal coordinate of firebar
00CB5A  1  E5 06                 sbc $06                  ;from the X coordinate of player's sprite 1
00CB5C  1  10 05                 bpl ChkFBCl              ;if modded X coordinate to the right of firebar
00CB5E  1  49 FF                 eor #$ff                 ;skip two's compliment part
00CB60  1  18                    clc                      ;otherwise get two's compliment
00CB61  1  69 01                 adc #$01
00CB63  1  C9 08        ChkFBCl: cmp #$08                 ;if difference < 8 pixels, collision, thus branch
00CB65  1  90 13                 bcc ChgSDir              ;to process
00CB67  1  A5 05        Chk2Ofs: lda $05                  ;if value of $02 was set earlier for whatever reason,
00CB69  1  C9 02                 cmp #$02                 ;branch to increment OAM offset and leave, no collision
00CB6B  1  F0 23                 beq NoColFB
00CB6D  1  A4 05                 ldy $05                  ;otherwise get temp here and use as offset
00CB6F  1  A5 CE                 lda Player_Y_Position
00CB71  1  18                    clc
00CB72  1  79 45 CA              adc FirebarYPos,y        ;add value loaded with offset to player's vertical coordinate
00CB75  1  E6 05                 inc $05                  ;then increment temp and jump back
00CB77  1  4C 3D CB              jmp FBCLoop
00CB7A  1  A2 01        ChgSDir: ldx #$01                 ;set movement direction by default
00CB7C  1  A5 04                 lda $04                  ;if OAM X coordinate of player's sprite 1
00CB7E  1  C5 06                 cmp $06                  ;is greater than horizontal coordinate of firebar
00CB80  1  B0 01                 bcs SetSDir              ;then do not alter movement direction
00CB82  1  E8                    inx                      ;otherwise increment it
00CB83  1  86 46        SetSDir: stx Enemy_MovingDir      ;store movement direction here
00CB85  1  A2 00                 ldx #$00
00CB87  1  A5 00                 lda $00                  ;save value written to $00 to stack
00CB89  1  48                    pha
00CB8A  1  20 1F D5              jsr InjurePlayer         ;perform sub to hurt or kill player
00CB8D  1  68                    pla
00CB8E  1  85 00                 sta $00                  ;get value of $00 from stack
00CB90  1  68           NoColFB: pla                      ;get OAM data offset
00CB91  1  18                    clc                      ;add four to it and save
00CB92  1  69 04                 adc #$04
00CB94  1  85 06                 sta $06
00CB96  1  A6 08                 ldx ObjectOffset         ;get enemy object buffer offset and leave
00CB98  1  60                    rts
00CB99  1               
00CB99  1               GetFirebarPosition:
00CB99  1  48                      pha                        ;save high byte of spinstate to the stack
00CB9A  1  29 0F                   and #%00001111             ;mask out low nybble
00CB9C  1  C9 09                   cmp #$09
00CB9E  1  90 05                   bcc GetHAdder              ;if lower than $09, branch ahead
00CBA0  1  49 0F                   eor #%00001111             ;otherwise get two's compliment to oscillate
00CBA2  1  18                      clc
00CBA3  1  69 01                   adc #$01
00CBA5  1  85 01        GetHAdder: sta $01                    ;store result, modified or not, here
00CBA7  1  A4 00                   ldy $00                    ;load number of firebar ball where we're at
00CBA9  1  B9 39 CA                lda FirebarTblOffsets,y    ;load offset to firebar position data
00CBAC  1  18                      clc
00CBAD  1  65 01                   adc $01                    ;add oscillated high byte of spinstate
00CBAF  1  A8                      tay                        ;to offset here and use as new offset
00CBB0  1  B9 D2 C9                lda FirebarPosLookupTbl,y  ;get data here and store as horizontal adder
00CBB3  1  85 01                   sta $01
00CBB5  1  68                      pla                        ;pull whatever was in A from the stack
00CBB6  1  48                      pha                        ;save it again because we still need it
00CBB7  1  18                      clc
00CBB8  1  69 08                   adc #$08                   ;add eight this time, to get vertical adder
00CBBA  1  29 0F                   and #%00001111             ;mask out high nybble
00CBBC  1  C9 09                   cmp #$09                   ;if lower than $09, branch ahead
00CBBE  1  90 05                   bcc GetVAdder
00CBC0  1  49 0F                   eor #%00001111             ;otherwise get two's compliment
00CBC2  1  18                      clc
00CBC3  1  69 01                   adc #$01
00CBC5  1  85 02        GetVAdder: sta $02                    ;store result here
00CBC7  1  A4 00                   ldy $00
00CBC9  1  B9 39 CA                lda FirebarTblOffsets,y    ;load offset to firebar position data again
00CBCC  1  18                      clc
00CBCD  1  65 02                   adc $02                    ;this time add value in $02 to offset here and use as offset
00CBCF  1  A8                      tay
00CBD0  1  B9 D2 C9                lda FirebarPosLookupTbl,y  ;get data here and store as vertica adder
00CBD3  1  85 02                   sta $02
00CBD5  1  68                      pla                        ;pull out whatever was in A one last time
00CBD6  1  4A                      lsr                        ;divide by eight or shift three to the right
00CBD7  1  4A                      lsr
00CBD8  1  4A                      lsr
00CBD9  1  A8                      tay                        ;use as offset
00CBDA  1  B9 35 CA                lda FirebarMirrorData,y    ;load mirroring data here
00CBDD  1  85 03                   sta $03                    ;store
00CBDF  1  60                      rts
00CBE0  1               
00CBE0  1               ;--------------------------------
00CBE0  1               
00CBE0  1               PRandomSubtracter:
00CBE0  1  F8 A0 70 BD        .byte $f8, $a0, $70, $bd, $00
00CBE4  1  00           
00CBE5  1               
00CBE5  1               FlyCCBPriority:
00CBE5  1  20 20 20 00        .byte $20, $20, $20, $00, $00
00CBE9  1  00           
00CBEA  1               
00CBEA  1               MoveFlyingCheepCheep:
00CBEA  1  B5 1E                lda Enemy_State,x          ;check cheep-cheep's enemy state
00CBEC  1  29 20                and #%00100000             ;for d5 set
00CBEE  1  F0 08                beq FlyCC                  ;branch to continue code if not set
00CBF0  1  A9 00                lda #$00
00CBF2  1  9D C5 03             sta Enemy_SprAttrib,x      ;otherwise clear sprite attributes
00CBF5  1  4C 49 C0             jmp MoveJ_EnemyVertically  ;and jump to move defeated cheep-cheep downwards
00CBF8  1  20 B9 BF     FlyCC:  jsr MoveEnemyHorizontally  ;move cheep-cheep horizontally based on speed and force
00CBFB  1  A0 0D                ldy #$0d                   ;set vertical movement amount
00CBFD  1  A9 05                lda #$05                   ;set maximum speed
00CBFF  1  20 4D C0             jsr SetXMoveAmt            ;branch to impose gravity on flying cheep-cheep
00CC02  1  BD 34 04             lda Enemy_Y_MoveForce,x
00CC05  1  4A                   lsr                        ;get vertical movement force and
00CC06  1  4A                   lsr                        ;move high nybble to low
00CC07  1  4A                   lsr
00CC08  1  4A                   lsr
00CC09  1  A8                   tay                        ;save as offset (note this tends to go into reach of code)
00CC0A  1  B5 CF                lda Enemy_Y_Position,x     ;get vertical position
00CC0C  1  38                   sec                        ;subtract pseudorandom value based on offset from position
00CC0D  1  F9 E0 CB             sbc PRandomSubtracter,y
00CC10  1  10 05                bpl AddCCF                  ;if result within top half of screen, skip this part
00CC12  1  49 FF                eor #$ff
00CC14  1  18                   clc                        ;otherwise get two's compliment
00CC15  1  69 01                adc #$01
00CC17  1  C9 08        AddCCF: cmp #$08                   ;if result or two's compliment greater than eight,
00CC19  1  B0 0E                bcs BPGet                  ;skip to the end without changing movement force
00CC1B  1  BD 34 04             lda Enemy_Y_MoveForce,x
00CC1E  1  18                   clc
00CC1F  1  69 10                adc #$10                   ;otherwise add to it
00CC21  1  9D 34 04             sta Enemy_Y_MoveForce,x
00CC24  1  4A                   lsr                        ;move high nybble to low again
00CC25  1  4A                   lsr
00CC26  1  4A                   lsr
00CC27  1  4A                   lsr
00CC28  1  A8                   tay
00CC29  1  B9 E5 CB     BPGet:  lda FlyCCBPriority,y       ;load bg priority data and store (this is very likely
00CC2C  1  9D C5 03             sta Enemy_SprAttrib,x      ;broken or residual code, value is overwritten before
00CC2F  1  60                   rts                        ;drawing it next frame), then leave
00CC30  1               
00CC30  1               ;--------------------------------
00CC30  1               ;$00 - used to hold horizontal difference
00CC30  1               ;$01-$03 - used to hold difference adjusters
00CC30  1               
00CC30  1               LakituDiffAdj:
00CC30  1  15 30 40           .byte $15, $30, $40
00CC33  1               
00CC33  1               MoveLakitu:
00CC33  1  B5 1E                 lda Enemy_State,x          ;check lakitu's enemy state
00CC35  1  29 20                 and #%00100000             ;for d5 set
00CC37  1  F0 03                 beq ChkLS                  ;if not set, continue with code
00CC39  1  4C 1A C0              jmp MoveD_EnemyVertically  ;otherwise jump to move defeated lakitu downwards
00CC3C  1  B5 1E        ChkLS:   lda Enemy_State,x          ;if lakitu's enemy state not set at all,
00CC3E  1  F0 0B                 beq Fr12S                  ;go ahead and continue with code
00CC40  1  A9 00                 lda #$00
00CC42  1  95 A0                 sta LakituMoveDirection,x  ;otherwise initialize moving direction to move to left
00CC44  1  8D CB 06              sta EnemyFrenzyBuffer      ;initialize frenzy buffer
00CC47  1  A9 10                 lda #$10
00CC49  1  D0 13                 bne SetLSpd                ;load horizontal speed and do unconditional branch
00CC4B  1  A9 12        Fr12S:   lda #Spiny
00CC4D  1  8D CB 06              sta EnemyFrenzyBuffer      ;set spiny identifier in frenzy buffer
00CC50  1  A0 02                 ldy #$02
00CC52  1  B9 30 CC     LdLDa:   lda LakituDiffAdj,y        ;load values
00CC55  1  99 01 00              sta $0001,y                ;store in zero page
00CC58  1  88                    dey
00CC59  1  10 F7                 bpl LdLDa                  ;do this until all values are stired
00CC5B  1  20 77 CC              jsr PlayerLakituDiff       ;execute sub to set speed and create spinys
00CC5E  1  95 58        SetLSpd: sta LakituMoveSpeed,x      ;set movement speed returned from sub
00CC60  1  A0 01                 ldy #$01                   ;set moving direction to right by default
00CC62  1  B5 A0                 lda LakituMoveDirection,x
00CC64  1  29 01                 and #$01                   ;get LSB of moving direction
00CC66  1  D0 0A                 bne SetLMov                ;if set, branch to the end to use moving direction
00CC68  1  B5 58                 lda LakituMoveSpeed,x
00CC6A  1  49 FF                 eor #$ff                   ;get two's compliment of moving speed
00CC6C  1  18                    clc
00CC6D  1  69 01                 adc #$01
00CC6F  1  95 58                 sta LakituMoveSpeed,x      ;store as new moving speed
00CC71  1  C8                    iny                        ;increment moving direction to left
00CC72  1  94 46        SetLMov: sty Enemy_MovingDir,x      ;store moving direction
00CC74  1  4C B9 BF              jmp MoveEnemyHorizontally  ;move lakitu horizontally
00CC77  1               
00CC77  1               PlayerLakituDiff:
00CC77  1  A0 00                   ldy #$00                   ;set Y for default value
00CC79  1  20 D3 DC                jsr PlayerEnemyDiff        ;get horizontal difference between enemy and player
00CC7C  1  10 0A                   bpl ChkLakDif              ;branch if enemy is to the right of the player
00CC7E  1  C8                      iny                        ;increment Y for left of player
00CC7F  1  A5 00                   lda $00
00CC81  1  49 FF                   eor #$ff                   ;get two's compliment of low byte of horizontal difference
00CC83  1  18                      clc
00CC84  1  69 01                   adc #$01                   ;store two's compliment as horizontal difference
00CC86  1  85 00                   sta $00
00CC88  1  A5 00        ChkLakDif: lda $00                    ;get low byte of horizontal difference
00CC8A  1  C9 3C                   cmp #$3c                   ;if within a certain distance of player, branch
00CC8C  1  90 1C                   bcc ChkPSpeed
00CC8E  1  A9 3C                   lda #$3c                   ;otherwise set maximum distance
00CC90  1  85 00                   sta $00
00CC92  1  B5 16                   lda Enemy_ID,x             ;check if lakitu is in our current enemy slot
00CC94  1  C9 11                   cmp #Lakitu
00CC96  1  D0 12                   bne ChkPSpeed              ;if not, branch elsewhere
00CC98  1  98                      tya                        ;compare contents of Y, now in A
00CC99  1  D5 A0                   cmp LakituMoveDirection,x  ;to what is being used as horizontal movement direction
00CC9B  1  F0 0D                   beq ChkPSpeed              ;if moving toward the player, branch, do not alter
00CC9D  1  B5 A0                   lda LakituMoveDirection,x  ;if moving to the left beyond maximum distance,
00CC9F  1  F0 06                   beq SetLMovD               ;branch and alter without delay
00CCA1  1  D6 58                   dec LakituMoveSpeed,x      ;decrement horizontal speed
00CCA3  1  B5 58                   lda LakituMoveSpeed,x      ;if horizontal speed not yet at zero, branch to leave
00CCA5  1  D0 40                   bne ExMoveLak
00CCA7  1  98           SetLMovD:  tya                        ;set horizontal direction depending on horizontal
00CCA8  1  95 A0                   sta LakituMoveDirection,x  ;difference between enemy and player if necessary
00CCAA  1  A5 00        ChkPSpeed: lda $00
00CCAC  1  29 3C                   and #%00111100             ;mask out all but four bits in the middle
00CCAE  1  4A                      lsr                        ;divide masked difference by four
00CCAF  1  4A                      lsr
00CCB0  1  85 00                   sta $00                    ;store as new value
00CCB2  1  A0 00                   ldy #$00                   ;init offset
00CCB4  1  A5 57                   lda Player_X_Speed
00CCB6  1  F0 24                   beq SubDifAdj              ;if player not moving horizontally, branch
00CCB8  1  AD 75 07                lda ScrollAmount
00CCBB  1  F0 1F                   beq SubDifAdj              ;if scroll speed not set, branch to same place
00CCBD  1  C8                      iny                        ;otherwise increment offset
00CCBE  1  A5 57                   lda Player_X_Speed
00CCC0  1  C9 19                   cmp #$19                   ;if player not running, branch
00CCC2  1  90 08                   bcc ChkSpinyO
00CCC4  1  AD 75 07                lda ScrollAmount
00CCC7  1  C9 02                   cmp #$02                   ;if scroll speed below a certain amount, branch
00CCC9  1  90 01                   bcc ChkSpinyO              ;to same place
00CCCB  1  C8                      iny                        ;otherwise increment once more
00CCCC  1  B5 16        ChkSpinyO: lda Enemy_ID,x             ;check for spiny object
00CCCE  1  C9 12                   cmp #Spiny
00CCD0  1  D0 04                   bne ChkEmySpd              ;branch if not found
00CCD2  1  A5 57                   lda Player_X_Speed         ;if player not moving, skip this part
00CCD4  1  D0 06                   bne SubDifAdj
00CCD6  1  B5 A0        ChkEmySpd: lda Enemy_Y_Speed,x        ;check vertical speed
00CCD8  1  D0 02                   bne SubDifAdj              ;branch if nonzero
00CCDA  1  A0 00                   ldy #$00                   ;otherwise reinit offset
00CCDC  1  B9 01 00     SubDifAdj: lda $0001,y                ;get one of three saved values from earlier
00CCDF  1  A4 00                   ldy $00                    ;get saved horizontal difference
00CCE1  1  38           SPixelLak: sec                        ;subtract one for each pixel of horizontal difference
00CCE2  1  E9 01                   sbc #$01                   ;from one of three saved values
00CCE4  1  88                      dey
00CCE5  1  10 FA                   bpl SPixelLak              ;branch until all pixels are subtracted, to adjust difference
00CCE7  1  60           ExMoveLak: rts                        ;leave!!!
00CCE8  1               
00CCE8  1               ;-------------------------------------------------------------------------------------
00CCE8  1               ;$04-$05 - used to store name table address in little endian order
00CCE8  1               
00CCE8  1               BridgeCollapseData:
00CCE8  1  1A                 .byte $1a ;axe
00CCE9  1  58                 .byte $58 ;chain
00CCEA  1  98 96 94 92        .byte $98, $96, $94, $92, $90, $8e, $8c ;bridge
00CCEE  1  90 8E 8C     
00CCF1  1  8A 88 86 84        .byte $8a, $88, $86, $84, $82, $80
00CCF5  1  82 80        
00CCF7  1               
00CCF7  1               BridgeCollapse:
00CCF7  1  20 00 FE            jsr Enter_EndOfCastle
00CCFA  1  AE 68 03            ldx BowserFront_Offset    ;get enemy offset for bowser
00CCFD  1  B5 16               lda Enemy_ID,x            ;check enemy object identifier for bowser
00CCFF  1  C9 2D               cmp #Bowser               ;if not found, branch ahead,
00CD01  1  D0 10               bne SetM2                 ;metatile removal not necessary
00CD03  1  86 08               stx ObjectOffset          ;store as enemy offset here
00CD05  1  B5 1E               lda Enemy_State,x         ;if bowser in normal state, skip all of this
00CD07  1  F0 1A               beq RemoveBridge
00CD09  1  29 40               and #%01000000            ;if bowser's state has d6 clear, skip to silence music
00CD0B  1  F0 06               beq SetM2
00CD0D  1  B5 CF               lda Enemy_Y_Position,x    ;check bowser's vertical coordinate
00CD0F  1  C9 E0               cmp #$e0                  ;if bowser not yet low enough, skip this part ahead
00CD11  1  90 0A               bcc MoveD_Bowser
00CD13  1  A9 80        SetM2: lda #Silence              ;silence music
00CD15  1  85 FC               sta EventMusicQueue
00CD17  1  EE 72 07            inc OperMode_Task         ;move onto next secondary mode in autoctrl mode
00CD1A  1  4C 7F CD            jmp KillAllEnemies        ;jump to empty all enemy slots and then leave
00CD1D  1               
00CD1D  1               MoveD_Bowser:
00CD1D  1  20 43 C0            jsr MoveEnemySlowVert     ;do a sub to move bowser downwards
00CD20  1  4C 89 CE            jmp BowserGfxHandler      ;jump to draw bowser's front and rear, then leave
00CD23  1               
00CD23  1               RemoveBridge:
00CD23  1  CE 64 03              dec BowserFeetCounter     ;decrement timer to control bowser's feet
00CD26  1  D0 44                 bne NoBFall               ;if not expired, skip all of this
00CD28  1  A9 04                 lda #$04
00CD2A  1  8D 64 03              sta BowserFeetCounter     ;otherwise, set timer now
00CD2D  1  AD 63 03              lda BowserBodyControls
00CD30  1  49 01                 eor #$01                  ;invert bit to control bowser's feet
00CD32  1  8D 63 03              sta BowserBodyControls
00CD35  1  A9 22                 lda #$22                  ;put high byte of name table address here for now
00CD37  1  85 05                 sta $05
00CD39  1  AC 69 03              ldy BridgeCollapseOffset  ;get bridge collapse offset here
00CD3C  1  B9 E8 CC              lda BridgeCollapseData,y  ;load low byte of name table address and store here
00CD3F  1  85 04                 sta $04
00CD41  1  AC 00 03              ldy VRAM_Buffer1_Offset   ;increment vram buffer offset
00CD44  1  C8                    iny
00CD45  1  A2 0C                 ldx #$0c                  ;set offset for tile data for sub to draw blank metatile
00CD47  1  20 9A F0              jsr RemBridge             ;do sub here to remove bowser's bridge metatiles
00CD4A  1  A6 08                 ldx ObjectOffset          ;get enemy offset
00CD4C  1  20 5C F0              jsr MoveVOffset           ;set new vram buffer offset
00CD4F  1  A9 08                 lda #Sfx_Blast            ;load the fireworks/gunfire sound into the square 2 sfx
00CD51  1  85 FE                 sta Square2SoundQueue     ;queue while at the same time loading the brick
00CD53  1  A9 01                 lda #Sfx_BrickShatter     ;shatter sound into the noise sfx queue thus
00CD55  1  85 FD                 sta NoiseSoundQueue       ;producing the unique sound of the bridge collapsing
00CD57  1  EE 69 03              inc BridgeCollapseOffset  ;increment bridge collapse offset
00CD5A  1  AD 69 03              lda BridgeCollapseOffset
00CD5D  1  C9 0F                 cmp #$0f                  ;if bridge collapse offset has not yet reached
00CD5F  1  D0 0B                 bne NoBFall               ;the end, go ahead and skip this part
00CD61  1  20 71 C1              jsr InitVStf              ;initialize whatever vertical speed bowser has
00CD64  1  A9 40                 lda #%01000000
00CD66  1  95 1E                 sta Enemy_State,x         ;set bowser's state to one of defeated states (d6 set)
00CD68  1  A9 80                 lda #Sfx_BowserFall
00CD6A  1  85 FE                 sta Square2SoundQueue     ;play bowser defeat sound
00CD6C  1  4C 89 CE     NoBFall: jmp BowserGfxHandler      ;jump to code that draws bowser
00CD6F  1               
00CD6F  1               ;--------------------------------
00CD6F  1               
00CD6F  1               PRandomRange:
00CD6F  1  21 41 11 31        .byte $21, $41, $11, $31
00CD73  1               
00CD73  1               RunBowser:
00CD73  1  B5 1E              lda Enemy_State,x       ;if d5 in enemy state is not set
00CD75  1  29 20              and #%00100000          ;then branch elsewhere to run bowser
00CD77  1  F0 14              beq BowserControl
00CD79  1  B5 CF              lda Enemy_Y_Position,x  ;otherwise check vertical position
00CD7B  1  C9 E0              cmp #$e0                ;if above a certain point, branch to move defeated bowser
00CD7D  1  90 9E              bcc MoveD_Bowser        ;otherwise proceed to KillAllEnemies
00CD7F  1               
00CD7F  1               KillAllEnemies:
00CD7F  1  A2 04                  ldx #$04              ;start with last enemy slot
00CD81  1  20 A3 C6     KillLoop: jsr EraseEnemyObject  ;branch to kill enemy objects
00CD84  1  CA                     dex                   ;move onto next enemy slot
00CD85  1  10 FA                  bpl KillLoop          ;do this until all slots are emptied
00CD87  1  8D CB 06               sta EnemyFrenzyBuffer ;empty frenzy buffer
00CD8A  1  A6 08                  ldx ObjectOffset      ;get enemy object offset and leave
00CD8C  1  60                     rts
00CD8D  1               
00CD8D  1               BowserControl:
00CD8D  1  A9 00                   lda #$00
00CD8F  1  8D CB 06                sta EnemyFrenzyBuffer      ;empty frenzy buffer
00CD92  1  AD 47 07                lda TimerControl           ;if master timer control not set,
00CD95  1  F0 03                   beq ChkMouth               ;skip jump and execute code here
00CD97  1  4C 47 CE                jmp SkipToFB               ;otherwise, jump over a bunch of code
00CD9A  1  AD 63 03     ChkMouth:  lda BowserBodyControls     ;check bowser's mouth
00CD9D  1  10 03                   bpl FeetTmr                ;if bit clear, go ahead with code here
00CD9F  1  4C 1D CE                jmp HammerChk              ;otherwise skip a whole section starting here
00CDA2  1  CE 64 03     FeetTmr:   dec BowserFeetCounter      ;decrement timer to control bowser's feet
00CDA5  1  D0 0D                   bne ResetMDr               ;if not expired, skip this part
00CDA7  1  A9 20                   lda #$20                   ;otherwise, reset timer
00CDA9  1  8D 64 03                sta BowserFeetCounter
00CDAC  1  AD 63 03                lda BowserBodyControls     ;and invert bit used
00CDAF  1  49 01                   eor #%00000001             ;to control bowser's feet
00CDB1  1  8D 63 03                sta BowserBodyControls
00CDB4  1  A5 09        ResetMDr:  lda FrameCounter           ;check frame counter
00CDB6  1  29 0F                   and #%00001111             ;if not on every sixteenth frame, skip
00CDB8  1  D0 04                   bne B_FaceP                ;ahead to continue code
00CDBA  1  A9 02                   lda #$02                   ;otherwise reset moving/facing direction every
00CDBC  1  95 46                   sta Enemy_MovingDir,x      ;sixteen frames
00CDBE  1  BD 8A 07     B_FaceP:   lda EnemyFrameTimer,x      ;if timer set here expired,
00CDC1  1  F0 1C                   beq GetPRCmp               ;branch to next section
00CDC3  1  20 D3 DC                jsr PlayerEnemyDiff        ;get horizontal difference between player and bowser,
00CDC6  1  10 17                   bpl GetPRCmp               ;and branch if bowser to the right of the player
00CDC8  1  A9 01                   lda #$01
00CDCA  1  95 46                   sta Enemy_MovingDir,x      ;set bowser to move and face to the right
00CDCC  1  A9 02                   lda #$02
00CDCE  1  8D 65 03                sta BowserMovementSpeed    ;set movement speed
00CDD1  1  A9 20                   lda #$20
00CDD3  1  9D 8A 07                sta EnemyFrameTimer,x      ;set timer here
00CDD6  1  8D 90 07                sta BowserFireBreathTimer  ;set timer used for bowser's flame
00CDD9  1  B5 87                   lda Enemy_X_Position,x
00CDDB  1  C9 C8                   cmp #$c8                   ;if bowser to the right past a certain point,
00CDDD  1  B0 3E                   bcs HammerChk              ;skip ahead to some other section
00CDDF  1  A5 09        GetPRCmp:  lda FrameCounter           ;get frame counter
00CDE1  1  29 03                   and #%00000011
00CDE3  1  D0 38                   bne HammerChk              ;execute this code every fourth frame, otherwise branch
00CDE5  1  B5 87                   lda Enemy_X_Position,x
00CDE7  1  CD 66 03                cmp BowserOrigXPos         ;if bowser not at original horizontal position,
00CDEA  1  D0 0C                   bne GetDToO                ;branch to skip this part
00CDEC  1  BD A7 07                lda PseudoRandomBitReg,x
00CDEF  1  29 03                   and #%00000011             ;get pseudorandom offset
00CDF1  1  A8                      tay
00CDF2  1  B9 6F CD                lda PRandomRange,y         ;load value using pseudorandom offset
00CDF5  1  8D DC 06                sta MaxRangeFromOrigin     ;and store here
00CDF8  1  B5 87        GetDToO:   lda Enemy_X_Position,x
00CDFA  1  18                      clc                        ;add movement speed to bowser's horizontal
00CDFB  1  6D 65 03                adc BowserMovementSpeed    ;coordinate and save as new horizontal position
00CDFE  1  95 87                   sta Enemy_X_Position,x
00CE00  1  B4 46                   ldy Enemy_MovingDir,x
00CE02  1  C0 01                   cpy #$01                   ;if bowser moving and facing to the right, skip ahead
00CE04  1  F0 17                   beq HammerChk
00CE06  1  A0 FF                   ldy #$ff                   ;set default movement speed here (move left)
00CE08  1  38                      sec                        ;get difference of current vs. original
00CE09  1  ED 66 03                sbc BowserOrigXPos         ;horizontal position
00CE0C  1  10 07                   bpl CompDToO               ;if current position to the right of original, skip ahead
00CE0E  1  49 FF                   eor #$ff
00CE10  1  18                      clc                        ;get two's compliment
00CE11  1  69 01                   adc #$01
00CE13  1  A0 01                   ldy #$01                   ;set alternate movement speed here (move right)
00CE15  1  CD DC 06     CompDToO:  cmp MaxRangeFromOrigin     ;compare difference with pseudorandom value
00CE18  1  90 03                   bcc HammerChk              ;if difference < pseudorandom value, leave speed alone
00CE1A  1  8C 65 03                sty BowserMovementSpeed    ;otherwise change bowser's movement speed
00CE1D  1  BD 8A 07     HammerChk: lda EnemyFrameTimer,x      ;if timer set here not expired yet, skip ahead to
00CE20  1  D0 28                   bne MakeBJump              ;some other section of code
00CE22  1  20 43 C0                jsr MoveEnemySlowVert      ;otherwise start by moving bowser downwards
00CE25  1  AD 5F 07                lda WorldNumber            ;check world number
00CE28  1  C9 05                   cmp #World6
00CE2A  1  90 09                   bcc SetHmrTmr              ;if world 1-5, skip this part (not time to throw hammers yet)
00CE2C  1  A5 09                   lda FrameCounter
00CE2E  1  29 03                   and #%00000011             ;check to see if it's time to execute sub
00CE30  1  D0 03                   bne SetHmrTmr              ;if not, skip sub, otherwise
00CE32  1  20 51 F1                jsr SpawnHammerObj         ;execute sub on every fourth frame to spawn misc object (hammer)
00CE35  1  B5 CF        SetHmrTmr: lda Enemy_Y_Position,x     ;get current vertical position
00CE37  1  C9 80                   cmp #$80                   ;if still above a certain point
00CE39  1  90 1C                   bcc ChkFireB               ;then skip to world number check for flames
00CE3B  1  BD A7 07                lda PseudoRandomBitReg,x
00CE3E  1  29 03                   and #%00000011             ;get pseudorandom offset
00CE40  1  A8                      tay
00CE41  1  B9 6F CD                lda PRandomRange,y         ;get value using pseudorandom offset
00CE44  1  9D 8A 07                sta EnemyFrameTimer,x      ;set for timer here
00CE47  1  4C 57 CE     SkipToFB:  jmp ChkFireB               ;jump to execute flames code
00CE4A  1  C9 01        MakeBJump: cmp #$01                   ;if timer not yet about to expire,
00CE4C  1  D0 09                   bne ChkFireB               ;skip ahead to next part
00CE4E  1  D6 CF                   dec Enemy_Y_Position,x     ;otherwise decrement vertical coordinate
00CE50  1  20 71 C1                jsr InitVStf               ;initialize movement amount
00CE53  1  A9 FE                   lda #$fe
00CE55  1  95 A0                   sta Enemy_Y_Speed,x        ;set vertical speed to move bowser upwards
00CE57  1  AD 5F 07     ChkFireB:  lda WorldNumber            ;check world number here
00CE5A  1  C9 07                   cmp #World8                ;world 8?
00CE5C  1  F0 04                   beq SpawnFBr               ;if so, execute this part here
00CE5E  1  C9 05                   cmp #World6                ;world 6-7?
00CE60  1  B0 27                   bcs BowserGfxHandler       ;if so, skip this part here
00CE62  1  AD 90 07     SpawnFBr:  lda BowserFireBreathTimer  ;check timer here
00CE65  1  D0 22                   bne BowserGfxHandler       ;if not expired yet, skip all of this
00CE67  1  A9 20                   lda #$20
00CE69  1  8D 90 07                sta BowserFireBreathTimer  ;set timer here
00CE6C  1  AD 63 03                lda BowserBodyControls
00CE6F  1  49 80                   eor #%10000000             ;invert bowser's mouth bit to open
00CE71  1  8D 63 03                sta BowserBodyControls     ;and close bowser's mouth
00CE74  1  30 E1                   bmi ChkFireB               ;if bowser's mouth open, loop back
00CE76  1  20 E7 CE                jsr SetFlameTimer          ;get timing for bowser's flame
00CE79  1  AC CC 06                ldy SecondaryHardMode
00CE7C  1  F0 03                   beq SetFBTmr               ;if secondary hard mode flag not set, skip this
00CE7E  1  38                      sec
00CE7F  1  E9 10                   sbc #$10                   ;otherwise subtract from value in A
00CE81  1  8D 90 07     SetFBTmr:  sta BowserFireBreathTimer  ;set value as timer here
00CE84  1  A9 15                   lda #BowserFlame           ;put bowser's flame identifier
00CE86  1  8D CB 06                sta EnemyFrenzyBuffer      ;in enemy frenzy buffer
00CE89  1               
00CE89  1               ;--------------------------------
00CE89  1               
00CE89  1               BowserGfxHandler:
00CE89  1  20 CA CE               jsr ProcessBowserHalf    ;do a sub here to process bowser's front
00CE8C  1  A0 10                  ldy #$10                 ;load default value here to position bowser's rear
00CE8E  1  B5 46                  lda Enemy_MovingDir,x    ;check moving direction
00CE90  1  4A                     lsr
00CE91  1  90 02                  bcc CopyFToR             ;if moving left, use default
00CE93  1  A0 F0                  ldy #$f0                 ;otherwise load alternate positioning value here
00CE95  1  98           CopyFToR: tya                      ;move bowser's rear object position value to A
00CE96  1  18                     clc
00CE97  1  75 87                  adc Enemy_X_Position,x   ;add to bowser's front object horizontal coordinate
00CE99  1  AC CF 06               ldy DuplicateObj_Offset  ;get bowser's rear object offset
00CE9C  1  99 87 00               sta Enemy_X_Position,y   ;store A as bowser's rear horizontal coordinate
00CE9F  1  B5 CF                  lda Enemy_Y_Position,x
00CEA1  1  18                     clc                      ;add eight pixels to bowser's front object
00CEA2  1  69 08                  adc #$08                 ;vertical coordinate and store as vertical coordinate
00CEA4  1  99 CF 00               sta Enemy_Y_Position,y   ;for bowser's rear
00CEA7  1  B5 1E                  lda Enemy_State,x
00CEA9  1  99 1E 00               sta Enemy_State,y        ;copy enemy state directly from front to rear
00CEAC  1  B5 46                  lda Enemy_MovingDir,x
00CEAE  1  99 46 00               sta Enemy_MovingDir,y    ;copy moving direction also
00CEB1  1  A5 08                  lda ObjectOffset         ;save enemy object offset of front to stack
00CEB3  1  48                     pha
00CEB4  1  AE CF 06               ldx DuplicateObj_Offset  ;put enemy object offset of rear as current
00CEB7  1  86 08                  stx ObjectOffset
00CEB9  1  A9 2D                  lda #Bowser              ;set bowser's enemy identifier
00CEBB  1  95 16                  sta Enemy_ID,x           ;store in bowser's rear object
00CEBD  1  20 CA CE               jsr ProcessBowserHalf    ;do a sub here to process bowser's rear
00CEC0  1  68                     pla
00CEC1  1  85 08                  sta ObjectOffset         ;get original enemy object offset
00CEC3  1  AA                     tax
00CEC4  1  A9 00                  lda #$00                 ;nullify bowser's front/rear graphics flag
00CEC6  1  8D 6A 03               sta BowserGfxFlag
00CEC9  1  60           ExBGfxH:  rts                      ;leave!
00CECA  1               
00CECA  1               ProcessBowserHalf:
00CECA  1  EE 6A 03           inc BowserGfxFlag         ;increment bowser's graphics flag, then run subroutines
00CECD  1  20 D1 C5           jsr RunRetainerObj        ;to get offscreen bits, relative position and draw bowser (finally!)
00CED0  1  B5 1E              lda Enemy_State,x
00CED2  1  D0 F5              bne ExBGfxH               ;if either enemy object not in normal state, branch to leave
00CED4  1  A9 0A              lda #$0a
00CED6  1  9D 9A 04           sta Enemy_BoundBoxCtrl,x  ;set bounding box size control
00CED9  1  20 D3 DD           jsr GetEnemyBoundBox      ;get bounding box coordinates
00CEDC  1  4C 46 D4           jmp PlayerEnemyCollision  ;do player-to-enemy collision detection
00CEDF  1               
00CEDF  1               ;-------------------------------------------------------------------------------------
00CEDF  1               ;$00 - used to hold movement force and tile number
00CEDF  1               ;$01 - used to hold sprite attribute data
00CEDF  1               
00CEDF  1               FlameTimerData:
00CEDF  1  BF 40 BF BF        .byte $bf, $40, $bf, $bf, $bf, $40, $40, $bf
00CEE3  1  BF 40 40 BF  
00CEE7  1               
00CEE7  1               SetFlameTimer:
00CEE7  1  AC 67 03           ldy BowserFlameTimerCtrl  ;load counter as offset
00CEEA  1  EE 67 03           inc BowserFlameTimerCtrl  ;increment
00CEED  1  AD 67 03           lda BowserFlameTimerCtrl  ;mask out all but 3 LSB
00CEF0  1  29 07              and #%00000111            ;to keep in range of 0-7
00CEF2  1  8D 67 03           sta BowserFlameTimerCtrl
00CEF5  1  B9 DF CE           lda FlameTimerData,y      ;load value to be used then leave
00CEF8  1  60           ExFl: rts
00CEF9  1               
00CEF9  1               ProcBowserFlame:
00CEF9  1  AD 47 07              lda TimerControl            ;if master timer control flag set,
00CEFC  1  D0 30                 bne SetGfxF                 ;skip all of this
00CEFE  1  A9 40                 lda #$40                    ;load default movement force
00CF00  1  AC CC 06              ldy SecondaryHardMode
00CF03  1  F0 02                 beq SFlmX                   ;if secondary hard mode flag not set, use default
00CF05  1  A9 60                 lda #$60                    ;otherwise load alternate movement force to go faster
00CF07  1  85 00        SFlmX:   sta $00                     ;store value here
00CF09  1  BD 01 04              lda Enemy_X_MoveForce,x
00CF0C  1  38                    sec                         ;subtract value from movement force
00CF0D  1  E5 00                 sbc $00
00CF0F  1  9D 01 04              sta Enemy_X_MoveForce,x     ;save new value
00CF12  1  B5 87                 lda Enemy_X_Position,x
00CF14  1  E9 01                 sbc #$01                    ;subtract one from horizontal position to move
00CF16  1  95 87                 sta Enemy_X_Position,x      ;to the left
00CF18  1  B5 6E                 lda Enemy_PageLoc,x
00CF1A  1  E9 00                 sbc #$00                    ;subtract borrow from page location
00CF1C  1  95 6E                 sta Enemy_PageLoc,x
00CF1E  1  BC 17 04              ldy BowserFlamePRandomOfs,x ;get some value here and use as offset
00CF21  1  B5 CF                 lda Enemy_Y_Position,x      ;load vertical coordinate
00CF23  1  D9 AB C3              cmp FlameYPosData,y         ;compare against coordinate data using $0417,x as offset
00CF26  1  F0 06                 beq SetGfxF                 ;if equal, branch and do not modify coordinate
00CF28  1  18                    clc
00CF29  1  7D 34 04              adc Enemy_Y_MoveForce,x     ;otherwise add value here to coordinate and store
00CF2C  1  95 CF                 sta Enemy_Y_Position,x      ;as new vertical coordinate
00CF2E  1  20 C2 EC     SetGfxF: jsr RelativeEnemyPosition   ;get new relative coordinates
00CF31  1  B5 1E                 lda Enemy_State,x           ;if bowser's flame not in normal state,
00CF33  1  D0 C3                 bne ExFl                    ;branch to leave
00CF35  1  A9 51                 lda #$51                    ;otherwise, continue
00CF37  1  85 00                 sta $00                     ;write first tile number
00CF39  1  A0 02                 ldy #$02                    ;load attributes without vertical flip by default
00CF3B  1  A5 09                 lda FrameCounter
00CF3D  1  29 02                 and #%00000010              ;invert vertical flip bit every 2 frames
00CF3F  1  F0 02                 beq FlmeAt                  ;if d1 not set, write default value
00CF41  1  A0 82                 ldy #$82                    ;otherwise write value with vertical flip bit set
00CF43  1  84 01        FlmeAt:  sty $01                     ;set bowser's flame sprite attributes here
00CF45  1  BC E5 06              ldy Enemy_SprDataOffset,x   ;get OAM data offset
00CF48  1  A2 00                 ldx #$00
00CF4A  1               
00CF4A  1               DrawFlameLoop:
00CF4A  1  AD B9 03              lda Enemy_Rel_YPos         ;get Y relative coordinate of current enemy object
00CF4D  1  99 00 02              sta Sprite_Y_Position,y    ;write into Y coordinate of OAM data
00CF50  1  A5 00                 lda $00
00CF52  1  99 01 02              sta Sprite_Tilenumber,y    ;write current tile number into OAM data
00CF55  1  E6 00                 inc $00                    ;increment tile number to draw more bowser's flame
00CF57  1  A5 01                 lda $01
00CF59  1  99 02 02              sta Sprite_Attributes,y    ;write saved attributes into OAM data
00CF5C  1  AD AE 03              lda Enemy_Rel_XPos
00CF5F  1  99 03 02              sta Sprite_X_Position,y    ;write X relative coordinate of current enemy object
00CF62  1  18                    clc
00CF63  1  69 08                 adc #$08
00CF65  1  8D AE 03              sta Enemy_Rel_XPos         ;then add eight to it and store
00CF68  1  C8                    iny
00CF69  1  C8                    iny
00CF6A  1  C8                    iny
00CF6B  1  C8                    iny                        ;increment Y four times to move onto the next OAM
00CF6C  1  E8                    inx                        ;move onto the next OAM, and branch if three
00CF6D  1  E0 03                 cpx #$03                   ;have not yet been done
00CF6F  1  90 D9                 bcc DrawFlameLoop
00CF71  1  A6 08                 ldx ObjectOffset           ;reload original enemy offset
00CF73  1  20 1F ED              jsr GetEnemyOffscreenBits  ;get offscreen information
00CF76  1  BC E5 06              ldy Enemy_SprDataOffset,x  ;get OAM data offset
00CF79  1  AD D1 03              lda Enemy_OffscreenBits    ;get enemy object offscreen bits
00CF7C  1  4A                    lsr                        ;move d0 to carry and result to stack
00CF7D  1  48                    pha
00CF7E  1  90 05                 bcc M3FOfs                 ;branch if carry not set
00CF80  1  A9 F8                 lda #$f8                   ;otherwise move sprite offscreen, this part likely
00CF82  1  99 0C 02              sta Sprite_Y_Position+12,y ;residual since flame is only made of three sprites
00CF85  1  68           M3FOfs:  pla                        ;get bits from stack
00CF86  1  4A                    lsr                        ;move d1 to carry and move bits back to stack
00CF87  1  48                    pha
00CF88  1  90 05                 bcc M2FOfs                 ;branch if carry not set again
00CF8A  1  A9 F8                 lda #$f8                   ;otherwise move third sprite offscreen
00CF8C  1  99 08 02              sta Sprite_Y_Position+8,y
00CF8F  1  68           M2FOfs:  pla                        ;get bits from stack again
00CF90  1  4A                    lsr                        ;move d2 to carry and move bits back to stack again
00CF91  1  48                    pha
00CF92  1  90 05                 bcc M1FOfs                 ;branch if carry not set yet again
00CF94  1  A9 F8                 lda #$f8                   ;otherwise move second sprite offscreen
00CF96  1  99 04 02              sta Sprite_Y_Position+4,y
00CF99  1  68           M1FOfs:  pla                        ;get bits from stack one last time
00CF9A  1  4A                    lsr                        ;move d3 to carry
00CF9B  1  90 05                 bcc ExFlmeD                ;branch if carry not set one last time
00CF9D  1  A9 F8                 lda #$f8
00CF9F  1  99 00 02              sta Sprite_Y_Position,y    ;otherwise move first sprite offscreen
00CFA2  1  60           ExFlmeD: rts                        ;leave
00CFA3  1               
00CFA3  1               ;--------------------------------
00CFA3  1               ;$00 - used to store horizontal difference between player and piranha plant
00CFA3  1               
00CFA3  1               MovePiranhaPlant:
00CFA3  1  B5 1E              lda Enemy_State,x           ;check enemy state
00CFA5  1  D0 56              bne PutinPipe               ;if set at all, branch to leave
00CFA7  1  BD 8A 07           lda EnemyFrameTimer,x       ;check enemy's timer here
00CFAA  1  D0 51              bne PutinPipe               ;branch to end if not yet expired
00CFAC  1  B5 A0              lda PiranhaPlant_MoveFlag,x ;check movement flag
00CFAE  1  D0 23              bne SetupToMovePPlant       ;if moving, skip to part ahead
00CFB0  1  B5 58              lda PiranhaPlant_Y_Speed,x  ;if currently rising, branch
00CFB2  1  30 14              bmi ReversePlantSpeed       ;to move enemy upwards out of pipe
00CFB4  1  20 D3 DC           jsr PlayerEnemyDiff         ;get horizontal difference between player and
00CFB7  1  10 09              bpl ChkPlayerNearPipe       ;piranha plant, and branch if enemy to right of player
00CFB9  1  A5 00              lda $00                     ;otherwise get saved horizontal difference
00CFBB  1  49 FF              eor #$ff
00CFBD  1  18                 clc                         ;and change to two's compliment
00CFBE  1  69 01              adc #$01
00CFC0  1  85 00              sta $00                     ;save as new horizontal difference
00CFC2  1               
00CFC2  1               ChkPlayerNearPipe:
00CFC2  1  A5 00              lda $00                     ;get saved horizontal difference
00CFC4  1  C9 21              cmp #$21
00CFC6  1  90 35              bcc PutinPipe               ;if player within a certain distance, branch to leave
00CFC8  1               
00CFC8  1               ReversePlantSpeed:
00CFC8  1  B5 58              lda PiranhaPlant_Y_Speed,x  ;get vertical speed
00CFCA  1  49 FF              eor #$ff
00CFCC  1  18                 clc                         ;change to two's compliment
00CFCD  1  69 01              adc #$01
00CFCF  1  95 58              sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
00CFD1  1  F6 A0              inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
00CFD3  1               
00CFD3  1               SetupToMovePPlant:
00CFD3  1  BD 34 04           lda PiranhaPlantDownYPos,x  ;get original vertical coordinate (lowest point)
00CFD6  1  B4 58              ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
00CFD8  1  10 03              bpl RiseFallPiranhaPlant    ;branch if moving downwards
00CFDA  1  BD 17 04           lda PiranhaPlantUpYPos,x    ;otherwise get other vertical coordinate (highest point)
00CFDD  1               
00CFDD  1               RiseFallPiranhaPlant:
00CFDD  1  85 00              sta $00                     ;save vertical coordinate here
00CFDF  1  A5 09              lda FrameCounter            ;get frame counter
00CFE1  1  4A                 lsr
00CFE2  1  90 19              bcc PutinPipe               ;branch to leave if d0 set (execute code every other frame)
00CFE4  1  AD 47 07           lda TimerControl            ;get master timer control
00CFE7  1  D0 14              bne PutinPipe               ;branch to leave if set (likely not necessary)
00CFE9  1  B5 CF              lda Enemy_Y_Position,x      ;get current vertical coordinate
00CFEB  1  18                 clc
00CFEC  1  75 58              adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
00CFEE  1  95 CF              sta Enemy_Y_Position,x      ;save as new vertical coordinate
00CFF0  1  C5 00              cmp $00                     ;compare against low or high coordinate
00CFF2  1  D0 09              bne PutinPipe               ;branch to leave if not yet reached
00CFF4  1  A9 00              lda #$00
00CFF6  1  95 A0              sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
00CFF8  1  A9 40              lda #$40
00CFFA  1  9D 8A 07           sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
00CFFD  1               
00CFFD  1               PutinPipe:
00CFFD  1  A9 20              lda #%00100000              ;set background priority bit in sprite
00CFFF  1  9D C5 03           sta Enemy_SprAttrib,x       ;attributes to give illusion of being inside pipe
00D002  1  60                 rts                         ;then leave
00D003  1               
00D003  1               ;-------------------------------------------------------------------------------------
00D003  1               ;$07 - spinning speed
00D003  1               
00D003  1               FirebarSpin:
00D003  1  85 07              sta $07                     ;save spinning speed here
00D005  1  B5 34              lda FirebarSpinDirection,x  ;check spinning direction
00D007  1  D0 0E              bne SpinCounterClockwise    ;if moving counter-clockwise, branch to other part
00D009  1  A0 18              ldy #$18                    ;possibly residual ldy
00D00B  1  B5 58              lda FirebarSpinState_Low,x
00D00D  1  18                 clc                         ;add spinning speed to what would normally be
00D00E  1  65 07              adc $07                     ;the horizontal speed
00D010  1  95 58              sta FirebarSpinState_Low,x
00D012  1  B5 A0              lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
00D014  1  69 00              adc #$00
00D016  1  60                 rts
00D017  1               
00D017  1               SpinCounterClockwise:
00D017  1  A0 08              ldy #$08                    ;possibly residual ldy
00D019  1  B5 58              lda FirebarSpinState_Low,x
00D01B  1  38                 sec                         ;subtract spinning speed to what would normally be
00D01C  1  E5 07              sbc $07                     ;the horizontal speed
00D01E  1  95 58              sta FirebarSpinState_Low,x
00D020  1  B5 A0              lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
00D022  1  E9 00              sbc #$00
00D024  1  60                 rts
00D025  1               
00D025  1               ;-------------------------------------------------------------------------------------
00D025  1               ;$00 - used to hold collision flag, Y movement force + 5 or low byte of name table for rope
00D025  1               ;$01 - used to hold high byte of name table for rope
00D025  1               ;$02 - used to hold page location of rope
00D025  1               
00D025  1               BalancePlatform:
00D025  1  B5 B6               lda Enemy_Y_HighPos,x       ;check high byte of vertical position
00D027  1  C9 03               cmp #$03
00D029  1  D0 03               bne DoBPl
00D02B  1  4C A3 C6            jmp EraseEnemyObject        ;if far below screen, kill the object
00D02E  1  B5 1E        DoBPl: lda Enemy_State,x           ;get object's state (set to $ff or other platform offset)
00D030  1  10 01               bpl CheckBalPlatform        ;if doing other balance platform, branch to leave
00D032  1  60                  rts
00D033  1               
00D033  1               CheckBalPlatform:
00D033  1  A8                  tay                         ;save offset from state as Y
00D034  1  BD A2 03            lda PlatformCollisionFlag,x ;get collision flag of platform
00D037  1  85 00               sta $00                     ;store here
00D039  1  B5 46               lda Enemy_MovingDir,x       ;get moving direction
00D03B  1  F0 03               beq ChkForFall
00D03D  1  4C AE D1            jmp PlatformFall            ;if set, jump here
00D040  1               
00D040  1               ChkForFall:
00D040  1  A9 2D               lda #$2d                    ;check if platform is above a certain point
00D042  1  D5 CF               cmp Enemy_Y_Position,x
00D044  1  90 0F               bcc ChkOtherForFall         ;if not, branch elsewhere
00D046  1  C4 00               cpy $00                     ;if collision flag is set to same value as
00D048  1  F0 08               beq MakePlatformFall        ;enemy state, branch to make platforms fall
00D04A  1  18                  clc
00D04B  1  69 02               adc #$02                    ;otherwise add 2 pixels to vertical position
00D04D  1  95 CF               sta Enemy_Y_Position,x      ;of current platform and branch elsewhere
00D04F  1  4C A4 D1            jmp StopPlatforms           ;to make platforms stop
00D052  1               
00D052  1               MakePlatformFall:
00D052  1  4C 8B D1            jmp InitPlatformFall        ;make platforms fall
00D055  1               
00D055  1               ChkOtherForFall:
00D055  1  D9 CF 00            cmp Enemy_Y_Position,y      ;check if other platform is above a certain point
00D058  1  90 0D               bcc ChkToMoveBalPlat        ;if not, branch elsewhere
00D05A  1  E4 00               cpx $00                     ;if collision flag is set to same value as
00D05C  1  F0 F4               beq MakePlatformFall        ;enemy state, branch to make platforms fall
00D05E  1  18                  clc
00D05F  1  69 02               adc #$02                    ;otherwise add 2 pixels to vertical position
00D061  1  99 CF 00            sta Enemy_Y_Position,y      ;of other platform and branch elsewhere
00D064  1  4C A4 D1            jmp StopPlatforms           ;jump to stop movement and do not return
00D067  1               
00D067  1               ChkToMoveBalPlat:
00D067  1  B5 CF                lda Enemy_Y_Position,x      ;save vertical position to stack
00D069  1  48                   pha
00D06A  1  BD A2 03             lda PlatformCollisionFlag,x ;get collision flag
00D06D  1  10 18                bpl ColFlg                  ;branch if collision
00D06F  1  BD 34 04             lda Enemy_Y_MoveForce,x
00D072  1  18                   clc                         ;add $05 to contents of moveforce, whatever they be
00D073  1  69 05                adc #$05
00D075  1  85 00                sta $00                     ;store here
00D077  1  B5 A0                lda Enemy_Y_Speed,x
00D079  1  69 00                adc #$00                    ;add carry to vertical speed
00D07B  1  30 1A                bmi PlatDn                  ;branch if moving downwards
00D07D  1  D0 0C                bne PlatUp                  ;branch elsewhere if moving upwards
00D07F  1  A5 00                lda $00
00D081  1  C9 0B                cmp #$0b                    ;check if there's still a little force left
00D083  1  90 0C                bcc PlatSt                  ;if not enough, branch to stop movement
00D085  1  B0 04                bcs PlatUp                  ;otherwise keep branch to move upwards
00D087  1  C5 08        ColFlg: cmp ObjectOffset            ;if collision flag matches
00D089  1  F0 0C                beq PlatDn                  ;current enemy object offset, branch
00D08B  1  20 6E C0     PlatUp: jsr MovePlatformUp          ;do a sub to move upwards
00D08E  1  4C 9A D0             jmp DoOtherPlatform         ;jump ahead to remaining code
00D091  1  20 A4 D1     PlatSt: jsr StopPlatforms           ;do a sub to stop movement
00D094  1  4C 9A D0             jmp DoOtherPlatform         ;jump ahead to remaining code
00D097  1  20 6B C0     PlatDn: jsr MovePlatformDown        ;do a sub to move downwards
00D09A  1               
00D09A  1               DoOtherPlatform:
00D09A  1  B4 1E               ldy Enemy_State,x           ;get offset of other platform
00D09C  1  68                  pla                         ;get old vertical coordinate from stack
00D09D  1  38                  sec
00D09E  1  F5 CF               sbc Enemy_Y_Position,x      ;get difference of old vs. new coordinate
00D0A0  1  18                  clc
00D0A1  1  79 CF 00            adc Enemy_Y_Position,y      ;add difference to vertical coordinate of other
00D0A4  1  99 CF 00            sta Enemy_Y_Position,y      ;platform to move it in the opposite direction
00D0A7  1  BD A2 03            lda PlatformCollisionFlag,x ;if no collision, skip this part here
00D0AA  1  30 04               bmi DrawEraseRope
00D0AC  1  AA                  tax                         ;put offset which collision occurred here
00D0AD  1  20 14 D8            jsr PositionPlayerOnVPlat   ;and use it to position player accordingly
00D0B0  1               
00D0B0  1               DrawEraseRope:
00D0B0  1  A4 08                 ldy ObjectOffset            ;get enemy object offset
00D0B2  1  B9 A0 00              lda Enemy_Y_Speed,y         ;check to see if current platform is
00D0B5  1  19 34 04              ora Enemy_Y_MoveForce,y     ;moving at all
00D0B8  1  F0 77                 beq ExitRp                  ;if not, skip all of this and branch to leave
00D0BA  1  AE 00 03              ldx VRAM_Buffer1_Offset     ;get vram buffer offset
00D0BD  1  E0 20                 cpx #$20                    ;if offset beyond a certain point, go ahead
00D0BF  1  B0 70                 bcs ExitRp                  ;and skip this, branch to leave
00D0C1  1  B9 A0 00              lda Enemy_Y_Speed,y
00D0C4  1  48                    pha                         ;save two copies of vertical speed to stack
00D0C5  1  48                    pha
00D0C6  1  20 34 D1              jsr SetupPlatformRope       ;do a sub to figure out where to put new bg tiles
00D0C9  1  A5 01                 lda $01                     ;write name table address to vram buffer
00D0CB  1  9D 01 03              sta VRAM_Buffer1,x          ;first the high byte, then the low
00D0CE  1  A5 00                 lda $00
00D0D0  1  9D 02 03              sta VRAM_Buffer1+1,x
00D0D3  1  A9 02                 lda #$02                    ;set length for 2 bytes
00D0D5  1  9D 03 03              sta VRAM_Buffer1+2,x
00D0D8  1  B9 A0 00              lda Enemy_Y_Speed,y         ;if platform moving upwards, branch
00D0DB  1  30 0D                 bmi EraseR1                 ;to do something else
00D0DD  1  A9 A2                 lda #$a2
00D0DF  1  9D 04 03              sta VRAM_Buffer1+3,x        ;otherwise put tile numbers for left
00D0E2  1  A9 A3                 lda #$a3                    ;and right sides of rope in vram buffer
00D0E4  1  9D 05 03              sta VRAM_Buffer1+4,x
00D0E7  1  4C F2 D0              jmp OtherRope               ;jump to skip this part
00D0EA  1  A9 24        EraseR1: lda #$24                    ;put blank tiles in vram buffer
00D0EC  1  9D 04 03              sta VRAM_Buffer1+3,x        ;to erase rope
00D0EF  1  9D 05 03              sta VRAM_Buffer1+4,x
00D0F2  1               
00D0F2  1               OtherRope:
00D0F2  1  B9 1E 00              lda Enemy_State,y           ;get offset of other platform from state
00D0F5  1  A8                    tay                         ;use as Y here
00D0F6  1  68                    pla                         ;pull second copy of vertical speed from stack
00D0F7  1  49 FF                 eor #$ff                    ;invert bits to reverse speed
00D0F9  1  20 34 D1              jsr SetupPlatformRope       ;do sub again to figure out where to put bg tiles
00D0FC  1  A5 01                 lda $01                     ;write name table address to vram buffer
00D0FE  1  9D 06 03              sta VRAM_Buffer1+5,x        ;this time we're doing putting tiles for
00D101  1  A5 00                 lda $00                     ;the other platform
00D103  1  9D 07 03              sta VRAM_Buffer1+6,x
00D106  1  A9 02                 lda #$02
00D108  1  9D 08 03              sta VRAM_Buffer1+7,x        ;set length again for 2 bytes
00D10B  1  68                    pla                         ;pull first copy of vertical speed from stack
00D10C  1  10 0D                 bpl EraseR2                 ;if moving upwards (note inversion earlier), skip this
00D10E  1  A9 A2                 lda #$a2
00D110  1  9D 09 03              sta VRAM_Buffer1+8,x        ;otherwise put tile numbers for left
00D113  1  A9 A3                 lda #$a3                    ;and right sides of rope in vram
00D115  1  9D 0A 03              sta VRAM_Buffer1+9,x        ;transfer buffer
00D118  1  4C 23 D1              jmp EndRp                   ;jump to skip this part
00D11B  1  A9 24        EraseR2: lda #$24                    ;put blank tiles in vram buffer
00D11D  1  9D 09 03              sta VRAM_Buffer1+8,x        ;to erase rope
00D120  1  9D 0A 03              sta VRAM_Buffer1+9,x
00D123  1  A9 00        EndRp:   lda #$00                    ;put null terminator at the end
00D125  1  9D 0B 03              sta VRAM_Buffer1+10,x
00D128  1  AD 00 03              lda VRAM_Buffer1_Offset     ;add ten bytes to the vram buffer offset
00D12B  1  18                    clc                         ;and store
00D12C  1  69 0A                 adc #10
00D12E  1  8D 00 03              sta VRAM_Buffer1_Offset
00D131  1  A6 08        ExitRp:  ldx ObjectOffset            ;get enemy object buffer offset and leave
00D133  1  60                    rts
00D134  1               
00D134  1               SetupPlatformRope:
00D134  1  48                   pha                     ;save second/third copy to stack
00D135  1  B9 87 00             lda Enemy_X_Position,y  ;get horizontal coordinate
00D138  1  18                   clc
00D139  1  69 08                adc #$08                ;add eight pixels
00D13B  1  AE CC 06             ldx SecondaryHardMode   ;if secondary hard mode flag set,
00D13E  1  D0 03                bne GetLRp              ;use coordinate as-is
00D140  1  18                   clc
00D141  1  69 10                adc #$10                ;otherwise add sixteen more pixels
00D143  1  48           GetLRp: pha                     ;save modified horizontal coordinate to stack
00D144  1  B9 6E 00             lda Enemy_PageLoc,y
00D147  1  69 00                adc #$00                ;add carry to page location
00D149  1  85 02                sta $02                 ;and save here
00D14B  1  68                   pla                     ;pull modified horizontal coordinate
00D14C  1  29 F0                and #%11110000          ;from the stack, mask out low nybble
00D14E  1  4A                   lsr                     ;and shift three bits to the right
00D14F  1  4A                   lsr
00D150  1  4A                   lsr
00D151  1  85 00                sta $00                 ;store result here as part of name table low byte
00D153  1  B6 CF                ldx Enemy_Y_Position,y  ;get vertical coordinate
00D155  1  68                   pla                     ;get second/third copy of vertical speed from stack
00D156  1  10 05                bpl GetHRp              ;skip this part if moving downwards or not at all
00D158  1  8A                   txa
00D159  1  18                   clc
00D15A  1  69 08                adc #$08                ;add eight to vertical coordinate and
00D15C  1  AA                   tax                     ;save as X
00D15D  1  8A           GetHRp: txa                     ;move vertical coordinate to A
00D15E  1  AE 00 03             ldx VRAM_Buffer1_Offset ;get vram buffer offset
00D161  1  0A                   asl
00D162  1  2A                   rol                     ;rotate d7 to d0 and d6 into carry
00D163  1  48                   pha                     ;save modified vertical coordinate to stack
00D164  1  2A                   rol                     ;rotate carry to d0, thus d7 and d6 are at 2 LSB
00D165  1  29 03                and #%00000011          ;mask out all bits but d7 and d6, then set
00D167  1  09 20                ora #%00100000          ;d5 to get appropriate high byte of name table
00D169  1  85 01                sta $01                 ;address, then store
00D16B  1  A5 02                lda $02                 ;get saved page location from earlier
00D16D  1  29 01                and #$01                ;mask out all but LSB
00D16F  1  0A                   asl
00D170  1  0A                   asl                     ;shift twice to the left and save with the
00D171  1  05 01                ora $01                 ;rest of the bits of the high byte, to get
00D173  1  85 01                sta $01                 ;the proper name table and the right place on it
00D175  1  68                   pla                     ;get modified vertical coordinate from stack
00D176  1  29 E0                and #%11100000          ;mask out low nybble and LSB of high nybble
00D178  1  18                   clc
00D179  1  65 00                adc $00                 ;add to horizontal part saved here
00D17B  1  85 00                sta $00                 ;save as name table low byte
00D17D  1  B9 CF 00             lda Enemy_Y_Position,y
00D180  1  C9 E8                cmp #$e8                ;if vertical position not below the
00D182  1  90 06                bcc ExPRp               ;bottom of the screen, we're done, branch to leave
00D184  1  A5 00                lda $00
00D186  1  29 BF                and #%10111111          ;mask out d6 of low byte of name table address
00D188  1  85 00                sta $00
00D18A  1  60           ExPRp:  rts                     ;leave!
00D18B  1               
00D18B  1               InitPlatformFall:
00D18B  1  98                 tya                        ;move offset of other platform from Y to X
00D18C  1  AA                 tax
00D18D  1  20 1F ED           jsr GetEnemyOffscreenBits  ;get offscreen bits
00D190  1  A9 06              lda #$06
00D192  1  20 12 D6           jsr SetupFloateyNumber     ;award 1000 points to player
00D195  1  AD AD 03           lda Player_Rel_XPos
00D198  1  9D 17 01           sta FloateyNum_X_Pos,x     ;put floatey number coordinates where player is
00D19B  1  A5 CE              lda Player_Y_Position
00D19D  1  9D 1E 01           sta FloateyNum_Y_Pos,x
00D1A0  1  A9 01              lda #$01                   ;set moving direction as flag for
00D1A2  1  95 46              sta Enemy_MovingDir,x      ;falling platforms
00D1A4  1               
00D1A4  1               StopPlatforms:
00D1A4  1  20 71 C1           jsr InitVStf             ;initialize vertical speed and low byte
00D1A7  1  99 A0 00           sta Enemy_Y_Speed,y      ;for both platforms and leave
00D1AA  1  99 34 04           sta Enemy_Y_MoveForce,y
00D1AD  1  60                 rts
00D1AE  1               
00D1AE  1               PlatformFall:
00D1AE  1  98                 tya                         ;save offset for other platform to stack
00D1AF  1  48                 pha
00D1B0  1  20 22 C0           jsr MoveFallingPlatform     ;make current platform fall
00D1B3  1  68                 pla
00D1B4  1  AA                 tax                         ;pull offset from stack and save to X
00D1B5  1  20 22 C0           jsr MoveFallingPlatform     ;make other platform fall
00D1B8  1  A6 08              ldx ObjectOffset
00D1BA  1  BD A2 03           lda PlatformCollisionFlag,x ;if player not standing on either platform,
00D1BD  1  30 04              bmi ExPF                    ;skip this part
00D1BF  1  AA                 tax                         ;transfer collision flag offset as offset to X
00D1C0  1  20 14 D8           jsr PositionPlayerOnVPlat   ;and position player appropriately
00D1C3  1  A6 08        ExPF: ldx ObjectOffset            ;get enemy object buffer offset and leave
00D1C5  1  60                 rts
00D1C6  1               
00D1C6  1               ;--------------------------------
00D1C6  1               
00D1C6  1               YMovingPlatform:
00D1C6  1  B5 A0                lda Enemy_Y_Speed,x          ;if platform moving up or down, skip ahead to
00D1C8  1  1D 34 04             ora Enemy_Y_MoveForce,x      ;check on other position
00D1CB  1  D0 15                bne ChkYCenterPos
00D1CD  1  9D 17 04             sta Enemy_YMF_Dummy,x        ;initialize dummy variable
00D1D0  1  B5 CF                lda Enemy_Y_Position,x
00D1D2  1  DD 01 04             cmp YPlatformTopYPos,x       ;if current vertical position => top position, branch
00D1D5  1  B0 0B                bcs ChkYCenterPos            ;ahead of all this
00D1D7  1  A5 09                lda FrameCounter
00D1D9  1  29 07                and #%00000111               ;check for every eighth frame
00D1DB  1  D0 02                bne SkipIY
00D1DD  1  F6 CF                inc Enemy_Y_Position,x       ;increase vertical position every eighth frame
00D1DF  1  4C F1 D1     SkipIY: jmp ChkYPCollision           ;skip ahead to last part
00D1E2  1               
00D1E2  1               ChkYCenterPos:
00D1E2  1  B5 CF                lda Enemy_Y_Position,x       ;if current vertical position < central position, branch
00D1E4  1  D5 58                cmp YPlatformCenterYPos,x    ;to slow ascent/move downwards
00D1E6  1  90 06                bcc YMDown
00D1E8  1  20 6E C0             jsr MovePlatformUp           ;otherwise start slowing descent/moving upwards
00D1EB  1  4C F1 D1             jmp ChkYPCollision
00D1EE  1  20 6B C0     YMDown: jsr MovePlatformDown         ;start slowing ascent/moving downwards
00D1F1  1               
00D1F1  1               ChkYPCollision:
00D1F1  1  BD A2 03            lda PlatformCollisionFlag,x  ;if collision flag not set here, branch
00D1F4  1  30 03               bmi ExYPl                    ;to leave
00D1F6  1  20 14 D8            jsr PositionPlayerOnVPlat    ;otherwise position player appropriately
00D1F9  1  60           ExYPl: rts                          ;leave
00D1FA  1               
00D1FA  1               ;--------------------------------
00D1FA  1               ;$00 - used as adder to position player hotizontally
00D1FA  1               
00D1FA  1               XMovingPlatform:
00D1FA  1  A9 0E              lda #$0e                     ;load preset maximum value for secondary counter
00D1FC  1  20 52 C8           jsr XMoveCntr_Platform       ;do a sub to increment counters for movement
00D1FF  1  20 71 C8           jsr MoveWithXMCntrs          ;do a sub to move platform accordingly, and return value
00D202  1  BD A2 03           lda PlatformCollisionFlag,x  ;if no collision with player,
00D205  1  30 1C              bmi ExXMP                    ;branch ahead to leave
00D207  1               
00D207  1               PositionPlayerOnHPlat:
00D207  1  A5 86                 lda Player_X_Position
00D209  1  18                    clc                       ;add saved value from second subroutine to
00D20A  1  65 00                 adc $00                   ;current player's position to position
00D20C  1  85 86                 sta Player_X_Position     ;player accordingly in horizontal position
00D20E  1  A5 6D                 lda Player_PageLoc        ;get player's page location
00D210  1  A4 00                 ldy $00                   ;check to see if saved value here is positive or negative
00D212  1  30 05                 bmi PPHSubt               ;if negative, branch to subtract
00D214  1  69 00                 adc #$00                  ;otherwise add carry to page location
00D216  1  4C 1B D2              jmp SetPVar               ;jump to skip subtraction
00D219  1  E9 00        PPHSubt: sbc #$00                  ;subtract borrow from page location
00D21B  1  85 6D        SetPVar: sta Player_PageLoc        ;save result to player's page location
00D21D  1  8C A1 03              sty Platform_X_Scroll     ;put saved value from second sub here to be used later
00D220  1  20 14 D8              jsr PositionPlayerOnVPlat ;position player vertically and appropriately
00D223  1  60           ExXMP:   rts                       ;and we are done here
00D224  1               
00D224  1               ;--------------------------------
00D224  1               
00D224  1               DropPlatform:
00D224  1  BD A2 03            lda PlatformCollisionFlag,x  ;if no collision between platform and player
00D227  1  30 06               bmi ExDPl                    ;occurred, just leave without moving anything
00D229  1  20 3F C0            jsr MoveDropPlatform         ;otherwise do a sub to move platform down very quickly
00D22C  1  20 14 D8            jsr PositionPlayerOnVPlat    ;do a sub to position player appropriately
00D22F  1  60           ExDPl: rts                          ;leave
00D230  1               
00D230  1               ;--------------------------------
00D230  1               ;$00 - residual value from sub
00D230  1               
00D230  1               RightPlatform:
00D230  1  20 B9 BF            jsr MoveEnemyHorizontally     ;move platform with current horizontal speed, if any
00D233  1  85 00               sta $00                       ;store saved value here (residual code)
00D235  1  BD A2 03            lda PlatformCollisionFlag,x   ;check collision flag, if no collision between player
00D238  1  30 07               bmi ExRPl                     ;and platform, branch ahead, leave speed unaltered
00D23A  1  A9 10               lda #$10
00D23C  1  95 58               sta Enemy_X_Speed,x           ;otherwise set new speed (gets moving if motionless)
00D23E  1  20 07 D2            jsr PositionPlayerOnHPlat     ;use saved value from earlier sub to position player
00D241  1  60           ExRPl: rts                           ;then leave
00D242  1               
00D242  1               ;--------------------------------
00D242  1               
00D242  1               MoveLargeLiftPlat:
00D242  1  20 4E D2           jsr MoveLiftPlatforms  ;execute common to all large and small lift platforms
00D245  1  4C F1 D1           jmp ChkYPCollision     ;branch to position player correctly
00D248  1               
00D248  1               MoveSmallPlatform:
00D248  1  20 4E D2           jsr MoveLiftPlatforms      ;execute common to all large and small lift platforms
00D24B  1  4C 64 D2           jmp ChkSmallPlatCollision  ;branch to position player correctly
00D24E  1               
00D24E  1               MoveLiftPlatforms:
00D24E  1  AD 47 07           lda TimerControl         ;if master timer control set, skip all of this
00D251  1  D0 19              bne ExLiftP              ;and branch to leave
00D253  1  BD 17 04           lda Enemy_YMF_Dummy,x
00D256  1  18                 clc                      ;add contents of movement amount to whatever's here
00D257  1  7D 34 04           adc Enemy_Y_MoveForce,x
00D25A  1  9D 17 04           sta Enemy_YMF_Dummy,x
00D25D  1  B5 CF              lda Enemy_Y_Position,x   ;add whatever vertical speed is set to current
00D25F  1  75 A0              adc Enemy_Y_Speed,x      ;vertical position plus carry to move up or down
00D261  1  95 CF              sta Enemy_Y_Position,x   ;and then leave
00D263  1  60                 rts
00D264  1               
00D264  1               ChkSmallPlatCollision:
00D264  1  BD A2 03              lda PlatformCollisionFlag,x ;get bounding box counter saved in collision flag
00D267  1  F0 03                 beq ExLiftP                 ;if none found, leave player position alone
00D269  1  20 0C D8              jsr PositionPlayerOnS_Plat  ;use to position player correctly
00D26C  1  60           ExLiftP: rts                         ;then leave
00D26D  1               
00D26D  1               ;-------------------------------------------------------------------------------------
00D26D  1               ;$00 - page location of extended left boundary
00D26D  1               ;$01 - extended left boundary position
00D26D  1               ;$02 - page location of extended right boundary
00D26D  1               ;$03 - extended right boundary position
00D26D  1               
00D26D  1               OffscreenBoundsCheck:
00D26D  1  B5 16                  lda Enemy_ID,x          ;check for cheep-cheep object
00D26F  1  C9 14                  cmp #FlyingCheepCheep   ;branch to leave if found
00D271  1  F0 55                  beq ExScrnBd
00D273  1  AD 1C 07               lda ScreenLeft_X_Pos    ;get horizontal coordinate for left side of screen
00D276  1  B4 16                  ldy Enemy_ID,x
00D278  1  C0 05                  cpy #HammerBro          ;check for hammer bro object
00D27A  1  F0 04                  beq LimitB
00D27C  1  C0 0D                  cpy #PiranhaPlant       ;check for piranha plant object
00D27E  1  D0 02                  bne ExtendLB            ;these two will be erased sooner than others if too far left
00D280  1  69 38        LimitB:   adc #$38                ;add 56 pixels to coordinate if hammer bro or piranha plant
00D282  1  E9 48        ExtendLB: sbc #$48                ;subtract 72 pixels regardless of enemy object
00D284  1  85 01                  sta $01                 ;store result here
00D286  1  AD 1A 07               lda ScreenLeft_PageLoc
00D289  1  E9 00                  sbc #$00                ;subtract borrow from page location of left side
00D28B  1  85 00                  sta $00                 ;store result here
00D28D  1  AD 1D 07               lda ScreenRight_X_Pos   ;add 72 pixels to the right side horizontal coordinate
00D290  1  69 48                  adc #$48
00D292  1  85 03                  sta $03                 ;store result here
00D294  1  AD 1B 07               lda ScreenRight_PageLoc
00D297  1  69 00                  adc #$00                ;then add the carry to the page location
00D299  1  85 02                  sta $02                 ;and store result here
00D29B  1  B5 87                  lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
00D29D  1  C5 01                  cmp $01                 ;to modified horizontal left edge coordinate to get carry
00D29F  1  B5 6E                  lda Enemy_PageLoc,x
00D2A1  1  E5 00                  sbc $00                 ;then subtract it from the page coordinate of the enemy object
00D2A3  1  30 20                  bmi TooFar              ;if enemy object is too far left, branch to erase it
00D2A5  1  B5 87                  lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
00D2A7  1  C5 03                  cmp $03                 ;to modified horizontal right edge coordinate to get carry
00D2A9  1  B5 6E                  lda Enemy_PageLoc,x
00D2AB  1  E5 02                  sbc $02                 ;then subtract it from the page coordinate of the enemy object
00D2AD  1  30 19                  bmi ExScrnBd            ;if enemy object is on the screen, leave, do not erase enemy
00D2AF  1  B5 1E                  lda Enemy_State,x       ;if at this point, enemy is offscreen to the right, so check
00D2B1  1  C9 05                  cmp #HammerBro          ;if in state used by spiny's egg, do not erase
00D2B3  1  F0 13                  beq ExScrnBd
00D2B5  1  C0 0D                  cpy #PiranhaPlant       ;if piranha plant, do not erase
00D2B7  1  F0 0F                  beq ExScrnBd
00D2B9  1  C0 30                  cpy #FlagpoleFlagObject ;if flagpole flag, do not erase
00D2BB  1  F0 0B                  beq ExScrnBd
00D2BD  1  C0 31                  cpy #StarFlagObject     ;if star flag, do not erase
00D2BF  1  F0 07                  beq ExScrnBd
00D2C1  1  C0 32                  cpy #JumpspringObject   ;if jumpspring, do not erase
00D2C3  1  F0 03                  beq ExScrnBd            ;erase all others too far to the right
00D2C5  1  20 A3 C6     TooFar:   jsr EraseEnemyObject    ;erase object if necessary
00D2C8  1  60           ExScrnBd: rts                     ;leave
00D2C9  1               
00D2C9  1               ;-------------------------------------------------------------------------------------
00D2C9  1               
00D2C9  1               ;some unused space
00D2C9  1  FF FF FF           .byte $ff, $ff, $ff
00D2CC  1               
00D2CC  1               ;-------------------------------------------------------------------------------------
00D2CC  1               ;$01 - enemy buffer offset
00D2CC  1               
00D2CC  1               FireballEnemyCollision:
00D2CC  1  B5 24              lda Fireball_State,x  ;check to see if fireball state is set at all
00D2CE  1  F0 56              beq ExitFBallEnemy    ;branch to leave if not
00D2D0  1  0A                 asl
00D2D1  1  B0 53              bcs ExitFBallEnemy    ;branch to leave also if d7 in state is set
00D2D3  1  A5 09              lda FrameCounter
00D2D5  1  4A                 lsr                   ;get LSB of frame counter
00D2D6  1  B0 4E              bcs ExitFBallEnemy    ;branch to leave if set (do routine every other frame)
00D2D8  1  8A                 txa
00D2D9  1  0A                 asl                   ;multiply fireball offset by four
00D2DA  1  0A                 asl
00D2DB  1  18                 clc
00D2DC  1  69 1C              adc #$1c              ;then add $1c or 28 bytes to it
00D2DE  1  A8                 tay                   ;to use fireball's bounding box coordinates
00D2DF  1  A2 04              ldx #$04
00D2E1  1               
00D2E1  1               FireballEnemyCDLoop:
00D2E1  1  86 01                   stx $01                     ;store enemy object offset here
00D2E3  1  98                      tya
00D2E4  1  48                      pha                         ;push fireball offset to the stack
00D2E5  1  B5 1E                   lda Enemy_State,x
00D2E7  1  29 20                   and #%00100000              ;check to see if d5 is set in enemy state
00D2E9  1  D0 34                   bne NoFToECol               ;if so, skip to next enemy slot
00D2EB  1  B5 0F                   lda Enemy_Flag,x            ;check to see if buffer flag is set
00D2ED  1  F0 30                   beq NoFToECol               ;if not, skip to next enemy slot
00D2EF  1  B5 16                   lda Enemy_ID,x              ;check enemy identifier
00D2F1  1  C9 24                   cmp #$24
00D2F3  1  90 04                   bcc GoombaDie               ;if < $24, branch to check further
00D2F5  1  C9 2B                   cmp #$2b
00D2F7  1  90 26                   bcc NoFToECol               ;if in range $24-$2a, skip to next enemy slot
00D2F9  1  C9 06        GoombaDie: cmp #Goomba                 ;check for goomba identifier
00D2FB  1  D0 06                   bne NotGoomba               ;if not found, continue with code
00D2FD  1  B5 1E                   lda Enemy_State,x           ;otherwise check for defeated state
00D2FF  1  C9 02                   cmp #$02                    ;if stomped or otherwise defeated,
00D301  1  B0 1C                   bcs NoFToECol               ;skip to next enemy slot
00D303  1  BD D8 03     NotGoomba: lda EnemyOffscrBitsMasked,x ;if any masked offscreen bits set,
00D306  1  D0 17                   bne NoFToECol               ;skip to next enemy slot
00D308  1  8A                      txa
00D309  1  0A                      asl                         ;otherwise multiply enemy offset by four
00D30A  1  0A                      asl
00D30B  1  18                      clc
00D30C  1  69 04                   adc #$04                    ;add 4 bytes to it
00D30E  1  AA                      tax                         ;to use enemy's bounding box coordinates
00D30F  1  20 B7 DE                jsr SprObjectCollisionCore  ;do fireball-to-enemy collision detection
00D312  1  A6 08                   ldx ObjectOffset            ;return fireball's original offset
00D314  1  90 09                   bcc NoFToECol               ;if carry clear, no collision, thus do next enemy slot
00D316  1  A9 80                   lda #%10000000
00D318  1  95 24                   sta Fireball_State,x        ;set d7 in enemy state
00D31A  1  A6 01                   ldx $01                     ;get enemy offset
00D31C  1  20 31 D3                jsr HandleEnemyFBallCol     ;jump to handle fireball to enemy collision
00D31F  1  68           NoFToECol: pla                         ;pull fireball offset from stack
00D320  1  A8                      tay                         ;put it in Y
00D321  1  A6 01                   ldx $01                     ;get enemy object offset
00D323  1  CA                      dex                         ;decrement it
00D324  1  10 BB                   bpl FireballEnemyCDLoop     ;loop back until collision detection done on all enemies
00D326  1               
00D326  1               ExitFBallEnemy:
00D326  1  A6 08              ldx ObjectOffset                 ;get original fireball offset and leave
00D328  1  60                 rts
00D329  1               
00D329  1               BowserIdentities:
00D329  1  06 00 02 12        .byte Goomba, GreenKoopa, BuzzyBeetle, Spiny, Lakitu, Bloober, HammerBro, Bowser
00D32D  1  11 07 05 2D  
00D331  1               
00D331  1               HandleEnemyFBallCol:
00D331  1  20 C2 EC           jsr RelativeEnemyPosition  ;get relative coordinate of enemy
00D334  1  A6 01              ldx $01                    ;get current enemy object offset
00D336  1  B5 0F              lda Enemy_Flag,x           ;check buffer flag for d7 set
00D338  1  10 0B              bpl ChkBuzzyBeetle         ;branch if not set to continue
00D33A  1  29 0F              and #%00001111             ;otherwise mask out high nybble and
00D33C  1  AA                 tax                        ;use low nybble as enemy offset
00D33D  1  B5 16              lda Enemy_ID,x
00D33F  1  C9 2D              cmp #Bowser                ;check enemy identifier for bowser
00D341  1  F0 0C              beq HurtBowser             ;branch if found
00D343  1  A6 01              ldx $01                    ;otherwise retrieve current enemy offset
00D345  1               
00D345  1               ChkBuzzyBeetle:
00D345  1  B5 16              lda Enemy_ID,x
00D347  1  C9 02              cmp #BuzzyBeetle           ;check for buzzy beetle
00D349  1  F0 6B              beq ExHCF                  ;branch if found to leave (buzzy beetles fireproof)
00D34B  1  C9 2D              cmp #Bowser                ;check for bowser one more time (necessary if d7 of flag was clear)
00D34D  1  D0 2D              bne ChkOtherEnemies        ;if not found, branch to check other enemies
00D34F  1               
00D34F  1               HurtBowser:
00D34F  1  CE 83 04               dec BowserHitPoints        ;decrement bowser's hit points
00D352  1  D0 62                  bne ExHCF                  ;if bowser still has hit points, branch to leave
00D354  1  20 71 C1               jsr InitVStf               ;otherwise do sub to init vertical speed and movement force
00D357  1  95 58                  sta Enemy_X_Speed,x        ;initialize horizontal speed
00D359  1  8D CB 06               sta EnemyFrenzyBuffer      ;init enemy frenzy buffer
00D35C  1  A9 FE                  lda #$fe
00D35E  1  95 A0                  sta Enemy_Y_Speed,x        ;set vertical speed to make defeated bowser jump a little
00D360  1  AC 5F 07               ldy WorldNumber            ;use world number as offset
00D363  1  B9 29 D3               lda BowserIdentities,y     ;get enemy identifier to replace bowser with
00D366  1  95 16                  sta Enemy_ID,x             ;set as new enemy identifier
00D368  1  A9 20                  lda #$20                   ;set A to use starting value for state
00D36A  1  C0 03                  cpy #$03                   ;check to see if using offset of 3 or more
00D36C  1  B0 02                  bcs SetDBSte               ;branch if so
00D36E  1  09 03                  ora #$03                   ;otherwise add 3 to enemy state
00D370  1  95 1E        SetDBSte: sta Enemy_State,x          ;set defeated enemy state
00D372  1  A9 80                  lda #Sfx_BowserFall
00D374  1  85 FE                  sta Square2SoundQueue      ;load bowser defeat sound
00D376  1  A6 01                  ldx $01                    ;get enemy offset
00D378  1  A9 09                  lda #$09                   ;award 5000 points to player for defeating bowser
00D37A  1  D0 33                  bne EnemySmackScore        ;unconditional branch to award points
00D37C  1               
00D37C  1               ChkOtherEnemies:
00D37C  1  C9 08              cmp #BulletBill_FrenzyVar
00D37E  1  F0 36              beq ExHCF                 ;branch to leave if bullet bill (frenzy variant)
00D380  1  C9 0C              cmp #Podoboo
00D382  1  F0 32              beq ExHCF                 ;branch to leave if podoboo
00D384  1  C9 15              cmp #$15
00D386  1  B0 2E              bcs ExHCF                 ;branch to leave if identifier => $15
00D388  1               
00D388  1               ShellOrBlockDefeat:
00D388  1  B5 16              lda Enemy_ID,x            ;check for piranha plant
00D38A  1  C9 0D              cmp #PiranhaPlant
00D38C  1  D0 06              bne StnE                  ;branch if not found
00D38E  1  B5 CF              lda Enemy_Y_Position,x
00D390  1  69 18              adc #$18                  ;add 24 pixels to enemy object's vertical position
00D392  1  95 CF              sta Enemy_Y_Position,x
00D394  1  20 AB DB     StnE: jsr ChkToStunEnemies      ;do yet another sub
00D397  1  B5 1E              lda Enemy_State,x
00D399  1  29 1F              and #%00011111            ;mask out 2 MSB of enemy object's state
00D39B  1  09 20              ora #%00100000            ;set d5 to defeat enemy and save as new state
00D39D  1  95 1E              sta Enemy_State,x
00D39F  1  A9 02              lda #$02                  ;award 200 points by default
00D3A1  1  B4 16              ldy Enemy_ID,x            ;check for hammer bro
00D3A3  1  C0 05              cpy #HammerBro
00D3A5  1  D0 02              bne GoombaPoints          ;branch if not found
00D3A7  1  A9 06              lda #$06                  ;award 1000 points for hammer bro
00D3A9  1               
00D3A9  1               GoombaPoints:
00D3A9  1  C0 06              cpy #Goomba               ;check for goomba
00D3AB  1  D0 02              bne EnemySmackScore       ;branch if not found
00D3AD  1  A9 01              lda #$01                  ;award 100 points for goomba
00D3AF  1               
00D3AF  1               EnemySmackScore:
00D3AF  1  20 12 D6            jsr SetupFloateyNumber   ;update necessary score variables
00D3B2  1  A9 08               lda #Sfx_EnemySmack      ;play smack enemy sound
00D3B4  1  85 FF               sta Square1SoundQueue
00D3B6  1  60           ExHCF: rts                      ;and now let's leave
00D3B7  1               
00D3B7  1               ;-------------------------------------------------------------------------------------
00D3B7  1               
00D3B7  1               PlayerHammerCollision:
00D3B7  1  A5 09                lda FrameCounter          ;get frame counter
00D3B9  1  4A                   lsr                       ;shift d0 into carry
00D3BA  1  90 36                bcc ExPHC                 ;branch to leave if d0 not set to execute every other frame
00D3BC  1  AD 47 07             lda TimerControl          ;if either master timer control
00D3BF  1  0D D6 03             ora Misc_OffscreenBits    ;or any offscreen bits for hammer are set,
00D3C2  1  D0 2E                bne ExPHC                 ;branch to leave
00D3C4  1  8A                   txa
00D3C5  1  0A                   asl                       ;multiply misc object offset by four
00D3C6  1  0A                   asl
00D3C7  1  18                   clc
00D3C8  1  69 24                adc #$24                  ;add 36 or $24 bytes to get proper offset
00D3CA  1  A8                   tay                       ;for misc object bounding box coordinates
00D3CB  1  20 B5 DE             jsr PlayerCollisionCore   ;do player-to-hammer collision detection
00D3CE  1  A6 08                ldx ObjectOffset          ;get misc object offset
00D3D0  1  90 1B                bcc ClHCol                ;if no collision, then branch
00D3D2  1  BD BE 06             lda Misc_Collision_Flag,x ;otherwise read collision flag
00D3D5  1  D0 1B                bne ExPHC                 ;if collision flag already set, branch to leave
00D3D7  1  A9 01                lda #$01
00D3D9  1  9D BE 06             sta Misc_Collision_Flag,x ;otherwise set collision flag now
00D3DC  1  B5 64                lda Misc_X_Speed,x
00D3DE  1  49 FF                eor #$ff                  ;get two's compliment of
00D3E0  1  18                   clc                       ;hammer's horizontal speed
00D3E1  1  69 01                adc #$01
00D3E3  1  95 64                sta Misc_X_Speed,x        ;set to send hammer flying the opposite direction
00D3E5  1  AD 9F 07             lda StarInvincibleTimer   ;if star mario invincibility timer set,
00D3E8  1  D0 08                bne ExPHC                 ;branch to leave
00D3EA  1  4C 1F D5             jmp InjurePlayer          ;otherwise jump to hurt player, do not return
00D3ED  1  A9 00        ClHCol: lda #$00                  ;clear collision flag
00D3EF  1  9D BE 06             sta Misc_Collision_Flag,x
00D3F2  1  60           ExPHC:  rts
00D3F3  1               
00D3F3  1               ;-------------------------------------------------------------------------------------
00D3F3  1               
00D3F3  1               HandlePowerUpCollision:
00D3F3  1  20 A3 C6           jsr EraseEnemyObject    ;erase the power-up object
00D3F6  1  A9 06              lda #$06
00D3F8  1  20 12 D6           jsr SetupFloateyNumber  ;award 1000 points to player by default
00D3FB  1  A9 20              lda #Sfx_PowerUpGrab
00D3FD  1  85 FE              sta Square2SoundQueue   ;play the power-up sound
00D3FF  1  A5 39              lda PowerUpType         ;check power-up type
00D401  1  C9 02              cmp #$02
00D403  1  90 0E              bcc Shroom_Flower_PUp   ;if mushroom or fire flower, branch
00D405  1  C9 03              cmp #$03
00D407  1  F0 24              beq SetFor1Up           ;if 1-up mushroom, branch
00D409  1  A9 23              lda #$23                ;otherwise set star mario invincibility
00D40B  1  8D 9F 07           sta StarInvincibleTimer ;timer, and load the star mario music
00D40E  1  A9 40              lda #StarPowerMusic     ;into the area music queue, then leave
00D410  1  85 FB              sta AreaMusicQueue
00D412  1  60                 rts
00D413  1               
00D413  1               Shroom_Flower_PUp:
00D413  1  AD 56 07           lda PlayerStatus    ;if player status = small, branch
00D416  1  F0 1B              beq UpToSuper
00D418  1  C9 01              cmp #$01            ;if player status not super, leave
00D41A  1  D0 23              bne NoPUp
00D41C  1  A6 08              ldx ObjectOffset    ;get enemy offset, not necessary
00D41E  1  A9 02              lda #$02            ;set player status to fiery
00D420  1  8D 56 07           sta PlayerStatus
00D423  1  20 CE EE           jsr GetPlayerColors ;run sub to change colors of player
00D426  1  A6 08              ldx ObjectOffset    ;get enemy offset again, and again not necessary
00D428  1  A9 0C              lda #$0c            ;set value to be used by subroutine tree (fiery)
00D42A  1  4C 3A D4           jmp UpToFiery       ;jump to set values accordingly
00D42D  1               
00D42D  1               SetFor1Up:
00D42D  1  A9 0B              lda #$0b                 ;change 1000 points into 1-up instead
00D42F  1  9D 10 01           sta FloateyNum_Control,x ;and then leave
00D432  1  60                 rts
00D433  1               
00D433  1               UpToSuper:
00D433  1  A9 01               lda #$01         ;set player status to super
00D435  1  8D 56 07            sta PlayerStatus
00D438  1  A9 09               lda #$09         ;set value to be used by subroutine tree (super)
00D43A  1               
00D43A  1               UpToFiery:
00D43A  1  A0 00               ldy #$00         ;set value to be used as new player state
00D43C  1  20 3B D5            jsr SetPRout     ;set values to stop certain things in motion
00D43F  1  60           NoPUp: rts
00D440  1               
00D440  1               ;--------------------------------
00D440  1               
00D440  1               ResidualXSpdData:
00D440  1  18 E8              .byte $18, $e8
00D442  1               
00D442  1               KickedShellXSpdData:
00D442  1  30 D0              .byte $30, $d0
00D444  1               
00D444  1               DemotedKoopaXSpdData:
00D444  1  08 F8              .byte $08, $f8
00D446  1               
00D446  1               PlayerEnemyCollision:
00D446  1  A5 09                 lda FrameCounter            ;check counter for d0 set
00D448  1  4A                    lsr
00D449  1  B0 F4                 bcs NoPUp                   ;if set, branch to leave
00D44B  1  20 34 D8              jsr CheckPlayerVertical     ;if player object is completely offscreen or
00D44E  1  B0 23                 bcs NoPECol                 ;if down past 224th pixel row, branch to leave
00D450  1  BD D8 03              lda EnemyOffscrBitsMasked,x ;if current enemy is offscreen by any amount,
00D453  1  D0 1E                 bne NoPECol                 ;go ahead and branch to leave
00D455  1  A5 0E                 lda GameEngineSubroutine
00D457  1  C9 08                 cmp #$08                    ;if not set to run player control routine
00D459  1  D0 18                 bne NoPECol                 ;on next frame, branch to leave
00D45B  1  B5 1E                 lda Enemy_State,x
00D45D  1  29 20                 and #%00100000              ;if enemy state has d5 set, branch to leave
00D45F  1  D0 12                 bne NoPECol
00D461  1  20 45 D8              jsr GetEnemyBoundBoxOfs     ;get bounding box offset for current enemy object
00D464  1  20 B5 DE              jsr PlayerCollisionCore     ;do collision detection on player vs. enemy
00D467  1  A6 08                 ldx ObjectOffset            ;get enemy object buffer offset
00D469  1  B0 09                 bcs CheckForPUpCollision    ;if collision, branch past this part here
00D46B  1  BD 91 04              lda Enemy_CollisionBits,x
00D46E  1  29 FE                 and #%11111110              ;otherwise, clear d0 of current enemy object's
00D470  1  9D 91 04              sta Enemy_CollisionBits,x   ;collision bit
00D473  1  60           NoPECol: rts
00D474  1               
00D474  1               CheckForPUpCollision:
00D474  1  B4 16               ldy Enemy_ID,x
00D476  1  C0 2E               cpy #PowerUpObject            ;check for power-up object
00D478  1  D0 03               bne EColl                     ;if not found, branch to next part
00D47A  1  4C F3 D3            jmp HandlePowerUpCollision    ;otherwise, unconditional jump backwards
00D47D  1  AD 9F 07     EColl: lda StarInvincibleTimer       ;if star mario invincibility timer expired,
00D480  1  F0 06               beq HandlePECollisions        ;perform task here, otherwise kill enemy like
00D482  1  4C 88 D3            jmp ShellOrBlockDefeat        ;hit with a shell, or from beneath
00D485  1               
00D485  1               KickedShellPtsData:
00D485  1  0A 06 04           .byte $0a, $06, $04
00D488  1               
00D488  1               HandlePECollisions:
00D488  1  BD 91 04            lda Enemy_CollisionBits,x    ;check enemy collision bits for d0 set
00D48B  1  29 01               and #%00000001               ;or for being offscreen at all
00D48D  1  1D D8 03            ora EnemyOffscrBitsMasked,x
00D490  1  D0 59               bne ExPEC                    ;branch to leave if either is true
00D492  1  A9 01               lda #$01
00D494  1  1D 91 04            ora Enemy_CollisionBits,x    ;otherwise set d0 now
00D497  1  9D 91 04            sta Enemy_CollisionBits,x
00D49A  1  C0 12               cpy #Spiny                   ;branch if spiny
00D49C  1  F0 4E               beq ChkForPlayerInjury
00D49E  1  C0 0D               cpy #PiranhaPlant            ;branch if piranha plant
00D4A0  1  F0 7D               beq InjurePlayer
00D4A2  1  C0 0C               cpy #Podoboo                 ;branch if podoboo
00D4A4  1  F0 79               beq InjurePlayer
00D4A6  1  C0 33               cpy #BulletBill_CannonVar    ;branch if bullet bill
00D4A8  1  F0 42               beq ChkForPlayerInjury
00D4AA  1  C0 15               cpy #$15                     ;branch if object => $15
00D4AC  1  B0 71               bcs InjurePlayer
00D4AE  1  AD 4E 07            lda AreaType                 ;branch if water type level
00D4B1  1  F0 6C               beq InjurePlayer
00D4B3  1  B5 1E               lda Enemy_State,x            ;branch if d7 of enemy state was set
00D4B5  1  0A                  asl
00D4B6  1  B0 34               bcs ChkForPlayerInjury
00D4B8  1  B5 1E               lda Enemy_State,x            ;mask out all but 3 LSB of enemy state
00D4BA  1  29 07               and #%00000111
00D4BC  1  C9 02               cmp #$02                     ;branch if enemy is in normal or falling state
00D4BE  1  90 2C               bcc ChkForPlayerInjury
00D4C0  1  B5 16               lda Enemy_ID,x               ;branch to leave if goomba in defeated state
00D4C2  1  C9 06               cmp #Goomba
00D4C4  1  F0 25               beq ExPEC
00D4C6  1  A9 08               lda #Sfx_EnemySmack          ;play smack enemy sound
00D4C8  1  85 FF               sta Square1SoundQueue
00D4CA  1  B5 1E               lda Enemy_State,x            ;set d7 in enemy state, thus become moving shell
00D4CC  1  09 80               ora #%10000000
00D4CE  1  95 1E               sta Enemy_State,x
00D4D0  1  20 F8 D5            jsr EnemyFacePlayer          ;set moving direction and get offset
00D4D3  1  B9 42 D4            lda KickedShellXSpdData,y    ;load and set horizontal speed data with offset
00D4D6  1  95 58               sta Enemy_X_Speed,x
00D4D8  1  A9 03               lda #$03                     ;add three to whatever the stomp counter contains
00D4DA  1  18                  clc                          ;to give points for kicking the shell
00D4DB  1  6D 84 04            adc StompChainCounter
00D4DE  1  BC 96 07            ldy EnemyIntervalTimer,x     ;check shell enemy's timer
00D4E1  1  C0 03               cpy #$03                     ;if above a certain point, branch using the points
00D4E3  1  B0 03               bcs KSPts                    ;data obtained from the stomp counter + 3
00D4E5  1  B9 85 D4            lda KickedShellPtsData,y     ;otherwise, set points based on proximity to timer expiration
00D4E8  1  20 12 D6     KSPts: jsr SetupFloateyNumber       ;set values for floatey number now
00D4EB  1  60           ExPEC: rts                          ;leave!!!
00D4EC  1               
00D4EC  1               ChkForPlayerInjury:
00D4EC  1  A5 9F                  lda Player_Y_Speed     ;check player's vertical speed
00D4EE  1  30 02                  bmi ChkInj             ;perform procedure below if player moving upwards
00D4F0  1  D0 6A                  bne EnemyStomped       ;or not at all, and branch elsewhere if moving downwards
00D4F2  1  B5 16        ChkInj:   lda Enemy_ID,x         ;branch if enemy object < $07
00D4F4  1  C9 07                  cmp #Bloober
00D4F6  1  90 09                  bcc ChkETmrs
00D4F8  1  A5 CE                  lda Player_Y_Position  ;add 12 pixels to player's vertical position
00D4FA  1  18                     clc
00D4FB  1  69 0C                  adc #$0c
00D4FD  1  D5 CF                  cmp Enemy_Y_Position,x ;compare modified player's position to enemy's position
00D4FF  1  90 5B                  bcc EnemyStomped       ;branch if this player's position above (less than) enemy's
00D501  1  AD 91 07     ChkETmrs: lda StompTimer         ;check stomp timer
00D504  1  D0 56                  bne EnemyStomped       ;branch if set
00D506  1  AD 9E 07               lda InjuryTimer        ;check to see if injured invincibility timer still
00D509  1  D0 3D                  bne ExInjColRoutines   ;counting down, and branch elsewhere to leave if so
00D50B  1  AD AD 03               lda Player_Rel_XPos
00D50E  1  CD AE 03               cmp Enemy_Rel_XPos     ;if player's relative position to the left of enemy's
00D511  1  90 03                  bcc TInjE              ;relative position, branch here
00D513  1  4C E9 D5               jmp ChkEnemyFaceRight  ;otherwise do a jump here
00D516  1  B5 46        TInjE:    lda Enemy_MovingDir,x  ;if enemy moving towards the left,
00D518  1  C9 01                  cmp #$01               ;branch, otherwise do a jump here
00D51A  1  D0 03                  bne InjurePlayer       ;to turn the enemy around
00D51C  1  4C F2 D5               jmp LInj
00D51F  1               
00D51F  1               InjurePlayer:
00D51F  1  AD 9E 07           lda InjuryTimer          ;check again to see if injured invincibility timer is
00D522  1  D0 24              bne ExInjColRoutines     ;at zero, and branch to leave if so
00D524  1               
00D524  1               ForceInjury:
00D524  1  AE 56 07               ldx PlayerStatus          ;check player's status
00D527  1  F0 22                  beq KillPlayer            ;branch if small
00D529  1  8D 56 07               sta PlayerStatus          ;otherwise set player's status to small
00D52C  1  A9 08                  lda #$08
00D52E  1  8D 9E 07               sta InjuryTimer           ;set injured invincibility timer
00D531  1  0A                     asl
00D532  1  85 FF                  sta Square1SoundQueue     ;play pipedown/injury sound
00D534  1  20 CE EE               jsr GetPlayerColors       ;change player's palette if necessary
00D537  1  A9 0A                  lda #$0a                  ;set subroutine to run on next frame
00D539  1  A0 01        SetKRout: ldy #$01                  ;set new player state
00D53B  1  85 0E        SetPRout: sta GameEngineSubroutine  ;load new value to run subroutine on next frame
00D53D  1  84 1D                  sty Player_State          ;store new player state
00D53F  1  A0 FF                  ldy #$ff
00D541  1  8C 47 07               sty TimerControl          ;set master timer control flag to halt timers
00D544  1  C8                     iny
00D545  1  8C 75 07               sty ScrollAmount          ;initialize scroll speed
00D548  1               
00D548  1               ExInjColRoutines:
00D548  1  A6 08              ldx ObjectOffset              ;get enemy offset and leave
00D54A  1  60                 rts
00D54B  1               
00D54B  1               KillPlayer:
00D54B  1  86 57              stx Player_X_Speed   ;halt player's horizontal movement by initializing speed
00D54D  1  E8                 inx
00D54E  1  86 FC              stx EventMusicQueue  ;set event music queue to death music
00D550  1  A9 FC              lda #$fc
00D552  1  85 9F              sta Player_Y_Speed   ;set new vertical speed
00D554  1  A9 0B              lda #$0b             ;set subroutine to run on next frame
00D556  1  D0 E1              bne SetKRout         ;branch to set player's state and other things
00D558  1               
00D558  1               StompedEnemyPtsData:
00D558  1  02 06 05 06        .byte $02, $06, $05, $06
00D55C  1               
00D55C  1               EnemyStomped:
00D55C  1  B5 16              lda Enemy_ID,x             ;check for spiny, branch to hurt player
00D55E  1  C9 12              cmp #Spiny                 ;if found
00D560  1  F0 BD              beq InjurePlayer
00D562  1  A9 04              lda #Sfx_EnemyStomp        ;otherwise play stomp/swim sound
00D564  1  85 FF              sta Square1SoundQueue
00D566  1  B5 16              lda Enemy_ID,x
00D568  1  A0 00              ldy #$00                   ;initialize points data offset for stomped enemies
00D56A  1  C9 14              cmp #FlyingCheepCheep      ;branch for cheep-cheep
00D56C  1  F0 1B              beq EnemyStompedPts
00D56E  1  C9 08              cmp #BulletBill_FrenzyVar  ;branch for either bullet bill object
00D570  1  F0 17              beq EnemyStompedPts
00D572  1  C9 33              cmp #BulletBill_CannonVar
00D574  1  F0 13              beq EnemyStompedPts
00D576  1  C9 0C              cmp #Podoboo               ;branch for podoboo (this branch is logically impossible
00D578  1  F0 0F              beq EnemyStompedPts        ;for cpu to take due to earlier checking of podoboo)
00D57A  1  C8                 iny                        ;increment points data offset
00D57B  1  C9 05              cmp #HammerBro             ;branch for hammer bro
00D57D  1  F0 0A              beq EnemyStompedPts
00D57F  1  C8                 iny                        ;increment points data offset
00D580  1  C9 11              cmp #Lakitu                ;branch for lakitu
00D582  1  F0 05              beq EnemyStompedPts
00D584  1  C8                 iny                        ;increment points data offset
00D585  1  C9 07              cmp #Bloober               ;branch if NOT bloober
00D587  1  D0 1D              bne ChkForDemoteKoopa
00D589  1               
00D589  1               EnemyStompedPts:
00D589  1  B9 58 D5           lda StompedEnemyPtsData,y  ;load points data using offset in Y
00D58C  1  20 12 D6           jsr SetupFloateyNumber     ;run sub to set floatey number controls
00D58F  1  B5 46              lda Enemy_MovingDir,x
00D591  1  48                 pha                        ;save enemy movement direction to stack
00D592  1  20 BF DB           jsr SetStun                ;run sub to kill enemy
00D595  1  68                 pla
00D596  1  95 46              sta Enemy_MovingDir,x      ;return enemy movement direction from stack
00D598  1  A9 20              lda #%00100000
00D59A  1  95 1E              sta Enemy_State,x          ;set d5 in enemy state
00D59C  1  20 71 C1           jsr InitVStf               ;nullify vertical speed, physics-related thing,
00D59F  1  95 58              sta Enemy_X_Speed,x        ;and horizontal speed
00D5A1  1  A9 FD              lda #$fd                   ;set player's vertical speed, to give bounce
00D5A3  1  85 9F              sta Player_Y_Speed
00D5A5  1  60                 rts
00D5A6  1               
00D5A6  1               ChkForDemoteKoopa:
00D5A6  1  C9 09              cmp #$09                   ;branch elsewhere if enemy object < $09
00D5A8  1  90 1D              bcc HandleStompedShellE
00D5AA  1  29 01              and #%00000001             ;demote koopa paratroopas to ordinary troopas
00D5AC  1  95 16              sta Enemy_ID,x
00D5AE  1  A0 00              ldy #$00                   ;return enemy to normal state
00D5B0  1  94 1E              sty Enemy_State,x
00D5B2  1  A9 03              lda #$03                   ;award 400 points to the player
00D5B4  1  20 12 D6           jsr SetupFloateyNumber
00D5B7  1  20 71 C1           jsr InitVStf               ;nullify physics-related thing and vertical speed
00D5BA  1  20 F8 D5           jsr EnemyFacePlayer        ;turn enemy around if necessary
00D5BD  1  B9 44 D4           lda DemotedKoopaXSpdData,y
00D5C0  1  95 58              sta Enemy_X_Speed,x        ;set appropriate moving speed based on direction
00D5C2  1  4C E4 D5           jmp SBnce                  ;then move onto something else
00D5C5  1               
00D5C5  1               RevivalRateData:
00D5C5  1  10 0B              .byte $10, $0b
00D5C7  1               
00D5C7  1               HandleStompedShellE:
00D5C7  1  A9 04               lda #$04                   ;set defeated state for enemy
00D5C9  1  95 1E               sta Enemy_State,x
00D5CB  1  EE 84 04            inc StompChainCounter      ;increment the stomp counter
00D5CE  1  AD 84 04            lda StompChainCounter      ;add whatever is in the stomp counter
00D5D1  1  18                  clc                        ;to whatever is in the stomp timer
00D5D2  1  6D 91 07            adc StompTimer
00D5D5  1  20 12 D6            jsr SetupFloateyNumber     ;award points accordingly
00D5D8  1  EE 91 07            inc StompTimer             ;increment stomp timer of some sort
00D5DB  1  AC 6A 07            ldy PrimaryHardMode        ;check primary hard mode flag
00D5DE  1  B9 C5 D5            lda RevivalRateData,y      ;load timer setting according to flag
00D5E1  1  9D 96 07            sta EnemyIntervalTimer,x   ;set as enemy timer to revive stomped enemy
00D5E4  1  A9 FC        SBnce: lda #$fc                   ;set player's vertical speed for bounce
00D5E6  1  85 9F               sta Player_Y_Speed         ;and then leave!!!
00D5E8  1  60                  rts
00D5E9  1               
00D5E9  1               ChkEnemyFaceRight:
00D5E9  1  B5 46               lda Enemy_MovingDir,x ;check to see if enemy is moving to the right
00D5EB  1  C9 01               cmp #$01
00D5ED  1  D0 03               bne LInj              ;if not, branch
00D5EF  1  4C 1F D5            jmp InjurePlayer      ;otherwise go back to hurt player
00D5F2  1  20 0F D7     LInj:  jsr EnemyTurnAround   ;turn the enemy around, if necessary
00D5F5  1  4C 1F D5            jmp InjurePlayer      ;go back to hurt player
00D5F8  1               
00D5F8  1               
00D5F8  1               EnemyFacePlayer:
00D5F8  1  A0 01               ldy #$01               ;set to move right by default
00D5FA  1  20 D3 DC            jsr PlayerEnemyDiff    ;get horizontal difference between player and enemy
00D5FD  1  10 01               bpl SFcRt              ;if enemy is to the right of player, do not increment
00D5FF  1  C8                  iny                    ;otherwise, increment to set to move to the left
00D600  1  94 46        SFcRt: sty Enemy_MovingDir,x  ;set moving direction here
00D602  1  88                  dey                    ;then decrement to use as a proper offset
00D603  1  60                  rts
00D604  1               
00D604  1               ;-------------------------------------------------------------------------------------
00D604  1               ;$01 - used to hold enemy offset for second enemy
00D604  1               
00D604  1               SetBitsMask:
00D604  1  80 40 20 10        .byte %10000000, %01000000, %00100000, %00010000, %00001000, %00000100, %00000010
00D608  1  08 04 02     
00D60B  1               
00D60B  1               ClearBitsMask:
00D60B  1  7F BF DF EF        .byte %01111111, %10111111, %11011111, %11101111, %11110111, %11111011, %11111101
00D60F  1  F7 FB FD     
00D612  1               
00D612  1               SetupFloateyNumber:
00D612  1  9D 10 01            sta FloateyNum_Control,x ;set number of points control for floatey numbers
00D615  1  A9 30               lda #$30
00D617  1  9D 2C 01            sta FloateyNum_Timer,x   ;set timer for floatey numbers
00D61A  1  B5 CF               lda Enemy_Y_Position,x
00D61C  1  9D 1E 01            sta FloateyNum_Y_Pos,x   ;set vertical coordinate
00D61F  1  AD AE 03            lda Enemy_Rel_XPos
00D622  1  9D 17 01            sta FloateyNum_X_Pos,x   ;set horizontal coordinate and leave
00D625  1  60           ExSFN: rts
00D626  1               
00D626  1               EnemiesCollision:
00D626  1  A5 09                lda FrameCounter            ;check counter for d0 set
00D628  1  4A                   lsr
00D629  1  90 FA                bcc ExSFN                   ;if d0 not set, leave
00D62B  1  AD 4E 07             lda AreaType
00D62E  1  F0 F5                beq ExSFN                   ;if water area type, leave
00D630  1  B5 16                lda Enemy_ID,x
00D632  1  C9 15                cmp #$15                    ;if enemy object => $15, branch to leave
00D634  1  B0 6E                bcs ExitECRoutine
00D636  1  C9 11                cmp #Lakitu                 ;if lakitu, branch to leave
00D638  1  F0 6A                beq ExitECRoutine
00D63A  1  C9 0D                cmp #PiranhaPlant           ;if piranha plant, branch to leave
00D63C  1  F0 66                beq ExitECRoutine
00D63E  1  BD D8 03             lda EnemyOffscrBitsMasked,x ;if masked offscreen bits nonzero, branch to leave
00D641  1  D0 61                bne ExitECRoutine
00D643  1  20 45 D8             jsr GetEnemyBoundBoxOfs     ;otherwise, do sub, get appropriate bounding box offset for
00D646  1  CA                   dex                         ;first enemy we're going to compare, then decrement for second
00D647  1  30 5B                bmi ExitECRoutine           ;branch to leave if there are no other enemies
00D649  1  86 01        ECLoop: stx $01                     ;save enemy object buffer offset for second enemy here
00D64B  1  98                   tya                         ;save first enemy's bounding box offset to stack
00D64C  1  48                   pha
00D64D  1  B5 0F                lda Enemy_Flag,x            ;check enemy object enable flag
00D64F  1  F0 4C                beq ReadyNextEnemy          ;branch if flag not set
00D651  1  B5 16                lda Enemy_ID,x
00D653  1  C9 15                cmp #$15                    ;check for enemy object => $15
00D655  1  B0 46                bcs ReadyNextEnemy          ;branch if true
00D657  1  C9 11                cmp #Lakitu
00D659  1  F0 42                beq ReadyNextEnemy          ;branch if enemy object is lakitu
00D65B  1  C9 0D                cmp #PiranhaPlant
00D65D  1  F0 3E                beq ReadyNextEnemy          ;branch if enemy object is piranha plant
00D65F  1  BD D8 03             lda EnemyOffscrBitsMasked,x
00D662  1  D0 39                bne ReadyNextEnemy          ;branch if masked offscreen bits set
00D664  1  8A                   txa                         ;get second enemy object's bounding box offset
00D665  1  0A                   asl                         ;multiply by four, then add four
00D666  1  0A                   asl
00D667  1  18                   clc
00D668  1  69 04                adc #$04
00D66A  1  AA                   tax                         ;use as new contents of X
00D66B  1  20 B7 DE             jsr SprObjectCollisionCore  ;do collision detection using the two enemies here
00D66E  1  A6 08                ldx ObjectOffset            ;use first enemy offset for X
00D670  1  A4 01                ldy $01                     ;use second enemy offset for Y
00D672  1  90 20                bcc NoEnemyCollision        ;if carry clear, no collision, branch ahead of this
00D674  1  B5 1E                lda Enemy_State,x
00D676  1  19 1E 00             ora Enemy_State,y           ;check both enemy states for d7 set
00D679  1  29 80                and #%10000000
00D67B  1  D0 11                bne YesEC                   ;branch if at least one of them is set
00D67D  1  B9 91 04             lda Enemy_CollisionBits,y   ;load first enemy's collision-related bits
00D680  1  3D 04 D6             and SetBitsMask,x           ;check to see if bit connected to second enemy is
00D683  1  D0 18                bne ReadyNextEnemy          ;already set, and move onto next enemy slot if set
00D685  1  B9 91 04             lda Enemy_CollisionBits,y
00D688  1  1D 04 D6             ora SetBitsMask,x           ;if the bit is not set, set it now
00D68B  1  99 91 04             sta Enemy_CollisionBits,y
00D68E  1  20 A7 D6     YesEC:  jsr ProcEnemyCollisions     ;react according to the nature of collision
00D691  1  4C 9D D6             jmp ReadyNextEnemy          ;move onto next enemy slot
00D694  1               
00D694  1               NoEnemyCollision:
00D694  1  B9 91 04           lda Enemy_CollisionBits,y     ;load first enemy's collision-related bits
00D697  1  3D 0B D6           and ClearBitsMask,x           ;clear bit connected to second enemy
00D69A  1  99 91 04           sta Enemy_CollisionBits,y     ;then move onto next enemy slot
00D69D  1               
00D69D  1               ReadyNextEnemy:
00D69D  1  68                 pla              ;get first enemy's bounding box offset from the stack
00D69E  1  A8                 tay              ;use as Y again
00D69F  1  A6 01              ldx $01          ;get and decrement second enemy's object buffer offset
00D6A1  1  CA                 dex
00D6A2  1  10 A5              bpl ECLoop       ;loop until all enemy slots have been checked
00D6A4  1               
00D6A4  1               ExitECRoutine:
00D6A4  1  A6 08              ldx ObjectOffset ;get enemy object buffer offset
00D6A6  1  60                 rts              ;leave
00D6A7  1               
00D6A7  1               ProcEnemyCollisions:
00D6A7  1  B9 1E 00           lda Enemy_State,y        ;check both enemy states for d5 set
00D6AA  1  15 1E              ora Enemy_State,x
00D6AC  1  29 20              and #%00100000           ;if d5 is set in either state, or both, branch
00D6AE  1  D0 33              bne ExitProcessEColl     ;to leave and do nothing else at this point
00D6B0  1  B5 1E              lda Enemy_State,x
00D6B2  1  C9 06              cmp #$06                 ;if second enemy state < $06, branch elsewhere
00D6B4  1  90 2E              bcc ProcSecondEnemyColl
00D6B6  1  B5 16              lda Enemy_ID,x           ;check second enemy identifier for hammer bro
00D6B8  1  C9 05              cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
00D6BA  1  F0 27              beq ExitProcessEColl
00D6BC  1  B9 1E 00           lda Enemy_State,y        ;check first enemy state for d7 set
00D6BF  1  0A                 asl
00D6C0  1  90 0A              bcc ShellCollisions      ;branch if d7 is clear
00D6C2  1  A9 06              lda #$06
00D6C4  1  20 12 D6           jsr SetupFloateyNumber   ;award 1000 points for killing enemy
00D6C7  1  20 88 D3           jsr ShellOrBlockDefeat   ;then kill enemy, then load
00D6CA  1  A4 01              ldy $01                  ;original offset of second enemy
00D6CC  1               
00D6CC  1               ShellCollisions:
00D6CC  1  98                 tya                      ;move Y to X
00D6CD  1  AA                 tax
00D6CE  1  20 88 D3           jsr ShellOrBlockDefeat   ;kill second enemy
00D6D1  1  A6 08              ldx ObjectOffset
00D6D3  1  BD 25 01           lda ShellChainCounter,x  ;get chain counter for shell
00D6D6  1  18                 clc
00D6D7  1  69 04              adc #$04                 ;add four to get appropriate point offset
00D6D9  1  A6 01              ldx $01
00D6DB  1  20 12 D6           jsr SetupFloateyNumber   ;award appropriate number of points for second enemy
00D6DE  1  A6 08              ldx ObjectOffset         ;load original offset of first enemy
00D6E0  1  FE 25 01           inc ShellChainCounter,x  ;increment chain counter for additional enemies
00D6E3  1               
00D6E3  1               ExitProcessEColl:
00D6E3  1  60                 rts                      ;leave!!!
00D6E4  1               
00D6E4  1               ProcSecondEnemyColl:
00D6E4  1  B9 1E 00           lda Enemy_State,y        ;if first enemy state < $06, branch elsewhere
00D6E7  1  C9 06              cmp #$06
00D6E9  1  90 1D              bcc MoveEOfs
00D6EB  1  B9 16 00           lda Enemy_ID,y           ;check first enemy identifier for hammer bro
00D6EE  1  C9 05              cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
00D6F0  1  F0 F1              beq ExitProcessEColl
00D6F2  1  20 88 D3           jsr ShellOrBlockDefeat   ;otherwise, kill first enemy
00D6F5  1  A4 01              ldy $01
00D6F7  1  B9 25 01           lda ShellChainCounter,y  ;get chain counter for shell
00D6FA  1  18                 clc
00D6FB  1  69 04              adc #$04                 ;add four to get appropriate point offset
00D6FD  1  A6 08              ldx ObjectOffset
00D6FF  1  20 12 D6           jsr SetupFloateyNumber   ;award appropriate number of points for first enemy
00D702  1  A6 01              ldx $01                  ;load original offset of second enemy
00D704  1  FE 25 01           inc ShellChainCounter,x  ;increment chain counter for additional enemies
00D707  1  60                 rts                      ;leave!!!
00D708  1               
00D708  1               MoveEOfs:
00D708  1  98                 tya                      ;move Y ($01) to X
00D709  1  AA                 tax
00D70A  1  20 0F D7           jsr EnemyTurnAround      ;do the sub here using value from $01
00D70D  1  A6 08              ldx ObjectOffset         ;then do it again using value from $08
00D70F  1               
00D70F  1               EnemyTurnAround:
00D70F  1  B5 16               lda Enemy_ID,x           ;check for specific enemies
00D711  1  C9 0D               cmp #PiranhaPlant
00D713  1  F0 22               beq ExTA                 ;if piranha plant, leave
00D715  1  C9 11               cmp #Lakitu
00D717  1  F0 1E               beq ExTA                 ;if lakitu, leave
00D719  1  C9 05               cmp #HammerBro
00D71B  1  F0 1A               beq ExTA                 ;if hammer bro, leave
00D71D  1  C9 12               cmp #Spiny
00D71F  1  F0 08               beq RXSpd                ;if spiny, turn it around
00D721  1  C9 0E               cmp #GreenParatroopaJump
00D723  1  F0 04               beq RXSpd                ;if green paratroopa, turn it around
00D725  1  C9 07               cmp #$07
00D727  1  B0 0E               bcs ExTA                 ;if any OTHER enemy object => $07, leave
00D729  1  B5 58        RXSpd: lda Enemy_X_Speed,x      ;load horizontal speed
00D72B  1  49 FF               eor #$ff                 ;get two's compliment for horizontal speed
00D72D  1  A8                  tay
00D72E  1  C8                  iny
00D72F  1  94 58               sty Enemy_X_Speed,x      ;store as new horizontal speed
00D731  1  B5 46               lda Enemy_MovingDir,x
00D733  1  49 03               eor #%00000011           ;invert moving direction and store, then leave
00D735  1  95 46               sta Enemy_MovingDir,x    ;thus effectively turning the enemy around
00D737  1  60           ExTA:  rts                      ;leave!!!
00D738  1               
00D738  1               ;-------------------------------------------------------------------------------------
00D738  1               ;$00 - vertical position of platform
00D738  1               
00D738  1               LargePlatformCollision:
00D738  1  A9 FF               lda #$ff                     ;save value here
00D73A  1  9D A2 03            sta PlatformCollisionFlag,x
00D73D  1  AD 47 07            lda TimerControl             ;check master timer control
00D740  1  D0 29               bne ExLPC                    ;if set, branch to leave
00D742  1  B5 1E               lda Enemy_State,x            ;if d7 set in object state,
00D744  1  30 25               bmi ExLPC                    ;branch to leave
00D746  1  B5 16               lda Enemy_ID,x
00D748  1  C9 24               cmp #$24                     ;check enemy object identifier for
00D74A  1  D0 06               bne ChkForPlayerC_LargeP     ;balance platform, branch if not found
00D74C  1  B5 1E               lda Enemy_State,x
00D74E  1  AA                  tax                          ;set state as enemy offset here
00D74F  1  20 52 D7            jsr ChkForPlayerC_LargeP     ;perform code with state offset, then original offset, in X
00D752  1               
00D752  1               ChkForPlayerC_LargeP:
00D752  1  20 34 D8            jsr CheckPlayerVertical      ;figure out if player is below a certain point
00D755  1  B0 14               bcs ExLPC                    ;or offscreen, branch to leave if true
00D757  1  8A                  txa
00D758  1  20 47 D8            jsr GetEnemyBoundBoxOfsArg   ;get bounding box offset in Y
00D75B  1  B5 CF               lda Enemy_Y_Position,x       ;store vertical coordinate in
00D75D  1  85 00               sta $00                      ;temp variable for now
00D75F  1  8A                  txa                          ;send offset we're on to the stack
00D760  1  48                  pha
00D761  1  20 B5 DE            jsr PlayerCollisionCore      ;do player-to-platform collision detection
00D764  1  68                  pla                          ;retrieve offset from the stack
00D765  1  AA                  tax
00D766  1  90 03               bcc ExLPC                    ;if no collision, branch to leave
00D768  1  20 AF D7            jsr ProcLPlatCollisions      ;otherwise collision, perform sub
00D76B  1  A6 08        ExLPC: ldx ObjectOffset             ;get enemy object buffer offset and leave
00D76D  1  60                  rts
00D76E  1               
00D76E  1               ;--------------------------------
00D76E  1               ;$00 - counter for bounding boxes
00D76E  1               
00D76E  1               SmallPlatformCollision:
00D76E  1  AD 47 07           lda TimerControl             ;if master timer control set,
00D771  1  D0 37              bne ExSPC                    ;branch to leave
00D773  1  9D A2 03           sta PlatformCollisionFlag,x  ;otherwise initialize collision flag
00D776  1  20 34 D8           jsr CheckPlayerVertical      ;do a sub to see if player is below a certain point
00D779  1  B0 2F              bcs ExSPC                    ;or entirely offscreen, and branch to leave if true
00D77B  1  A9 02              lda #$02
00D77D  1  85 00              sta $00                      ;load counter here for 2 bounding boxes
00D77F  1               
00D77F  1               ChkSmallPlatLoop:
00D77F  1  A6 08              ldx ObjectOffset           ;get enemy object offset
00D781  1  20 45 D8           jsr GetEnemyBoundBoxOfs    ;get bounding box offset in Y
00D784  1  29 02              and #%00000010             ;if d1 of offscreen lower nybble bits was set
00D786  1  D0 22              bne ExSPC                  ;then branch to leave
00D788  1  B9 AD 04           lda BoundingBox_UL_YPos,y  ;check top of platform's bounding box for being
00D78B  1  C9 20              cmp #$20                   ;above a specific point
00D78D  1  90 05              bcc MoveBoundBox           ;if so, branch, don't do collision detection
00D78F  1  20 B5 DE           jsr PlayerCollisionCore    ;otherwise, perform player-to-platform collision detection
00D792  1  B0 19              bcs ProcSPlatCollisions    ;skip ahead if collision
00D794  1               
00D794  1               MoveBoundBox:
00D794  1  B9 AD 04            lda BoundingBox_UL_YPos,y  ;move bounding box vertical coordinates
00D797  1  18                  clc                        ;128 pixels downwards
00D798  1  69 80               adc #$80
00D79A  1  99 AD 04            sta BoundingBox_UL_YPos,y
00D79D  1  B9 AF 04            lda BoundingBox_DR_YPos,y
00D7A0  1  18                  clc
00D7A1  1  69 80               adc #$80
00D7A3  1  99 AF 04            sta BoundingBox_DR_YPos,y
00D7A6  1  C6 00               dec $00                    ;decrement counter we set earlier
00D7A8  1  D0 D5               bne ChkSmallPlatLoop       ;loop back until both bounding boxes are checked
00D7AA  1  A6 08        ExSPC: ldx ObjectOffset           ;get enemy object buffer offset, then leave
00D7AC  1  60                  rts
00D7AD  1               
00D7AD  1               ;--------------------------------
00D7AD  1               
00D7AD  1               ProcSPlatCollisions:
00D7AD  1  A6 08              ldx ObjectOffset             ;return enemy object buffer offset to X, then continue
00D7AF  1               
00D7AF  1               ProcLPlatCollisions:
00D7AF  1  B9 AF 04           lda BoundingBox_DR_YPos,y    ;get difference by subtracting the top
00D7B2  1  38                 sec                          ;of the player's bounding box from the bottom
00D7B3  1  ED AD 04           sbc BoundingBox_UL_YPos      ;of the platform's bounding box
00D7B6  1  C9 04              cmp #$04                     ;if difference too large or negative,
00D7B8  1  B0 08              bcs ChkForTopCollision       ;branch, do not alter vertical speed of player
00D7BA  1  A5 9F              lda Player_Y_Speed           ;check to see if player's vertical speed is moving down
00D7BC  1  10 04              bpl ChkForTopCollision       ;if so, don't mess with it
00D7BE  1  A9 01              lda #$01                     ;otherwise, set vertical
00D7C0  1  85 9F              sta Player_Y_Speed           ;speed of player to kill jump
00D7C2  1               
00D7C2  1               ChkForTopCollision:
00D7C2  1  AD AF 04           lda BoundingBox_DR_YPos      ;get difference by subtracting the top
00D7C5  1  38                 sec                          ;of the platform's bounding box from the bottom
00D7C6  1  F9 AD 04           sbc BoundingBox_UL_YPos,y    ;of the player's bounding box
00D7C9  1  C9 06              cmp #$06
00D7CB  1  B0 1B              bcs PlatformSideCollisions   ;if difference not close enough, skip all of this
00D7CD  1  A5 9F              lda Player_Y_Speed
00D7CF  1  30 17              bmi PlatformSideCollisions   ;if player's vertical speed moving upwards, skip this
00D7D1  1  A5 00              lda $00                      ;get saved bounding box counter from earlier
00D7D3  1  B4 16              ldy Enemy_ID,x
00D7D5  1  C0 2B              cpy #$2b                     ;if either of the two small platform objects are found,
00D7D7  1  F0 05              beq SetCollisionFlag         ;regardless of which one, branch to use bounding box counter
00D7D9  1  C0 2C              cpy #$2c                     ;as contents of collision flag
00D7DB  1  F0 01              beq SetCollisionFlag
00D7DD  1  8A                 txa                          ;otherwise use enemy object buffer offset
00D7DE  1               
00D7DE  1               SetCollisionFlag:
00D7DE  1  A6 08              ldx ObjectOffset             ;get enemy object buffer offset
00D7E0  1  9D A2 03           sta PlatformCollisionFlag,x  ;save either bounding box counter or enemy offset here
00D7E3  1  A9 00              lda #$00
00D7E5  1  85 1D              sta Player_State             ;set player state to normal then leave
00D7E7  1  60                 rts
00D7E8  1               
00D7E8  1               PlatformSideCollisions:
00D7E8  1  A9 01                 lda #$01                   ;set value here to indicate possible horizontal
00D7EA  1  85 00                 sta $00                    ;collision on left side of platform
00D7EC  1  AD AE 04              lda BoundingBox_DR_XPos    ;get difference by subtracting platform's left edge
00D7EF  1  38                    sec                        ;from player's right edge
00D7F0  1  F9 AC 04              sbc BoundingBox_UL_XPos,y
00D7F3  1  C9 08                 cmp #$08                   ;if difference close enough, skip all of this
00D7F5  1  90 0D                 bcc SideC
00D7F7  1  E6 00                 inc $00                    ;otherwise increment value set here for right side collision
00D7F9  1  B9 AE 04              lda BoundingBox_DR_XPos,y  ;get difference by subtracting player's left edge
00D7FC  1  18                    clc                        ;from platform's right edge
00D7FD  1  ED AC 04              sbc BoundingBox_UL_XPos
00D800  1  C9 09                 cmp #$09                   ;if difference not close enough, skip subroutine
00D802  1  B0 03                 bcs NoSideC                ;and instead branch to leave (no collision)
00D804  1  20 DB DA     SideC:   jsr ImpedePlayerMove       ;deal with horizontal collision
00D807  1  A6 08        NoSideC: ldx ObjectOffset           ;return with enemy object buffer offset
00D809  1  60                    rts
00D80A  1               
00D80A  1               ;-------------------------------------------------------------------------------------
00D80A  1               
00D80A  1               PlayerPosSPlatData:
00D80A  1  80 00              .byte $80, $00
00D80C  1               
00D80C  1               PositionPlayerOnS_Plat:
00D80C  1  A8                 tay                        ;use bounding box counter saved in collision flag
00D80D  1  B5 CF              lda Enemy_Y_Position,x     ;for offset
00D80F  1  18                 clc                        ;add positioning data using offset to the vertical
00D810  1  79 09 D8           adc PlayerPosSPlatData-1,y ;coordinate
00D813  1  2C                 .byte $2c                    ;BIT instruction opcode
00D814  1               
00D814  1               PositionPlayerOnVPlat:
00D814  1  B5 CF                 lda Enemy_Y_Position,x    ;get vertical coordinate
00D816  1  A4 0E                 ldy GameEngineSubroutine
00D818  1  C0 0B                 cpy #$0b                  ;if certain routine being executed on this frame,
00D81A  1  F0 17                 beq ExPlPos               ;skip all of this
00D81C  1  B4 B6                 ldy Enemy_Y_HighPos,x
00D81E  1  C0 01                 cpy #$01                  ;if vertical high byte offscreen, skip this
00D820  1  D0 11                 bne ExPlPos
00D822  1  38                    sec                       ;subtract 32 pixels from vertical coordinate
00D823  1  E9 20                 sbc #$20                  ;for the player object's height
00D825  1  85 CE                 sta Player_Y_Position     ;save as player's new vertical coordinate
00D827  1  98                    tya
00D828  1  E9 00                 sbc #$00                  ;subtract borrow and store as player's
00D82A  1  85 B5                 sta Player_Y_HighPos      ;new vertical high byte
00D82C  1  A9 00                 lda #$00
00D82E  1  85 9F                 sta Player_Y_Speed        ;initialize vertical speed and low byte of force
00D830  1  8D 33 04              sta Player_Y_MoveForce    ;and then leave
00D833  1  60           ExPlPos: rts
00D834  1               
00D834  1               ;-------------------------------------------------------------------------------------
00D834  1               
00D834  1               CheckPlayerVertical:
00D834  1  AD D0 03            lda Player_OffscreenBits  ;if player object is completely offscreen
00D837  1  C9 F0               cmp #$f0                  ;vertically, leave this routine
00D839  1  B0 09               bcs ExCPV
00D83B  1  A4 B5               ldy Player_Y_HighPos      ;if player high vertical byte is not
00D83D  1  88                  dey                       ;within the screen, leave this routine
00D83E  1  D0 04               bne ExCPV
00D840  1  A5 CE               lda Player_Y_Position     ;if on the screen, check to see how far down
00D842  1  C9 D0               cmp #$d0                  ;the player is vertically
00D844  1  60           ExCPV: rts
00D845  1               
00D845  1               ;-------------------------------------------------------------------------------------
00D845  1               
00D845  1               GetEnemyBoundBoxOfs:
00D845  1  A5 08              lda ObjectOffset         ;get enemy object buffer offset
00D847  1               
00D847  1               GetEnemyBoundBoxOfsArg:
00D847  1  0A                 asl                      ;multiply A by four, then add four
00D848  1  0A                 asl                      ;to skip player's bounding box
00D849  1  18                 clc
00D84A  1  69 04              adc #$04
00D84C  1  A8                 tay                      ;send to Y
00D84D  1  AD D1 03           lda Enemy_OffscreenBits  ;get offscreen bits for enemy object
00D850  1  29 0F              and #%00001111           ;save low nybble
00D852  1  C9 0F              cmp #%00001111           ;check for all bits set
00D854  1  60                 rts
00D855  1               
00D855  1               ;-------------------------------------------------------------------------------------
00D855  1               ;$00-$01 - used to hold many values, essentially temp variables
00D855  1               ;$04 - holds lower nybble of vertical coordinate from block buffer routine
00D855  1               ;$eb - used to hold block buffer adder
00D855  1               
00D855  1               PlayerBGUpperExtent:
00D855  1  20 10              .byte $20, $10
00D857  1               
00D857  1               PlayerBGCollision:
00D857  1  AD 16 07               lda DisableCollisionDet   ;if collision detection disabled flag set,
00D85A  1  D0 2E                  bne ExPBGCol              ;branch to leave
00D85C  1  A5 0E                  lda GameEngineSubroutine
00D85E  1  C9 0B                  cmp #$0b                  ;if running routine #11 or $0b
00D860  1  F0 28                  beq ExPBGCol              ;branch to leave
00D862  1  C9 04                  cmp #$04
00D864  1  90 24                  bcc ExPBGCol              ;if running routines $00-$03 branch to leave
00D866  1  A9 01                  lda #$01                  ;load default player state for swimming
00D868  1  AC 04 07               ldy SwimmingFlag          ;if swimming flag set,
00D86B  1  D0 0A                  bne SetPSte               ;branch ahead to set default state
00D86D  1  A5 1D                  lda Player_State          ;if player in normal state,
00D86F  1  F0 04                  beq SetFallS              ;branch to set default state for falling
00D871  1  C9 03                  cmp #$03
00D873  1  D0 04                  bne ChkOnScr              ;if in any other state besides climbing, skip to next part
00D875  1  A9 02        SetFallS: lda #$02                  ;load default player state for falling
00D877  1  85 1D        SetPSte:  sta Player_State          ;set whatever player state is appropriate
00D879  1  A5 B5        ChkOnScr: lda Player_Y_HighPos
00D87B  1  C9 01                  cmp #$01                  ;check player's vertical high byte for still on the screen
00D87D  1  D0 0B                  bne ExPBGCol              ;branch to leave if not
00D87F  1  A9 FF                  lda #$ff
00D881  1  8D 90 04               sta Player_CollisionBits  ;initialize player's collision flag
00D884  1  A5 CE                  lda Player_Y_Position
00D886  1  C9 CF                  cmp #$cf                  ;check player's vertical coordinate
00D888  1  90 01                  bcc ChkCollSize           ;if not too close to the bottom of screen, continue
00D88A  1  60           ExPBGCol: rts                       ;otherwise leave
00D88B  1               
00D88B  1               ChkCollSize:
00D88B  1  A0 02                 ldy #$02                    ;load default offset
00D88D  1  AD 14 07              lda CrouchingFlag
00D890  1  D0 0C                 bne GBBAdr                  ;if player crouching, skip ahead
00D892  1  AD 54 07              lda PlayerSize
00D895  1  D0 07                 bne GBBAdr                  ;if player small, skip ahead
00D897  1  88                    dey                         ;otherwise decrement offset for big player not crouching
00D898  1  AD 04 07              lda SwimmingFlag
00D89B  1  D0 01                 bne GBBAdr                  ;if swimming flag set, skip ahead
00D89D  1  88                    dey                         ;otherwise decrement offset
00D89E  1  B9 3D DF     GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
00D8A1  1  85 EB                 sta $eb                     ;store value here
00D8A3  1  A8                    tay                         ;put value into Y, as offset for block buffer routine
00D8A4  1  AE 54 07              ldx PlayerSize              ;get player's size as offset
00D8A7  1  AD 14 07              lda CrouchingFlag
00D8AA  1  F0 01                 beq HeadChk                 ;if player not crouching, branch ahead
00D8AC  1  E8                    inx                         ;otherwise increment size as offset
00D8AD  1  A5 CE        HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
00D8AF  1  DD 55 D8              cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
00D8B2  1  90 35                 bcc DoFootCheck             ;if player is too high, skip this part
00D8B4  1  20 79 DF              jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
00D8B7  1  F0 30                 beq DoFootCheck             ;player, and branch if nothing above player's head
00D8B9  1  20 31 DB              jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
00D8BC  1  B0 4F                 bcs AwardTouchedCoin        ;if so, branch to some other part of code
00D8BE  1  A4 9F                 ldy Player_Y_Speed          ;check player's vertical speed
00D8C0  1  10 27                 bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
00D8C2  1  A4 04                 ldy $04                     ;check lower nybble of vertical coordinate returned
00D8C4  1  C0 04                 cpy #$04                    ;from collision detection routine
00D8C6  1  90 21                 bcc DoFootCheck             ;if low nybble < 4, branch
00D8C8  1  20 1F DB              jsr CheckForSolidMTiles     ;check to see what player's head bumped on
00D8CB  1  B0 10                 bcs SolidOrClimb            ;if player collided with solid metatile, branch
00D8CD  1  AC 4E 07              ldy AreaType                ;otherwise check area type
00D8D0  1  F0 13                 beq NYSpd                   ;if water level, branch ahead
00D8D2  1  AC 84 07              ldy BlockBounceTimer        ;if block bounce timer not expired,
00D8D5  1  D0 0E                 bne NYSpd                   ;branch ahead, do not process collision
00D8D7  1  20 A4 BD              jsr PlayerHeadCollision     ;otherwise do a sub to process collision
00D8DA  1  4C E9 D8              jmp DoFootCheck             ;jump ahead to skip these other parts here
00D8DD  1               
00D8DD  1               SolidOrClimb:
00D8DD  1  C9 26               cmp #$26               ;if climbing metatile,
00D8DF  1  F0 04               beq NYSpd              ;branch ahead and do not play sound
00D8E1  1  A9 02               lda #Sfx_Bump
00D8E3  1  85 FF               sta Square1SoundQueue  ;otherwise load bump sound
00D8E5  1  A9 01        NYSpd: lda #$01               ;set player's vertical speed to nullify
00D8E7  1  85 9F               sta Player_Y_Speed     ;jump or swim
00D8E9  1               
00D8E9  1               DoFootCheck:
00D8E9  1  A4 EB              ldy $eb                    ;get block buffer adder offset
00D8EB  1  A5 CE              lda Player_Y_Position
00D8ED  1  C9 CF              cmp #$cf                   ;check to see how low player is
00D8EF  1  B0 60              bcs DoPlayerSideCheck      ;if player is too far down on screen, skip all of this
00D8F1  1  20 78 DF           jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom left of player
00D8F4  1  20 31 DB           jsr CheckForCoinMTiles     ;check to see if player touched coin with their left foot
00D8F7  1  B0 14              bcs AwardTouchedCoin       ;if so, branch to some other part of code
00D8F9  1  48                 pha                        ;save bottom left metatile to stack
00D8FA  1  20 78 DF           jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom right of player
00D8FD  1  85 00              sta $00                    ;save bottom right metatile here
00D8FF  1  68                 pla
00D900  1  85 01              sta $01                    ;pull bottom left metatile and save here
00D902  1  D0 0C              bne ChkFootMTile           ;if anything here, skip this part
00D904  1  A5 00              lda $00                    ;otherwise check for anything in bottom right metatile
00D906  1  F0 49              beq DoPlayerSideCheck      ;and skip ahead if not
00D908  1  20 31 DB           jsr CheckForCoinMTiles     ;check to see if player touched coin with their right foot
00D90B  1  90 03              bcc ChkFootMTile           ;if not, skip unconditional jump and continue code
00D90D  1               
00D90D  1               AwardTouchedCoin:
00D90D  1  4C F8 D9           jmp HandleCoinMetatile     ;follow the code to erase coin and award to player 1 coin
00D910  1               
00D910  1               ChkFootMTile:
00D910  1  20 2A DB               jsr CheckForClimbMTiles    ;check to see if player landed on climbable metatiles
00D913  1  B0 3C                  bcs DoPlayerSideCheck      ;if so, branch
00D915  1  A4 9F                  ldy Player_Y_Speed         ;check player's vertical speed
00D917  1  30 38                  bmi DoPlayerSideCheck      ;if player moving upwards, branch
00D919  1  C9 C5                  cmp #$c5
00D91B  1  D0 03                  bne ContChk                ;if player did not touch axe, skip ahead
00D91D  1  4C 01 DA               jmp HandleAxeMetatile      ;otherwise jump to set modes of operation
00D920  1  20 B0 DA     ContChk:  jsr ChkInvisibleMTiles     ;do sub to check for hidden coin or 1-up blocks
00D923  1  F0 2C                  beq DoPlayerSideCheck      ;if either found, branch
00D925  1  AC 0E 07               ldy JumpspringAnimCtrl     ;if jumpspring animating right now,
00D928  1  D0 23                  bne InitSteP               ;branch ahead
00D92A  1  A4 04                  ldy $04                    ;check lower nybble of vertical coordinate returned
00D92C  1  C0 05                  cpy #$05                   ;from collision detection routine
00D92E  1  90 07                  bcc LandPlyr               ;if lower nybble < 5, branch
00D930  1  A5 45                  lda Player_MovingDir
00D932  1  85 00                  sta $00                    ;use player's moving direction as temp variable
00D934  1  4C DB DA               jmp ImpedePlayerMove       ;jump to impede player's movement in that direction
00D937  1  20 B7 DA     LandPlyr: jsr ChkForLandJumpSpring   ;do sub to check for jumpspring metatiles and deal with it
00D93A  1  A9 F0                  lda #$f0
00D93C  1  25 CE                  and Player_Y_Position      ;mask out lower nybble of player's vertical position
00D93E  1  85 CE                  sta Player_Y_Position      ;and store as new vertical position to land player properly
00D940  1  20 99 B4               jsr HandlePipeEntry        ;do sub to process potential pipe entry
00D943  1  A9 00                  lda #$00
00D945  1  85 9F                  sta Player_Y_Speed         ;initialize vertical speed and fractional
00D947  1  8D 33 04               sta Player_Y_MoveForce     ;movement force to stop player's vertical movement
00D94A  1  8D 84 04               sta StompChainCounter      ;initialize enemy stomp counter
00D94D  1  A9 00        InitSteP: lda #$00
00D94F  1  85 1D                  sta Player_State           ;set player's state to normal
00D951  1               
00D951  1               DoPlayerSideCheck:
00D951  1  A4 EB              ldy $eb       ;get block buffer adder offset
00D953  1  C8                 iny
00D954  1  C8                 iny           ;increment offset 2 bytes to use adders for side collisions
00D955  1  A9 02              lda #$02      ;set value here to be used as counter
00D957  1  85 00              sta $00
00D959  1               
00D959  1               SideCheckLoop:
00D959  1  C8                  iny                       ;move onto the next one
00D95A  1  84 EB               sty $eb                   ;store it
00D95C  1  A5 CE               lda Player_Y_Position
00D95E  1  C9 20               cmp #$20                  ;check player's vertical position
00D960  1  90 16               bcc BHalf                 ;if player is in status bar area, branch ahead to skip this part
00D962  1  C9 E4               cmp #$e4
00D964  1  B0 28               bcs ExSCH                 ;branch to leave if player is too far down
00D966  1  20 7C DF            jsr BlockBufferColli_Side ;do player-to-bg collision detection on one half of player
00D969  1  F0 0D               beq BHalf                 ;branch ahead if nothing found
00D96B  1  C9 1C               cmp #$1c                  ;otherwise check for pipe metatiles
00D96D  1  F0 09               beq BHalf                 ;if collided with sideways pipe (top), branch ahead
00D96F  1  C9 6B               cmp #$6b
00D971  1  F0 05               beq BHalf                 ;if collided with water pipe (top), branch ahead
00D973  1  20 2A DB            jsr CheckForClimbMTiles   ;do sub to see if player bumped into anything climbable
00D976  1  90 17               bcc CheckSideMTiles       ;if not, branch to alternate section of code
00D978  1  A4 EB        BHalf: ldy $eb                   ;load block adder offset
00D97A  1  C8                  iny                       ;increment it
00D97B  1  A5 CE               lda Player_Y_Position     ;get player's vertical position
00D97D  1  C9 08               cmp #$08
00D97F  1  90 0D               bcc ExSCH                 ;if too high, branch to leave
00D981  1  C9 D0               cmp #$d0
00D983  1  B0 09               bcs ExSCH                 ;if too low, branch to leave
00D985  1  20 7C DF            jsr BlockBufferColli_Side ;do player-to-bg collision detection on other half of player
00D988  1  D0 05               bne CheckSideMTiles       ;if something found, branch
00D98A  1  C6 00               dec $00                   ;otherwise decrement counter
00D98C  1  D0 CB               bne SideCheckLoop         ;run code until both sides of player are checked
00D98E  1  60           ExSCH: rts                       ;leave
00D98F  1               
00D98F  1               CheckSideMTiles:
00D98F  1  20 B0 DA               jsr ChkInvisibleMTiles     ;check for hidden or coin 1-up blocks
00D992  1  F0 61                  beq ExCSM                  ;branch to leave if either found
00D994  1  20 2A DB               jsr CheckForClimbMTiles    ;check for climbable metatiles
00D997  1  90 03                  bcc ContSChk               ;if not found, skip and continue with code
00D999  1  4C 21 DA               jmp HandleClimbing         ;otherwise jump to handle climbing
00D99C  1  20 31 DB     ContSChk: jsr CheckForCoinMTiles     ;check to see if player touched coin
00D99F  1  B0 57                  bcs HandleCoinMetatile     ;if so, execute code to erase coin and award to player 1 coin
00D9A1  1  20 D0 DA               jsr ChkJumpspringMetatiles ;check for jumpspring metatiles
00D9A4  1  90 08                  bcc ChkPBtm                ;if not found, branch ahead to continue cude
00D9A6  1  AD 0E 07               lda JumpspringAnimCtrl     ;otherwise check jumpspring animation control
00D9A9  1  D0 4A                  bne ExCSM                  ;branch to leave if set
00D9AB  1  4C F2 D9               jmp StopPlayerMove         ;otherwise jump to impede player's movement
00D9AE  1  A4 1D        ChkPBtm:  ldy Player_State           ;get player's state
00D9B0  1  C0 00                  cpy #$00                   ;check for player's state set to normal
00D9B2  1  D0 3E                  bne StopPlayerMove         ;if not, branch to impede player's movement
00D9B4  1  A4 33                  ldy PlayerFacingDir        ;get player's facing direction
00D9B6  1  88                     dey
00D9B7  1  D0 39                  bne StopPlayerMove         ;if facing left, branch to impede movement
00D9B9  1  C9 6C                  cmp #$6c                   ;otherwise check for pipe metatiles
00D9BB  1  F0 04                  beq PipeDwnS               ;if collided with sideways pipe (bottom), branch
00D9BD  1  C9 1F                  cmp #$1f                   ;if collided with water pipe (bottom), continue
00D9BF  1  D0 31                  bne StopPlayerMove         ;otherwise branch to impede player's movement
00D9C1  1  AD C4 03     PipeDwnS: lda Player_SprAttrib       ;check player's attributes
00D9C4  1  D0 04                  bne PlyrPipe               ;if already set, branch, do not play sound again
00D9C6  1  A0 10                  ldy #Sfx_PipeDown_Injury
00D9C8  1  84 FF                  sty Square1SoundQueue      ;otherwise load pipedown/injury sound
00D9CA  1  09 20        PlyrPipe: ora #%00100000
00D9CC  1  8D C4 03               sta Player_SprAttrib       ;set background priority bit in player attributes
00D9CF  1  A5 86                  lda Player_X_Position
00D9D1  1  29 0F                  and #%00001111             ;get lower nybble of player's horizontal coordinate
00D9D3  1  F0 0E                  beq ChkGERtn               ;if at zero, branch ahead to skip this part
00D9D5  1  A0 00                  ldy #$00                   ;set default offset for timer setting data
00D9D7  1  AD 1A 07               lda ScreenLeft_PageLoc     ;load page location for left side of screen
00D9DA  1  F0 01                  beq SetCATmr               ;if at page zero, use default offset
00D9DC  1  C8                     iny                        ;otherwise increment offset
00D9DD  1  B9 F6 D9     SetCATmr: lda AreaChangeTimerData,y  ;set timer for change of area as appropriate
00D9E0  1  8D DE 06               sta ChangeAreaTimer
00D9E3  1  A5 0E        ChkGERtn: lda GameEngineSubroutine   ;get number of game engine routine running
00D9E5  1  C9 07                  cmp #$07
00D9E7  1  F0 0C                  beq ExCSM                  ;if running player entrance routine or
00D9E9  1  C9 08                  cmp #$08                   ;player control routine, go ahead and branch to leave
00D9EB  1  D0 08                  bne ExCSM
00D9ED  1  A9 02                  lda #$02
00D9EF  1  85 0E                  sta GameEngineSubroutine   ;otherwise set sideways pipe entry routine to run
00D9F1  1  60                     rts                        ;and leave
00D9F2  1               
00D9F2  1               ;--------------------------------
00D9F2  1               ;$02 - high nybble of vertical coordinate from block buffer
00D9F2  1               ;$04 - low nybble of horizontal coordinate from block buffer
00D9F2  1               ;$06-$07 - block buffer address
00D9F2  1               
00D9F2  1               StopPlayerMove:
00D9F2  1  20 DB DA            jsr ImpedePlayerMove      ;stop player's movement
00D9F5  1  60           ExCSM: rts                       ;leave
00D9F6  1               
00D9F6  1               AreaChangeTimerData:
00D9F6  1  A0 34              .byte $a0, $34
00D9F8  1               
00D9F8  1               HandleCoinMetatile:
00D9F8  1  20 0F DA           jsr ErACM             ;do sub to erase coin metatile from block buffer
00D9FB  1  EE 48 07           inc CoinTallyFor1Ups  ;increment coin tally used for 1-up blocks
00D9FE  1  4C B8 BC           jmp GiveOneCoin       ;update coin amount and tally on the screen
00DA01  1               
00DA01  1               HandleAxeMetatile:
00DA01  1  A9 00               lda #$00
00DA03  1  8D 72 07            sta OperMode_Task   ;reset secondary mode
00DA06  1  A9 02               lda #$02
00DA08  1  8D 70 07            sta OperMode        ;set primary mode to autoctrl mode
00DA0B  1  A9 18               lda #$18
00DA0D  1  85 57               sta Player_X_Speed  ;set horizontal speed and continue to erase axe metatile
00DA0F  1  A4 02        ErACM: ldy $02             ;load vertical high nybble offset for block buffer
00DA11  1  A9 00               lda #$00            ;load blank metatile
00DA13  1  91 06               sta ($06),y         ;store to remove old contents from block buffer
00DA15  1  4C 1A F0            jmp RemoveCoin_Axe  ;update the screen accordingly
00DA18  1               
00DA18  1               ;--------------------------------
00DA18  1               ;$02 - high nybble of vertical coordinate from block buffer
00DA18  1               ;$04 - low nybble of horizontal coordinate from block buffer
00DA18  1               ;$06-$07 - block buffer address
00DA18  1               
00DA18  1               ClimbXPosAdder:
00DA18  1  F9 07              .byte $f9, $07
00DA1A  1               
00DA1A  1               ClimbPLocAdder:
00DA1A  1  FF 00              .byte $ff, $00
00DA1C  1               
00DA1C  1               FlagpoleYPosData:
00DA1C  1  18 22 50 68        .byte $18, $22, $50, $68, $90
00DA20  1  90           
00DA21  1               
00DA21  1               HandleClimbing:
00DA21  1  A4 04              ldy $04            ;check low nybble of horizontal coordinate returned from
00DA23  1  C0 06              cpy #$06           ;collision detection routine against certain values, this
00DA25  1  90 04              bcc ExHC           ;makes actual physical part of vine or flagpole thinner
00DA27  1  C0 0A              cpy #$0a           ;than 16 pixels
00DA29  1  90 01              bcc ChkForFlagpole
00DA2B  1  60           ExHC: rts                ;leave if too far left or too far right
00DA2C  1               
00DA2C  1               ChkForFlagpole:
00DA2C  1  C9 24              cmp #$24               ;check climbing metatiles
00DA2E  1  F0 04              beq FlagpoleCollision  ;branch if flagpole ball found
00DA30  1  C9 25              cmp #$25
00DA32  1  D0 39              bne VineCollision      ;branch to alternate code if flagpole shaft not found
00DA34  1               
00DA34  1               FlagpoleCollision:
00DA34  1  A5 0E              lda GameEngineSubroutine
00DA36  1  C9 05              cmp #$05                  ;check for end-of-level routine running
00DA38  1  F0 41              beq PutPlayerOnVine       ;if running, branch to end of climbing code
00DA3A  1  A9 01              lda #$01
00DA3C  1  85 33              sta PlayerFacingDir       ;set player's facing direction to right
00DA3E  1  EE 23 07           inc ScrollLock            ;set scroll lock flag
00DA41  1  A5 0E              lda GameEngineSubroutine
00DA43  1  C9 04              cmp #$04                  ;check for flagpole slide routine running
00DA45  1  F0 1F              beq RunFR                 ;if running, branch to end of flagpole code here
00DA47  1  A9 33              lda #BulletBill_CannonVar ;load identifier for bullet bills (cannon variant)
00DA49  1  20 7E EE           jsr KillEnemies           ;get rid of them
00DA4C  1  A9 80              lda #Silence
00DA4E  1  85 FC              sta EventMusicQueue       ;silence music
00DA50  1  4A                 lsr
00DA51  1  8D 13 07           sta FlagpoleSoundQueue    ;load flagpole sound into flagpole sound queue
00DA54  1  A2 04              ldx #$04                  ;start at end of vertical coordinate data
00DA56  1  A5 CE              lda Player_Y_Position
00DA58  1  8D 0F 07           sta FlagpoleCollisionYPos ;store player's vertical coordinate here to be used later
00DA5B  1               
00DA5B  1               ChkFlagpoleYPosLoop:
00DA5B  1  DD 1C DA            cmp FlagpoleYPosData,x    ;compare with current vertical coordinate data
00DA5E  1  B0 03               bcs MtchF                 ;if player's => current, branch to use current offset
00DA60  1  CA                  dex                       ;otherwise decrement offset to use
00DA61  1  D0 F8               bne ChkFlagpoleYPosLoop   ;do this until all data is checked (use last one if all checked)
00DA63  1  8E 0F 01     MtchF: stx FlagpoleScore         ;store offset here to be used later
00DA66  1  A9 04        RunFR: lda #$04
00DA68  1  85 0E               sta GameEngineSubroutine  ;set value to run flagpole slide routine
00DA6A  1  4C 7B DA            jmp PutPlayerOnVine       ;jump to end of climbing code
00DA6D  1               
00DA6D  1               VineCollision:
00DA6D  1  C9 26              cmp #$26                  ;check for climbing metatile used on vines
00DA6F  1  D0 0A              bne PutPlayerOnVine
00DA71  1  A5 CE              lda Player_Y_Position     ;check player's vertical coordinate
00DA73  1  C9 20              cmp #$20                  ;for being in status bar area
00DA75  1  B0 04              bcs PutPlayerOnVine       ;branch if not that far up
00DA77  1  A9 01              lda #$01
00DA79  1  85 0E              sta GameEngineSubroutine  ;otherwise set to run autoclimb routine next frame
00DA7B  1               
00DA7B  1               PutPlayerOnVine:
00DA7B  1  A9 03                 lda #$03                ;set player state to climbing
00DA7D  1  85 1D                 sta Player_State
00DA7F  1  A9 00                 lda #$00                ;nullify player's horizontal speed
00DA81  1  85 57                 sta Player_X_Speed      ;and fractional horizontal movement force
00DA83  1  8D 05 07              sta Player_X_MoveForce
00DA86  1  A5 86                 lda Player_X_Position   ;get player's horizontal coordinate
00DA88  1  38                    sec
00DA89  1  ED 1C 07              sbc ScreenLeft_X_Pos    ;subtract from left side horizontal coordinate
00DA8C  1  C9 10                 cmp #$10
00DA8E  1  B0 04                 bcs SetVXPl             ;if 16 or more pixels difference, do not alter facing direction
00DA90  1  A9 02                 lda #$02
00DA92  1  85 33                 sta PlayerFacingDir     ;otherwise force player to face left
00DA94  1  A4 33        SetVXPl: ldy PlayerFacingDir     ;get current facing direction, use as offset
00DA96  1  A5 06                 lda $06                 ;get low byte of block buffer address
00DA98  1  0A                    asl
00DA99  1  0A                    asl                     ;move low nybble to high
00DA9A  1  0A                    asl
00DA9B  1  0A                    asl
00DA9C  1  18                    clc
00DA9D  1  79 17 DA              adc ClimbXPosAdder-1,y  ;add pixels depending on facing direction
00DAA0  1  85 86                 sta Player_X_Position   ;store as player's horizontal coordinate
00DAA2  1  A5 06                 lda $06                 ;get low byte of block buffer address again
00DAA4  1  D0 09                 bne ExPVne              ;if not zero, branch
00DAA6  1  AD 1B 07              lda ScreenRight_PageLoc ;load page location of right side of screen
00DAA9  1  18                    clc
00DAAA  1  79 19 DA              adc ClimbPLocAdder-1,y  ;add depending on facing location
00DAAD  1  85 6D                 sta Player_PageLoc      ;store as player's page location
00DAAF  1  60           ExPVne:  rts                     ;finally, we're done!
00DAB0  1               
00DAB0  1               ;--------------------------------
00DAB0  1               
00DAB0  1               ChkInvisibleMTiles:
00DAB0  1  C9 5F                 cmp #$5f       ;check for hidden coin block
00DAB2  1  F0 02                 beq ExCInvT    ;branch to leave if found
00DAB4  1  C9 60                 cmp #$60       ;check for hidden 1-up block
00DAB6  1  60           ExCInvT: rts            ;leave with zero flag set if either found
00DAB7  1               
00DAB7  1               ;--------------------------------
00DAB7  1               ;$00-$01 - used to hold bottom right and bottom left metatiles (in that order)
00DAB7  1               ;$00 - used as flag by ImpedePlayerMove to restrict specific movement
00DAB7  1               
00DAB7  1               ChkForLandJumpSpring:
00DAB7  1  20 D0 DA             jsr ChkJumpspringMetatiles  ;do sub to check if player landed on jumpspring
00DABA  1  90 13                bcc ExCJSp                  ;if carry not set, jumpspring not found, therefore leave
00DABC  1  A9 70                lda #$70
00DABE  1  8D 09 07             sta VerticalForce           ;otherwise set vertical movement force for player
00DAC1  1  A9 F9                lda #$f9
00DAC3  1  8D DB 06             sta JumpspringForce         ;set default jumpspring force
00DAC6  1  A9 03                lda #$03
00DAC8  1  8D 86 07             sta JumpspringTimer         ;set jumpspring timer to be used later
00DACB  1  4A                   lsr
00DACC  1  8D 0E 07             sta JumpspringAnimCtrl      ;set jumpspring animation control to start animating
00DACF  1  60           ExCJSp: rts                         ;and leave
00DAD0  1               
00DAD0  1               ChkJumpspringMetatiles:
00DAD0  1  C9 67                 cmp #$67      ;check for top jumpspring metatile
00DAD2  1  F0 05                 beq JSFnd     ;branch to set carry if found
00DAD4  1  C9 68                 cmp #$68      ;check for bottom jumpspring metatile
00DAD6  1  18                    clc           ;clear carry flag
00DAD7  1  D0 01                 bne NoJSFnd   ;branch to use cleared carry if not found
00DAD9  1  38           JSFnd:   sec           ;set carry if found
00DADA  1  60           NoJSFnd: rts           ;leave
00DADB  1               
00DADB  1               ImpedePlayerMove:
00DADB  1  A9 00               lda #$00                  ;initialize value here
00DADD  1  A4 57               ldy Player_X_Speed        ;get player's horizontal speed
00DADF  1  A6 00               ldx $00                   ;check value set earlier for
00DAE1  1  CA                  dex                       ;left side collision
00DAE2  1  D0 0A               bne RImpd                 ;if right side collision, skip this part
00DAE4  1  E8                  inx                       ;return value to X
00DAE5  1  C0 00               cpy #$00                  ;if player moving to the left,
00DAE7  1  30 28               bmi ExIPM                 ;branch to invert bit and leave
00DAE9  1  A9 FF               lda #$ff                  ;otherwise load A with value to be used later
00DAEB  1  4C F6 DA            jmp NXSpd                 ;and jump to affect movement
00DAEE  1  A2 02        RImpd: ldx #$02                  ;return $02 to X
00DAF0  1  C0 01               cpy #$01                  ;if player moving to the right,
00DAF2  1  10 1D               bpl ExIPM                 ;branch to invert bit and leave
00DAF4  1  A9 01               lda #$01                  ;otherwise load A with value to be used here
00DAF6  1  A0 10        NXSpd: ldy #$10
00DAF8  1  8C 85 07            sty SideCollisionTimer    ;set timer of some sort
00DAFB  1  A0 00               ldy #$00
00DAFD  1  84 57               sty Player_X_Speed        ;nullify player's horizontal speed
00DAFF  1  C9 00               cmp #$00                  ;if value set in A not set to $ff,
00DB01  1  10 01               bpl PlatF                 ;branch ahead, do not decrement Y
00DB03  1  88                  dey                       ;otherwise decrement Y now
00DB04  1  84 00        PlatF: sty $00                   ;store Y as high bits of horizontal adder
00DB06  1  18                  clc
00DB07  1  65 86               adc Player_X_Position     ;add contents of A to player's horizontal
00DB09  1  85 86               sta Player_X_Position     ;position to move player left or right
00DB0B  1  A5 6D               lda Player_PageLoc
00DB0D  1  65 00               adc $00                   ;add high bits and carry to
00DB0F  1  85 6D               sta Player_PageLoc        ;page location if necessary
00DB11  1  8A           ExIPM: txa                       ;invert contents of X
00DB12  1  49 FF               eor #$ff
00DB14  1  2D 90 04            and Player_CollisionBits  ;mask out bit that was set here
00DB17  1  8D 90 04            sta Player_CollisionBits  ;store to clear bit
00DB1A  1  60                  rts
00DB1B  1               
00DB1B  1               ;--------------------------------
00DB1B  1               
00DB1B  1               SolidMTileUpperExt:
00DB1B  1  10 61 88 C4        .byte $10, $61, $88, $c4
00DB1F  1               
00DB1F  1               CheckForSolidMTiles:
00DB1F  1  20 40 DB           jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
00DB22  1  DD 1B DB           cmp SolidMTileUpperExt,x  ;compare current metatile with solid metatiles
00DB25  1  60                 rts
00DB26  1               
00DB26  1               ClimbMTileUpperExt:
00DB26  1  24 6D 8A C6        .byte $24, $6d, $8a, $c6
00DB2A  1               
00DB2A  1               CheckForClimbMTiles:
00DB2A  1  20 40 DB           jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
00DB2D  1  DD 26 DB           cmp ClimbMTileUpperExt,x  ;compare current metatile with climbable metatiles
00DB30  1  60                 rts
00DB31  1               
00DB31  1               CheckForCoinMTiles:
00DB31  1  C9 C2                 cmp #$c2              ;check for regular coin
00DB33  1  F0 06                 beq CoinSd            ;branch if found
00DB35  1  C9 C3                 cmp #$c3              ;check for underwater coin
00DB37  1  F0 02                 beq CoinSd            ;branch if found
00DB39  1  18                    clc                   ;otherwise clear carry and leave
00DB3A  1  60                    rts
00DB3B  1  A9 01        CoinSd:  lda #Sfx_CoinGrab
00DB3D  1  85 FE                 sta Square2SoundQueue ;load coin grab sound and leave
00DB3F  1  60                    rts
00DB40  1               
00DB40  1               GetMTileAttrib:
00DB40  1  A8                  tay            ;save metatile value into Y
00DB41  1  29 C0               and #%11000000 ;mask out all but 2 MSB
00DB43  1  0A                  asl
00DB44  1  2A                  rol            ;shift and rotate d7-d6 to d1-d0
00DB45  1  2A                  rol
00DB46  1  AA                  tax            ;use as offset for metatile data
00DB47  1  98                  tya            ;get original metatile value back
00DB48  1  60           ExEBG: rts            ;leave
00DB49  1               
00DB49  1               ;-------------------------------------------------------------------------------------
00DB49  1               ;$06-$07 - address from block buffer routine
00DB49  1               
00DB49  1               EnemyBGCStateData:
00DB49  1  01 01 02 02        .byte $01, $01, $02, $02, $02, $05
00DB4D  1  02 05        
00DB4F  1               
00DB4F  1               EnemyBGCXSpdData:
00DB4F  1  10 F0              .byte $10, $f0
00DB51  1               
00DB51  1               EnemyToBGCollisionDet:
00DB51  1  B5 1E              lda Enemy_State,x        ;check enemy state for d6 set
00DB53  1  29 20              and #%00100000
00DB55  1  D0 F1              bne ExEBG                ;if set, branch to leave
00DB57  1  20 EB DC           jsr SubtEnemyYPos        ;otherwise, do a subroutine here
00DB5A  1  90 EC              bcc ExEBG                ;if enemy vertical coord + 62 < 68, branch to leave
00DB5C  1  B4 16              ldy Enemy_ID,x
00DB5E  1  C0 12              cpy #Spiny               ;if enemy object is not spiny, branch elsewhere
00DB60  1  D0 06              bne DoIDCheckBGColl
00DB62  1  B5 CF              lda Enemy_Y_Position,x
00DB64  1  C9 25              cmp #$25                 ;if enemy vertical coordinate < 36 branch to leave
00DB66  1  90 E0              bcc ExEBG
00DB68  1               
00DB68  1               DoIDCheckBGColl:
00DB68  1  C0 0E               cpy #GreenParatroopaJump ;check for some other enemy object
00DB6A  1  D0 03               bne HBChk                ;branch if not found
00DB6C  1  4C F3 DC            jmp EnemyJump            ;otherwise jump elsewhere
00DB6F  1  C0 05        HBChk: cpy #HammerBro           ;check for hammer bro
00DB71  1  D0 03               bne CInvu                ;branch if not found
00DB73  1  4C 15 DD            jmp HammerBroBGColl      ;otherwise jump elsewhere
00DB76  1  C0 12        CInvu: cpy #Spiny               ;if enemy object is spiny, branch
00DB78  1  F0 08               beq YesIn
00DB7A  1  C0 2E               cpy #PowerUpObject       ;if special power-up object, branch
00DB7C  1  F0 04               beq YesIn
00DB7E  1  C0 07               cpy #$07                 ;if enemy object =>$07, branch to leave
00DB80  1  B0 74               bcs ExEBGChk
00DB82  1  20 3E DD     YesIn: jsr ChkUnderEnemy        ;if enemy object < $07, or = $12 or $2e, do this sub
00DB85  1  D0 03               bne HandleEToBGCollision ;if block underneath enemy, branch
00DB87  1               
00DB87  1               NoEToBGCollision:
00DB87  1  4C 72 DC            jmp ChkForRedKoopa       ;otherwise skip and do something else
00DB8A  1               
00DB8A  1               ;--------------------------------
00DB8A  1               ;$02 - vertical coordinate from block buffer routine
00DB8A  1               
00DB8A  1               HandleEToBGCollision:
00DB8A  1  20 45 DD           jsr ChkForNonSolids       ;if something is underneath enemy, find out what
00DB8D  1  F0 F8              beq NoEToBGCollision      ;if blank $26, coins, or hidden blocks, jump, enemy falls through
00DB8F  1  C9 23              cmp #$23
00DB91  1  D0 64              bne LandEnemyProperly     ;check for blank metatile $23 and branch if not found
00DB93  1  A4 02              ldy $02                   ;get vertical coordinate used to find block
00DB95  1  A9 00              lda #$00                  ;store default blank metatile in that spot so we won't
00DB97  1  91 06              sta ($06),y               ;trigger this routine accidentally again
00DB99  1  B5 16              lda Enemy_ID,x
00DB9B  1  C9 15              cmp #$15                  ;if enemy object => $15, branch ahead
00DB9D  1  B0 0C              bcs ChkToStunEnemies
00DB9F  1  C9 06              cmp #Goomba               ;if enemy object not goomba, branch ahead of this routine
00DBA1  1  D0 03              bne GiveOEPoints
00DBA3  1  20 1E DD           jsr KillEnemyAboveBlock   ;if enemy object IS goomba, do this sub
00DBA6  1               
00DBA6  1               GiveOEPoints:
00DBA6  1  A9 01              lda #$01                  ;award 100 points for hitting block beneath enemy
00DBA8  1  20 12 D6           jsr SetupFloateyNumber
00DBAB  1               
00DBAB  1               ChkToStunEnemies:
00DBAB  1  C9 09                  cmp #$09                   ;perform many comparisons on enemy object identifier
00DBAD  1  90 10                  bcc SetStun
00DBAF  1  C9 11                  cmp #$11                   ;if the enemy object identifier is equal to the values
00DBB1  1  B0 0C                  bcs SetStun                ;$09, $0e, $0f or $10, it will be modified, and not
00DBB3  1  C9 0A                  cmp #$0a                   ;modified if not any of those values, note that piranha plant will
00DBB5  1  90 04                  bcc Demote                 ;always fail this test because A will still have vertical
00DBB7  1  C9 0D                  cmp #PiranhaPlant          ;coordinate from previous addition, also these comparisons
00DBB9  1  90 04                  bcc SetStun                ;are only necessary if branching from $d7a1
00DBBB  1  29 01        Demote:   and #%00000001             ;erase all but LSB, essentially turning enemy object
00DBBD  1  95 16                  sta Enemy_ID,x             ;into green or red koopa troopa to demote them
00DBBF  1  B5 1E        SetStun:  lda Enemy_State,x          ;load enemy state
00DBC1  1  29 F0                  and #%11110000             ;save high nybble
00DBC3  1  09 02                  ora #%00000010
00DBC5  1  95 1E                  sta Enemy_State,x          ;set d1 of enemy state
00DBC7  1  D6 CF                  dec Enemy_Y_Position,x
00DBC9  1  D6 CF                  dec Enemy_Y_Position,x     ;subtract two pixels from enemy's vertical position
00DBCB  1  B5 16                  lda Enemy_ID,x
00DBCD  1  C9 07                  cmp #Bloober               ;check for bloober object
00DBCF  1  F0 07                  beq SetWYSpd
00DBD1  1  A9 FD                  lda #$fd                   ;set default vertical speed
00DBD3  1  AC 4E 07               ldy AreaType
00DBD6  1  D0 02                  bne SetNotW                ;if area type not water, set as speed, otherwise
00DBD8  1  A9 FF        SetWYSpd: lda #$ff                   ;change the vertical speed
00DBDA  1  95 A0        SetNotW:  sta Enemy_Y_Speed,x        ;set vertical speed now
00DBDC  1  A0 01                  ldy #$01
00DBDE  1  20 D3 DC               jsr PlayerEnemyDiff        ;get horizontal difference between player and enemy object
00DBE1  1  10 01                  bpl ChkBBill               ;branch if enemy is to the right of player
00DBE3  1  C8                     iny                        ;increment Y if not
00DBE4  1  B5 16        ChkBBill: lda Enemy_ID,x
00DBE6  1  C9 33                  cmp #BulletBill_CannonVar  ;check for bullet bill (cannon variant)
00DBE8  1  F0 06                  beq NoCDirF
00DBEA  1  C9 08                  cmp #BulletBill_FrenzyVar  ;check for bullet bill (frenzy variant)
00DBEC  1  F0 02                  beq NoCDirF                ;branch if either found, direction does not change
00DBEE  1  94 46                  sty Enemy_MovingDir,x      ;store as moving direction
00DBF0  1  88           NoCDirF:  dey                        ;decrement and use as offset
00DBF1  1  B9 4F DB               lda EnemyBGCXSpdData,y     ;get proper horizontal speed
00DBF4  1  95 58                  sta Enemy_X_Speed,x        ;and store, then leave
00DBF6  1  60           ExEBGChk: rts
00DBF7  1               
00DBF7  1               ;--------------------------------
00DBF7  1               ;$04 - low nybble of vertical coordinate from block buffer routine
00DBF7  1               
00DBF7  1               LandEnemyProperly:
00DBF7  1  A5 04               lda $04                 ;check lower nybble of vertical coordinate saved earlier
00DBF9  1  38                  sec
00DBFA  1  E9 08               sbc #$08                ;subtract eight pixels
00DBFC  1  C9 05               cmp #$05                ;used to determine whether enemy landed from falling
00DBFE  1  B0 72               bcs ChkForRedKoopa      ;branch if lower nybble in range of $0d-$0f before subtract
00DC00  1  B5 1E               lda Enemy_State,x
00DC02  1  29 40               and #%01000000          ;branch if d6 in enemy state is set
00DC04  1  D0 57               bne LandEnemyInitState
00DC06  1  B5 1E               lda Enemy_State,x
00DC08  1  0A                  asl                     ;branch if d7 in enemy state is not set
00DC09  1  90 03               bcc ChkLandedEnemyState
00DC0B  1  4C 8E DC     SChkA: jmp DoEnemySideCheck    ;if lower nybble < $0d, d7 set but d6 not set, jump here
00DC0E  1               
00DC0E  1               ChkLandedEnemyState:
00DC0E  1  B5 1E                   lda Enemy_State,x         ;if enemy in normal state, branch back to jump here
00DC10  1  F0 F9                   beq SChkA
00DC12  1  C9 05                   cmp #$05                  ;if in state used by spiny's egg
00DC14  1  F0 1F                   beq ProcEnemyDirection    ;then branch elsewhere
00DC16  1  C9 03                   cmp #$03                  ;if already in state used by koopas and buzzy beetles
00DC18  1  B0 1A                   bcs ExSteChk              ;or in higher numbered state, branch to leave
00DC1A  1  B5 1E                   lda Enemy_State,x         ;load enemy state again (why?)
00DC1C  1  C9 02                   cmp #$02                  ;if not in $02 state (used by koopas and buzzy beetles)
00DC1E  1  D0 15                   bne ProcEnemyDirection    ;then branch elsewhere
00DC20  1  A9 10                   lda #$10                  ;load default timer here
00DC22  1  B4 16                   ldy Enemy_ID,x            ;check enemy identifier for spiny
00DC24  1  C0 12                   cpy #Spiny
00DC26  1  D0 02                   bne SetForStn             ;branch if not found
00DC28  1  A9 00                   lda #$00                  ;set timer for $00 if spiny
00DC2A  1  9D 96 07     SetForStn: sta EnemyIntervalTimer,x  ;set timer here
00DC2D  1  A9 03                   lda #$03                  ;set state here, apparently used to render
00DC2F  1  95 1E                   sta Enemy_State,x         ;upside-down koopas and buzzy beetles
00DC31  1  20 DF DC                jsr EnemyLanding          ;then land it properly
00DC34  1  60           ExSteChk:  rts                       ;then leave
00DC35  1               
00DC35  1               ProcEnemyDirection:
00DC35  1  B5 16                 lda Enemy_ID,x            ;check enemy identifier for goomba
00DC37  1  C9 06                 cmp #Goomba               ;branch if found
00DC39  1  F0 22                 beq LandEnemyInitState
00DC3B  1  C9 12                 cmp #Spiny                ;check for spiny
00DC3D  1  D0 0E                 bne InvtD                 ;branch if not found
00DC3F  1  A9 01                 lda #$01
00DC41  1  95 46                 sta Enemy_MovingDir,x     ;send enemy moving to the right by default
00DC43  1  A9 08                 lda #$08
00DC45  1  95 58                 sta Enemy_X_Speed,x       ;set horizontal speed accordingly
00DC47  1  A5 09                 lda FrameCounter
00DC49  1  29 07                 and #%00000111            ;if timed appropriately, spiny will skip over
00DC4B  1  F0 10                 beq LandEnemyInitState    ;trying to face the player
00DC4D  1  A0 01        InvtD:   ldy #$01                  ;load 1 for enemy to face the left (inverted here)
00DC4F  1  20 D3 DC              jsr PlayerEnemyDiff       ;get horizontal difference between player and enemy
00DC52  1  10 01                 bpl CNwCDir               ;if enemy to the right of player, branch
00DC54  1  C8                    iny                       ;if to the left, increment by one for enemy to face right (inverted)
00DC55  1  98           CNwCDir: tya
00DC56  1  D5 46                 cmp Enemy_MovingDir,x     ;compare direction in A with current direction in memory
00DC58  1  D0 03                 bne LandEnemyInitState
00DC5A  1  20 B4 DC              jsr ChkForBump_HammerBroJ ;if equal, not facing in correct dir, do sub to turn around
00DC5D  1               
00DC5D  1               LandEnemyInitState:
00DC5D  1  20 DF DC           jsr EnemyLanding       ;land enemy properly
00DC60  1  B5 1E              lda Enemy_State,x
00DC62  1  29 80              and #%10000000         ;if d7 of enemy state is set, branch
00DC64  1  D0 05              bne NMovShellFallBit
00DC66  1  A9 00              lda #$00               ;otherwise initialize enemy state and leave
00DC68  1  95 1E              sta Enemy_State,x      ;note this will also turn spiny's egg into spiny
00DC6A  1  60                 rts
00DC6B  1               
00DC6B  1               NMovShellFallBit:
00DC6B  1  B5 1E              lda Enemy_State,x   ;nullify d6 of enemy state, save other bits
00DC6D  1  29 BF              and #%10111111      ;and store, then leave
00DC6F  1  95 1E              sta Enemy_State,x
00DC71  1  60                 rts
00DC72  1               
00DC72  1               ;--------------------------------
00DC72  1               
00DC72  1               ChkForRedKoopa:
00DC72  1  B5 16                     lda Enemy_ID,x            ;check for red koopa troopa $03
00DC74  1  C9 03                     cmp #RedKoopa
00DC76  1  D0 04                     bne Chk2MSBSt             ;branch if not found
00DC78  1  B5 1E                     lda Enemy_State,x
00DC7A  1  F0 38                     beq ChkForBump_HammerBroJ ;if enemy found and in normal state, branch
00DC7C  1  B5 1E        Chk2MSBSt:   lda Enemy_State,x         ;save enemy state into Y
00DC7E  1  A8                        tay
00DC7F  1  0A                        asl                       ;check for d7 set
00DC80  1  90 07                     bcc GetSteFromD           ;branch if not set
00DC82  1  B5 1E                     lda Enemy_State,x
00DC84  1  09 40                     ora #%01000000            ;set d6
00DC86  1  4C 8C DC                  jmp SetD6Ste              ;jump ahead of this part
00DC89  1  B9 49 DB     GetSteFromD: lda EnemyBGCStateData,y   ;load new enemy state with old as offset
00DC8C  1  95 1E        SetD6Ste:    sta Enemy_State,x         ;set as new state
00DC8E  1               
00DC8E  1               ;--------------------------------
00DC8E  1               ;$00 - used to store bitmask (not used but initialized here)
00DC8E  1               ;$eb - used in DoEnemySideCheck as counter and to compare moving directions
00DC8E  1               
00DC8E  1               DoEnemySideCheck:
00DC8E  1  B5 CF                  lda Enemy_Y_Position,x     ;if enemy within status bar, branch to leave
00DC90  1  C9 20                  cmp #$20                   ;because there's nothing there that impedes movement
00DC92  1  90 1F                  bcc ExESdeC
00DC94  1  A0 16                  ldy #$16                   ;start by finding block to the left of enemy ($00,$14)
00DC96  1  A9 02                  lda #$02                   ;set value here in what is also used as
00DC98  1  85 EB                  sta $eb                    ;OAM data offset
00DC9A  1  A5 EB        SdeCLoop: lda $eb                    ;check value
00DC9C  1  D5 46                  cmp Enemy_MovingDir,x      ;compare value against moving direction
00DC9E  1  D0 0C                  bne NextSdeC               ;branch if different and do not seek block there
00DCA0  1  A9 01                  lda #$01                   ;set flag in A for save horizontal coordinate
00DCA2  1  20 18 DF               jsr BlockBufferChk_Enemy   ;find block to left or right of enemy object
00DCA5  1  F0 05                  beq NextSdeC               ;if nothing found, branch
00DCA7  1  20 45 DD               jsr ChkForNonSolids        ;check for non-solid blocks
00DCAA  1  D0 08                  bne ChkForBump_HammerBroJ  ;branch if not found
00DCAC  1  C6 EB        NextSdeC: dec $eb                    ;move to the next direction
00DCAE  1  C8                     iny
00DCAF  1  C0 18                  cpy #$18                   ;increment Y, loop only if Y < $18, thus we check
00DCB1  1  90 E7                  bcc SdeCLoop               ;enemy ($00, $14) and ($10, $14) pixel coordinates
00DCB3  1  60           ExESdeC:  rts
00DCB4  1               
00DCB4  1               ChkForBump_HammerBroJ:
00DCB4  1  E0 05                cpx #$05               ;check if we're on the special use slot
00DCB6  1  F0 09                beq NoBump             ;and if so, branch ahead and do not play sound
00DCB8  1  B5 1E                lda Enemy_State,x      ;if enemy state d7 not set, branch
00DCBA  1  0A                   asl                    ;ahead and do not play sound
00DCBB  1  90 04                bcc NoBump
00DCBD  1  A9 02                lda #Sfx_Bump          ;otherwise, play bump sound
00DCBF  1  85 FF                sta Square1SoundQueue  ;sound will never be played if branching from ChkForRedKoopa
00DCC1  1  B5 16        NoBump: lda Enemy_ID,x         ;check for hammer bro
00DCC3  1  C9 05                cmp #$05
00DCC5  1  D0 09                bne InvEnemyDir        ;branch if not found
00DCC7  1  A9 00                lda #$00
00DCC9  1  85 00                sta $00                ;initialize value here for bitmask
00DCCB  1  A0 FA                ldy #$fa               ;load default vertical speed for jumping
00DCCD  1  4C 42 C7             jmp SetHJ              ;jump to code that makes hammer bro jump
00DCD0  1               
00DCD0  1               InvEnemyDir:
00DCD0  1  4C 29 D7           jmp RXSpd     ;jump to turn the enemy around
00DCD3  1               
00DCD3  1               ;--------------------------------
00DCD3  1               ;$00 - used to hold horizontal difference between player and enemy
00DCD3  1               
00DCD3  1               PlayerEnemyDiff:
00DCD3  1  B5 87              lda Enemy_X_Position,x  ;get distance between enemy object's
00DCD5  1  38                 sec                     ;horizontal coordinate and the player's
00DCD6  1  E5 86              sbc Player_X_Position   ;horizontal coordinate
00DCD8  1  85 00              sta $00                 ;and store here
00DCDA  1  B5 6E              lda Enemy_PageLoc,x
00DCDC  1  E5 6D              sbc Player_PageLoc      ;subtract borrow, then leave
00DCDE  1  60                 rts
00DCDF  1               
00DCDF  1               ;--------------------------------
00DCDF  1               
00DCDF  1               EnemyLanding:
00DCDF  1  20 71 C1           jsr InitVStf            ;do something here to vertical speed and something else
00DCE2  1  B5 CF              lda Enemy_Y_Position,x
00DCE4  1  29 F0              and #%11110000          ;save high nybble of vertical coordinate, and
00DCE6  1  09 08              ora #%00001000          ;set d3, then store, probably used to set enemy object
00DCE8  1  95 CF              sta Enemy_Y_Position,x  ;neatly on whatever it's landing on
00DCEA  1  60                 rts
00DCEB  1               
00DCEB  1               SubtEnemyYPos:
00DCEB  1  B5 CF              lda Enemy_Y_Position,x  ;add 62 pixels to enemy object's
00DCED  1  18                 clc                     ;vertical coordinate
00DCEE  1  69 3E              adc #$3e
00DCF0  1  C9 44              cmp #$44                ;compare against a certain range
00DCF2  1  60                 rts                     ;and leave with flags set for conditional branch
00DCF3  1               
00DCF3  1               EnemyJump:
00DCF3  1  20 EB DC             jsr SubtEnemyYPos     ;do a sub here
00DCF6  1  90 1A                bcc DoSide            ;if enemy vertical coord + 62 < 68, branch to leave
00DCF8  1  B5 A0                lda Enemy_Y_Speed,x
00DCFA  1  18                   clc                   ;add two to vertical speed
00DCFB  1  69 02                adc #$02
00DCFD  1  C9 03                cmp #$03              ;if green paratroopa not falling, branch ahead
00DCFF  1  90 11                bcc DoSide
00DD01  1  20 3E DD             jsr ChkUnderEnemy     ;otherwise, check to see if green paratroopa is
00DD04  1  F0 0C                beq DoSide            ;standing on anything, then branch to same place if not
00DD06  1  20 45 DD             jsr ChkForNonSolids   ;check for non-solid blocks
00DD09  1  F0 07                beq DoSide            ;branch if found
00DD0B  1  20 DF DC             jsr EnemyLanding      ;change vertical coordinate and speed
00DD0E  1  A9 FD                lda #$fd
00DD10  1  95 A0                sta Enemy_Y_Speed,x   ;make the paratroopa jump again
00DD12  1  4C 8E DC     DoSide: jmp DoEnemySideCheck  ;check for horizontal blockage, then leave
00DD15  1               
00DD15  1               ;--------------------------------
00DD15  1               
00DD15  1               HammerBroBGColl:
00DD15  1  20 3E DD           jsr ChkUnderEnemy    ;check to see if hammer bro is standing on anything
00DD18  1  F0 1D              beq NoUnderHammerBro
00DD1A  1  C9 23              cmp #$23             ;check for blank metatile $23 and branch if not found
00DD1C  1  D0 08              bne UnderHammerBro
00DD1E  1               
00DD1E  1               KillEnemyAboveBlock:
00DD1E  1  20 88 D3           jsr ShellOrBlockDefeat  ;do this sub to kill enemy
00DD21  1  A9 FC              lda #$fc                ;alter vertical speed of enemy and leave
00DD23  1  95 A0              sta Enemy_Y_Speed,x
00DD25  1  60                 rts
00DD26  1               
00DD26  1               UnderHammerBro:
00DD26  1  BD 8A 07           lda EnemyFrameTimer,x ;check timer used by hammer bro
00DD29  1  D0 0C              bne NoUnderHammerBro  ;branch if not expired
00DD2B  1  B5 1E              lda Enemy_State,x
00DD2D  1  29 88              and #%10001000        ;save d7 and d3 from enemy state, nullify other bits
00DD2F  1  95 1E              sta Enemy_State,x     ;and store
00DD31  1  20 DF DC           jsr EnemyLanding      ;modify vertical coordinate, speed and something else
00DD34  1  4C 8E DC           jmp DoEnemySideCheck  ;then check for horizontal blockage and leave
00DD37  1               
00DD37  1               NoUnderHammerBro:
00DD37  1  B5 1E              lda Enemy_State,x  ;if hammer bro is not standing on anything, set d0
00DD39  1  09 01              ora #$01           ;in the enemy state to indicate jumping or falling, then leave
00DD3B  1  95 1E              sta Enemy_State,x
00DD3D  1  60                 rts
00DD3E  1               
00DD3E  1               ChkUnderEnemy:
00DD3E  1  A9 00              lda #$00                  ;set flag in A for save vertical coordinate
00DD40  1  A0 15              ldy #$15                  ;set Y to check the bottom middle (8,18) of enemy object
00DD42  1  4C 18 DF           jmp BlockBufferChk_Enemy  ;hop to it!
00DD45  1               
00DD45  1               ChkForNonSolids:
00DD45  1  C9 26               cmp #$26       ;blank metatile used for vines?
00DD47  1  F0 0E               beq NSFnd
00DD49  1  C9 C2               cmp #$c2       ;regular coin?
00DD4B  1  F0 0A               beq NSFnd
00DD4D  1  C9 C3               cmp #$c3       ;underwater coin?
00DD4F  1  F0 06               beq NSFnd
00DD51  1  C9 5F               cmp #$5f       ;hidden coin block?
00DD53  1  F0 02               beq NSFnd
00DD55  1  C9 60               cmp #$60       ;hidden 1-up block?
00DD57  1  60           NSFnd: rts
00DD58  1               
00DD58  1               ;-------------------------------------------------------------------------------------
00DD58  1               
00DD58  1               FireballBGCollision:
00DD58  1  B5 D5              lda Fireball_Y_Position,x   ;check fireball's vertical coordinate
00DD5A  1  C9 18              cmp #$18
00DD5C  1  90 21              bcc ClearBounceFlag         ;if within the status bar area of the screen, branch ahead
00DD5E  1  20 2C DF           jsr BlockBufferChk_FBall    ;do fireball to background collision detection on bottom of it
00DD61  1  F0 1C              beq ClearBounceFlag         ;if nothing underneath fireball, branch
00DD63  1  20 45 DD           jsr ChkForNonSolids         ;check for non-solid metatiles
00DD66  1  F0 17              beq ClearBounceFlag         ;branch if any found
00DD68  1  B5 A6              lda Fireball_Y_Speed,x      ;if fireball's vertical speed set to move upwards,
00DD6A  1  30 18              bmi InitFireballExplode     ;branch to set exploding bit in fireball's state
00DD6C  1  B5 3A              lda FireballBouncingFlag,x  ;if bouncing flag already set,
00DD6E  1  D0 14              bne InitFireballExplode     ;branch to set exploding bit in fireball's state
00DD70  1  A9 FD              lda #$fd
00DD72  1  95 A6              sta Fireball_Y_Speed,x      ;otherwise set vertical speed to move upwards (give it bounce)
00DD74  1  A9 01              lda #$01
00DD76  1  95 3A              sta FireballBouncingFlag,x  ;set bouncing flag
00DD78  1  B5 D5              lda Fireball_Y_Position,x
00DD7A  1  29 F8              and #$f8                    ;modify vertical coordinate to land it properly
00DD7C  1  95 D5              sta Fireball_Y_Position,x   ;store as new vertical coordinate
00DD7E  1  60                 rts                         ;leave
00DD7F  1               
00DD7F  1               ClearBounceFlag:
00DD7F  1  A9 00              lda #$00
00DD81  1  95 3A              sta FireballBouncingFlag,x  ;clear bouncing flag by default
00DD83  1  60                 rts                         ;leave
00DD84  1               
00DD84  1               InitFireballExplode:
00DD84  1  A9 80              lda #$80
00DD86  1  95 24              sta Fireball_State,x        ;set exploding flag in fireball's state
00DD88  1  A9 02              lda #Sfx_Bump
00DD8A  1  85 FF              sta Square1SoundQueue       ;load bump sound
00DD8C  1  60                 rts                         ;leave
00DD8D  1               
00DD8D  1               ;-------------------------------------------------------------------------------------
00DD8D  1               ;$00 - used to hold one of bitmasks, or offset
00DD8D  1               ;$01 - used for relative X coordinate, also used to store middle screen page location
00DD8D  1               ;$02 - used for relative Y coordinate, also used to store middle screen coordinate
00DD8D  1               
00DD8D  1               ;this data added to relative coordinates of sprite objects
00DD8D  1               ;stored in order: left edge, top edge, right edge, bottom edge
00DD8D  1               BoundBoxCtrlData:
00DD8D  1  02 08 0E 20        .byte $02, $08, $0e, $20
00DD91  1  03 14 0D 20        .byte $03, $14, $0d, $20
00DD95  1  02 14 0E 20        .byte $02, $14, $0e, $20
00DD99  1  02 09 0E 15        .byte $02, $09, $0e, $15
00DD9D  1  00 00 18 06        .byte $00, $00, $18, $06
00DDA1  1  00 00 20 0D        .byte $00, $00, $20, $0d
00DDA5  1  00 00 30 0D        .byte $00, $00, $30, $0d
00DDA9  1  00 00 08 08        .byte $00, $00, $08, $08
00DDAD  1  06 04 0A 08        .byte $06, $04, $0a, $08
00DDB1  1  03 0E 0D 14        .byte $03, $0e, $0d, $14
00DDB5  1  00 02 10 15        .byte $00, $02, $10, $15
00DDB9  1  04 04 0C 1C        .byte $04, $04, $0c, $1c
00DDBD  1               
00DDBD  1               GetFireballBoundBox:
00DDBD  1  8A                 txa         ;add seven bytes to offset
00DDBE  1  18                 clc         ;to use in routines as offset for fireball
00DDBF  1  69 07              adc #$07
00DDC1  1  AA                 tax
00DDC2  1  A0 02              ldy #$02    ;set offset for relative coordinates
00DDC4  1  D0 07              bne FBallB  ;unconditional branch
00DDC6  1               
00DDC6  1               GetMiscBoundBox:
00DDC6  1  8A                   txa                       ;add nine bytes to offset
00DDC7  1  18                   clc                       ;to use in routines as offset for misc object
00DDC8  1  69 09                adc #$09
00DDCA  1  AA                   tax
00DDCB  1  A0 06                ldy #$06                  ;set offset for relative coordinates
00DDCD  1  20 2C DE     FBallB: jsr BoundingBoxCore       ;get bounding box coordinates
00DDD0  1  4C 6E DE             jmp CheckRightScreenBBox  ;jump to handle any offscreen coordinates
00DDD3  1               
00DDD3  1               GetEnemyBoundBox:
00DDD3  1  A0 48              ldy #$48                 ;store bitmask here for now
00DDD5  1  84 00              sty $00
00DDD7  1  A0 44              ldy #$44                 ;store another bitmask here for now and jump
00DDD9  1  4C E2 DD           jmp GetMaskedOffScrBits
00DDDC  1               
00DDDC  1               SmallPlatformBoundBox:
00DDDC  1  A0 08              ldy #$08                 ;store bitmask here for now
00DDDE  1  84 00              sty $00
00DDE0  1  A0 04              ldy #$04                 ;store another bitmask here for now
00DDE2  1               
00DDE2  1               GetMaskedOffScrBits:
00DDE2  1  B5 87                lda Enemy_X_Position,x      ;get enemy object position relative
00DDE4  1  38                   sec                         ;to the left side of the screen
00DDE5  1  ED 1C 07             sbc ScreenLeft_X_Pos
00DDE8  1  85 01                sta $01                     ;store here
00DDEA  1  B5 6E                lda Enemy_PageLoc,x         ;subtract borrow from current page location
00DDEC  1  ED 1A 07             sbc ScreenLeft_PageLoc      ;of left side
00DDEF  1  30 06                bmi CMBits                  ;if enemy object is beyond left edge, branch
00DDF1  1  05 01                ora $01
00DDF3  1  F0 02                beq CMBits                  ;if precisely at the left edge, branch
00DDF5  1  A4 00                ldy $00                     ;if to the right of left edge, use value in $00 for A
00DDF7  1  98           CMBits: tya                         ;otherwise use contents of Y
00DDF8  1  2D D1 03             and Enemy_OffscreenBits     ;preserve bitwise whatever's in here
00DDFB  1  9D D8 03             sta EnemyOffscrBitsMasked,x ;save masked offscreen bits here
00DDFE  1  D0 19                bne MoveBoundBoxOffscreen   ;if anything set here, branch
00DE00  1  4C 0C DE             jmp SetupEOffsetFBBox       ;otherwise, do something else
00DE03  1               
00DE03  1               LargePlatformBoundBox:
00DE03  1  E8                 inx                        ;increment X to get the proper offset
00DE04  1  20 66 ED           jsr GetXOffscreenBits      ;then jump directly to the sub for horizontal offscreen bits
00DE07  1  CA                 dex                        ;decrement to return to original offset
00DE08  1  C9 FE              cmp #$fe                   ;if completely offscreen, branch to put entire bounding
00DE0A  1  B0 0D              bcs MoveBoundBoxOffscreen  ;box offscreen, otherwise start getting coordinates
00DE0C  1               
00DE0C  1               SetupEOffsetFBBox:
00DE0C  1  8A                 txa                        ;add 1 to offset to properly address
00DE0D  1  18                 clc                        ;the enemy object memory locations
00DE0E  1  69 01              adc #$01
00DE10  1  AA                 tax
00DE11  1  A0 01              ldy #$01                   ;load 1 as offset here, same reason
00DE13  1  20 2C DE           jsr BoundingBoxCore        ;do a sub to get the coordinates of the bounding box
00DE16  1  4C 6E DE           jmp CheckRightScreenBBox   ;jump to handle offscreen coordinates of bounding box
00DE19  1               
00DE19  1               MoveBoundBoxOffscreen:
00DE19  1  8A                 txa                            ;multiply offset by 4
00DE1A  1  0A                 asl
00DE1B  1  0A                 asl
00DE1C  1  A8                 tay                            ;use as offset here
00DE1D  1  A9 FF              lda #$ff
00DE1F  1  99 B0 04           sta EnemyBoundingBoxCoord,y    ;load value into four locations here and leave
00DE22  1  99 B1 04           sta EnemyBoundingBoxCoord+1,y
00DE25  1  99 B2 04           sta EnemyBoundingBoxCoord+2,y
00DE28  1  99 B3 04           sta EnemyBoundingBoxCoord+3,y
00DE2B  1  60                 rts
00DE2C  1               
00DE2C  1               BoundingBoxCore:
00DE2C  1  86 00              stx $00                     ;save offset here
00DE2E  1  B9 B8 03           lda SprObject_Rel_YPos,y    ;store object coordinates relative to screen
00DE31  1  85 02              sta $02                     ;vertically and horizontally, respectively
00DE33  1  B9 AD 03           lda SprObject_Rel_XPos,y
00DE36  1  85 01              sta $01
00DE38  1  8A                 txa                         ;multiply offset by four and save to stack
00DE39  1  0A                 asl
00DE3A  1  0A                 asl
00DE3B  1  48                 pha
00DE3C  1  A8                 tay                         ;use as offset for Y, X is left alone
00DE3D  1  BD 99 04           lda SprObj_BoundBoxCtrl,x   ;load value here to be used as offset for X
00DE40  1  0A                 asl                         ;multiply that by four and use as X
00DE41  1  0A                 asl
00DE42  1  AA                 tax
00DE43  1  A5 01              lda $01                     ;add the first number in the bounding box data to the
00DE45  1  18                 clc                         ;relative horizontal coordinate using enemy object offset
00DE46  1  7D 8D DD           adc BoundBoxCtrlData,x      ;and store somewhere using same offset * 4
00DE49  1  99 AC 04           sta BoundingBox_UL_Corner,y ;store here
00DE4C  1  A5 01              lda $01
00DE4E  1  18                 clc
00DE4F  1  7D 8F DD           adc BoundBoxCtrlData+2,x    ;add the third number in the bounding box data to the
00DE52  1  99 AE 04           sta BoundingBox_LR_Corner,y ;relative horizontal coordinate and store
00DE55  1  E8                 inx                         ;increment both offsets
00DE56  1  C8                 iny
00DE57  1  A5 02              lda $02                     ;add the second number to the relative vertical coordinate
00DE59  1  18                 clc                         ;using incremented offset and store using the other
00DE5A  1  7D 8D DD           adc BoundBoxCtrlData,x      ;incremented offset
00DE5D  1  99 AC 04           sta BoundingBox_UL_Corner,y
00DE60  1  A5 02              lda $02
00DE62  1  18                 clc
00DE63  1  7D 8F DD           adc BoundBoxCtrlData+2,x    ;add the fourth number to the relative vertical coordinate
00DE66  1  99 AE 04           sta BoundingBox_LR_Corner,y ;and store
00DE69  1  68                 pla                         ;get original offset loaded into $00 * y from stack
00DE6A  1  A8                 tay                         ;use as Y
00DE6B  1  A6 00              ldx $00                     ;get original offset and use as X again
00DE6D  1  60                 rts
00DE6E  1               
00DE6E  1               CheckRightScreenBBox:
00DE6E  1  AD 1C 07            lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
00DE71  1  18                  clc                        ;and store as horizontal coordinate of middle
00DE72  1  69 80               adc #$80
00DE74  1  85 02               sta $02
00DE76  1  AD 1A 07            lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
00DE79  1  69 00               adc #$00                   ;and store as page location of middle
00DE7B  1  85 01               sta $01
00DE7D  1  B5 86               lda SprObject_X_Position,x ;get horizontal coordinate
00DE7F  1  C5 02               cmp $02                    ;compare against middle horizontal coordinate
00DE81  1  B5 6D               lda SprObject_PageLoc,x    ;get page location
00DE83  1  E5 01               sbc $01                    ;subtract from middle page location
00DE85  1  90 15               bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
00DE87  1  B9 AE 04            lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
00DE8A  1  30 0D               bmi NoOfs                  ;coordinates, branch if still on the screen
00DE8C  1  A9 FF               lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
00DE8E  1  BE AC 04            ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
00DE91  1  30 03               bmi SORte                  ;coordinates, and branch if still on the screen
00DE93  1  99 AC 04            sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
00DE96  1  99 AE 04     SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
00DE99  1  A6 08        NoOfs: ldx ObjectOffset           ;get object offset and leave
00DE9B  1  60                  rts
00DE9C  1               
00DE9C  1               CheckLeftScreenBBox:
00DE9C  1  B9 AC 04             lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
00DE9F  1  10 11                bpl NoOfs2                 ;coordinates, and branch if still on the screen
00DEA1  1  C9 A0                cmp #$a0                   ;check to see if left-side edge is in the middle of the
00DEA3  1  90 0D                bcc NoOfs2                 ;screen or really offscreen, and branch if still on
00DEA5  1  A9 00                lda #$00
00DEA7  1  BE AE 04             ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
00DEAA  1  10 03                bpl SOLft                  ;coordinates, branch if still onscreen
00DEAC  1  99 AE 04             sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
00DEAF  1  99 AC 04     SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
00DEB2  1  A6 08        NoOfs2: ldx ObjectOffset           ;get object offset and leave
00DEB4  1  60                   rts
00DEB5  1               
00DEB5  1               ;-------------------------------------------------------------------------------------
00DEB5  1               ;$06 - second object's offset
00DEB5  1               ;$07 - counter
00DEB5  1               
00DEB5  1               PlayerCollisionCore:
00DEB5  1  A2 00              ldx #$00     ;initialize X to use player's bounding box for comparison
00DEB7  1               
00DEB7  1               SprObjectCollisionCore:
00DEB7  1  84 06              sty $06      ;save contents of Y here
00DEB9  1  A9 01              lda #$01
00DEBB  1  85 07              sta $07      ;save value 1 here as counter, compare horizontal coordinates first
00DEBD  1               
00DEBD  1               CollisionCoreLoop:
00DEBD  1  B9 AC 04           lda BoundingBox_UL_Corner,y  ;compare left/top coordinates
00DEC0  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;of first and second objects' bounding boxes
00DEC3  1  B0 2A              bcs FirstBoxGreater          ;if first left/top => second, branch
00DEC5  1  DD AE 04           cmp BoundingBox_LR_Corner,x  ;otherwise compare to right/bottom of second
00DEC8  1  90 12              bcc SecondBoxVerticalChk     ;if first left/top < second right/bottom, branch elsewhere
00DECA  1  F0 42              beq CollisionFound           ;if somehow equal, collision, thus branch
00DECC  1  B9 AE 04           lda BoundingBox_LR_Corner,y  ;if somehow greater, check to see if bottom of
00DECF  1  D9 AC 04           cmp BoundingBox_UL_Corner,y  ;first object's bounding box is greater than its top
00DED2  1  90 3A              bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
00DED4  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;otherwise compare bottom of first bounding box to the top
00DED7  1  B0 35              bcs CollisionFound           ;of second box, and if equal or greater, collision, thus branch
00DED9  1  A4 06              ldy $06                      ;otherwise return with carry clear and Y = $0006
00DEDB  1  60                 rts                          ;note horizontal wrapping never occurs
00DEDC  1               
00DEDC  1               SecondBoxVerticalChk:
00DEDC  1  BD AE 04           lda BoundingBox_LR_Corner,x  ;check to see if the vertical bottom of the box
00DEDF  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;is greater than the vertical top
00DEE2  1  90 2A              bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
00DEE4  1  B9 AE 04           lda BoundingBox_LR_Corner,y  ;otherwise compare horizontal right or vertical bottom
00DEE7  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;of first box with horizontal left or vertical top of second box
00DEEA  1  B0 22              bcs CollisionFound           ;if equal or greater, collision, thus branch
00DEEC  1  A4 06              ldy $06                      ;otherwise return with carry clear and Y = $0006
00DEEE  1  60                 rts
00DEEF  1               
00DEEF  1               FirstBoxGreater:
00DEEF  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;compare first and second box horizontal left/vertical top again
00DEF2  1  F0 1A              beq CollisionFound           ;if first coordinate = second, collision, thus branch
00DEF4  1  DD AE 04           cmp BoundingBox_LR_Corner,x  ;if not, compare with second object right or bottom edge
00DEF7  1  90 15              bcc CollisionFound           ;if left/top of first less than or equal to right/bottom of second
00DEF9  1  F0 13              beq CollisionFound           ;then collision, thus branch
00DEFB  1  D9 AE 04           cmp BoundingBox_LR_Corner,y  ;otherwise check to see if top of first box is greater than bottom
00DEFE  1  90 0A              bcc NoCollisionFound         ;if less than or equal, no collision, branch to end
00DF00  1  F0 08              beq NoCollisionFound
00DF02  1  B9 AE 04           lda BoundingBox_LR_Corner,y  ;otherwise compare bottom of first to top of second
00DF05  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;if bottom of first is greater than top of second, vertical wrap
00DF08  1  B0 04              bcs CollisionFound           ;collision, and branch, otherwise, proceed onwards here
00DF0A  1               
00DF0A  1               NoCollisionFound:
00DF0A  1  18                 clc          ;clear carry, then load value set earlier, then leave
00DF0B  1  A4 06              ldy $06      ;like previous ones, if horizontal coordinates do not collide, we do
00DF0D  1  60                 rts          ;not bother checking vertical ones, because what's the point?
00DF0E  1               
00DF0E  1               CollisionFound:
00DF0E  1  E8                 inx                    ;increment offsets on both objects to check
00DF0F  1  C8                 iny                    ;the vertical coordinates
00DF10  1  C6 07              dec $07                ;decrement counter to reflect this
00DF12  1  10 A9              bpl CollisionCoreLoop  ;if counter not expired, branch to loop
00DF14  1  38                 sec                    ;otherwise we already did both sets, therefore collision, so set carry
00DF15  1  A4 06              ldy $06                ;load original value set here earlier, then leave
00DF17  1  60                 rts
00DF18  1               
00DF18  1               ;-------------------------------------------------------------------------------------
00DF18  1               ;$02 - modified y coordinate
00DF18  1               ;$03 - stores metatile involved in block buffer collisions
00DF18  1               ;$04 - comes in with offset to block buffer adder data, goes out with low nybble x/y coordinate
00DF18  1               ;$05 - modified x coordinate
00DF18  1               ;$06-$07 - block buffer address
00DF18  1               
00DF18  1               BlockBufferChk_Enemy:
00DF18  1  48                 pha        ;save contents of A to stack
00DF19  1  8A                 txa
00DF1A  1  18                 clc        ;add 1 to X to run sub with enemy offset in mind
00DF1B  1  69 01              adc #$01
00DF1D  1  AA                 tax
00DF1E  1  68                 pla        ;pull A from stack and jump elsewhere
00DF1F  1  4C 35 DF           jmp BBChk_E
00DF22  1               
00DF22  1               ResidualMiscObjectCode:
00DF22  1  8A                 txa
00DF23  1  18                 clc           ;supposedly used once to set offset for
00DF24  1  69 0D              adc #$0d      ;miscellaneous objects
00DF26  1  AA                 tax
00DF27  1  A0 1B              ldy #$1b      ;supposedly used once to set offset for block buffer data
00DF29  1  4C 33 DF           jmp ResJmpM   ;probably used in early stages to do misc to bg collision detection
00DF2C  1               
00DF2C  1               BlockBufferChk_FBall:
00DF2C  1  A0 1A                 ldy #$1a                  ;set offset for block buffer adder data
00DF2E  1  8A                    txa
00DF2F  1  18                    clc
00DF30  1  69 07                 adc #$07                  ;add seven bytes to use
00DF32  1  AA                    tax
00DF33  1  A9 00        ResJmpM: lda #$00                  ;set A to return vertical coordinate
00DF35  1  20 80 DF     BBChk_E: jsr BlockBufferCollision  ;do collision detection subroutine for sprite object
00DF38  1  A6 08                 ldx ObjectOffset          ;get object offset
00DF3A  1  C9 00                 cmp #$00                  ;check to see if object bumped into anything
00DF3C  1  60                    rts
00DF3D  1               
00DF3D  1               BlockBufferAdderData:
00DF3D  1  00 07 0E           .byte $00, $07, $0e
00DF40  1               
00DF40  1               BlockBuffer_X_Adder:
00DF40  1  08 03 0C 02        .byte $08, $03, $0c, $02, $02, $0d, $0d, $08
00DF44  1  02 0D 0D 08  
00DF48  1  03 0C 02 02        .byte $03, $0c, $02, $02, $0d, $0d, $08, $03
00DF4C  1  0D 0D 08 03  
00DF50  1  0C 02 02 0D        .byte $0c, $02, $02, $0d, $0d, $08, $00, $10
00DF54  1  0D 08 00 10  
00DF58  1  04 14 04 04        .byte $04, $14, $04, $04
00DF5C  1               
00DF5C  1               BlockBuffer_Y_Adder:
00DF5C  1  04 20 20 08        .byte $04, $20, $20, $08, $18, $08, $18, $02
00DF60  1  18 08 18 02  
00DF64  1  20 20 08 18        .byte $20, $20, $08, $18, $08, $18, $12, $20
00DF68  1  08 18 12 20  
00DF6C  1  20 18 18 18        .byte $20, $18, $18, $18, $18, $18, $14, $14
00DF70  1  18 18 14 14  
00DF74  1  06 06 08 10        .byte $06, $06, $08, $10
00DF78  1               
00DF78  1               BlockBufferColli_Feet:
00DF78  1  C8                  iny            ;if branched here, increment to next set of adders
00DF79  1               
00DF79  1               BlockBufferColli_Head:
00DF79  1  A9 00               lda #$00       ;set flag to return vertical coordinate
00DF7B  1  2C                  .byte $2c        ;BIT instruction opcode
00DF7C  1               
00DF7C  1               BlockBufferColli_Side:
00DF7C  1  A9 01               lda #$01       ;set flag to return horizontal coordinate
00DF7E  1  A2 00               ldx #$00       ;set offset for player object
00DF80  1               
00DF80  1               BlockBufferCollision:
00DF80  1  48                  pha                         ;save contents of A to stack
00DF81  1  84 04               sty $04                     ;save contents of Y here
00DF83  1  B9 40 DF            lda BlockBuffer_X_Adder,y   ;add horizontal coordinate
00DF86  1  18                  clc                         ;of object to value obtained using Y as offset
00DF87  1  75 86               adc SprObject_X_Position,x
00DF89  1  85 05               sta $05                     ;store here
00DF8B  1  B5 6D               lda SprObject_PageLoc,x
00DF8D  1  69 00               adc #$00                    ;add carry to page location
00DF8F  1  29 01               and #$01                    ;get LSB, mask out all other bits
00DF91  1  4A                  lsr                         ;move to carry
00DF92  1  05 05               ora $05                     ;get stored value
00DF94  1  6A                  ror                         ;rotate carry to MSB of A
00DF95  1  4A                  lsr                         ;and effectively move high nybble to
00DF96  1  4A                  lsr                         ;lower, LSB which became MSB will be
00DF97  1  4A                  lsr                         ;d4 at this point
00DF98  1  20 3E EE            jsr GetBlockBufferAddr      ;get address of block buffer into $06, $07
00DF9B  1  A4 04               ldy $04                     ;get old contents of Y
00DF9D  1  B5 CE               lda SprObject_Y_Position,x  ;get vertical coordinate of object
00DF9F  1  18                  clc
00DFA0  1  79 5C DF            adc BlockBuffer_Y_Adder,y   ;add it to value obtained using Y as offset
00DFA3  1  29 F0               and #%11110000              ;mask out low nybble
00DFA5  1  38                  sec
00DFA6  1  E9 20               sbc #$20                    ;subtract 32 pixels for the status bar
00DFA8  1  85 02               sta $02                     ;store result here
00DFAA  1  A8                  tay                         ;use as offset for block buffer
00DFAB  1  B1 06               lda ($06),y                 ;check current content of block buffer
00DFAD  1  85 03               sta $03                     ;and store here
00DFAF  1  A4 04               ldy $04                     ;get old contents of Y again
00DFB1  1  68                  pla                         ;pull A from stack
00DFB2  1  D0 05               bne RetXC                   ;if A = 1, branch
00DFB4  1  B5 CE               lda SprObject_Y_Position,x  ;if A = 0, load vertical coordinate
00DFB6  1  4C BB DF            jmp RetYC                   ;and jump
00DFB9  1  B5 86        RetXC: lda SprObject_X_Position,x  ;otherwise load horizontal coordinate
00DFBB  1  29 0F        RetYC: and #%00001111              ;and mask out high nybble
00DFBD  1  85 04               sta $04                     ;store masked out result here
00DFBF  1  A5 03               lda $03                     ;get saved content of block buffer
00DFC1  1  60                  rts                         ;and leave
00DFC2  1               
00DFC2  1               ;-------------------------------------------------------------------------------------
00DFC2  1               
00DFC2  1               ;unused byte
00DFC2  1  FF                 .byte $ff
00DFC3  1               
00DFC3  1               ;-------------------------------------------------------------------------------------
00DFC3  1               ;$00 - offset to vine Y coordinate adder
00DFC3  1               ;$02 - offset to sprite data
00DFC3  1               
00DFC3  1               VineYPosAdder:
00DFC3  1  00 30              .byte $00, $30
00DFC5  1               
00DFC5  1               DrawVine:
00DFC5  1  84 00                 sty $00                    ;save offset here
00DFC7  1  AD B9 03              lda Enemy_Rel_YPos         ;get relative vertical coordinate
00DFCA  1  18                    clc
00DFCB  1  79 C3 DF              adc VineYPosAdder,y        ;add value using offset in Y to get value
00DFCE  1  BE 9A 03              ldx VineObjOffset,y        ;get offset to vine
00DFD1  1  BC E5 06              ldy Enemy_SprDataOffset,x  ;get sprite data offset
00DFD4  1  84 02                 sty $02                    ;store sprite data offset here
00DFD6  1  20 3E E0              jsr SixSpriteStacker       ;stack six sprites on top of each other vertically
00DFD9  1  AD AE 03              lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00DFDC  1  99 03 02              sta Sprite_X_Position,y    ;store in first, third and fifth sprites
00DFDF  1  99 0B 02              sta Sprite_X_Position+8,y
00DFE2  1  99 13 02              sta Sprite_X_Position+16,y
00DFE5  1  18                    clc
00DFE6  1  69 06                 adc #$06                   ;add six pixels to second, fourth and sixth sprites
00DFE8  1  99 07 02              sta Sprite_X_Position+4,y  ;to give characteristic staggered vine shape to
00DFEB  1  99 0F 02              sta Sprite_X_Position+12,y ;our vertical stack of sprites
00DFEE  1  99 17 02              sta Sprite_X_Position+20,y
00DFF1  1  A9 21                 lda #%00100001             ;set bg priority and palette attribute bits
00DFF3  1  99 02 02              sta Sprite_Attributes,y    ;set in first, third and fifth sprites
00DFF6  1  99 0A 02              sta Sprite_Attributes+8,y
00DFF9  1  99 12 02              sta Sprite_Attributes+16,y
00DFFC  1  09 40                 ora #%01000000             ;additionally, set horizontal flip bit
00DFFE  1  99 06 02              sta Sprite_Attributes+4,y  ;for second, fourth and sixth sprites
00E001  1  99 0E 02              sta Sprite_Attributes+12,y
00E004  1  99 16 02              sta Sprite_Attributes+20,y
00E007  1  A2 05                 ldx #$05                   ;set tiles for six sprites
00E009  1  A9 E1        VineTL:  lda #$e1                   ;set tile number for sprite
00E00B  1  99 01 02              sta Sprite_Tilenumber,y
00E00E  1  C8                    iny                        ;move offset to next sprite data
00E00F  1  C8                    iny
00E010  1  C8                    iny
00E011  1  C8                    iny
00E012  1  CA                    dex                        ;move onto next sprite
00E013  1  10 F4                 bpl VineTL                 ;loop until all sprites are done
00E015  1  A4 02                 ldy $02                    ;get original offset
00E017  1  A5 00                 lda $00                    ;get offset to vine adding data
00E019  1  D0 05                 bne SkpVTop                ;if offset not zero, skip this part
00E01B  1  A9 E0                 lda #$e0
00E01D  1  99 01 02              sta Sprite_Tilenumber,y    ;set other tile number for top of vine
00E020  1  A2 00        SkpVTop: ldx #$00                   ;start with the first sprite again
00E022  1  AD 9D 03     ChkFTop: lda VineStart_Y_Position   ;get original starting vertical coordinate
00E025  1  38                    sec
00E026  1  F9 00 02              sbc Sprite_Y_Position,y    ;subtract top-most sprite's Y coordinate
00E029  1  C9 64                 cmp #$64                   ;if two coordinates are less than 100/$64 pixels
00E02B  1  90 05                 bcc NextVSp                ;apart, skip this to leave sprite alone
00E02D  1  A9 F8                 lda #$f8
00E02F  1  99 00 02              sta Sprite_Y_Position,y    ;otherwise move sprite offscreen
00E032  1  C8           NextVSp: iny                        ;move offset to next OAM data
00E033  1  C8                    iny
00E034  1  C8                    iny
00E035  1  C8                    iny
00E036  1  E8                    inx                        ;move onto next sprite
00E037  1  E0 06                 cpx #$06                   ;do this until all sprites are checked
00E039  1  D0 E7                 bne ChkFTop
00E03B  1  A4 00                 ldy $00                    ;return offset set earlier
00E03D  1  60                    rts
00E03E  1               
00E03E  1               SixSpriteStacker:
00E03E  1  A2 06               ldx #$06           ;do six sprites
00E040  1  99 00 02     StkLp: sta Sprite_Data,y  ;store X or Y coordinate into OAM data
00E043  1  18                  clc
00E044  1  69 08               adc #$08           ;add eight pixels
00E046  1  C8                  iny
00E047  1  C8                  iny                ;move offset four bytes forward
00E048  1  C8                  iny
00E049  1  C8                  iny
00E04A  1  CA                  dex                ;do another sprite
00E04B  1  D0 F3               bne StkLp          ;do this until all sprites are done
00E04D  1  A4 02               ldy $02            ;get saved OAM data offset and leave
00E04F  1  60                  rts
00E050  1               
00E050  1               ;-------------------------------------------------------------------------------------
00E050  1               
00E050  1               FirstSprXPos:
00E050  1  04 00 04 00        .byte $04, $00, $04, $00
00E054  1               
00E054  1               FirstSprYPos:
00E054  1  00 04 00 04        .byte $00, $04, $00, $04
00E058  1               
00E058  1               SecondSprXPos:
00E058  1  00 08 00 08        .byte $00, $08, $00, $08
00E05C  1               
00E05C  1               SecondSprYPos:
00E05C  1  08 00 08 00        .byte $08, $00, $08, $00
00E060  1               
00E060  1               FirstSprTilenum:
00E060  1  80 82 81 83        .byte $80, $82, $81, $83
00E064  1               
00E064  1               SecondSprTilenum:
00E064  1  81 83 80 82        .byte $81, $83, $80, $82
00E068  1               
00E068  1               HammerSprAttrib:
00E068  1  03 03 C3 C3        .byte $03, $03, $c3, $c3
00E06C  1               
00E06C  1               DrawHammer:
00E06C  1  BC F3 06                 ldy Misc_SprDataOffset,x    ;get misc object OAM data offset
00E06F  1  AD 47 07                 lda TimerControl
00E072  1  D0 08                    bne ForceHPose              ;if master timer control set, skip this part
00E074  1  B5 2A                    lda Misc_State,x            ;otherwise get hammer's state
00E076  1  29 7F                    and #%01111111              ;mask out d7
00E078  1  C9 01                    cmp #$01                    ;check to see if set to 1 yet
00E07A  1  F0 04                    beq GetHPose                ;if so, branch
00E07C  1  A2 00        ForceHPose: ldx #$00                    ;reset offset here
00E07E  1  F0 07                    beq RenderH                 ;do unconditional branch to rendering part
00E080  1  A5 09        GetHPose:   lda FrameCounter            ;get frame counter
00E082  1  4A                       lsr                         ;move d3-d2 to d1-d0
00E083  1  4A                       lsr
00E084  1  29 03                    and #%00000011              ;mask out all but d1-d0 (changes every four frames)
00E086  1  AA                       tax                         ;use as timing offset
00E087  1  AD BE 03     RenderH:    lda Misc_Rel_YPos           ;get relative vertical coordinate
00E08A  1  18                       clc
00E08B  1  7D 54 E0                 adc FirstSprYPos,x          ;add first sprite vertical adder based on offset
00E08E  1  99 00 02                 sta Sprite_Y_Position,y     ;store as sprite Y coordinate for first sprite
00E091  1  18                       clc
00E092  1  7D 5C E0                 adc SecondSprYPos,x         ;add second sprite vertical adder based on offset
00E095  1  99 04 02                 sta Sprite_Y_Position+4,y   ;store as sprite Y coordinate for second sprite
00E098  1  AD B3 03                 lda Misc_Rel_XPos           ;get relative horizontal coordinate
00E09B  1  18                       clc
00E09C  1  7D 50 E0                 adc FirstSprXPos,x          ;add first sprite horizontal adder based on offset
00E09F  1  99 03 02                 sta Sprite_X_Position,y     ;store as sprite X coordinate for first sprite
00E0A2  1  18                       clc
00E0A3  1  7D 58 E0                 adc SecondSprXPos,x         ;add second sprite horizontal adder based on offset
00E0A6  1  99 07 02                 sta Sprite_X_Position+4,y   ;store as sprite X coordinate for second sprite
00E0A9  1  BD 60 E0                 lda FirstSprTilenum,x
00E0AC  1  99 01 02                 sta Sprite_Tilenumber,y     ;get and store tile number of first sprite
00E0AF  1  BD 64 E0                 lda SecondSprTilenum,x
00E0B2  1  99 05 02                 sta Sprite_Tilenumber+4,y   ;get and store tile number of second sprite
00E0B5  1  BD 68 E0                 lda HammerSprAttrib,x
00E0B8  1  99 02 02                 sta Sprite_Attributes,y     ;get and store attribute bytes for both
00E0BB  1  99 06 02                 sta Sprite_Attributes+4,y   ;note in this case they use the same data
00E0BE  1  A6 08                    ldx ObjectOffset            ;get misc object offset
00E0C0  1  AD D6 03                 lda Misc_OffscreenBits
00E0C3  1  29 FC                    and #%11111100              ;check offscreen bits
00E0C5  1  F0 09                    beq NoHOffscr               ;if all bits clear, leave object alone
00E0C7  1  A9 00                    lda #$00
00E0C9  1  95 2A                    sta Misc_State,x            ;otherwise nullify misc object state
00E0CB  1  A9 F8                    lda #$f8
00E0CD  1  20 51 E1                 jsr DumpTwoSpr              ;do sub to move hammer sprites offscreen
00E0D0  1  60           NoHOffscr:  rts                         ;leave
00E0D1  1               
00E0D1  1               ;-------------------------------------------------------------------------------------
00E0D1  1               ;$00-$01 - used to hold tile numbers ($01 addressed in draw floatey number part)
00E0D1  1               ;$02 - used to hold Y coordinate for floatey number
00E0D1  1               ;$03 - residual byte used for flip (but value set here affects nothing)
00E0D1  1               ;$04 - attribute byte for floatey number
00E0D1  1               ;$05 - used as X coordinate for floatey number
00E0D1  1               
00E0D1  1               FlagpoleScoreNumTiles:
00E0D1  1  F9 50              .byte $f9, $50
00E0D3  1  F7 50              .byte $f7, $50
00E0D5  1  FA FB              .byte $fa, $fb
00E0D7  1  F8 FB              .byte $f8, $fb
00E0D9  1  F6 FB              .byte $f6, $fb
00E0DB  1               
00E0DB  1               FlagpoleGfxHandler:
00E0DB  1  BC E5 06           ldy Enemy_SprDataOffset,x      ;get sprite data offset for flagpole flag
00E0DE  1  AD AE 03           lda Enemy_Rel_XPos             ;get relative horizontal coordinate
00E0E1  1  99 03 02           sta Sprite_X_Position,y        ;store as X coordinate for first sprite
00E0E4  1  18                 clc
00E0E5  1  69 08              adc #$08                       ;add eight pixels and store
00E0E7  1  99 07 02           sta Sprite_X_Position+4,y      ;as X coordinate for second and third sprites
00E0EA  1  99 0B 02           sta Sprite_X_Position+8,y
00E0ED  1  18                 clc
00E0EE  1  69 0C              adc #$0c                       ;add twelve more pixels and
00E0F0  1  85 05              sta $05                        ;store here to be used later by floatey number
00E0F2  1  B5 CF              lda Enemy_Y_Position,x         ;get vertical coordinate
00E0F4  1  20 51 E1           jsr DumpTwoSpr                 ;and do sub to dump into first and second sprites
00E0F7  1  69 08              adc #$08                       ;add eight pixels
00E0F9  1  99 08 02           sta Sprite_Y_Position+8,y      ;and store into third sprite
00E0FC  1  AD 0D 01           lda FlagpoleFNum_Y_Pos         ;get vertical coordinate for floatey number
00E0FF  1  85 02              sta $02                        ;store it here
00E101  1  A9 01              lda #$01
00E103  1  85 03              sta $03                        ;set value for flip which will not be used, and
00E105  1  85 04              sta $04                        ;attribute byte for floatey number
00E107  1  99 02 02           sta Sprite_Attributes,y        ;set attribute bytes for all three sprites
00E10A  1  99 06 02           sta Sprite_Attributes+4,y
00E10D  1  99 0A 02           sta Sprite_Attributes+8,y
00E110  1  A9 7E              lda #$7e
00E112  1  99 01 02           sta Sprite_Tilenumber,y        ;put triangle shaped tile
00E115  1  99 09 02           sta Sprite_Tilenumber+8,y      ;into first and third sprites
00E118  1  A9 7F              lda #$7f
00E11A  1  99 05 02           sta Sprite_Tilenumber+4,y      ;put skull tile into second sprite
00E11D  1  AD 0F 07           lda FlagpoleCollisionYPos      ;get vertical coordinate at time of collision
00E120  1  F0 15              beq ChkFlagOffscreen           ;if zero, branch ahead
00E122  1  98                 tya
00E123  1  18                 clc                            ;add 12 bytes to sprite data offset
00E124  1  69 0C              adc #$0c
00E126  1  A8                 tay                            ;put back in Y
00E127  1  AD 0F 01           lda FlagpoleScore              ;get offset used to award points for touching flagpole
00E12A  1  0A                 asl                            ;multiply by 2 to get proper offset here
00E12B  1  AA                 tax
00E12C  1  BD D1 E0           lda FlagpoleScoreNumTiles,x    ;get appropriate tile data
00E12F  1  85 00              sta $00
00E131  1  BD D2 E0           lda FlagpoleScoreNumTiles+1,x
00E134  1  20 42 E7           jsr DrawOneSpriteRow           ;use it to render floatey number
00E137  1               
00E137  1               ChkFlagOffscreen:
00E137  1  A6 08              ldx ObjectOffset               ;get object offset for flag
00E139  1  BC E5 06           ldy Enemy_SprDataOffset,x      ;get OAM data offset
00E13C  1  AD D1 03           lda Enemy_OffscreenBits        ;get offscreen bits
00E13F  1  29 0E              and #%00001110                 ;mask out all but d3-d1
00E141  1  F0 14              beq ExitDumpSpr                ;if none of these bits set, branch to leave
00E143  1               
00E143  1               ;-------------------------------------------------------------------------------------
00E143  1               
00E143  1               MoveSixSpritesOffscreen:
00E143  1  A9 F8              lda #$f8                  ;set offscreen coordinate if jumping here
00E145  1               
00E145  1               DumpSixSpr:
00E145  1  99 14 02           sta Sprite_Data+20,y      ;dump A contents
00E148  1  99 10 02           sta Sprite_Data+16,y      ;into third row sprites
00E14B  1               
00E14B  1               DumpFourSpr:
00E14B  1  99 0C 02           sta Sprite_Data+12,y      ;into second row sprites
00E14E  1               
00E14E  1               DumpThreeSpr:
00E14E  1  99 08 02           sta Sprite_Data+8,y
00E151  1               
00E151  1               DumpTwoSpr:
00E151  1  99 04 02           sta Sprite_Data+4,y       ;and into first row sprites
00E154  1  99 00 02           sta Sprite_Data,y
00E157  1               
00E157  1               ExitDumpSpr:
00E157  1  60                 rts
00E158  1               
00E158  1               ;-------------------------------------------------------------------------------------
00E158  1               
00E158  1               DrawLargePlatform:
00E158  1  BC E5 06           ldy Enemy_SprDataOffset,x   ;get OAM data offset
00E15B  1  84 02              sty $02                     ;store here
00E15D  1  C8                 iny                         ;add 3 to it for offset
00E15E  1  C8                 iny                         ;to X coordinate
00E15F  1  C8                 iny
00E160  1  AD AE 03           lda Enemy_Rel_XPos          ;get horizontal relative coordinate
00E163  1  20 3E E0           jsr SixSpriteStacker        ;store X coordinates using A as base, stack horizontally
00E166  1  A6 08              ldx ObjectOffset
00E168  1  B5 CF              lda Enemy_Y_Position,x      ;get vertical coordinate
00E16A  1  20 4B E1           jsr DumpFourSpr             ;dump into first four sprites as Y coordinate
00E16D  1  AC 4E 07           ldy AreaType
00E170  1  C0 03              cpy #$03                    ;check for castle-type level
00E172  1  F0 05              beq ShrinkPlatform
00E174  1  AC CC 06           ldy SecondaryHardMode       ;check for secondary hard mode flag set
00E177  1  F0 02              beq SetLast2Platform        ;branch if not set elsewhere
00E179  1               
00E179  1               ShrinkPlatform:
00E179  1  A9 F8              lda #$f8                    ;load offscreen coordinate if flag set or castle-type level
00E17B  1               
00E17B  1               SetLast2Platform:
00E17B  1  BC E5 06           ldy Enemy_SprDataOffset,x   ;get OAM data offset
00E17E  1  99 10 02           sta Sprite_Y_Position+16,y  ;store vertical coordinate or offscreen
00E181  1  99 14 02           sta Sprite_Y_Position+20,y  ;coordinate into last two sprites as Y coordinate
00E184  1  A9 5B              lda #$5b                    ;load default tile for platform (girder)
00E186  1  AE 43 07           ldx CloudTypeOverride
00E189  1  F0 02              beq SetPlatformTilenum      ;if cloud level override flag not set, use
00E18B  1  A9 75              lda #$75                    ;otherwise load other tile for platform (puff)
00E18D  1               
00E18D  1               SetPlatformTilenum:
00E18D  1  A6 08                ldx ObjectOffset            ;get enemy object buffer offset
00E18F  1  C8                   iny                         ;increment Y for tile offset
00E190  1  20 45 E1             jsr DumpSixSpr              ;dump tile number into all six sprites
00E193  1  A9 02                lda #$02                    ;set palette controls
00E195  1  C8                   iny                         ;increment Y for sprite attributes
00E196  1  20 45 E1             jsr DumpSixSpr              ;dump attributes into all six sprites
00E199  1  E8                   inx                         ;increment X for enemy objects
00E19A  1  20 66 ED             jsr GetXOffscreenBits       ;get offscreen bits again
00E19D  1  CA                   dex
00E19E  1  BC E5 06             ldy Enemy_SprDataOffset,x   ;get OAM data offset
00E1A1  1  0A                   asl                         ;rotate d7 into carry, save remaining
00E1A2  1  48                   pha                         ;bits to the stack
00E1A3  1  90 05                bcc SChk2
00E1A5  1  A9 F8                lda #$f8                    ;if d7 was set, move first sprite offscreen
00E1A7  1  99 00 02             sta Sprite_Y_Position,y
00E1AA  1  68           SChk2:  pla                         ;get bits from stack
00E1AB  1  0A                   asl                         ;rotate d6 into carry
00E1AC  1  48                   pha                         ;save to stack
00E1AD  1  90 05                bcc SChk3
00E1AF  1  A9 F8                lda #$f8                    ;if d6 was set, move second sprite offscreen
00E1B1  1  99 04 02             sta Sprite_Y_Position+4,y
00E1B4  1  68           SChk3:  pla                         ;get bits from stack
00E1B5  1  0A                   asl                         ;rotate d5 into carry
00E1B6  1  48                   pha                         ;save to stack
00E1B7  1  90 05                bcc SChk4
00E1B9  1  A9 F8                lda #$f8                    ;if d5 was set, move third sprite offscreen
00E1BB  1  99 08 02             sta Sprite_Y_Position+8,y
00E1BE  1  68           SChk4:  pla                         ;get bits from stack
00E1BF  1  0A                   asl                         ;rotate d4 into carry
00E1C0  1  48                   pha                         ;save to stack
00E1C1  1  90 05                bcc SChk5
00E1C3  1  A9 F8                lda #$f8                    ;if d4 was set, move fourth sprite offscreen
00E1C5  1  99 0C 02             sta Sprite_Y_Position+12,y
00E1C8  1  68           SChk5:  pla                         ;get bits from stack
00E1C9  1  0A                   asl                         ;rotate d3 into carry
00E1CA  1  48                   pha                         ;save to stack
00E1CB  1  90 05                bcc SChk6
00E1CD  1  A9 F8                lda #$f8                    ;if d3 was set, move fifth sprite offscreen
00E1CF  1  99 10 02             sta Sprite_Y_Position+16,y
00E1D2  1  68           SChk6:  pla                         ;get bits from stack
00E1D3  1  0A                   asl                         ;rotate d2 into carry
00E1D4  1  90 05                bcc SLChk                   ;save to stack
00E1D6  1  A9 F8                lda #$f8
00E1D8  1  99 14 02             sta Sprite_Y_Position+20,y  ;if d2 was set, move sixth sprite offscreen
00E1DB  1  AD D1 03     SLChk:  lda Enemy_OffscreenBits     ;check d7 of offscreen bits
00E1DE  1  0A                   asl                         ;and if d7 is not set, skip sub
00E1DF  1  90 03                bcc ExDLPl
00E1E1  1  20 43 E1             jsr MoveSixSpritesOffscreen ;otherwise branch to move all sprites offscreen
00E1E4  1  60           ExDLPl: rts
00E1E5  1               
00E1E5  1               ;-------------------------------------------------------------------------------------
00E1E5  1               
00E1E5  1               DrawFloateyNumber_Coin:
00E1E5  1  A5 09                  lda FrameCounter          ;get frame counter
00E1E7  1  4A                     lsr                       ;divide by 2
00E1E8  1  B0 02                  bcs NotRsNum              ;branch if d0 not set to raise number every other frame
00E1EA  1  D6 DB                  dec Misc_Y_Position,x     ;otherwise, decrement vertical coordinate
00E1EC  1  B5 DB        NotRsNum: lda Misc_Y_Position,x     ;get vertical coordinate
00E1EE  1  20 51 E1               jsr DumpTwoSpr            ;dump into both sprites
00E1F1  1  AD B3 03               lda Misc_Rel_XPos         ;get relative horizontal coordinate
00E1F4  1  99 03 02               sta Sprite_X_Position,y   ;store as X coordinate for first sprite
00E1F7  1  18                     clc
00E1F8  1  69 08                  adc #$08                  ;add eight pixels
00E1FA  1  99 07 02               sta Sprite_X_Position+4,y ;store as X coordinate for second sprite
00E1FD  1  A9 02                  lda #$02
00E1FF  1  99 02 02               sta Sprite_Attributes,y   ;store attribute byte in both sprites
00E202  1  99 06 02               sta Sprite_Attributes+4,y
00E205  1  A9 F7                  lda #$f7
00E207  1  99 01 02               sta Sprite_Tilenumber,y   ;put tile numbers into both sprites
00E20A  1  A9 FB                  lda #$fb                  ;that resemble "200"
00E20C  1  99 05 02               sta Sprite_Tilenumber+4,y
00E20F  1  4C 4D E2               jmp ExJCGfx               ;then jump to leave (why not an rts here instead?)
00E212  1               
00E212  1               JumpingCoinTiles:
00E212  1  60 61 62 63        .byte $60, $61, $62, $63
00E216  1               
00E216  1               JCoinGfxHandler:
00E216  1  BC F3 06              ldy Misc_SprDataOffset,x    ;get coin/floatey number's OAM data offset
00E219  1  B5 2A                 lda Misc_State,x            ;get state of misc object
00E21B  1  C9 02                 cmp #$02                    ;if 2 or greater,
00E21D  1  B0 C6                 bcs DrawFloateyNumber_Coin  ;branch to draw floatey number
00E21F  1  B5 DB                 lda Misc_Y_Position,x       ;store vertical coordinate as
00E221  1  99 00 02              sta Sprite_Y_Position,y     ;Y coordinate for first sprite
00E224  1  18                    clc
00E225  1  69 08                 adc #$08                    ;add eight pixels
00E227  1  99 04 02              sta Sprite_Y_Position+4,y   ;store as Y coordinate for second sprite
00E22A  1  AD B3 03              lda Misc_Rel_XPos           ;get relative horizontal coordinate
00E22D  1  99 03 02              sta Sprite_X_Position,y
00E230  1  99 07 02              sta Sprite_X_Position+4,y   ;store as X coordinate for first and second sprites
00E233  1  A5 09                 lda FrameCounter            ;get frame counter
00E235  1  4A                    lsr                         ;divide by 2 to alter every other frame
00E236  1  29 03                 and #%00000011              ;mask out d2-d1
00E238  1  AA                    tax                         ;use as graphical offset
00E239  1  BD 12 E2              lda JumpingCoinTiles,x      ;load tile number
00E23C  1  C8                    iny                         ;increment OAM data offset to write tile numbers
00E23D  1  20 51 E1              jsr DumpTwoSpr              ;do sub to dump tile number into both sprites
00E240  1  88                    dey                         ;decrement to get old offset
00E241  1  A9 02                 lda #$02
00E243  1  99 02 02              sta Sprite_Attributes,y     ;set attribute byte in first sprite
00E246  1  A9 82                 lda #$82
00E248  1  99 06 02              sta Sprite_Attributes+4,y   ;set attribute byte with vertical flip in second sprite
00E24B  1  A6 08                 ldx ObjectOffset            ;get misc object offset
00E24D  1  60           ExJCGfx: rts                         ;leave
00E24E  1               
00E24E  1               ;-------------------------------------------------------------------------------------
00E24E  1               ;$00-$01 - used to hold tiles for drawing the power-up, $00 also used to hold power-up type
00E24E  1               ;$02 - used to hold bottom row Y position
00E24E  1               ;$03 - used to hold flip control (not used here)
00E24E  1               ;$04 - used to hold sprite attributes
00E24E  1               ;$05 - used to hold X position
00E24E  1               ;$07 - counter
00E24E  1               
00E24E  1               ;tiles arranged in top left, right, bottom left, right order
00E24E  1               PowerUpGfxTable:
00E24E  1  76 77 78 79        .byte $76, $77, $78, $79 ;regular mushroom
00E252  1  D6 D6 D9 D9        .byte $d6, $d6, $d9, $d9 ;fire flower
00E256  1  8D 8D E4 E4        .byte $8d, $8d, $e4, $e4 ;star
00E25A  1  76 77 78 79        .byte $76, $77, $78, $79 ;1-up mushroom
00E25E  1               
00E25E  1               PowerUpAttributes:
00E25E  1  02 01 02 01        .byte $02, $01, $02, $01
00E262  1               
00E262  1               DrawPowerUp:
00E262  1  AC EA 06           ldy Enemy_SprDataOffset+5  ;get power-up's sprite data offset
00E265  1  AD B9 03           lda Enemy_Rel_YPos         ;get relative vertical coordinate
00E268  1  18                 clc
00E269  1  69 08              adc #$08                   ;add eight pixels
00E26B  1  85 02              sta $02                    ;store result here
00E26D  1  AD AE 03           lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00E270  1  85 05              sta $05                    ;store here
00E272  1  A6 39              ldx PowerUpType            ;get power-up type
00E274  1  BD 5E E2           lda PowerUpAttributes,x    ;get attribute data for power-up type
00E277  1  0D CA 03           ora Enemy_SprAttrib+5      ;add background priority bit if set
00E27A  1  85 04              sta $04                    ;store attributes here
00E27C  1  8A                 txa
00E27D  1  48                 pha                        ;save power-up type to the stack
00E27E  1  0A                 asl
00E27F  1  0A                 asl                        ;multiply by four to get proper offset
00E280  1  AA                 tax                        ;use as X
00E281  1  A9 01              lda #$01
00E283  1  85 07              sta $07                    ;set counter here to draw two rows of sprite object
00E285  1  85 03              sta $03                    ;init d1 of flip control
00E287  1               
00E287  1               PUpDrawLoop:
00E287  1  BD 4E E2             lda PowerUpGfxTable,x      ;load left tile of power-up object
00E28A  1  85 00                sta $00
00E28C  1  BD 4F E2             lda PowerUpGfxTable+1,x    ;load right tile
00E28F  1  20 42 E7             jsr DrawOneSpriteRow       ;branch to draw one row of our power-up object
00E292  1  C6 07                dec $07                    ;decrement counter
00E294  1  10 F1                bpl PUpDrawLoop            ;branch until two rows are drawn
00E296  1  AC EA 06             ldy Enemy_SprDataOffset+5  ;get sprite data offset again
00E299  1  68                   pla                        ;pull saved power-up type from the stack
00E29A  1  F0 2F                beq PUpOfs                 ;if regular mushroom, branch, do not change colors or flip
00E29C  1  C9 03                cmp #$03
00E29E  1  F0 2B                beq PUpOfs                 ;if 1-up mushroom, branch, do not change colors or flip
00E2A0  1  85 00                sta $00                    ;store power-up type here now
00E2A2  1  A5 09                lda FrameCounter           ;get frame counter
00E2A4  1  4A                   lsr                        ;divide by 2 to change colors every two frames
00E2A5  1  29 03                and #%00000011             ;mask out all but d1 and d0 (previously d2 and d1)
00E2A7  1  0D CA 03             ora Enemy_SprAttrib+5      ;add background priority bit if any set
00E2AA  1  99 02 02             sta Sprite_Attributes,y    ;set as new palette bits for top left and
00E2AD  1  99 06 02             sta Sprite_Attributes+4,y  ;top right sprites for fire flower and star
00E2B0  1  A6 00                ldx $00
00E2B2  1  CA                   dex                        ;check power-up type for fire flower
00E2B3  1  F0 06                beq FlipPUpRightSide       ;if found, skip this part
00E2B5  1  99 0A 02             sta Sprite_Attributes+8,y  ;otherwise set new palette bits  for bottom left
00E2B8  1  99 0E 02             sta Sprite_Attributes+12,y ;and bottom right sprites as well for star only
00E2BB  1               
00E2BB  1               FlipPUpRightSide:
00E2BB  1  B9 06 02             lda Sprite_Attributes+4,y
00E2BE  1  09 40                ora #%01000000             ;set horizontal flip bit for top right sprite
00E2C0  1  99 06 02             sta Sprite_Attributes+4,y
00E2C3  1  B9 0E 02             lda Sprite_Attributes+12,y
00E2C6  1  09 40                ora #%01000000             ;set horizontal flip bit for bottom right sprite
00E2C8  1  99 0E 02             sta Sprite_Attributes+12,y ;note these are only done for fire flower and star power-ups
00E2CB  1  4C F4 E6     PUpOfs: jmp SprObjectOffscrChk     ;jump to check to see if power-up is offscreen at all, then leave
00E2CE  1               
00E2CE  1               ;-------------------------------------------------------------------------------------
00E2CE  1               ;$00-$01 - used in DrawEnemyObjRow to hold sprite tile numbers
00E2CE  1               ;$02 - used to store Y position
00E2CE  1               ;$03 - used to store moving direction, used to flip enemies horizontally
00E2CE  1               ;$04 - used to store enemy's sprite attributes
00E2CE  1               ;$05 - used to store X position
00E2CE  1               ;$eb - used to hold sprite data offset
00E2CE  1               ;$ec - used to hold either altered enemy state or special value used in gfx handler as condition
00E2CE  1               ;$ed - used to hold enemy state from buffer
00E2CE  1               ;$ef - used to hold enemy code used in gfx handler (may or may not resemble Enemy_ID values)
00E2CE  1               
00E2CE  1               ;tiles arranged in top left, right, middle left, right, bottom left, right order
00E2CE  1               EnemyGraphicsTable:
00E2CE  1  FC FC AA AB        .byte $fc, $fc, $aa, $ab, $ac, $ad  ;buzzy beetle frame 1
00E2D2  1  AC AD        
00E2D4  1  FC FC AE AF        .byte $fc, $fc, $ae, $af, $b0, $b1  ;             frame 2
00E2D8  1  B0 B1        
00E2DA  1  FC A5 A6 A7        .byte $fc, $a5, $a6, $a7, $a8, $a9  ;koopa troopa frame 1
00E2DE  1  A8 A9        
00E2E0  1  FC A0 A1 A2        .byte $fc, $a0, $a1, $a2, $a3, $a4  ;             frame 2
00E2E4  1  A3 A4        
00E2E6  1  69 A5 6A A7        .byte $69, $a5, $6a, $a7, $a8, $a9  ;koopa paratroopa frame 1
00E2EA  1  A8 A9        
00E2EC  1  6B A0 6C A2        .byte $6b, $a0, $6c, $a2, $a3, $a4  ;                 frame 2
00E2F0  1  A3 A4        
00E2F2  1  FC FC 96 97        .byte $fc, $fc, $96, $97, $98, $99  ;spiny frame 1
00E2F6  1  98 99        
00E2F8  1  FC FC 9A 9B        .byte $fc, $fc, $9a, $9b, $9c, $9d  ;      frame 2
00E2FC  1  9C 9D        
00E2FE  1  FC FC 8F 8E        .byte $fc, $fc, $8f, $8e, $8e, $8f  ;spiny's egg frame 1
00E302  1  8E 8F        
00E304  1  FC FC 95 94        .byte $fc, $fc, $95, $94, $94, $95  ;            frame 2
00E308  1  94 95        
00E30A  1  FC FC DC DC        .byte $fc, $fc, $dc, $dc, $df, $df  ;bloober frame 1
00E30E  1  DF DF        
00E310  1  DC DC DD DD        .byte $dc, $dc, $dd, $dd, $de, $de  ;        frame 2
00E314  1  DE DE        
00E316  1  FC FC B2 B3        .byte $fc, $fc, $b2, $b3, $b4, $b5  ;cheep-cheep frame 1
00E31A  1  B4 B5        
00E31C  1  FC FC B6 B3        .byte $fc, $fc, $b6, $b3, $b7, $b5  ;            frame 2
00E320  1  B7 B5        
00E322  1  FC FC 70 71        .byte $fc, $fc, $70, $71, $72, $73  ;goomba
00E326  1  72 73        
00E328  1  FC FC 6E 6E        .byte $fc, $fc, $6e, $6e, $6f, $6f  ;koopa shell frame 1 (upside-down)
00E32C  1  6F 6F        
00E32E  1  FC FC 6D 6D        .byte $fc, $fc, $6d, $6d, $6f, $6f  ;            frame 2
00E332  1  6F 6F        
00E334  1  FC FC 6F 6F        .byte $fc, $fc, $6f, $6f, $6e, $6e  ;koopa shell frame 1 (rightsideup)
00E338  1  6E 6E        
00E33A  1  FC FC 6F 6F        .byte $fc, $fc, $6f, $6f, $6d, $6d  ;            frame 2
00E33E  1  6D 6D        
00E340  1  FC FC F4 F4        .byte $fc, $fc, $f4, $f4, $f5, $f5  ;buzzy beetle shell frame 1 (rightsideup)
00E344  1  F5 F5        
00E346  1  FC FC F4 F4        .byte $fc, $fc, $f4, $f4, $f5, $f5  ;                   frame 2
00E34A  1  F5 F5        
00E34C  1  FC FC F5 F5        .byte $fc, $fc, $f5, $f5, $f4, $f4  ;buzzy beetle shell frame 1 (upside-down)
00E350  1  F4 F4        
00E352  1  FC FC F5 F5        .byte $fc, $fc, $f5, $f5, $f4, $f4  ;                   frame 2
00E356  1  F4 F4        
00E358  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $ef, $ef  ;defeated goomba
00E35C  1  EF EF        
00E35E  1  B9 B8 BB BA        .byte $b9, $b8, $bb, $ba, $bc, $bc  ;lakitu frame 1
00E362  1  BC BC        
00E364  1  FC FC BD BD        .byte $fc, $fc, $bd, $bd, $bc, $bc  ;       frame 2
00E368  1  BC BC        
00E36A  1  7A 7B DA DB        .byte $7a, $7b, $da, $db, $d8, $d8  ;princess
00E36E  1  D8 D8        
00E370  1  CD CD CE CE        .byte $cd, $cd, $ce, $ce, $cf, $cf  ;mushroom retainer
00E374  1  CF CF        
00E376  1  7D 7C D1 8C        .byte $7d, $7c, $d1, $8c, $d3, $d2  ;hammer bro frame 1
00E37A  1  D3 D2        
00E37C  1  7D 7C 89 88        .byte $7d, $7c, $89, $88, $8b, $8a  ;           frame 2
00E380  1  8B 8A        
00E382  1  D5 D4 E3 E2        .byte $d5, $d4, $e3, $e2, $d3, $d2  ;           frame 3
00E386  1  D3 D2        
00E388  1  D5 D4 E3 E2        .byte $d5, $d4, $e3, $e2, $8b, $8a  ;           frame 4
00E38C  1  8B 8A        
00E38E  1  E5 E5 E6 E6        .byte $e5, $e5, $e6, $e6, $eb, $eb  ;piranha plant frame 1
00E392  1  EB EB        
00E394  1  EC EC ED ED        .byte $ec, $ec, $ed, $ed, $ee, $ee  ;              frame 2
00E398  1  EE EE        
00E39A  1  FC FC D0 D0        .byte $fc, $fc, $d0, $d0, $d7, $d7  ;podoboo
00E39E  1  D7 D7        
00E3A0  1  BF BE C1 C0        .byte $bf, $be, $c1, $c0, $c2, $fc  ;bowser front frame 1
00E3A4  1  C2 FC        
00E3A6  1  C4 C3 C6 C5        .byte $c4, $c3, $c6, $c5, $c8, $c7  ;bowser rear frame 1
00E3AA  1  C8 C7        
00E3AC  1  BF BE CA C9        .byte $bf, $be, $ca, $c9, $c2, $fc  ;       front frame 2
00E3B0  1  C2 FC        
00E3B2  1  C4 C3 C6 C5        .byte $c4, $c3, $c6, $c5, $cc, $cb  ;       rear frame 2
00E3B6  1  CC CB        
00E3B8  1  FC FC E8 E7        .byte $fc, $fc, $e8, $e7, $ea, $e9  ;bullet bill
00E3BC  1  EA E9        
00E3BE  1  F2 F2 F3 F3        .byte $f2, $f2, $f3, $f3, $f2, $f2  ;jumpspring frame 1
00E3C2  1  F2 F2        
00E3C4  1  F1 F1 F1 F1        .byte $f1, $f1, $f1, $f1, $fc, $fc  ;           frame 2
00E3C8  1  FC FC        
00E3CA  1  F0 F0 FC FC        .byte $f0, $f0, $fc, $fc, $fc, $fc  ;           frame 3
00E3CE  1  FC FC        
00E3D0  1               
00E3D0  1               EnemyGfxTableOffsets:
00E3D0  1  0C 0C 00 0C        .byte $0c, $0c, $00, $0c, $0c, $a8, $54, $3c
00E3D4  1  0C A8 54 3C  
00E3D8  1  EA 18 48 48        .byte $ea, $18, $48, $48, $cc, $c0, $18, $18
00E3DC  1  CC C0 18 18  
00E3E0  1  18 90 24 FF        .byte $18, $90, $24, $ff, $48, $9c, $d2, $d8
00E3E4  1  48 9C D2 D8  
00E3E8  1  F0 F6 FC           .byte $f0, $f6, $fc
00E3EB  1               
00E3EB  1               EnemyAttributeData:
00E3EB  1  01 02 03 02        .byte $01, $02, $03, $02, $01, $01, $03, $03
00E3EF  1  01 01 03 03  
00E3F3  1  03 01 01 02        .byte $03, $01, $01, $02, $02, $21, $01, $02
00E3F7  1  02 21 01 02  
00E3FB  1  01 01 02 FF        .byte $01, $01, $02, $ff, $02, $02, $01, $01
00E3FF  1  02 02 01 01  
00E403  1  02 02 02           .byte $02, $02, $02
00E406  1               
00E406  1               EnemyAnimTimingBMask:
00E406  1  08 18              .byte $08, $18
00E408  1               
00E408  1               JumpspringFrameOffsets:
00E408  1  18 19 1A 19        .byte $18, $19, $1a, $19, $18
00E40C  1  18           
00E40D  1               
00E40D  1               EnemyGfxHandler:
00E40D  1  B5 CF              lda Enemy_Y_Position,x      ;get enemy object vertical position
00E40F  1  85 02              sta $02
00E411  1  AD AE 03           lda Enemy_Rel_XPos          ;get enemy object horizontal position
00E414  1  85 05              sta $05                     ;relative to screen
00E416  1  BC E5 06           ldy Enemy_SprDataOffset,x
00E419  1  84 EB              sty $eb                     ;get sprite data offset
00E41B  1  A9 00              lda #$00
00E41D  1  8D 09 01           sta VerticalFlipFlag        ;initialize vertical flip flag by default
00E420  1  B5 46              lda Enemy_MovingDir,x
00E422  1  85 03              sta $03                     ;get enemy object moving direction
00E424  1  BD C5 03           lda Enemy_SprAttrib,x
00E427  1  85 04              sta $04                     ;get enemy object sprite attributes
00E429  1  B5 16              lda Enemy_ID,x
00E42B  1  C9 0D              cmp #PiranhaPlant           ;is enemy object piranha plant?
00E42D  1  D0 0A              bne CheckForRetainerObj     ;if not, branch
00E42F  1  B4 58              ldy PiranhaPlant_Y_Speed,x
00E431  1  30 06              bmi CheckForRetainerObj     ;if piranha plant moving upwards, branch
00E433  1  BC 8A 07           ldy EnemyFrameTimer,x
00E436  1  F0 01              beq CheckForRetainerObj     ;if timer for movement expired, branch
00E438  1  60                 rts                         ;if all conditions fail, leave
00E439  1               
00E439  1               CheckForRetainerObj:
00E439  1  B5 1E              lda Enemy_State,x           ;store enemy state
00E43B  1  85 ED              sta $ed
00E43D  1  29 1F              and #%00011111              ;nullify all but 5 LSB and use as Y
00E43F  1  A8                 tay
00E440  1  B5 16              lda Enemy_ID,x              ;check for mushroom retainer/princess object
00E442  1  C9 35              cmp #RetainerObject
00E444  1  D0 08              bne CheckForBulletBillCV    ;if not found, branch
00E446  1  A0 00              ldy #$00                    ;if found, nullify saved state in Y
00E448  1  A9 01              lda #$01                    ;set value that will not be used
00E44A  1  85 03              sta $03
00E44C  1  A9 15              lda #$15                    ;set value $15 as code for mushroom retainer/princess object
00E44E  1               
00E44E  1               CheckForBulletBillCV:
00E44E  1  C9 33               cmp #BulletBill_CannonVar   ;otherwise check for bullet bill object
00E450  1  D0 13               bne CheckForJumpspring      ;if not found, branch again
00E452  1  C6 02               dec $02                     ;decrement saved vertical position
00E454  1  A9 03               lda #$03
00E456  1  BC 8A 07            ldy EnemyFrameTimer,x       ;get timer for enemy object
00E459  1  F0 02               beq SBBAt                   ;if expired, do not set priority bit
00E45B  1  09 20               ora #%00100000              ;otherwise do so
00E45D  1  85 04        SBBAt: sta $04                     ;set new sprite attributes
00E45F  1  A0 00               ldy #$00                    ;nullify saved enemy state both in Y and in
00E461  1  84 ED               sty $ed                     ;memory location here
00E463  1  A9 08               lda #$08                    ;set specific value to unconditionally branch once
00E465  1               
00E465  1               CheckForJumpspring:
00E465  1  C9 32              cmp #JumpspringObject        ;check for jumpspring object
00E467  1  D0 08              bne CheckForPodoboo
00E469  1  A0 03              ldy #$03                     ;set enemy state -2 MSB here for jumpspring object
00E46B  1  AE 0E 07           ldx JumpspringAnimCtrl       ;get current frame number for jumpspring object
00E46E  1  BD 08 E4           lda JumpspringFrameOffsets,x ;load data using frame number as offset
00E471  1               
00E471  1               CheckForPodoboo:
00E471  1  85 EF              sta $ef                 ;store saved enemy object value here
00E473  1  84 EC              sty $ec                 ;and Y here (enemy state -2 MSB if not changed)
00E475  1  A6 08              ldx ObjectOffset        ;get enemy object offset
00E477  1  C9 0C              cmp #$0c                ;check for podoboo object
00E479  1  D0 07              bne CheckBowserGfxFlag  ;branch if not found
00E47B  1  B5 A0              lda Enemy_Y_Speed,x     ;if moving upwards, branch
00E47D  1  30 03              bmi CheckBowserGfxFlag
00E47F  1  EE 09 01           inc VerticalFlipFlag    ;otherwise, set flag for vertical flip
00E482  1               
00E482  1               CheckBowserGfxFlag:
00E482  1  AD 6A 03                  lda BowserGfxFlag   ;if not drawing bowser at all, skip to something else
00E485  1  F0 09                     beq CheckForGoomba
00E487  1  A0 16                     ldy #$16            ;if set to 1, draw bowser's front
00E489  1  C9 01                     cmp #$01
00E48B  1  F0 01                     beq SBwsrGfxOfs
00E48D  1  C8                        iny                 ;otherwise draw bowser's rear
00E48E  1  84 EF        SBwsrGfxOfs: sty $ef
00E490  1               
00E490  1               CheckForGoomba:
00E490  1  A4 EF                  ldy $ef               ;check value for goomba object
00E492  1  C0 06                  cpy #Goomba
00E494  1  D0 1D                  bne CheckBowserFront  ;branch if not found
00E496  1  B5 1E                  lda Enemy_State,x
00E498  1  C9 02                  cmp #$02              ;check for defeated state
00E49A  1  90 04                  bcc GmbaAnim          ;if not defeated, go ahead and animate
00E49C  1  A2 04                  ldx #$04              ;if defeated, write new value here
00E49E  1  86 EC                  stx $ec
00E4A0  1  29 20        GmbaAnim: and #%00100000        ;check for d5 set in enemy object state
00E4A2  1  0D 47 07               ora TimerControl      ;or timer disable flag set
00E4A5  1  D0 0C                  bne CheckBowserFront  ;if either condition true, do not animate goomba
00E4A7  1  A5 09                  lda FrameCounter
00E4A9  1  29 08                  and #%00001000        ;check for every eighth frame
00E4AB  1  D0 06                  bne CheckBowserFront
00E4AD  1  A5 03                  lda $03
00E4AF  1  49 03                  eor #%00000011        ;invert bits to flip horizontally every eight frames
00E4B1  1  85 03                  sta $03               ;leave alone otherwise
00E4B3  1               
00E4B3  1               CheckBowserFront:
00E4B3  1  B9 EB E3                  lda EnemyAttributeData,y    ;load sprite attribute using enemy object
00E4B6  1  05 04                     ora $04                     ;as offset, and add to bits already loaded
00E4B8  1  85 04                     sta $04
00E4BA  1  B9 D0 E3                  lda EnemyGfxTableOffsets,y  ;load value based on enemy object as offset
00E4BD  1  AA                        tax                         ;save as X
00E4BE  1  A4 EC                     ldy $ec                     ;get previously saved value
00E4C0  1  AD 6A 03                  lda BowserGfxFlag
00E4C3  1  F0 30                     beq CheckForSpiny           ;if not drawing bowser object at all, skip all of this
00E4C5  1  C9 01                     cmp #$01
00E4C7  1  D0 13                     bne CheckBowserRear         ;if not drawing front part, branch to draw the rear part
00E4C9  1  AD 63 03                  lda BowserBodyControls      ;check bowser's body control bits
00E4CC  1  10 02                     bpl ChkFrontSte             ;branch if d7 not set (control's bowser's mouth)
00E4CE  1  A2 DE                     ldx #$de                    ;otherwise load offset for second frame
00E4D0  1  A5 ED        ChkFrontSte: lda $ed                     ;check saved enemy state
00E4D2  1  29 20                     and #%00100000              ;if bowser not defeated, do not set flag
00E4D4  1  F0 03                     beq DrawBowser
00E4D6  1               
00E4D6  1               FlipBowserOver:
00E4D6  1  8E 09 01           stx VerticalFlipFlag  ;set vertical flip flag to nonzero
00E4D9  1               
00E4D9  1               DrawBowser:
00E4D9  1  4C DB E5           jmp DrawEnemyObject   ;draw bowser's graphics now
00E4DC  1               
00E4DC  1               CheckBowserRear:
00E4DC  1  AD 63 03                 lda BowserBodyControls  ;check bowser's body control bits
00E4DF  1  29 01                    and #$01
00E4E1  1  F0 02                    beq ChkRearSte          ;branch if d0 not set (control's bowser's feet)
00E4E3  1  A2 E4                    ldx #$e4                ;otherwise load offset for second frame
00E4E5  1  A5 ED        ChkRearSte: lda $ed                 ;check saved enemy state
00E4E7  1  29 20                    and #%00100000          ;if bowser not defeated, do not set flag
00E4E9  1  F0 EE                    beq DrawBowser
00E4EB  1  A5 02                    lda $02                 ;subtract 16 pixels from
00E4ED  1  38                       sec                     ;saved vertical coordinate
00E4EE  1  E9 10                    sbc #$10
00E4F0  1  85 02                    sta $02
00E4F2  1  4C D6 E4                 jmp FlipBowserOver      ;jump to set vertical flip flag
00E4F5  1               
00E4F5  1               CheckForSpiny:
00E4F5  1  E0 24                cpx #$24               ;check if value loaded is for spiny
00E4F7  1  D0 11                bne CheckForLakitu     ;if not found, branch
00E4F9  1  C0 05                cpy #$05               ;if enemy state set to $05, do this,
00E4FB  1  D0 0A                bne NotEgg             ;otherwise branch
00E4FD  1  A2 30                ldx #$30               ;set to spiny egg offset
00E4FF  1  A9 02                lda #$02
00E501  1  85 03                sta $03                ;set enemy direction to reverse sprites horizontally
00E503  1  A9 05                lda #$05
00E505  1  85 EC                sta $ec                ;set enemy state
00E507  1  4C 5A E5     NotEgg: jmp CheckForHammerBro  ;skip a big chunk of this if we found spiny but not in egg
00E50A  1               
00E50A  1               CheckForLakitu:
00E50A  1  E0 90                cpx #$90                  ;check value for lakitu's offset loaded
00E50C  1  D0 12                bne CheckUpsideDownShell  ;branch if not loaded
00E50E  1  A5 ED                lda $ed
00E510  1  29 20                and #%00100000            ;check for d5 set in enemy state
00E512  1  D0 09                bne NoLAFr                ;branch if set
00E514  1  AD 8F 07             lda FrenzyEnemyTimer
00E517  1  C9 10                cmp #$10                  ;check timer to see if we've reached a certain range
00E519  1  B0 02                bcs NoLAFr                ;branch if not
00E51B  1  A2 96                ldx #$96                  ;if d6 not set and timer in range, load alt frame for lakitu
00E51D  1  4C C7 E5     NoLAFr: jmp CheckDefeatedState    ;skip this next part if we found lakitu but alt frame not needed
00E520  1               
00E520  1               CheckUpsideDownShell:
00E520  1  A5 EF              lda $ef                    ;check for enemy object => $04
00E522  1  C9 04              cmp #$04
00E524  1  B0 10              bcs CheckRightSideUpShell  ;branch if true
00E526  1  C0 02              cpy #$02
00E528  1  90 0C              bcc CheckRightSideUpShell  ;branch if enemy state < $02
00E52A  1  A2 5A              ldx #$5a                   ;set for upside-down koopa shell by default
00E52C  1  A4 EF              ldy $ef
00E52E  1  C0 02              cpy #BuzzyBeetle           ;check for buzzy beetle object
00E530  1  D0 04              bne CheckRightSideUpShell
00E532  1  A2 7E              ldx #$7e                   ;set for upside-down buzzy beetle shell if found
00E534  1  E6 02              inc $02                    ;increment vertical position by one pixel
00E536  1               
00E536  1               CheckRightSideUpShell:
00E536  1  A5 EC              lda $ec                ;check for value set here
00E538  1  C9 04              cmp #$04               ;if enemy state < $02, do not change to shell, if
00E53A  1  D0 1E              bne CheckForHammerBro  ;enemy state => $02 but not = $04, leave shell upside-down
00E53C  1  A2 72              ldx #$72               ;set right-side up buzzy beetle shell by default
00E53E  1  E6 02              inc $02                ;increment saved vertical position by one pixel
00E540  1  A4 EF              ldy $ef
00E542  1  C0 02              cpy #BuzzyBeetle       ;check for buzzy beetle object
00E544  1  F0 04              beq CheckForDefdGoomba ;branch if found
00E546  1  A2 66              ldx #$66               ;change to right-side up koopa shell if not found
00E548  1  E6 02              inc $02                ;and increment saved vertical position again
00E54A  1               
00E54A  1               CheckForDefdGoomba:
00E54A  1  C0 06              cpy #Goomba            ;check for goomba object (necessary if previously
00E54C  1  D0 0C              bne CheckForHammerBro  ;failed buzzy beetle object test)
00E54E  1  A2 54              ldx #$54               ;load for regular goomba
00E550  1  A5 ED              lda $ed                ;note that this only gets performed if enemy state => $02
00E552  1  29 20              and #%00100000         ;check saved enemy state for d5 set
00E554  1  D0 04              bne CheckForHammerBro  ;branch if set
00E556  1  A2 8A              ldx #$8a               ;load offset for defeated goomba
00E558  1  C6 02              dec $02                ;set different value and decrement saved vertical position
00E55A  1               
00E55A  1               CheckForHammerBro:
00E55A  1  A4 08              ldy ObjectOffset
00E55C  1  A5 EF              lda $ef                  ;check for hammer bro object
00E55E  1  C9 05              cmp #HammerBro
00E560  1  D0 0C              bne CheckForBloober      ;branch if not found
00E562  1  A5 ED              lda $ed
00E564  1  F0 24              beq CheckToAnimateEnemy  ;branch if not in normal enemy state
00E566  1  29 08              and #%00001000
00E568  1  F0 5D              beq CheckDefeatedState   ;if d3 not set, branch further away
00E56A  1  A2 B4              ldx #$b4                 ;otherwise load offset for different frame
00E56C  1  D0 1C              bne CheckToAnimateEnemy  ;unconditional branch
00E56E  1               
00E56E  1               CheckForBloober:
00E56E  1  E0 48              cpx #$48                 ;check for cheep-cheep offset loaded
00E570  1  F0 18              beq CheckToAnimateEnemy  ;branch if found
00E572  1  B9 96 07           lda EnemyIntervalTimer,y
00E575  1  C9 05              cmp #$05
00E577  1  B0 4E              bcs CheckDefeatedState   ;branch if some timer is above a certain point
00E579  1  E0 3C              cpx #$3c                 ;check for bloober offset loaded
00E57B  1  D0 0D              bne CheckToAnimateEnemy  ;branch if not found this time
00E57D  1  C9 01              cmp #$01
00E57F  1  F0 46              beq CheckDefeatedState   ;branch if timer is set to certain point
00E581  1  E6 02              inc $02                  ;increment saved vertical coordinate three pixels
00E583  1  E6 02              inc $02
00E585  1  E6 02              inc $02
00E587  1  4C B9 E5           jmp CheckAnimationStop   ;and do something else
00E58A  1               
00E58A  1               CheckToAnimateEnemy:
00E58A  1  A5 EF              lda $ef                  ;check for specific enemy objects
00E58C  1  C9 06              cmp #Goomba
00E58E  1  F0 37              beq CheckDefeatedState   ;branch if goomba
00E590  1  C9 08              cmp #$08
00E592  1  F0 33              beq CheckDefeatedState   ;branch if bullet bill (note both variants use $08 here)
00E594  1  C9 0C              cmp #Podoboo
00E596  1  F0 2F              beq CheckDefeatedState   ;branch if podoboo
00E598  1  C9 18              cmp #$18                 ;branch if => $18
00E59A  1  B0 2B              bcs CheckDefeatedState
00E59C  1  A0 00              ldy #$00
00E59E  1  C9 15              cmp #$15                 ;check for mushroom retainer/princess object
00E5A0  1  D0 10              bne CheckForSecondFrame  ;which uses different code here, branch if not found
00E5A2  1  C8                 iny                      ;residual instruction
00E5A3  1  AD 5F 07           lda WorldNumber          ;are we on world 8?
00E5A6  1  C9 07              cmp #World8
00E5A8  1  B0 1D              bcs CheckDefeatedState   ;if so, leave the offset alone (use princess)
00E5AA  1  A2 A2              ldx #$a2                 ;otherwise, set for mushroom retainer object instead
00E5AC  1  A9 03              lda #$03                 ;set alternate state here
00E5AE  1  85 EC              sta $ec
00E5B0  1  D0 15              bne CheckDefeatedState   ;unconditional branch
00E5B2  1               
00E5B2  1               CheckForSecondFrame:
00E5B2  1  A5 09              lda FrameCounter            ;load frame counter
00E5B4  1  39 06 E4           and EnemyAnimTimingBMask,y  ;mask it (partly residual, one byte not ever used)
00E5B7  1  D0 0E              bne CheckDefeatedState      ;branch if timing is off
00E5B9  1               
00E5B9  1               CheckAnimationStop:
00E5B9  1  A5 ED              lda $ed                 ;check saved enemy state
00E5BB  1  29 A0              and #%10100000          ;for d7 or d5, or check for timers stopped
00E5BD  1  0D 47 07           ora TimerControl
00E5C0  1  D0 05              bne CheckDefeatedState  ;if either condition true, branch
00E5C2  1  8A                 txa
00E5C3  1  18                 clc
00E5C4  1  69 06              adc #$06                ;add $06 to current enemy offset
00E5C6  1  AA                 tax                     ;to animate various enemy objects
00E5C7  1               
00E5C7  1               CheckDefeatedState:
00E5C7  1  A5 ED              lda $ed               ;check saved enemy state
00E5C9  1  29 20              and #%00100000        ;for d5 set
00E5CB  1  F0 0E              beq DrawEnemyObject   ;branch if not set
00E5CD  1  A5 EF              lda $ef
00E5CF  1  C9 04              cmp #$04              ;check for saved enemy object => $04
00E5D1  1  90 08              bcc DrawEnemyObject   ;branch if less
00E5D3  1  A0 01              ldy #$01
00E5D5  1  8C 09 01           sty VerticalFlipFlag  ;set vertical flip flag
00E5D8  1  88                 dey
00E5D9  1  84 EC              sty $ec               ;init saved value here
00E5DB  1               
00E5DB  1               DrawEnemyObject:
00E5DB  1  A4 EB              ldy $eb                    ;load sprite data offset
00E5DD  1  20 3A E7           jsr DrawEnemyObjRow        ;draw six tiles of data
00E5E0  1  20 3A E7           jsr DrawEnemyObjRow        ;into sprite data
00E5E3  1  20 3A E7           jsr DrawEnemyObjRow
00E5E6  1  A6 08              ldx ObjectOffset           ;get enemy object offset
00E5E8  1  BC E5 06           ldy Enemy_SprDataOffset,x  ;get sprite data offset
00E5EB  1  A5 EF              lda $ef
00E5ED  1  C9 08              cmp #$08                   ;get saved enemy object and check
00E5EF  1  D0 03              bne CheckForVerticalFlip   ;for bullet bill, branch if not found
00E5F1  1               
00E5F1  1               SkipToOffScrChk:
00E5F1  1  4C F4 E6           jmp SprObjectOffscrChk     ;jump if found
00E5F4  1               
00E5F4  1               CheckForVerticalFlip:
00E5F4  1  AD 09 01           lda VerticalFlipFlag       ;check if vertical flip flag is set here
00E5F7  1  F0 3D              beq CheckForESymmetry      ;branch if not
00E5F9  1  B9 02 02           lda Sprite_Attributes,y    ;get attributes of first sprite we dealt with
00E5FC  1  09 80              ora #%10000000             ;set bit for vertical flip
00E5FE  1  C8                 iny
00E5FF  1  C8                 iny                        ;increment two bytes so that we store the vertical flip
00E600  1  20 45 E1           jsr DumpSixSpr             ;in attribute bytes of enemy obj sprite data
00E603  1  88                 dey
00E604  1  88                 dey                        ;now go back to the Y coordinate offset
00E605  1  98                 tya
00E606  1  AA                 tax                        ;give offset to X
00E607  1  A5 EF              lda $ef
00E609  1  C9 05              cmp #HammerBro             ;check saved enemy object for hammer bro
00E60B  1  F0 0D              beq FlipEnemyVertically
00E60D  1  C9 11              cmp #Lakitu                ;check saved enemy object for lakitu
00E60F  1  F0 09              beq FlipEnemyVertically    ;branch for hammer bro or lakitu
00E611  1  C9 15              cmp #$15
00E613  1  B0 05              bcs FlipEnemyVertically    ;also branch if enemy object => $15
00E615  1  8A                 txa
00E616  1  18                 clc
00E617  1  69 08              adc #$08                   ;if not selected objects or => $15, set
00E619  1  AA                 tax                        ;offset in X for next row
00E61A  1               
00E61A  1               FlipEnemyVertically:
00E61A  1  BD 01 02           lda Sprite_Tilenumber,x     ;load first or second row tiles
00E61D  1  48                 pha                         ;and save tiles to the stack
00E61E  1  BD 05 02           lda Sprite_Tilenumber+4,x
00E621  1  48                 pha
00E622  1  B9 11 02           lda Sprite_Tilenumber+16,y  ;exchange third row tiles
00E625  1  9D 01 02           sta Sprite_Tilenumber,x     ;with first or second row tiles
00E628  1  B9 15 02           lda Sprite_Tilenumber+20,y
00E62B  1  9D 05 02           sta Sprite_Tilenumber+4,x
00E62E  1  68                 pla                         ;pull first or second row tiles from stack
00E62F  1  99 15 02           sta Sprite_Tilenumber+20,y  ;and save in third row
00E632  1  68                 pla
00E633  1  99 11 02           sta Sprite_Tilenumber+16,y
00E636  1               
00E636  1               CheckForESymmetry:
00E636  1  AD 6A 03             lda BowserGfxFlag           ;are we drawing bowser at all?
00E639  1  D0 B6                bne SkipToOffScrChk         ;branch if so
00E63B  1  A5 EF                lda $ef
00E63D  1  A6 EC                ldx $ec                     ;get alternate enemy state
00E63F  1  C9 05                cmp #$05                    ;check for hammer bro object
00E641  1  D0 03                bne ContES
00E643  1  4C F4 E6             jmp SprObjectOffscrChk      ;jump if found
00E646  1  C9 07        ContES: cmp #Bloober                ;check for bloober object
00E648  1  F0 1D                beq MirrorEnemyGfx
00E64A  1  C9 0D                cmp #PiranhaPlant           ;check for piranha plant object
00E64C  1  F0 19                beq MirrorEnemyGfx
00E64E  1  C9 0C                cmp #Podoboo                ;check for podoboo object
00E650  1  F0 15                beq MirrorEnemyGfx          ;branch if either of three are found
00E652  1  C9 12                cmp #Spiny                  ;check for spiny object
00E654  1  D0 04                bne ESRtnr                  ;branch closer if not found
00E656  1  E0 05                cpx #$05                    ;check spiny's state
00E658  1  D0 48                bne CheckToMirrorLakitu     ;branch if not an egg, otherwise
00E65A  1  C9 15        ESRtnr: cmp #$15                    ;check for princess/mushroom retainer object
00E65C  1  D0 05                bne SpnySC
00E65E  1  A9 42                lda #$42                    ;set horizontal flip on bottom right sprite
00E660  1  99 16 02             sta Sprite_Attributes+20,y  ;note that palette bits were already set earlier
00E663  1  E0 02        SpnySC: cpx #$02                    ;if alternate enemy state set to 1 or 0, branch
00E665  1  90 3B                bcc CheckToMirrorLakitu
00E667  1               
00E667  1               MirrorEnemyGfx:
00E667  1  AD 6A 03             lda BowserGfxFlag           ;if enemy object is bowser, skip all of this
00E66A  1  D0 36                bne CheckToMirrorLakitu
00E66C  1  B9 02 02             lda Sprite_Attributes,y     ;load attribute bits of first sprite
00E66F  1  29 A3                and #%10100011
00E671  1  99 02 02             sta Sprite_Attributes,y     ;save vertical flip, priority, and palette bits
00E674  1  99 0A 02             sta Sprite_Attributes+8,y   ;in left sprite column of enemy object OAM data
00E677  1  99 12 02             sta Sprite_Attributes+16,y
00E67A  1  09 40                ora #%01000000              ;set horizontal flip
00E67C  1  E0 05                cpx #$05                    ;check for state used by spiny's egg
00E67E  1  D0 02                bne EggExc                  ;if alternate state not set to $05, branch
00E680  1  09 80                ora #%10000000              ;otherwise set vertical flip
00E682  1  99 06 02     EggExc: sta Sprite_Attributes+4,y   ;set bits of right sprite column
00E685  1  99 0E 02             sta Sprite_Attributes+12,y  ;of enemy object sprite data
00E688  1  99 16 02             sta Sprite_Attributes+20,y
00E68B  1  E0 04                cpx #$04                    ;check alternate enemy state
00E68D  1  D0 13                bne CheckToMirrorLakitu     ;branch if not $04
00E68F  1  B9 0A 02             lda Sprite_Attributes+8,y   ;get second row left sprite attributes
00E692  1  09 80                ora #%10000000
00E694  1  99 0A 02             sta Sprite_Attributes+8,y   ;store bits with vertical flip in
00E697  1  99 12 02             sta Sprite_Attributes+16,y  ;second and third row left sprites
00E69A  1  09 40                ora #%01000000
00E69C  1  99 0E 02             sta Sprite_Attributes+12,y  ;store with horizontal and vertical flip in
00E69F  1  99 16 02             sta Sprite_Attributes+20,y  ;second and third row right sprites
00E6A2  1               
00E6A2  1               CheckToMirrorLakitu:
00E6A2  1  A5 EF                lda $ef                     ;check for lakitu enemy object
00E6A4  1  C9 11                cmp #Lakitu
00E6A6  1  D0 36                bne CheckToMirrorJSpring    ;branch if not found
00E6A8  1  AD 09 01             lda VerticalFlipFlag
00E6AB  1  D0 21                bne NVFLak                  ;branch if vertical flip flag not set
00E6AD  1  B9 12 02             lda Sprite_Attributes+16,y  ;save vertical flip and palette bits
00E6B0  1  29 81                and #%10000001              ;in third row left sprite
00E6B2  1  99 12 02             sta Sprite_Attributes+16,y
00E6B5  1  B9 16 02             lda Sprite_Attributes+20,y  ;set horizontal flip and palette bits
00E6B8  1  09 41                ora #%01000001              ;in third row right sprite
00E6BA  1  99 16 02             sta Sprite_Attributes+20,y
00E6BD  1  AE 8F 07             ldx FrenzyEnemyTimer        ;check timer
00E6C0  1  E0 10                cpx #$10
00E6C2  1  B0 30                bcs SprObjectOffscrChk      ;branch if timer has not reached a certain range
00E6C4  1  99 0E 02             sta Sprite_Attributes+12,y  ;otherwise set same for second row right sprite
00E6C7  1  29 81                and #%10000001
00E6C9  1  99 0A 02             sta Sprite_Attributes+8,y   ;preserve vertical flip and palette bits for left sprite
00E6CC  1  90 26                bcc SprObjectOffscrChk      ;unconditional branch
00E6CE  1  B9 02 02     NVFLak: lda Sprite_Attributes,y     ;get first row left sprite attributes
00E6D1  1  29 81                and #%10000001
00E6D3  1  99 02 02             sta Sprite_Attributes,y     ;save vertical flip and palette bits
00E6D6  1  B9 06 02             lda Sprite_Attributes+4,y   ;get first row right sprite attributes
00E6D9  1  09 41                ora #%01000001              ;set horizontal flip and palette bits
00E6DB  1  99 06 02             sta Sprite_Attributes+4,y   ;note that vertical flip is left as-is
00E6DE  1               
00E6DE  1               CheckToMirrorJSpring:
00E6DE  1  A5 EF              lda $ef                     ;check for jumpspring object (any frame)
00E6E0  1  C9 18              cmp #$18
00E6E2  1  90 10              bcc SprObjectOffscrChk      ;branch if not jumpspring object at all
00E6E4  1  A9 82              lda #$82
00E6E6  1  99 0A 02           sta Sprite_Attributes+8,y   ;set vertical flip and palette bits of
00E6E9  1  99 12 02           sta Sprite_Attributes+16,y  ;second and third row left sprites
00E6EC  1  09 40              ora #%01000000
00E6EE  1  99 0E 02           sta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip
00E6F1  1  99 16 02           sta Sprite_Attributes+20,y  ;for second and third row right sprites
00E6F4  1               
00E6F4  1               SprObjectOffscrChk:
00E6F4  1  A6 08                 ldx ObjectOffset          ;get enemy buffer offset
00E6F6  1  AD D1 03              lda Enemy_OffscreenBits   ;check offscreen information
00E6F9  1  4A                    lsr
00E6FA  1  4A                    lsr                       ;shift three times to the right
00E6FB  1  4A                    lsr                       ;which puts d2 into carry
00E6FC  1  48                    pha                       ;save to stack
00E6FD  1  90 05                 bcc LcChk                 ;branch if not set
00E6FF  1  A9 04                 lda #$04                  ;set for right column sprites
00E701  1  20 51 E7              jsr MoveESprColOffscreen  ;and move them offscreen
00E704  1  68           LcChk:   pla                       ;get from stack
00E705  1  4A                    lsr                       ;move d3 to carry
00E706  1  48                    pha                       ;save to stack
00E707  1  90 05                 bcc Row3C                 ;branch if not set
00E709  1  A9 00                 lda #$00                  ;set for left column sprites,
00E70B  1  20 51 E7              jsr MoveESprColOffscreen  ;move them offscreen
00E70E  1  68           Row3C:   pla                       ;get from stack again
00E70F  1  4A                    lsr                       ;move d5 to carry this time
00E710  1  4A                    lsr
00E711  1  48                    pha                       ;save to stack again
00E712  1  90 05                 bcc Row23C                ;branch if carry not set
00E714  1  A9 10                 lda #$10                  ;set for third row of sprites
00E716  1  20 47 E7              jsr MoveESprRowOffscreen  ;and move them offscreen
00E719  1  68           Row23C:  pla                       ;get from stack
00E71A  1  4A                    lsr                       ;move d6 into carry
00E71B  1  48                    pha                       ;save to stack
00E71C  1  90 05                 bcc AllRowC
00E71E  1  A9 08                 lda #$08                  ;set for second and third rows
00E720  1  20 47 E7              jsr MoveESprRowOffscreen  ;move them offscreen
00E723  1  68           AllRowC: pla                       ;get from stack once more
00E724  1  4A                    lsr                       ;move d7 into carry
00E725  1  90 12                 bcc ExEGHandler
00E727  1  20 47 E7              jsr MoveESprRowOffscreen  ;move all sprites offscreen (A should be 0 by now)
00E72A  1  B5 16                 lda Enemy_ID,x
00E72C  1  C9 0C                 cmp #Podoboo              ;check enemy identifier for podoboo
00E72E  1  F0 09                 beq ExEGHandler           ;skip this part if found, we do not want to erase podoboo!
00E730  1  B5 B6                 lda Enemy_Y_HighPos,x     ;check high byte of vertical position
00E732  1  C9 02                 cmp #$02                  ;if not yet past the bottom of the screen, branch
00E734  1  D0 03                 bne ExEGHandler
00E736  1  20 A3 C6              jsr EraseEnemyObject      ;what it says
00E739  1               
00E739  1               ExEGHandler:
00E739  1  60                 rts
00E73A  1               
00E73A  1               DrawEnemyObjRow:
00E73A  1  BD CE E2           lda EnemyGraphicsTable,x    ;load two tiles of enemy graphics
00E73D  1  85 00              sta $00
00E73F  1  BD CF E2           lda EnemyGraphicsTable+1,x
00E742  1               
00E742  1               DrawOneSpriteRow:
00E742  1  85 01              sta $01
00E744  1  4C F2 ED           jmp DrawSpriteObject        ;draw them
00E747  1               
00E747  1               MoveESprRowOffscreen:
00E747  1  18                 clc                         ;add A to enemy object OAM data offset
00E748  1  7D E5 06           adc Enemy_SprDataOffset,x
00E74B  1  A8                 tay                         ;use as offset
00E74C  1  A9 F8              lda #$f8
00E74E  1  4C 51 E1           jmp DumpTwoSpr              ;move first row of sprites offscreen
00E751  1               
00E751  1               MoveESprColOffscreen:
00E751  1  18                 clc                         ;add A to enemy object OAM data offset
00E752  1  7D E5 06           adc Enemy_SprDataOffset,x
00E755  1  A8                 tay                         ;use as offset
00E756  1  20 DA E7           jsr MoveColOffscreen        ;move first and second row sprites in column offscreen
00E759  1  99 10 02           sta Sprite_Data+16,y        ;move third row sprite in column offscreen
00E75C  1  60                 rts
00E75D  1               
00E75D  1               ;-------------------------------------------------------------------------------------
00E75D  1               ;$00-$01 - tile numbers
00E75D  1               ;$02 - relative Y position
00E75D  1               ;$03 - horizontal flip flag (not used here)
00E75D  1               ;$04 - attributes
00E75D  1               ;$05 - relative X position
00E75D  1               
00E75D  1               DefaultBlockObjTiles:
00E75D  1  85 85 86 86        .byte $85, $85, $86, $86             ;brick w/ line (these are sprite tiles, not BG!)
00E761  1               
00E761  1               DrawBlock:
00E761  1  AD BC 03                lda Block_Rel_YPos            ;get relative vertical coordinate of block object
00E764  1  85 02                   sta $02                       ;store here
00E766  1  AD B1 03                lda Block_Rel_XPos            ;get relative horizontal coordinate of block object
00E769  1  85 05                   sta $05                       ;store here
00E76B  1  A9 03                   lda #$03
00E76D  1  85 04                   sta $04                       ;set attribute byte here
00E76F  1  4A                      lsr
00E770  1  85 03                   sta $03                       ;set horizontal flip bit here (will not be used)
00E772  1  BC EC 06                ldy Block_SprDataOffset,x     ;get sprite data offset
00E775  1  A2 00                   ldx #$00                      ;reset X for use as offset to tile data
00E777  1  BD 5D E7     DBlkLoop:  lda DefaultBlockObjTiles,x    ;get left tile number
00E77A  1  85 00                   sta $00                       ;set here
00E77C  1  BD 5E E7                lda DefaultBlockObjTiles+1,x  ;get right tile number
00E77F  1  20 42 E7                jsr DrawOneSpriteRow          ;do sub to write tile numbers to first row of sprites
00E782  1  E0 04                   cpx #$04                      ;check incremented offset
00E784  1  D0 F1                   bne DBlkLoop                  ;and loop back until all four sprites are done
00E786  1  A6 08                   ldx ObjectOffset              ;get block object offset
00E788  1  BC EC 06                ldy Block_SprDataOffset,x     ;get sprite data offset
00E78B  1  AD 4E 07                lda AreaType
00E78E  1  C9 01                   cmp #$01                      ;check for ground level type area
00E790  1  F0 08                   beq ChkRep                    ;if found, branch to next part
00E792  1  A9 86                   lda #$86
00E794  1  99 01 02                sta Sprite_Tilenumber,y       ;otherwise remove brick tiles with lines
00E797  1  99 05 02                sta Sprite_Tilenumber+4,y     ;and replace then with lineless brick tiles
00E79A  1  BD E8 03     ChkRep:    lda Block_Metatile,x          ;check replacement metatile
00E79D  1  C9 C4                   cmp #$c4                      ;if not used block metatile, then
00E79F  1  D0 24                   bne BlkOffscr                 ;branch ahead to use current graphics
00E7A1  1  A9 87                   lda #$87                      ;set A for used block tile
00E7A3  1  C8                      iny                           ;increment Y to write to tile bytes
00E7A4  1  20 4B E1                jsr DumpFourSpr               ;do sub to dump into all four sprites
00E7A7  1  88                      dey                           ;return Y to original offset
00E7A8  1  A9 03                   lda #$03                      ;set palette bits
00E7AA  1  AE 4E 07                ldx AreaType
00E7AD  1  CA                      dex                           ;check for ground level type area again
00E7AE  1  F0 01                   beq SetBFlip                  ;if found, use current palette bits
00E7B0  1  4A                      lsr                           ;otherwise set to $01
00E7B1  1  A6 08        SetBFlip:  ldx ObjectOffset              ;put block object offset back in X
00E7B3  1  99 02 02                sta Sprite_Attributes,y       ;store attribute byte as-is in first sprite
00E7B6  1  09 40                   ora #%01000000
00E7B8  1  99 06 02                sta Sprite_Attributes+4,y     ;set horizontal flip bit for second sprite
00E7BB  1  09 80                   ora #%10000000
00E7BD  1  99 0E 02                sta Sprite_Attributes+12,y    ;set both flip bits for fourth sprite
00E7C0  1  29 83                   and #%10000011
00E7C2  1  99 0A 02                sta Sprite_Attributes+8,y     ;set vertical flip bit for third sprite
00E7C5  1  AD D4 03     BlkOffscr: lda Block_OffscreenBits       ;get offscreen bits for block object
00E7C8  1  48                      pha                           ;save to stack
00E7C9  1  29 04                   and #%00000100                ;check to see if d2 in offscreen bits are set
00E7CB  1  F0 08                   beq PullOfsB                  ;if not set, branch, otherwise move sprites offscreen
00E7CD  1  A9 F8                   lda #$f8                      ;move offscreen two OAMs
00E7CF  1  99 04 02                sta Sprite_Y_Position+4,y     ;on the right side
00E7D2  1  99 0C 02                sta Sprite_Y_Position+12,y
00E7D5  1  68           PullOfsB:  pla                           ;pull offscreen bits from stack
00E7D6  1  29 08        ChkLeftCo: and #%00001000                ;check to see if d3 in offscreen bits are set
00E7D8  1  F0 08                   beq ExDBlk                    ;if not set, branch, otherwise move sprites offscreen
00E7DA  1               
00E7DA  1               MoveColOffscreen:
00E7DA  1  A9 F8                lda #$f8                   ;move offscreen two OAMs
00E7DC  1  99 00 02             sta Sprite_Y_Position,y    ;on the left side (or two rows of enemy on either side
00E7DF  1  99 08 02             sta Sprite_Y_Position+8,y  ;if branched here from enemy graphics handler)
00E7E2  1  60           ExDBlk: rts
00E7E3  1               
00E7E3  1               ;-------------------------------------------------------------------------------------
00E7E3  1               ;$00 - used to hold palette bits for attribute byte or relative X position
00E7E3  1               
00E7E3  1               DrawBrickChunks:
00E7E3  1  A9 02                 lda #$02                   ;set palette bits here
00E7E5  1  85 00                 sta $00
00E7E7  1  A9 75                 lda #$75                   ;set tile number for ball (something residual, likely)
00E7E9  1  A4 0E                 ldy GameEngineSubroutine
00E7EB  1  C0 05                 cpy #$05                   ;if end-of-level routine running,
00E7ED  1  F0 06                 beq DChunks                ;use palette and tile number assigned
00E7EF  1  A9 03                 lda #$03                   ;otherwise set different palette bits
00E7F1  1  85 00                 sta $00
00E7F3  1  A9 84                 lda #$84                   ;and set tile number for brick chunks
00E7F5  1  BC EC 06     DChunks: ldy Block_SprDataOffset,x  ;get OAM data offset
00E7F8  1  C8                    iny                        ;increment to start with tile bytes in OAM
00E7F9  1  20 4B E1              jsr DumpFourSpr            ;do sub to dump tile number into all four sprites
00E7FC  1  A5 09                 lda FrameCounter           ;get frame counter
00E7FE  1  0A                    asl
00E7FF  1  0A                    asl
00E800  1  0A                    asl                        ;move low nybble to high
00E801  1  0A                    asl
00E802  1  29 C0                 and #$c0                   ;get what was originally d3-d2 of low nybble
00E804  1  05 00                 ora $00                    ;add palette bits
00E806  1  C8                    iny                        ;increment offset for attribute bytes
00E807  1  20 4B E1              jsr DumpFourSpr            ;do sub to dump attribute data into all four sprites
00E80A  1  88                    dey
00E80B  1  88                    dey                        ;decrement offset to Y coordinate
00E80C  1  AD BC 03              lda Block_Rel_YPos         ;get first block object's relative vertical coordinate
00E80F  1  20 51 E1              jsr DumpTwoSpr             ;do sub to dump current Y coordinate into two sprites
00E812  1  AD B1 03              lda Block_Rel_XPos         ;get first block object's relative horizontal coordinate
00E815  1  99 03 02              sta Sprite_X_Position,y    ;save into X coordinate of first sprite
00E818  1  BD F1 03              lda Block_Orig_XPos,x      ;get original horizontal coordinate
00E81B  1  38                    sec
00E81C  1  ED 1C 07              sbc ScreenLeft_X_Pos       ;subtract coordinate of left side from original coordinate
00E81F  1  85 00                 sta $00                    ;store result as relative horizontal coordinate of original
00E821  1  38                    sec
00E822  1  ED B1 03              sbc Block_Rel_XPos         ;get difference of relative positions of original - current
00E825  1  65 00                 adc $00                    ;add original relative position to result
00E827  1  69 06                 adc #$06                   ;plus 6 pixels to position second brick chunk correctly
00E829  1  99 07 02              sta Sprite_X_Position+4,y  ;save into X coordinate of second sprite
00E82C  1  AD BD 03              lda Block_Rel_YPos+1       ;get second block object's relative vertical coordinate
00E82F  1  99 08 02              sta Sprite_Y_Position+8,y
00E832  1  99 0C 02              sta Sprite_Y_Position+12,y ;dump into Y coordinates of third and fourth sprites
00E835  1  AD B2 03              lda Block_Rel_XPos+1       ;get second block object's relative horizontal coordinate
00E838  1  99 0B 02              sta Sprite_X_Position+8,y  ;save into X coordinate of third sprite
00E83B  1  A5 00                 lda $00                    ;use original relative horizontal position
00E83D  1  38                    sec
00E83E  1  ED B2 03              sbc Block_Rel_XPos+1       ;get difference of relative positions of original - current
00E841  1  65 00                 adc $00                    ;add original relative position to result
00E843  1  69 06                 adc #$06                   ;plus 6 pixels to position fourth brick chunk correctly
00E845  1  99 0F 02              sta Sprite_X_Position+12,y ;save into X coordinate of fourth sprite
00E848  1  AD D4 03              lda Block_OffscreenBits    ;get offscreen bits for block object
00E84B  1  20 D6 E7              jsr ChkLeftCo              ;do sub to move left half of sprites offscreen if necessary
00E84E  1  AD D4 03              lda Block_OffscreenBits    ;get offscreen bits again
00E851  1  0A                    asl                        ;shift d7 into carry
00E852  1  90 05                 bcc ChnkOfs                ;if d7 not set, branch to last part
00E854  1  A9 F8                 lda #$f8
00E856  1  20 51 E1              jsr DumpTwoSpr             ;otherwise move top sprites offscreen
00E859  1  A5 00        ChnkOfs: lda $00                    ;if relative position on left side of screen,
00E85B  1  10 10                 bpl ExBCDr                 ;go ahead and leave
00E85D  1  B9 03 02              lda Sprite_X_Position,y    ;otherwise compare left-side X coordinate
00E860  1  D9 07 02              cmp Sprite_X_Position+4,y  ;to right-side X coordinate
00E863  1  90 08                 bcc ExBCDr                 ;branch to leave if less
00E865  1  A9 F8                 lda #$f8                   ;otherwise move right half of sprites offscreen
00E867  1  99 04 02              sta Sprite_Y_Position+4,y
00E86A  1  99 0C 02              sta Sprite_Y_Position+12,y
00E86D  1  60           ExBCDr:  rts                        ;leave
00E86E  1               
00E86E  1               ;-------------------------------------------------------------------------------------
00E86E  1               
00E86E  1               DrawFireball:
00E86E  1  BC F1 06           ldy FBall_SprDataOffset,x  ;get fireball's sprite data offset
00E871  1  AD BA 03           lda Fireball_Rel_YPos      ;get relative vertical coordinate
00E874  1  99 00 02           sta Sprite_Y_Position,y    ;store as sprite Y coordinate
00E877  1  AD AF 03           lda Fireball_Rel_XPos      ;get relative horizontal coordinate
00E87A  1  99 03 02           sta Sprite_X_Position,y    ;store as sprite X coordinate, then do shared code
00E87D  1               
00E87D  1               DrawFirebar:
00E87D  1  A5 09               lda FrameCounter         ;get frame counter
00E87F  1  4A                  lsr                      ;divide by four
00E880  1  4A                  lsr
00E881  1  48                  pha                      ;save result to stack
00E882  1  29 01               and #$01                 ;mask out all but last bit
00E884  1  49 64               eor #$64                 ;set either tile $64 or $65 as fireball tile
00E886  1  99 01 02            sta Sprite_Tilenumber,y  ;thus tile changes every four frames
00E889  1  68                  pla                      ;get from stack
00E88A  1  4A                  lsr                      ;divide by four again
00E88B  1  4A                  lsr
00E88C  1  A9 02               lda #$02                 ;load value $02 to set palette in attrib byte
00E88E  1  90 02               bcc FireA                ;if last bit shifted out was not set, skip this
00E890  1  09 C0               ora #%11000000           ;otherwise flip both ways every eight frames
00E892  1  99 02 02     FireA: sta Sprite_Attributes,y  ;store attribute byte and leave
00E895  1  60                  rts
00E896  1               
00E896  1               ;-------------------------------------------------------------------------------------
00E896  1               
00E896  1               ExplosionTiles:
00E896  1  68 67 66           .byte $68, $67, $66
00E899  1               
00E899  1               DrawExplosion_Fireball:
00E899  1  BC EC 06           ldy Alt_SprDataOffset,x  ;get OAM data offset of alternate sort for fireball's explosion
00E89C  1  B5 24              lda Fireball_State,x     ;load fireball state
00E89E  1  F6 24              inc Fireball_State,x     ;increment state for next frame
00E8A0  1  4A                 lsr                      ;divide by 2
00E8A1  1  29 07              and #%00000111           ;mask out all but d3-d1
00E8A3  1  C9 03              cmp #$03                 ;check to see if time to kill fireball
00E8A5  1  B0 4A              bcs KillFireBall         ;branch if so, otherwise continue to draw explosion
00E8A7  1               
00E8A7  1               DrawExplosion_Fireworks:
00E8A7  1  AA                 tax                         ;use whatever's in A for offset
00E8A8  1  BD 96 E8           lda ExplosionTiles,x        ;get tile number using offset
00E8AB  1  C8                 iny                         ;increment Y (contains sprite data offset)
00E8AC  1  20 4B E1           jsr DumpFourSpr             ;and dump into tile number part of sprite data
00E8AF  1  88                 dey                         ;decrement Y so we have the proper offset again
00E8B0  1  A6 08              ldx ObjectOffset            ;return enemy object buffer offset to X
00E8B2  1  AD BA 03           lda Fireball_Rel_YPos       ;get relative vertical coordinate
00E8B5  1  38                 sec                         ;subtract four pixels vertically
00E8B6  1  E9 04              sbc #$04                    ;for first and third sprites
00E8B8  1  99 00 02           sta Sprite_Y_Position,y
00E8BB  1  99 08 02           sta Sprite_Y_Position+8,y
00E8BE  1  18                 clc                         ;add eight pixels vertically
00E8BF  1  69 08              adc #$08                    ;for second and fourth sprites
00E8C1  1  99 04 02           sta Sprite_Y_Position+4,y
00E8C4  1  99 0C 02           sta Sprite_Y_Position+12,y
00E8C7  1  AD AF 03           lda Fireball_Rel_XPos       ;get relative horizontal coordinate
00E8CA  1  38                 sec                         ;subtract four pixels horizontally
00E8CB  1  E9 04              sbc #$04                    ;for first and second sprites
00E8CD  1  99 03 02           sta Sprite_X_Position,y
00E8D0  1  99 07 02           sta Sprite_X_Position+4,y
00E8D3  1  18                 clc                         ;add eight pixels horizontally
00E8D4  1  69 08              adc #$08                    ;for third and fourth sprites
00E8D6  1  99 0B 02           sta Sprite_X_Position+8,y
00E8D9  1  99 0F 02           sta Sprite_X_Position+12,y
00E8DC  1  A9 02              lda #$02                    ;set palette attributes for all sprites, but
00E8DE  1  99 02 02           sta Sprite_Attributes,y     ;set no flip at all for first sprite
00E8E1  1  A9 82              lda #$82
00E8E3  1  99 06 02           sta Sprite_Attributes+4,y   ;set vertical flip for second sprite
00E8E6  1  A9 42              lda #$42
00E8E8  1  99 0A 02           sta Sprite_Attributes+8,y   ;set horizontal flip for third sprite
00E8EB  1  A9 C2              lda #$c2
00E8ED  1  99 0E 02           sta Sprite_Attributes+12,y  ;set both flips for fourth sprite
00E8F0  1  60                 rts                         ;we are done
00E8F1  1               
00E8F1  1               KillFireBall:
00E8F1  1  A9 00              lda #$00                    ;clear fireball state to kill it
00E8F3  1  95 24              sta Fireball_State,x
00E8F5  1  60                 rts
00E8F6  1               
00E8F6  1               ;-------------------------------------------------------------------------------------
00E8F6  1               
00E8F6  1               DrawSmallPlatform:
00E8F6  1  BC E5 06            ldy Enemy_SprDataOffset,x   ;get OAM data offset
00E8F9  1  A9 5B               lda #$5b                    ;load tile number for small platforms
00E8FB  1  C8                  iny                         ;increment offset for tile numbers
00E8FC  1  20 45 E1            jsr DumpSixSpr              ;dump tile number into all six sprites
00E8FF  1  C8                  iny                         ;increment offset for attributes
00E900  1  A9 02               lda #$02                    ;load palette controls
00E902  1  20 45 E1            jsr DumpSixSpr              ;dump attributes into all six sprites
00E905  1  88                  dey                         ;decrement for original offset
00E906  1  88                  dey
00E907  1  AD AE 03            lda Enemy_Rel_XPos          ;get relative horizontal coordinate
00E90A  1  99 03 02            sta Sprite_X_Position,y
00E90D  1  99 0F 02            sta Sprite_X_Position+12,y  ;dump as X coordinate into first and fourth sprites
00E910  1  18                  clc
00E911  1  69 08               adc #$08                    ;add eight pixels
00E913  1  99 07 02            sta Sprite_X_Position+4,y   ;dump into second and fifth sprites
00E916  1  99 13 02            sta Sprite_X_Position+16,y
00E919  1  18                  clc
00E91A  1  69 08               adc #$08                    ;add eight more pixels
00E91C  1  99 0B 02            sta Sprite_X_Position+8,y   ;dump into third and sixth sprites
00E91F  1  99 17 02            sta Sprite_X_Position+20,y
00E922  1  B5 CF               lda Enemy_Y_Position,x      ;get vertical coordinate
00E924  1  AA                  tax
00E925  1  48                  pha                         ;save to stack
00E926  1  E0 20               cpx #$20                    ;if vertical coordinate below status bar,
00E928  1  B0 02               bcs TopSP                   ;do not mess with it
00E92A  1  A9 F8               lda #$f8                    ;otherwise move first three sprites offscreen
00E92C  1  20 4E E1     TopSP: jsr DumpThreeSpr            ;dump vertical coordinate into Y coordinates
00E92F  1  68                  pla                         ;pull from stack
00E930  1  18                  clc
00E931  1  69 80               adc #$80                    ;add 128 pixels
00E933  1  AA                  tax
00E934  1  E0 20               cpx #$20                    ;if below status bar (taking wrap into account)
00E936  1  B0 02               bcs BotSP                   ;then do not change altered coordinate
00E938  1  A9 F8               lda #$f8                    ;otherwise move last three sprites offscreen
00E93A  1  99 0C 02     BotSP: sta Sprite_Y_Position+12,y  ;dump vertical coordinate + 128 pixels
00E93D  1  99 10 02            sta Sprite_Y_Position+16,y  ;into Y coordinates
00E940  1  99 14 02            sta Sprite_Y_Position+20,y
00E943  1  AD D1 03            lda Enemy_OffscreenBits     ;get offscreen bits
00E946  1  48                  pha                         ;save to stack
00E947  1  29 08               and #%00001000              ;check d3
00E949  1  F0 08               beq SOfs
00E94B  1  A9 F8               lda #$f8                    ;if d3 was set, move first and
00E94D  1  99 00 02            sta Sprite_Y_Position,y     ;fourth sprites offscreen
00E950  1  99 0C 02            sta Sprite_Y_Position+12,y
00E953  1  68           SOfs:  pla                         ;move out and back into stack
00E954  1  48                  pha
00E955  1  29 04               and #%00000100              ;check d2
00E957  1  F0 08               beq SOfs2
00E959  1  A9 F8               lda #$f8                    ;if d2 was set, move second and
00E95B  1  99 04 02            sta Sprite_Y_Position+4,y   ;fifth sprites offscreen
00E95E  1  99 10 02            sta Sprite_Y_Position+16,y
00E961  1  68           SOfs2: pla                         ;get from stack
00E962  1  29 02               and #%00000010              ;check d1
00E964  1  F0 08               beq ExSPl
00E966  1  A9 F8               lda #$f8                    ;if d1 was set, move third and
00E968  1  99 08 02            sta Sprite_Y_Position+8,y   ;sixth sprites offscreen
00E96B  1  99 14 02            sta Sprite_Y_Position+20,y
00E96E  1  A6 08        ExSPl: ldx ObjectOffset            ;get enemy object offset and leave
00E970  1  60                  rts
00E971  1               
00E971  1               ;-------------------------------------------------------------------------------------
00E971  1               
00E971  1               DrawBubble:
00E971  1  A4 B5                ldy Player_Y_HighPos        ;if player's vertical high position
00E973  1  88                   dey                         ;not within screen, skip all of this
00E974  1  D0 20                bne ExDBub
00E976  1  AD D3 03             lda Bubble_OffscreenBits    ;check air bubble's offscreen bits
00E979  1  29 08                and #%00001000
00E97B  1  D0 19                bne ExDBub                  ;if bit set, branch to leave
00E97D  1  BC EE 06             ldy Bubble_SprDataOffset,x  ;get air bubble's OAM data offset
00E980  1  AD B0 03             lda Bubble_Rel_XPos         ;get relative horizontal coordinate
00E983  1  99 03 02             sta Sprite_X_Position,y     ;store as X coordinate here
00E986  1  AD BB 03             lda Bubble_Rel_YPos         ;get relative vertical coordinate
00E989  1  99 00 02             sta Sprite_Y_Position,y     ;store as Y coordinate here
00E98C  1  A9 74                lda #$74
00E98E  1  99 01 02             sta Sprite_Tilenumber,y     ;put air bubble tile into OAM data
00E991  1  A9 02                lda #$02
00E993  1  99 02 02             sta Sprite_Attributes,y     ;set attribute byte
00E996  1  60           ExDBub: rts                         ;leave
00E997  1               
00E997  1               ;-------------------------------------------------------------------------------------
00E997  1               ;$00 - used to store player's vertical offscreen bits
00E997  1               
00E997  1               PlayerGfxTblOffsets:
00E997  1  20 28 C8 18        .byte $20, $28, $c8, $18, $00, $40, $50, $58
00E99B  1  00 40 50 58  
00E99F  1  80 88 B8 78        .byte $80, $88, $b8, $78, $60, $a0, $b0, $b8
00E9A3  1  60 A0 B0 B8  
00E9A7  1               
00E9A7  1               ;tiles arranged in order, 2 tiles per row, top to bottom
00E9A7  1               
00E9A7  1               PlayerGraphicsTable:
00E9A7  1               ;big player table
00E9A7  1  00 01 02 03        .byte $00, $01, $02, $03, $04, $05, $06, $07 ;walking frame 1
00E9AB  1  04 05 06 07  
00E9AF  1  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $0d, $0e, $0f ;        frame 2
00E9B3  1  0C 0D 0E 0F  
00E9B7  1  10 11 12 13        .byte $10, $11, $12, $13, $14, $15, $16, $17 ;        frame 3
00E9BB  1  14 15 16 17  
00E9BF  1  18 19 1A 1B        .byte $18, $19, $1a, $1b, $1c, $1d, $1e, $1f ;skidding
00E9C3  1  1C 1D 1E 1F  
00E9C7  1  20 21 22 23        .byte $20, $21, $22, $23, $24, $25, $26, $27 ;jumping
00E9CB  1  24 25 26 27  
00E9CF  1  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $2c, $2d ;swimming frame 1
00E9D3  1  2A 2B 2C 2D  
00E9D7  1  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $30, $2c, $2d ;         frame 2
00E9DB  1  0C 30 2C 2D  
00E9DF  1  08 09 0A 0B        .byte $08, $09, $0a, $0b, $2e, $2f, $2c, $2d ;         frame 3
00E9E3  1  2E 2F 2C 2D  
00E9E7  1  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $5c, $5d ;climbing frame 1
00E9EB  1  2A 2B 5C 5D  
00E9EF  1  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $0d, $5e, $5f ;         frame 2
00E9F3  1  0C 0D 5E 5F  
00E9F7  1  FC FC 08 09        .byte $fc, $fc, $08, $09, $58, $59, $5a, $5a ;crouching
00E9FB  1  58 59 5A 5A  
00E9FF  1  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $0e, $0f ;fireball throwing
00EA03  1  2A 2B 0E 0F  
00EA07  1               
00EA07  1               ;small player table
00EA07  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $34, $35 ;walking frame 1
00EA0B  1  32 33 34 35  
00EA0F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $36, $37, $38, $39 ;        frame 2
00EA13  1  36 37 38 39  
00EA17  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $3b, $3c ;        frame 3
00EA1B  1  3A 37 3B 3C  
00EA1F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3d, $3e, $3f, $40 ;skidding
00EA23  1  3D 3E 3F 40  
00EA27  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $41, $42, $43 ;jumping
00EA2B  1  32 41 42 43  
00EA2F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $44, $45 ;swimming frame 1
00EA33  1  32 33 44 45  
00EA37  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $44, $47 ;         frame 2
00EA3B  1  32 33 44 47  
00EA3F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $48, $49 ;         frame 3
00EA43  1  32 33 48 49  
00EA47  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $90, $91 ;climbing frame 1
00EA4B  1  32 33 90 91  
00EA4F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $92, $93 ;         frame 2
00EA53  1  3A 37 92 93  
00EA57  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $9e, $9e, $9f, $9f ;killed
00EA5B  1  9E 9E 9F 9F  
00EA5F  1               
00EA5F  1               ;used by both player sizes
00EA5F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $4f, $4f ;small player standing
00EA63  1  3A 37 4F 4F  
00EA67  1  FC FC 00 01        .byte $fc, $fc, $00, $01, $4c, $4d, $4e, $4e ;intermediate grow frame
00EA6B  1  4C 4D 4E 4E  
00EA6F  1  00 01 4C 4D        .byte $00, $01, $4c, $4d, $4a, $4a, $4b, $4b ;big player standing
00EA73  1  4A 4A 4B 4B  
00EA77  1               
00EA77  1               SwimKickTileNum:
00EA77  1  31 46              .byte $31, $46
00EA79  1               
00EA79  1               PlayerGfxHandler:
00EA79  1  AD 9E 07             lda InjuryTimer             ;if player's injured invincibility timer
00EA7C  1  F0 05                beq CntPl                   ;not set, skip checkpoint and continue code
00EA7E  1  A5 09                lda FrameCounter
00EA80  1  4A                   lsr                         ;otherwise check frame counter and branch
00EA81  1  B0 40                bcs ExPGH                   ;to leave on every other frame (when d0 is set)
00EA83  1  A5 0E        CntPl:  lda GameEngineSubroutine    ;if executing specific game engine routine,
00EA85  1  C9 0B                cmp #$0b                    ;branch ahead to some other part
00EA87  1  F0 47                beq PlayerKilled
00EA89  1  AD 0B 07             lda PlayerChangeSizeFlag    ;if grow/shrink flag set
00EA8C  1  D0 3C                bne DoChangeSize            ;then branch to some other code
00EA8E  1  AC 04 07             ldy SwimmingFlag            ;if swimming flag set, branch to
00EA91  1  F0 31                beq FindPlayerAction        ;different part, do not return
00EA93  1  A5 1D                lda Player_State
00EA95  1  C9 00                cmp #$00                    ;if player status normal,
00EA97  1  F0 2B                beq FindPlayerAction        ;branch and do not return
00EA99  1  20 C4 EA             jsr FindPlayerAction        ;otherwise jump and return
00EA9C  1  A5 09                lda FrameCounter
00EA9E  1  29 04                and #%00000100              ;check frame counter for d2 set (8 frames every
00EAA0  1  D0 21                bne ExPGH                   ;eighth frame), and branch if set to leave
00EAA2  1  AA                   tax                         ;initialize X to zero
00EAA3  1  AC E4 06             ldy Player_SprDataOffset    ;get player sprite data offset
00EAA6  1  A5 33                lda PlayerFacingDir         ;get player's facing direction
00EAA8  1  4A                   lsr
00EAA9  1  B0 04                bcs SwimKT                  ;if player facing to the right, use current offset
00EAAB  1  C8                   iny
00EAAC  1  C8                   iny                         ;otherwise move to next OAM data
00EAAD  1  C8                   iny
00EAAE  1  C8                   iny
00EAAF  1  AD 54 07     SwimKT: lda PlayerSize              ;check player's size
00EAB2  1  F0 09                beq BigKTS                  ;if big, use first tile
00EAB4  1  B9 19 02             lda Sprite_Tilenumber+24,y  ;check tile number of seventh/eighth sprite
00EAB7  1  CD 45 EA             cmp SwimTileRepOffset       ;against tile number in player graphics table
00EABA  1  F0 07                beq ExPGH                   ;if spr7/spr8 tile number = value, branch to leave
00EABC  1  E8                   inx                         ;otherwise increment X for second tile
00EABD  1  BD 77 EA     BigKTS: lda SwimKickTileNum,x       ;overwrite tile number in sprite 7/8
00EAC0  1  99 19 02             sta Sprite_Tilenumber+24,y  ;to animate player's feet when swimming
00EAC3  1  60           ExPGH:  rts                         ;then leave
00EAC4  1               
00EAC4  1               FindPlayerAction:
00EAC4  1  20 5C EB           jsr ProcessPlayerAction       ;find proper offset to graphics table by player's actions
00EAC7  1  4C D5 EA           jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
00EACA  1               
00EACA  1               DoChangeSize:
00EACA  1  20 20 EC           jsr HandleChangeSize          ;find proper offset to graphics table for grow/shrink
00EACD  1  4C D5 EA           jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
00EAD0  1               
00EAD0  1               PlayerKilled:
00EAD0  1  A0 0E              ldy #$0e                      ;load offset for player killed
00EAD2  1  B9 97 E9           lda PlayerGfxTblOffsets,y     ;get offset to graphics table
00EAD5  1               
00EAD5  1               PlayerGfxProcessing:
00EAD5  1  8D D5 06            sta PlayerGfxOffset           ;store offset to graphics table here
00EAD8  1  A9 04               lda #$04
00EADA  1  20 2E EB            jsr RenderPlayerSub           ;draw player based on offset loaded
00EADD  1  20 59 EC            jsr ChkForPlayerAttrib        ;set horizontal flip bits as necessary
00EAE0  1  AD 11 07            lda FireballThrowingTimer
00EAE3  1  F0 25               beq PlayerOffscreenChk        ;if fireball throw timer not set, skip to the end
00EAE5  1  A0 00               ldy #$00                      ;set value to initialize by default
00EAE7  1  AD 81 07            lda PlayerAnimTimer           ;get animation frame timer
00EAEA  1  CD 11 07            cmp FireballThrowingTimer     ;compare to fireball throw timer
00EAED  1  8C 11 07            sty FireballThrowingTimer     ;initialize fireball throw timer
00EAF0  1  B0 18               bcs PlayerOffscreenChk        ;if animation frame timer => fireball throw timer skip to end
00EAF2  1  8D 11 07            sta FireballThrowingTimer     ;otherwise store animation timer into fireball throw timer
00EAF5  1  A0 07               ldy #$07                      ;load offset for throwing
00EAF7  1  B9 97 E9            lda PlayerGfxTblOffsets,y     ;get offset to graphics table
00EAFA  1  8D D5 06            sta PlayerGfxOffset           ;store it for use later
00EAFD  1  A0 04               ldy #$04                      ;set to update four sprite rows by default
00EAFF  1  A5 57               lda Player_X_Speed
00EB01  1  05 0C               ora Left_Right_Buttons        ;check for horizontal speed or left/right button press
00EB03  1  F0 01               beq SUpdR                     ;if no speed or button press, branch using set value in Y
00EB05  1  88                  dey                           ;otherwise set to update only three sprite rows
00EB06  1  98           SUpdR: tya                           ;save in A for use
00EB07  1  20 2E EB            jsr RenderPlayerSub           ;in sub, draw player object again
00EB0A  1               
00EB0A  1               PlayerOffscreenChk:
00EB0A  1  AD D0 03                lda Player_OffscreenBits      ;get player's offscreen bits
00EB0D  1  4A                      lsr
00EB0E  1  4A                      lsr                           ;move vertical bits to low nybble
00EB0F  1  4A                      lsr
00EB10  1  4A                      lsr
00EB11  1  85 00                   sta $00                       ;store here
00EB13  1  A2 03                   ldx #$03                      ;check all four rows of player sprites
00EB15  1  AD E4 06                lda Player_SprDataOffset      ;get player's sprite data offset
00EB18  1  18                      clc
00EB19  1  69 18                   adc #$18                      ;add 24 bytes to start at bottom row
00EB1B  1  A8                      tay                           ;set as offset here
00EB1C  1  A9 F8        PROfsLoop: lda #$f8                      ;load offscreen Y coordinate just in case
00EB1E  1  46 00                   lsr $00                       ;shift bit into carry
00EB20  1  90 03                   bcc NPROffscr                 ;if bit not set, skip, do not move sprites
00EB22  1  20 51 E1                jsr DumpTwoSpr                ;otherwise dump offscreen Y coordinate into sprite data
00EB25  1  98           NPROffscr: tya
00EB26  1  38                      sec                           ;subtract eight bytes to do
00EB27  1  E9 08                   sbc #$08                      ;next row up
00EB29  1  A8                      tay
00EB2A  1  CA                      dex                           ;decrement row counter
00EB2B  1  10 EF                   bpl PROfsLoop                 ;do this until all sprite rows are checked
00EB2D  1  60                      rts                           ;then we are done!
00EB2E  1               
00EB2E  1               ;-------------------------------------------------------------------------------------
00EB2E  1               ;$00-$01 - used to hold tile numbers, $00 also used to hold upper extent of animation frames
00EB2E  1               ;$02 - vertical position
00EB2E  1               ;$03 - facing direction, used as horizontal flip control
00EB2E  1               ;$04 - attributes
00EB2E  1               ;$05 - horizontal position
00EB2E  1               ;$07 - number of rows to draw
00EB2E  1               ;these also used in IntermediatePlayerData
00EB2E  1               
00EB2E  1               RenderPlayerSub:
00EB2E  1  85 07                sta $07                      ;store number of rows of sprites to draw
00EB30  1  AD AD 03             lda Player_Rel_XPos
00EB33  1  8D 55 07             sta Player_Pos_ForScroll     ;store player's relative horizontal position
00EB36  1  85 05                sta $05                      ;store it here also
00EB38  1  AD B8 03             lda Player_Rel_YPos
00EB3B  1  85 02                sta $02                      ;store player's vertical position
00EB3D  1  A5 33                lda PlayerFacingDir
00EB3F  1  85 03                sta $03                      ;store player's facing direction
00EB41  1  AD C4 03             lda Player_SprAttrib
00EB44  1  85 04                sta $04                      ;store player's sprite attributes
00EB46  1  AE D5 06             ldx PlayerGfxOffset          ;load graphics table offset
00EB49  1  AC E4 06             ldy Player_SprDataOffset     ;get player's sprite data offset
00EB4C  1               
00EB4C  1               DrawPlayerLoop:
00EB4C  1  BD A7 E9             lda PlayerGraphicsTable,x    ;load player's left side
00EB4F  1  85 00                sta $00
00EB51  1  BD A8 E9             lda PlayerGraphicsTable+1,x  ;now load right side
00EB54  1  20 42 E7             jsr DrawOneSpriteRow
00EB57  1  C6 07                dec $07                      ;decrement rows of sprites to draw
00EB59  1  D0 F1                bne DrawPlayerLoop           ;do this until all rows are drawn
00EB5B  1  60                   rts
00EB5C  1               
00EB5C  1               ProcessPlayerAction:
00EB5C  1  A5 1D                lda Player_State      ;get player's state
00EB5E  1  C9 03                cmp #$03
00EB60  1  F0 52                beq ActionClimbing    ;if climbing, branch here
00EB62  1  C9 02                cmp #$02
00EB64  1  F0 3E                beq ActionFalling     ;if falling, branch here
00EB66  1  C9 01                cmp #$01
00EB68  1  D0 11                bne ProcOnGroundActs  ;if not jumping, branch here
00EB6A  1  AD 04 07             lda SwimmingFlag
00EB6D  1  D0 51                bne ActionSwimming    ;if swimming flag set, branch elsewhere
00EB6F  1  A0 06                ldy #$06              ;load offset for crouching
00EB71  1  AD 14 07             lda CrouchingFlag     ;get crouching flag
00EB74  1  D0 22                bne NonAnimatedActs   ;if set, branch to get offset for graphics table
00EB76  1  A0 00                ldy #$00              ;otherwise load offset for jumping
00EB78  1  4C 98 EB             jmp NonAnimatedActs   ;go to get offset to graphics table
00EB7B  1               
00EB7B  1               ProcOnGroundActs:
00EB7B  1  A0 06                ldy #$06                   ;load offset for crouching
00EB7D  1  AD 14 07             lda CrouchingFlag          ;get crouching flag
00EB80  1  D0 16                bne NonAnimatedActs        ;if set, branch to get offset for graphics table
00EB82  1  A0 02                ldy #$02                   ;load offset for standing
00EB84  1  A5 57                lda Player_X_Speed         ;check player's horizontal speed
00EB86  1  05 0C                ora Left_Right_Buttons     ;and left/right controller bits
00EB88  1  F0 0E                beq NonAnimatedActs        ;if no speed or buttons pressed, use standing offset
00EB8A  1  AD 00 07             lda Player_XSpeedAbsolute  ;load walking/running speed
00EB8D  1  C9 09                cmp #$09
00EB8F  1  90 1B                bcc ActionWalkRun          ;if less than a certain amount, branch, too slow to skid
00EB91  1  A5 45                lda Player_MovingDir       ;otherwise check to see if moving direction
00EB93  1  25 33                and PlayerFacingDir        ;and facing direction are the same
00EB95  1  D0 15                bne ActionWalkRun          ;if moving direction = facing direction, branch, don't skid
00EB97  1  C8                   iny                        ;otherwise increment to skid offset ($03)
00EB98  1               
00EB98  1               NonAnimatedActs:
00EB98  1  20 01 EC             jsr GetGfxOffsetAdder      ;do a sub here to get offset adder for graphics table
00EB9B  1  A9 00                lda #$00
00EB9D  1  8D 0D 07             sta PlayerAnimCtrl         ;initialize animation frame control
00EBA0  1  B9 97 E9             lda PlayerGfxTblOffsets,y  ;load offset to graphics table using size as offset
00EBA3  1  60                   rts
00EBA4  1               
00EBA4  1               ActionFalling:
00EBA4  1  A0 04                ldy #$04                  ;load offset for walking/running
00EBA6  1  20 01 EC             jsr GetGfxOffsetAdder     ;get offset to graphics table
00EBA9  1  4C D2 EB             jmp GetCurrentAnimOffset  ;execute instructions for falling state
00EBAC  1               
00EBAC  1               ActionWalkRun:
00EBAC  1  A0 04                ldy #$04               ;load offset for walking/running
00EBAE  1  20 01 EC             jsr GetGfxOffsetAdder  ;get offset to graphics table
00EBB1  1  4C D8 EB             jmp FourFrameExtent    ;execute instructions for normal state
00EBB4  1               
00EBB4  1               ActionClimbing:
00EBB4  1  A0 05                ldy #$05               ;load offset for climbing
00EBB6  1  A5 9F                lda Player_Y_Speed     ;check player's vertical speed
00EBB8  1  F0 DE                beq NonAnimatedActs    ;if no speed, branch, use offset as-is
00EBBA  1  20 01 EC             jsr GetGfxOffsetAdder  ;otherwise get offset for graphics table
00EBBD  1  4C DD EB             jmp ThreeFrameExtent   ;then skip ahead to more code
00EBC0  1               
00EBC0  1               ActionSwimming:
00EBC0  1  A0 01                ldy #$01               ;load offset for swimming
00EBC2  1  20 01 EC             jsr GetGfxOffsetAdder
00EBC5  1  AD 82 07             lda JumpSwimTimer      ;check jump/swim timer
00EBC8  1  0D 0D 07             ora PlayerAnimCtrl     ;and animation frame control
00EBCB  1  D0 0B                bne FourFrameExtent    ;if any one of these set, branch ahead
00EBCD  1  A5 0A                lda A_B_Buttons
00EBCF  1  0A                   asl                    ;check for A button pressed
00EBD0  1  B0 06                bcs FourFrameExtent    ;branch to same place if A button pressed
00EBD2  1               
00EBD2  1               GetCurrentAnimOffset:
00EBD2  1  AD 0D 07             lda PlayerAnimCtrl         ;get animation frame control
00EBD5  1  4C 40 EC             jmp GetOffsetFromAnimCtrl  ;jump to get proper offset to graphics table
00EBD8  1               
00EBD8  1               FourFrameExtent:
00EBD8  1  A9 03                lda #$03              ;load upper extent for frame control
00EBDA  1  4C DF EB             jmp AnimationControl  ;jump to get offset and animate player object
00EBDD  1               
00EBDD  1               ThreeFrameExtent:
00EBDD  1  A9 02                lda #$02              ;load upper extent for frame control for climbing
00EBDF  1               
00EBDF  1               AnimationControl:
00EBDF  1  85 00                  sta $00                   ;store upper extent here
00EBE1  1  20 D2 EB               jsr GetCurrentAnimOffset  ;get proper offset to graphics table
00EBE4  1  48                     pha                       ;save offset to stack
00EBE5  1  AD 81 07               lda PlayerAnimTimer       ;load animation frame timer
00EBE8  1  D0 15                  bne ExAnimC               ;branch if not expired
00EBEA  1  AD 0C 07               lda PlayerAnimTimerSet    ;get animation frame timer amount
00EBED  1  8D 81 07               sta PlayerAnimTimer       ;and set timer accordingly
00EBF0  1  AD 0D 07               lda PlayerAnimCtrl
00EBF3  1  18                     clc                       ;add one to animation frame control
00EBF4  1  69 01                  adc #$01
00EBF6  1  C5 00                  cmp $00                   ;compare to upper extent
00EBF8  1  90 02                  bcc SetAnimC              ;if frame control + 1 < upper extent, use as next
00EBFA  1  A9 00                  lda #$00                  ;otherwise initialize frame control
00EBFC  1  8D 0D 07     SetAnimC: sta PlayerAnimCtrl        ;store as new animation frame control
00EBFF  1  68           ExAnimC:  pla                       ;get offset to graphics table from stack and leave
00EC00  1  60                     rts
00EC01  1               
00EC01  1               GetGfxOffsetAdder:
00EC01  1  AD 54 07             lda PlayerSize  ;get player's size
00EC04  1  F0 05                beq SzOfs       ;if player big, use current offset as-is
00EC06  1  98                   tya             ;for big player
00EC07  1  18                   clc             ;otherwise add eight bytes to offset
00EC08  1  69 08                adc #$08        ;for small player
00EC0A  1  A8                   tay
00EC0B  1  60           SzOfs:  rts             ;go back
00EC0C  1               
00EC0C  1               ChangeSizeOffsetAdder:
00EC0C  1  00 01 00 01          .byte $00, $01, $00, $01, $00, $01, $02, $00, $01, $02
00EC10  1  00 01 02 00  
00EC14  1  01 02        
00EC16  1  02 00 02 00          .byte $02, $00, $02, $00, $02, $00, $02, $00, $02, $00
00EC1A  1  02 00 02 00  
00EC1E  1  02 00        
00EC20  1               
00EC20  1               HandleChangeSize:
00EC20  1  AC 0D 07              ldy PlayerAnimCtrl           ;get animation frame control
00EC23  1  A5 09                 lda FrameCounter
00EC25  1  29 03                 and #%00000011               ;get frame counter and execute this code every
00EC27  1  D0 0D                 bne GorSLog                  ;fourth frame, otherwise branch ahead
00EC29  1  C8                    iny                          ;increment frame control
00EC2A  1  C0 0A                 cpy #$0a                     ;check for preset upper extent
00EC2C  1  90 05                 bcc CSzNext                  ;if not there yet, skip ahead to use
00EC2E  1  A0 00                 ldy #$00                     ;otherwise initialize both grow/shrink flag
00EC30  1  8C 0B 07              sty PlayerChangeSizeFlag     ;and animation frame control
00EC33  1  8C 0D 07     CSzNext: sty PlayerAnimCtrl           ;store proper frame control
00EC36  1  AD 54 07     GorSLog: lda PlayerSize               ;get player's size
00EC39  1  D0 0C                 bne ShrinkPlayer             ;if player small, skip ahead to next part
00EC3B  1               GrowPlayer:
00EC3B  1  B9 0C EC              lda ChangeSizeOffsetAdder,y  ;get offset adder based on frame control as offset
00EC3E  1  A0 0F                 ldy #$0f                     ;load offset for player growing
00EC40  1               
00EC40  1               GetOffsetFromAnimCtrl:
00EC40  1  0A                   asl                        ;multiply animation frame control
00EC41  1  0A                   asl                        ;by eight to get proper amount
00EC42  1  0A                   asl                        ;to add to our offset
00EC43  1  79 97 E9             adc PlayerGfxTblOffsets,y  ;add to offset to graphics table
00EC46  1  60                   rts                        ;and return with result in A
00EC47  1               
00EC47  1               ShrinkPlayer:
00EC47  1  98                   tya                          ;add ten bytes to frame control as offset
00EC48  1  18                   clc
00EC49  1  69 0A                adc #$0a                     ;this thing apparently uses two of the swimming frames
00EC4B  1  AA                   tax                          ;to draw the player shrinking
00EC4C  1  A0 09                ldy #$09                     ;load offset for small player swimming
00EC4E  1  BD 0C EC             lda ChangeSizeOffsetAdder,x  ;get what would normally be offset adder
00EC51  1  D0 02                bne ShrPlF                   ;and branch to use offset if nonzero
00EC53  1  A0 01                ldy #$01                     ;otherwise load offset for big player swimming
00EC55  1  B9 97 E9     ShrPlF: lda PlayerGfxTblOffsets,y    ;get offset to graphics table based on offset loaded
00EC58  1  60                   rts                          ;and leave
00EC59  1               
00EC59  1               ChkForPlayerAttrib:
00EC59  1  AC E4 06                ldy Player_SprDataOffset    ;get sprite data offset
00EC5C  1  A5 0E                   lda GameEngineSubroutine
00EC5E  1  C9 0B                   cmp #$0b                    ;if executing specific game engine routine,
00EC60  1  F0 13                   beq KilledAtt               ;branch to change third and fourth row OAM attributes
00EC62  1  AD D5 06                lda PlayerGfxOffset         ;get graphics table offset
00EC65  1  C9 50                   cmp #$50
00EC67  1  F0 1E                   beq C_S_IGAtt               ;if crouch offset, either standing offset,
00EC69  1  C9 B8                   cmp #$b8                    ;or intermediate growing offset,
00EC6B  1  F0 1A                   beq C_S_IGAtt               ;go ahead and execute code to change
00EC6D  1  C9 C0                   cmp #$c0                    ;fourth row OAM attributes only
00EC6F  1  F0 16                   beq C_S_IGAtt
00EC71  1  C9 C8                   cmp #$c8
00EC73  1  D0 24                   bne ExPlyrAt                ;if none of these, branch to leave
00EC75  1  B9 12 02     KilledAtt: lda Sprite_Attributes+16,y
00EC78  1  29 3F                   and #%00111111              ;mask out horizontal and vertical flip bits
00EC7A  1  99 12 02                sta Sprite_Attributes+16,y  ;for third row sprites and save
00EC7D  1  B9 16 02                lda Sprite_Attributes+20,y
00EC80  1  29 3F                   and #%00111111
00EC82  1  09 40                   ora #%01000000              ;set horizontal flip bit for second
00EC84  1  99 16 02                sta Sprite_Attributes+20,y  ;sprite in the third row
00EC87  1  B9 1A 02     C_S_IGAtt: lda Sprite_Attributes+24,y
00EC8A  1  29 3F                   and #%00111111              ;mask out horizontal and vertical flip bits
00EC8C  1  99 1A 02                sta Sprite_Attributes+24,y  ;for fourth row sprites and save
00EC8F  1  B9 1E 02                lda Sprite_Attributes+28,y
00EC92  1  29 3F                   and #%00111111
00EC94  1  09 40                   ora #%01000000              ;set horizontal flip bit for second
00EC96  1  99 1E 02                sta Sprite_Attributes+28,y  ;sprite in the fourth row
00EC99  1  60           ExPlyrAt:  rts                         ;leave
00EC9A  1               
00EC9A  1               ;-------------------------------------------------------------------------------------
00EC9A  1               ;$00 - used in adding to get proper offset
00EC9A  1               
00EC9A  1               RelativePlayerPosition:
00EC9A  1  A2 00                ldx #$00      ;set offsets for relative cooordinates
00EC9C  1  A0 00                ldy #$00      ;routine to correspond to player object
00EC9E  1  4C B2 EC             jmp RelWOfs   ;get the coordinates
00ECA1  1               
00ECA1  1               RelativeBubblePosition:
00ECA1  1  A0 01                ldy #$01                ;set for air bubble offsets
00ECA3  1  20 18 ED             jsr GetProperObjOffset  ;modify X to get proper air bubble offset
00ECA6  1  A0 03                ldy #$03
00ECA8  1  4C B2 EC             jmp RelWOfs             ;get the coordinates
00ECAB  1               
00ECAB  1               RelativeFireballPosition:
00ECAB  1  A0 00                 ldy #$00                    ;set for fireball offsets
00ECAD  1  20 18 ED              jsr GetProperObjOffset      ;modify X to get proper fireball offset
00ECB0  1  A0 02                 ldy #$02
00ECB2  1  20 E1 EC     RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
00ECB5  1  A6 08                 ldx ObjectOffset            ;return original offset
00ECB7  1  60                    rts                         ;leave
00ECB8  1               
00ECB8  1               RelativeMiscPosition:
00ECB8  1  A0 02                ldy #$02                ;set for misc object offsets
00ECBA  1  20 18 ED             jsr GetProperObjOffset  ;modify X to get proper misc object offset
00ECBD  1  A0 06                ldy #$06
00ECBF  1  4C B2 EC             jmp RelWOfs             ;get the coordinates
00ECC2  1               
00ECC2  1               RelativeEnemyPosition:
00ECC2  1  A9 01                lda #$01                     ;get coordinates of enemy object
00ECC4  1  A0 01                ldy #$01                     ;relative to the screen
00ECC6  1  4C D5 EC             jmp VariableObjOfsRelPos
00ECC9  1               
00ECC9  1               RelativeBlockPosition:
00ECC9  1  A9 09                lda #$09                     ;get coordinates of one block object
00ECCB  1  A0 04                ldy #$04                     ;relative to the screen
00ECCD  1  20 D5 EC             jsr VariableObjOfsRelPos
00ECD0  1  E8                   inx                          ;adjust offset for other block object if any
00ECD1  1  E8                   inx
00ECD2  1  A9 09                lda #$09
00ECD4  1  C8                   iny                          ;adjust other and get coordinates for other one
00ECD5  1               
00ECD5  1               VariableObjOfsRelPos:
00ECD5  1  86 00                stx $00                     ;store value to add to A here
00ECD7  1  18                   clc
00ECD8  1  65 00                adc $00                     ;add A to value stored
00ECDA  1  AA                   tax                         ;use as enemy offset
00ECDB  1  20 E1 EC             jsr GetObjRelativePosition
00ECDE  1  A6 08                ldx ObjectOffset            ;reload old object offset and leave
00ECE0  1  60                   rts
00ECE1  1               
00ECE1  1               GetObjRelativePosition:
00ECE1  1  B5 CE                lda SprObject_Y_Position,x  ;load vertical coordinate low
00ECE3  1  99 B8 03             sta SprObject_Rel_YPos,y    ;store here
00ECE6  1  B5 86                lda SprObject_X_Position,x  ;load horizontal coordinate
00ECE8  1  38                   sec                         ;subtract left edge coordinate
00ECE9  1  ED 1C 07             sbc ScreenLeft_X_Pos
00ECEC  1  99 AD 03             sta SprObject_Rel_XPos,y    ;store result here
00ECEF  1  60                   rts
00ECF0  1               
00ECF0  1               ;-------------------------------------------------------------------------------------
00ECF0  1               ;$00 - used as temp variable to hold offscreen bits
00ECF0  1               
00ECF0  1               GetPlayerOffscreenBits:
00ECF0  1  A2 00                ldx #$00                 ;set offsets for player-specific variables
00ECF2  1  A0 00                ldy #$00                 ;and get offscreen information about player
00ECF4  1  4C 30 ED             jmp GetOffScreenBitsSet
00ECF7  1               
00ECF7  1               GetFireballOffscreenBits:
00ECF7  1  A0 00                ldy #$00                 ;set for fireball offsets
00ECF9  1  20 18 ED             jsr GetProperObjOffset   ;modify X to get proper fireball offset
00ECFC  1  A0 02                ldy #$02                 ;set other offset for fireball's offscreen bits
00ECFE  1  4C 30 ED             jmp GetOffScreenBitsSet  ;and get offscreen information about fireball
00ED01  1               
00ED01  1               GetBubbleOffscreenBits:
00ED01  1  A0 01                ldy #$01                 ;set for air bubble offsets
00ED03  1  20 18 ED             jsr GetProperObjOffset   ;modify X to get proper air bubble offset
00ED06  1  A0 03                ldy #$03                 ;set other offset for airbubble's offscreen bits
00ED08  1  4C 30 ED             jmp GetOffScreenBitsSet  ;and get offscreen information about air bubble
00ED0B  1               
00ED0B  1               GetMiscOffscreenBits:
00ED0B  1  A0 02                ldy #$02                 ;set for misc object offsets
00ED0D  1  20 18 ED             jsr GetProperObjOffset   ;modify X to get proper misc object offset
00ED10  1  A0 06                ldy #$06                 ;set other offset for misc object's offscreen bits
00ED12  1  4C 30 ED             jmp GetOffScreenBitsSet  ;and get offscreen information about misc object
00ED15  1               
00ED15  1               ObjOffsetData:
00ED15  1  07 16 0D             .byte $07, $16, $0d
00ED18  1               
00ED18  1               GetProperObjOffset:
00ED18  1  8A                   txa                  ;move offset to A
00ED19  1  18                   clc
00ED1A  1  79 15 ED             adc ObjOffsetData,y  ;add amount of bytes to offset depending on setting in Y
00ED1D  1  AA                   tax                  ;put back in X and leave
00ED1E  1  60                   rts
00ED1F  1               
00ED1F  1               GetEnemyOffscreenBits:
00ED1F  1  A9 01                lda #$01                 ;set A to add 1 byte in order to get enemy offset
00ED21  1  A0 01                ldy #$01                 ;set Y to put offscreen bits in Enemy_OffscreenBits
00ED23  1  4C 2A ED             jmp SetOffscrBitsOffset
00ED26  1               
00ED26  1               GetBlockOffscreenBits:
00ED26  1  A9 09                lda #$09       ;set A to add 9 bytes in order to get block obj offset
00ED28  1  A0 04                ldy #$04       ;set Y to put offscreen bits in Block_OffscreenBits
00ED2A  1               
00ED2A  1               SetOffscrBitsOffset:
00ED2A  1  86 00                stx $00
00ED2C  1  18                   clc           ;add contents of X to A to get
00ED2D  1  65 00                adc $00       ;appropriate offset, then give back to X
00ED2F  1  AA                   tax
00ED30  1               
00ED30  1               GetOffScreenBitsSet:
00ED30  1  98                   tya                         ;save offscreen bits offset to stack for now
00ED31  1  48                   pha
00ED32  1  20 47 ED             jsr RunOffscrBitsSubs
00ED35  1  0A                   asl                         ;move low nybble to high nybble
00ED36  1  0A                   asl
00ED37  1  0A                   asl
00ED38  1  0A                   asl
00ED39  1  05 00                ora $00                     ;mask together with previously saved low nybble
00ED3B  1  85 00                sta $00                     ;store both here
00ED3D  1  68                   pla                         ;get offscreen bits offset from stack
00ED3E  1  A8                   tay
00ED3F  1  A5 00                lda $00                     ;get value here and store elsewhere
00ED41  1  99 D0 03             sta SprObject_OffscrBits,y
00ED44  1  A6 08                ldx ObjectOffset
00ED46  1  60                   rts
00ED47  1               
00ED47  1               RunOffscrBitsSubs:
00ED47  1  20 66 ED             jsr GetXOffscreenBits  ;do subroutine here
00ED4A  1  4A                   lsr                    ;move high nybble to low
00ED4B  1  4A                   lsr
00ED4C  1  4A                   lsr
00ED4D  1  4A                   lsr
00ED4E  1  85 00                sta $00                ;store here
00ED50  1  4C A9 ED             jmp GetYOffscreenBits
00ED53  1               
00ED53  1               ;--------------------------------
00ED53  1               ;(these apply to these three subsections)
00ED53  1               ;$04 - used to store proper offset
00ED53  1               ;$05 - used as adder in DividePDiff
00ED53  1               ;$06 - used to store preset value used to compare to pixel difference in $07
00ED53  1               ;$07 - used to store difference between coordinates of object and screen edges
00ED53  1               
00ED53  1               XOffscreenBitsData:
00ED53  1  7F 3F 1F 0F          .byte $7f, $3f, $1f, $0f, $07, $03, $01, $00
00ED57  1  07 03 01 00  
00ED5B  1  80 C0 E0 F0          .byte $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
00ED5F  1  F8 FC FE FF  
00ED63  1               
00ED63  1               DefaultXOnscreenOfs:
00ED63  1  07 0F 07             .byte $07, $0f, $07
00ED66  1               
00ED66  1               GetXOffscreenBits:
00ED66  1  86 04                  stx $04                     ;save position in buffer to here
00ED68  1  A0 01                  ldy #$01                    ;start with right side of screen
00ED6A  1  B9 1C 07     XOfsLoop: lda ScreenEdge_X_Pos,y      ;get pixel coordinate of edge
00ED6D  1  38                     sec                         ;get difference between pixel coordinate of edge
00ED6E  1  F5 86                  sbc SprObject_X_Position,x  ;and pixel coordinate of object position
00ED70  1  85 07                  sta $07                     ;store here
00ED72  1  B9 1A 07               lda ScreenEdge_PageLoc,y    ;get page location of edge
00ED75  1  F5 6D                  sbc SprObject_PageLoc,x     ;subtract from page location of object position
00ED77  1  BE 63 ED               ldx DefaultXOnscreenOfs,y   ;load offset value here
00ED7A  1  C9 00                  cmp #$00
00ED7C  1  30 10                  bmi XLdBData                ;if beyond right edge or in front of left edge, branch
00ED7E  1  BE 64 ED               ldx DefaultXOnscreenOfs+1,y ;if not, load alternate offset value here
00ED81  1  C9 01                  cmp #$01
00ED83  1  10 09                  bpl XLdBData                ;if one page or more to the left of either edge, branch
00ED85  1  A9 38                  lda #$38                    ;if no branching, load value here and store
00ED87  1  85 06                  sta $06
00ED89  1  A9 08                  lda #$08                    ;load some other value and execute subroutine
00ED8B  1  20 DD ED               jsr DividePDiff
00ED8E  1  BD 53 ED     XLdBData: lda XOffscreenBitsData,x    ;get bits here
00ED91  1  A6 04                  ldx $04                     ;reobtain position in buffer
00ED93  1  C9 00                  cmp #$00                    ;if bits not zero, branch to leave
00ED95  1  D0 03                  bne ExXOfsBS
00ED97  1  88                     dey                         ;otherwise, do left side of screen now
00ED98  1  10 D0                  bpl XOfsLoop                ;branch if not already done with left side
00ED9A  1  60           ExXOfsBS: rts
00ED9B  1               
00ED9B  1               ;--------------------------------
00ED9B  1               
00ED9B  1               YOffscreenBitsData:
00ED9B  1  00 08 0C 0E          .byte $00, $08, $0c, $0e
00ED9F  1  0F 07 03 01          .byte $0f, $07, $03, $01
00EDA3  1  00                   .byte $00
00EDA4  1               
00EDA4  1               DefaultYOnscreenOfs:
00EDA4  1  04 00 04             .byte $04, $00, $04
00EDA7  1               
00EDA7  1               HighPosUnitData:
00EDA7  1  FF 00                .byte $ff, $00
00EDA9  1               
00EDA9  1               GetYOffscreenBits:
00EDA9  1  86 04                  stx $04                      ;save position in buffer to here
00EDAB  1  A0 01                  ldy #$01                     ;start with top of screen
00EDAD  1  B9 A7 ED     YOfsLoop: lda HighPosUnitData,y        ;load coordinate for edge of vertical unit
00EDB0  1  38                     sec
00EDB1  1  F5 CE                  sbc SprObject_Y_Position,x   ;subtract from vertical coordinate of object
00EDB3  1  85 07                  sta $07                      ;store here
00EDB5  1  A9 01                  lda #$01                     ;subtract one from vertical high byte of object
00EDB7  1  F5 B5                  sbc SprObject_Y_HighPos,x
00EDB9  1  BE A4 ED               ldx DefaultYOnscreenOfs,y    ;load offset value here
00EDBC  1  C9 00                  cmp #$00
00EDBE  1  30 10                  bmi YLdBData                 ;if under top of the screen or beyond bottom, branch
00EDC0  1  BE A5 ED               ldx DefaultYOnscreenOfs+1,y  ;if not, load alternate offset value here
00EDC3  1  C9 01                  cmp #$01
00EDC5  1  10 09                  bpl YLdBData                 ;if one vertical unit or more above the screen, branch
00EDC7  1  A9 20                  lda #$20                     ;if no branching, load value here and store
00EDC9  1  85 06                  sta $06
00EDCB  1  A9 04                  lda #$04                     ;load some other value and execute subroutine
00EDCD  1  20 DD ED               jsr DividePDiff
00EDD0  1  BD 9B ED     YLdBData: lda YOffscreenBitsData,x     ;get offscreen data bits using offset
00EDD3  1  A6 04                  ldx $04                      ;reobtain position in buffer
00EDD5  1  C9 00                  cmp #$00
00EDD7  1  D0 03                  bne ExYOfsBS                 ;if bits not zero, branch to leave
00EDD9  1  88                     dey                          ;otherwise, do bottom of the screen now
00EDDA  1  10 D1                  bpl YOfsLoop
00EDDC  1  60           ExYOfsBS: rts
00EDDD  1               
00EDDD  1               ;--------------------------------
00EDDD  1               
00EDDD  1               DividePDiff:
00EDDD  1  85 05                  sta $05       ;store current value in A here
00EDDF  1  A5 07                  lda $07       ;get pixel difference
00EDE1  1  C5 06                  cmp $06       ;compare to preset value
00EDE3  1  B0 0C                  bcs ExDivPD   ;if pixel difference >= preset value, branch
00EDE5  1  4A                     lsr           ;divide by eight
00EDE6  1  4A                     lsr
00EDE7  1  4A                     lsr
00EDE8  1  29 07                  and #$07      ;mask out all but 3 LSB
00EDEA  1  C0 01                  cpy #$01      ;right side of the screen or top?
00EDEC  1  B0 02                  bcs SetOscrO  ;if so, branch, use difference / 8 as offset
00EDEE  1  65 05                  adc $05       ;if not, add value to difference / 8
00EDF0  1  AA           SetOscrO: tax           ;use as offset
00EDF1  1  60           ExDivPD:  rts           ;leave
00EDF2  1               
00EDF2  1               ;-------------------------------------------------------------------------------------
00EDF2  1               ;$00-$01 - tile numbers
00EDF2  1               ;$02 - Y coordinate
00EDF2  1               ;$03 - flip control
00EDF2  1               ;$04 - sprite attributes
00EDF2  1               ;$05 - X coordinate
00EDF2  1               
00EDF2  1               DrawSpriteObject:
00EDF2  1  A5 03                 lda $03                    ;get saved flip control bits
00EDF4  1  4A                    lsr
00EDF5  1  4A                    lsr                        ;move d1 into carry
00EDF6  1  A5 00                 lda $00
00EDF8  1  90 0C                 bcc NoHFlip                ;if d1 not set, branch
00EDFA  1  99 05 02              sta Sprite_Tilenumber+4,y  ;store first tile into second sprite
00EDFD  1  A5 01                 lda $01                    ;and second into first sprite
00EDFF  1  99 01 02              sta Sprite_Tilenumber,y
00EE02  1  A9 40                 lda #$40                   ;activate horizontal flip OAM attribute
00EE04  1  D0 0A                 bne SetHFAt                ;and unconditionally branch
00EE06  1  99 01 02     NoHFlip: sta Sprite_Tilenumber,y    ;store first tile into first sprite
00EE09  1  A5 01                 lda $01                    ;and second into second sprite
00EE0B  1  99 05 02              sta Sprite_Tilenumber+4,y
00EE0E  1  A9 00                 lda #$00                   ;clear bit for horizontal flip
00EE10  1  05 04        SetHFAt: ora $04                    ;add other OAM attributes if necessary
00EE12  1  99 02 02              sta Sprite_Attributes,y    ;store sprite attributes
00EE15  1  99 06 02              sta Sprite_Attributes+4,y
00EE18  1  A5 02                 lda $02                    ;now the y coordinates
00EE1A  1  99 00 02              sta Sprite_Y_Position,y    ;note because they are
00EE1D  1  99 04 02              sta Sprite_Y_Position+4,y  ;side by side, they are the same
00EE20  1  A5 05                 lda $05
00EE22  1  99 03 02              sta Sprite_X_Position,y    ;store x coordinate, then
00EE25  1  18                    clc                        ;add 8 pixels and store another to
00EE26  1  69 08                 adc #$08                   ;put them side by side
00EE28  1  99 07 02              sta Sprite_X_Position+4,y
00EE2B  1  A5 02                 lda $02                    ;add eight pixels to the next y
00EE2D  1  18                    clc                        ;coordinate
00EE2E  1  69 08                 adc #$08
00EE30  1  85 02                 sta $02
00EE32  1  98                    tya                        ;add eight to the offset in Y to
00EE33  1  18                    clc                        ;move to the next two sprites
00EE34  1  69 08                 adc #$08
00EE36  1  A8                    tay
00EE37  1  E8                    inx                        ;increment offset to return it to the
00EE38  1  E8                    inx                        ;routine that called this subroutine
00EE39  1  60                    rts
00EE3A  1               
00EE3A  1               ;-------------------------------------------------------------------------------------
00EE3A  1               ;$06-$07 - used to store block buffer address used as indirect
00EE3A  1               
00EE3A  1               BlockBufferAddr:
00EE3A  1  00 D0              .byte <Block_Buffer_1, <Block_Buffer_2
00EE3C  1  05 05              .byte >Block_Buffer_1, >Block_Buffer_2
00EE3E  1               
00EE3E  1               GetBlockBufferAddr:
00EE3E  1  48                 pha                      ;take value of A, save
00EE3F  1  4A                 lsr                      ;move high nybble to low
00EE40  1  4A                 lsr
00EE41  1  4A                 lsr
00EE42  1  4A                 lsr
00EE43  1  A8                 tay                      ;use nybble as pointer to high byte
00EE44  1  B9 3C EE           lda BlockBufferAddr+2,y  ;of indirect here
00EE47  1  85 07              sta $07
00EE49  1  68                 pla
00EE4A  1  29 0F              and #%00001111           ;pull from stack, mask out high nybble
00EE4C  1  18                 clc
00EE4D  1  79 3A EE           adc BlockBufferAddr,y    ;add to low byte
00EE50  1  85 06              sta $06                  ;store here and leave
00EE52  1  60                 rts
00EE53  1               
00EE53  1               ;-------------------------------------------------------------------------------------
00EE53  1               
00EE53  1               Setup_Vine:
00EE53  1  A9 2F                lda #VineObject          ;load identifier for vine object
00EE55  1  95 16                sta Enemy_ID,x           ;store in buffer
00EE57  1  A9 01                lda #$01
00EE59  1  95 0F                sta Enemy_Flag,x         ;set flag for enemy object buffer
00EE5B  1  B9 76 00             lda Block_PageLoc,y
00EE5E  1  95 6E                sta Enemy_PageLoc,x      ;copy page location from previous object
00EE60  1  B9 8F 00             lda Block_X_Position,y
00EE63  1  95 87                sta Enemy_X_Position,x   ;copy horizontal coordinate from previous object
00EE65  1  B9 D7 00             lda Block_Y_Position,y
00EE68  1  95 CF                sta Enemy_Y_Position,x   ;copy vertical coordinate from previous object
00EE6A  1  AC 98 03             ldy VineFlagOffset       ;load vine flag/offset to next available vine slot
00EE6D  1  D0 03                bne NextVO               ;if set at all, don't bother to store vertical
00EE6F  1  8D 9D 03             sta VineStart_Y_Position ;otherwise store vertical coordinate here
00EE72  1  8A           NextVO: txa                      ;store object offset to next available vine slot
00EE73  1  99 9A 03             sta VineObjOffset,y      ;using vine flag as offset
00EE76  1  EE 98 03             inc VineFlagOffset       ;increment vine flag offset
00EE79  1  A9 04                lda #Sfx_GrowVine
00EE7B  1  85 FE                sta Square2SoundQueue    ;load vine grow sound
00EE7D  1  60                   rts
00EE7E  1               
00EE7E  1               ;--------------------------------
00EE7E  1               ;$00 - used to store enemy identifier in KillEnemies
00EE7E  1               
00EE7E  1               KillEnemies:
00EE7E  1  85 00                   sta $00           ;store identifier here
00EE80  1  A9 00                   lda #$00
00EE82  1  A2 04                   ldx #$04          ;check for identifier in enemy object buffer
00EE84  1  B4 16        KillELoop: ldy Enemy_ID,x
00EE86  1  C4 00                   cpy $00           ;if not found, branch
00EE88  1  D0 02                   bne NoKillE
00EE8A  1  95 0F                   sta Enemy_Flag,x  ;if found, deactivate enemy object flag
00EE8C  1  CA           NoKillE:   dex               ;do this until all slots are checked
00EE8D  1  10 F5                   bpl KillELoop
00EE8F  1  60                      rts
00EE90  1               
00EE90  1               ;-------------------------------------------------------------------------------------
00EE90  1               
00EE90  1               AreaPalette:
00EE90  1  01 02 03 04        .byte $01, $02, $03, $04
00EE94  1               
00EE94  1               GetAreaPalette:
00EE94  1  AC 4E 07                    ldy AreaType             ;select appropriate palette to load
00EE97  1  BE 90 EE                    ldx AreaPalette,y        ;based on area type
00EE9A  1  8E 73 07     SetVRAMAddr_A: stx VRAM_Buffer_AddrCtrl ;store offset into buffer control
00EE9D  1  4C 3C EF     			   jmp IncSubtask           ;move onto next task
00EEA0  1               
00EEA0  1               ;-------------------------------------------------------------------------------------
00EEA0  1               ;$00 - used as temp counter in GetPlayerColors
00EEA0  1               
00EEA0  1               BGColorCtrl_Addr:
00EEA0  1  00 09 0A 04        .byte $00, $09, $0a, $04
00EEA4  1               
00EEA4  1               BackgroundColors:
00EEA4  1  22 22 0F 0F        .byte $22, $22, $0f, $0f ;used by area type if bg color ctrl not set
00EEA8  1  0F 22 0F 0F        .byte $0f, $22, $0f, $0f ;used by background color control if set
00EEAC  1               
00EEAC  1               PlayerColors:
00EEAC  1  22 16 27 18        .byte $22, $16, $27, $18 ;mario's colors
00EEB0  1  22 30 27 19        .byte $22, $30, $27, $19 ;luigi's colors
00EEB4  1  22 37 27 16        .byte $22, $37, $27, $16 ;fiery (used by both)
00EEB8  1               PeachColors:
00EEB8  1  22 16 27 30        .byte $22, $16, $27, $30 ; peach colors
00EEBC  1  22 16 27 37        .byte $22, $16, $27, $37 ; peach fire colors
00EEC0  1               
00EEC0  1               GetBackgroundColor:
00EEC0  1  AC 44 07                ldy BackgroundColorCtrl   ;check background color control
00EEC3  1  F0 06                   beq NoBGColor             ;if not set, increment task and fetch palette
00EEC5  1  B9 9C EE                lda BGColorCtrl_Addr-4,y  ;put appropriate palette into vram
00EEC8  1  8D 73 07                sta VRAM_Buffer_AddrCtrl  ;note that if set to 5-7, $0301 will not be read
00EECB  1  EE 3C 07     NoBGColor: inc ScreenRoutineTask     ;increment to next subtask and plod on through
00EECE  1               
00EECE  1               GetPlayerColors:
00EECE  1  AE 00 03                 ldx VRAM_Buffer1_Offset  ;get current buffer offset
00EED1  1  A0 00                    ldy #$00
00EED3  1  AD 53 07                 lda CurrentPlayer        ;check which player is on the screen
00EED6  1  F0 02                    beq ChkFiery
00EED8  1  A0 04                    ldy #$04                 ;load offset for luigi
00EEDA  1               ChkFiery:
00EEDA  1  AD 56 07                 lda PlayerStatus         ;check player status
00EEDD  1  C9 02                    cmp #$02
00EEDF  1  D0 02                    bne StartClrGet          ;if fiery, load alternate offset for fiery player
00EEE1  1  A0 08                    ldy #$08
00EEE3  1               StartClrGet:
00EEE3  1  AD 94 61                 lda WRAM_IsContraMode
00EEE6  1  F0 0B                    beq @ok_copy
00EEE8  1  A0 0C                    ldy #(PeachColors - PlayerColors)
00EEEA  1  AD 56 07                 lda PlayerStatus
00EEED  1  C9 02                    cmp #2
00EEEF  1  D0 02                    bne @ok_copy
00EEF1  1  A0 10                    ldy #((PeachColors - PlayerColors)+4)
00EEF3  1               @ok_copy:
00EEF3  1  A9 03                    lda #$03                 ;do four colors
00EEF5  1  85 00                    sta $00
00EEF7  1               ClrGetLoop:
00EEF7  1  B9 AC EE                 lda PlayerColors,y       ;fetch player colors and store them
00EEFA  1  9D 04 03                 sta VRAM_Buffer1+3,x     ;in the buffer
00EEFD  1  C8                       iny
00EEFE  1  E8                       inx
00EEFF  1  C6 00                    dec $00
00EF01  1  10 F4                    bpl ClrGetLoop
00EF03  1  AE 00 03                 ldx VRAM_Buffer1_Offset  ;load original offset from before
00EF06  1  AC 44 07                 ldy BackgroundColorCtrl  ;if this value is four or greater, it will be set
00EF09  1  D0 03                    bne SetBGColor           ;therefore use it as offset to background color
00EF0B  1  AC 4E 07                 ldy AreaType             ;otherwise use area type bits from area offset as offset
00EF0E  1               SetBGColor:
00EF0E  1  B9 A4 EE                 lda BackgroundColors,y   ;to background color instead
00EF11  1  9D 04 03                 sta VRAM_Buffer1+3,x
00EF14  1  A9 3F                    lda #$3f                 ;set for sprite palette address
00EF16  1  9D 01 03                 sta VRAM_Buffer1,x       ;save to buffer
00EF19  1  A9 10                    lda #$10
00EF1B  1  9D 02 03                 sta VRAM_Buffer1+1,x
00EF1E  1  A9 04                    lda #$04                 ;write length byte to buffer
00EF20  1  9D 03 03                 sta VRAM_Buffer1+2,x
00EF23  1  A9 00                    lda #$00                 ;now the null terminator
00EF25  1  9D 08 03                 sta VRAM_Buffer1+7,x
00EF28  1  8A                       txa                      ;move the buffer pointer ahead 7 bytes
00EF29  1  18                       clc                      ;in case we want to write anything else later
00EF2A  1  69 07                    adc #$07
00EF2C  1               SetVRAMOffset:
00EF2C  1  8D 00 03                 sta VRAM_Buffer1_Offset  ;store as new vram buffer offset
00EF2F  1  60                       rts
00EF30  1               
00EF30  1               ;-------------------------------------------------------------------------------------
00EF30  1               
00EF30  1               GetAlternatePalette1:
00EF30  1  AD 33 07                    lda AreaStyle            ;check for mushroom level style
00EF33  1  C9 01                       cmp #$01
00EF35  1  D0 05                       bne IncSubtask
00EF37  1  A9 0B                       lda #$0b                 ;if found, load appropriate palette
00EF39  1  8D 73 07     SetVRAMAddr_B: sta VRAM_Buffer_AddrCtrl
00EF3C  1  EE 3C 07     IncSubtask:  inc ScreenRoutineTask      ;move onto next task
00EF3F  1  60                        rts
00EF40  1               
00EF40  1               ;-------------------------------------------------------------------------------------
00EF40  1               
00EF40  1               Jumpspring_Y_PosData:
00EF40  1  08 10 08 00        .byte $08, $10, $08, $00
00EF44  1               
00EF44  1               JumpspringHandler:
00EF44  1  20 1F ED                jsr GetEnemyOffscreenBits   ;get offscreen information
00EF47  1  AD 47 07                lda TimerControl            ;check master timer control
00EF4A  1  D0 40                   bne DrawJSpr                ;branch to last section if set
00EF4C  1  AD 0E 07                lda JumpspringAnimCtrl      ;check jumpspring frame control
00EF4F  1  F0 3B                   beq DrawJSpr                ;branch to last section if not set
00EF51  1  A8                      tay
00EF52  1  88                      dey                         ;subtract one from frame control,
00EF53  1  98                      tya                         ;the only way a poor nmos 6502 can
00EF54  1  29 02                   and #%00000010              ;mask out all but d1, original value still in Y
00EF56  1  D0 07                   bne DownJSpr                ;if set, branch to move player up
00EF58  1  E6 CE                   inc Player_Y_Position
00EF5A  1  E6 CE                   inc Player_Y_Position       ;move player's vertical position down two pixels
00EF5C  1  4C 63 EF                jmp PosJSpr                 ;skip to next part
00EF5F  1  C6 CE        DownJSpr:  dec Player_Y_Position       ;move player's vertical position up two pixels
00EF61  1  C6 CE                   dec Player_Y_Position
00EF63  1  B5 58        PosJSpr:   lda Jumpspring_FixedYPos,x  ;get permanent vertical position
00EF65  1  18                      clc
00EF66  1  79 40 EF                adc Jumpspring_Y_PosData,y  ;add value using frame control as offset
00EF69  1  95 CF                   sta Enemy_Y_Position,x      ;store as new vertical position
00EF6B  1  C0 01                   cpy #$01                    ;check frame control offset (second frame is $00)
00EF6D  1  90 0F                   bcc BounceJS                ;if offset not yet at third frame ($01), skip to next part
00EF6F  1  A5 0A                   lda A_B_Buttons
00EF71  1  29 80                   and #A_Button               ;check saved controller bits for A button press
00EF73  1  F0 09                   beq BounceJS                ;skip to next part if A not pressed
00EF75  1  25 0D                   and PreviousA_B_Buttons     ;check for A button pressed in previous frame
00EF77  1  D0 05                   bne BounceJS                ;skip to next part if so
00EF79  1  A9 F4                   lda #$f4
00EF7B  1  8D DB 06                sta JumpspringForce         ;otherwise write new jumpspring force here
00EF7E  1  C0 03        BounceJS:  cpy #$03                    ;check frame control offset again
00EF80  1  D0 0A                   bne DrawJSpr                ;skip to last part if not yet at fifth frame ($03)
00EF82  1  AD DB 06                lda JumpspringForce
00EF85  1  85 9F                   sta Player_Y_Speed          ;store jumpspring force as player's new vertical speed
00EF87  1  A9 00                   lda #$00
00EF89  1  8D 0E 07                sta JumpspringAnimCtrl      ;initialize jumpspring frame control
00EF8C  1  20 C2 EC     DrawJSpr:  jsr RelativeEnemyPosition   ;get jumpspring's relative coordinates
00EF8F  1  20 0D E4                jsr EnemyGfxHandler         ;draw jumpspring
00EF92  1  20 6D D2                jsr OffscreenBoundsCheck    ;check to see if we need to kill it
00EF95  1  AD 0E 07                lda JumpspringAnimCtrl      ;if frame control at zero, don't bother
00EF98  1  F0 0D                   beq ExJSpring               ;trying to animate it, just leave
00EF9A  1  AD 86 07                lda JumpspringTimer
00EF9D  1  D0 08                   bne ExJSpring               ;if jumpspring timer not expired yet, leave
00EF9F  1  A9 04                   lda #$04
00EFA1  1  8D 86 07                sta JumpspringTimer         ;otherwise initialize jumpspring timer
00EFA4  1  EE 0E 07                inc JumpspringAnimCtrl      ;increment frame control to animate jumpspring
00EFA7  1  60           ExJSpring: rts                         ;leave
00EFA8  1               
00EFA8  1               
00EFA8  1               ;-------------------------------------------------------------------------------------
00EFA8  1               ;$02 - used to store vertical high nybble offset from block buffer routine
00EFA8  1               ;$06 - used to store low byte of block buffer address
00EFA8  1               
00EFA8  1               CoinBlock:
00EFA8  1  20 F4 EF           jsr FindEmptyMiscSlot   ;set offset for empty or last misc object buffer slot
00EFAB  1  B5 76              lda Block_PageLoc,x     ;get page location of block object
00EFAD  1  99 7A 00           sta Misc_PageLoc,y      ;store as page location of misc object
00EFB0  1  B5 8F              lda Block_X_Position,x  ;get horizontal coordinate of block object
00EFB2  1  09 05              ora #$05                ;add 5 pixels
00EFB4  1  99 93 00           sta Misc_X_Position,y   ;store as horizontal coordinate of misc object
00EFB7  1  B5 D7              lda Block_Y_Position,x  ;get vertical coordinate of block object
00EFB9  1  E9 10              sbc #$10                ;subtract 16 pixels
00EFBB  1  99 DB 00           sta Misc_Y_Position,y   ;store as vertical coordinate of misc object
00EFBE  1  4C DC EF           jmp JCoinC              ;jump to rest of code as applies to this misc object
00EFC1  1               
00EFC1  1               SetupJumpCoin:
00EFC1  1  20 F4 EF             jsr FindEmptyMiscSlot  ;set offset for empty or last misc object buffer slot
00EFC4  1  BD EA 03             lda Block_PageLoc2,x   ;get page location saved earlier
00EFC7  1  99 7A 00             sta Misc_PageLoc,y     ;and save as page location for misc object
00EFCA  1  A5 06                lda $06                ;get low byte of block buffer offset
00EFCC  1  0A                   asl
00EFCD  1  0A                   asl                    ;multiply by 16 to use lower nybble
00EFCE  1  0A                   asl
00EFCF  1  0A                   asl
00EFD0  1  09 05                ora #$05               ;add five pixels
00EFD2  1  99 93 00             sta Misc_X_Position,y  ;save as horizontal coordinate for misc object
00EFD5  1  A5 02                lda $02                ;get vertical high nybble offset from earlier
00EFD7  1  69 20                adc #$20               ;add 32 pixels for the status bar
00EFD9  1  99 DB 00             sta Misc_Y_Position,y  ;store as vertical coordinate
00EFDC  1  A9 FB        JCoinC: lda #$fb
00EFDE  1  99 AC 00             sta Misc_Y_Speed,y     ;set vertical speed
00EFE1  1  A9 01                lda #$01
00EFE3  1  99 C2 00             sta Misc_Y_HighPos,y   ;set vertical high byte
00EFE6  1  99 2A 00             sta Misc_State,y       ;set state for misc object
00EFE9  1  85 FE                sta Square2SoundQueue  ;load coin grab sound
00EFEB  1  86 08                stx ObjectOffset       ;store current control bit as misc object offset
00EFED  1  20 B8 BC             jsr GiveOneCoin        ;update coin tally on the screen and coin amount variable
00EFF0  1  EE 48 07             inc CoinTallyFor1Ups   ;increment coin tally used to activate 1-up block flag
00EFF3  1  60                   rts
00EFF4  1               
00EFF4  1               FindEmptyMiscSlot:
00EFF4  1  A0 08                   ldy #$08                ;start at end of misc objects buffer
00EFF6  1  B9 2A 00     FMiscLoop: lda Misc_State,y        ;get misc object state
00EFF9  1  F0 07                   beq UseMiscS            ;branch if none found to use current offset
00EFFB  1  88                      dey                     ;decrement offset
00EFFC  1  C0 05                   cpy #$05                ;do this for three slots
00EFFE  1  D0 F6                   bne FMiscLoop           ;do this until all slots are checked
00F000  1  A0 08                   ldy #$08                ;if no empty slots found, use last slot
00F002  1  8C B7 06     UseMiscS:  sty JumpCoinMiscOffset  ;store offset of misc object buffer here (residual)
00F005  1  60                      rts
00F006  1               
00F006  1               ;-------------------------------------------------------------------------------------
00F006  1               ;$00 - temp store for offset control bit
00F006  1               ;$01 - temp vram buffer offset
00F006  1               ;$02 - temp store for vertical high nybble in block buffer routine
00F006  1               ;$03 - temp adder for high byte of name table address
00F006  1               ;$04, $05 - name table address low/high
00F006  1               ;$06, $07 - block buffer address low/high
00F006  1               
00F006  1               BlockGfxData:
00F006  1  45 45 47 47         .byte $45, $45, $47, $47
00F00A  1  47 47 47 47         .byte $47, $47, $47, $47
00F00E  1  57 58 59 5A         .byte $57, $58, $59, $5a
00F012  1  24 24 24 24         .byte $24, $24, $24, $24
00F016  1  26 26 26 26         .byte $26, $26, $26, $26
00F01A  1               
00F01A  1               RemoveCoin_Axe:
00F01A  1  A0 41                      ldy #$41                 ;set low byte so offset points to $0341
00F01C  1  A9 03                      lda #$03                 ;load offset for default blank metatile
00F01E  1  AE 4E 07                   ldx AreaType             ;check area type
00F021  1  D0 02                      bne WriteBlankMT         ;if not water type, use offset
00F023  1  A9 04                      lda #$04                 ;otherwise load offset for blank metatile used in water
00F025  1  20 64 F0     WriteBlankMT: jsr PutBlockMetatile     ;do a sub to write blank metatile to vram buffer
00F028  1  A9 06                      lda #$06
00F02A  1  8D 73 07                   sta VRAM_Buffer_AddrCtrl ;set vram address controller to $0341 and leave
00F02D  1  60                         rts
00F02E  1               
00F02E  1               ReplaceBlockMetatile:
00F02E  1  20 3A F0            jsr WriteBlockMetatile    ;write metatile to vram buffer to replace block object
00F031  1  EE F0 03            inc Block_ResidualCounter ;increment unused counter (residual code)
00F034  1  DE EC 03            dec Block_RepFlag,x       ;decrement flag (residual code)
00F037  1  60                  rts                       ;leave
00F038  1               
00F038  1               DestroyBlockMetatile:
00F038  1  A9 00               lda #$00       ;force blank metatile if branched/jumped to this point
00F03A  1               
00F03A  1               WriteBlockMetatile:
00F03A  1  A0 03                     ldy #$03                ;load offset for blank metatile
00F03C  1  C9 00                     cmp #$00                ;check contents of A for blank metatile
00F03E  1  F0 14                     beq UseBOffset          ;branch if found (unconditional if branched from 8a6b)
00F040  1  A0 00                     ldy #$00                ;load offset for brick metatile w/ line
00F042  1  C9 58                     cmp #$58
00F044  1  F0 0E                     beq UseBOffset          ;use offset if metatile is brick with coins (w/ line)
00F046  1  C9 51                     cmp #$51
00F048  1  F0 0A                     beq UseBOffset          ;use offset if metatile is breakable brick w/ line
00F04A  1  C8                        iny                     ;increment offset for brick metatile w/o line
00F04B  1  C9 5D                     cmp #$5d
00F04D  1  F0 05                     beq UseBOffset          ;use offset if metatile is brick with coins (w/o line)
00F04F  1  C9 52                     cmp #$52
00F051  1  F0 01                     beq UseBOffset          ;use offset if metatile is breakable brick w/o line
00F053  1  C8                        iny                     ;if any other metatile, increment offset for empty block
00F054  1  98           UseBOffset:  tya                     ;put Y in A
00F055  1  AC 00 03                  ldy VRAM_Buffer1_Offset ;get vram buffer offset
00F058  1  C8                        iny                     ;move onto next byte
00F059  1  20 64 F0                  jsr PutBlockMetatile    ;get appropriate block data and write to vram buffer
00F05C  1  88           MoveVOffset: dey                     ;decrement vram buffer offset
00F05D  1  98                        tya                     ;add 10 bytes to it
00F05E  1  18                        clc
00F05F  1  69 0A                     adc #10
00F061  1  4C 2C EF                  jmp SetVRAMOffset       ;branch to store as new vram buffer offset
00F064  1               
00F064  1               PutBlockMetatile:
00F064  1  86 00                    stx $00               ;store control bit from SprDataOffset_Ctrl
00F066  1  84 01                    sty $01               ;store vram buffer offset for next byte
00F068  1  0A                       asl
00F069  1  0A                       asl                   ;multiply A by four and use as X
00F06A  1  AA                       tax
00F06B  1  A0 20                    ldy #$20              ;load high byte for name table 0
00F06D  1  A5 06                    lda $06               ;get low byte of block buffer pointer
00F06F  1  C9 D0                    cmp #$d0              ;check to see if we're on odd-page block buffer
00F071  1  90 02                    bcc SaveHAdder        ;if not, use current high byte
00F073  1  A0 24                    ldy #$24              ;otherwise load high byte for name table 1
00F075  1  84 03        SaveHAdder: sty $03               ;save high byte here
00F077  1  29 0F                    and #$0f              ;mask out high nybble of block buffer pointer
00F079  1  0A                       asl                   ;multiply by 2 to get appropriate name table low byte
00F07A  1  85 04                    sta $04               ;and then store it here
00F07C  1  A9 00                    lda #$00
00F07E  1  85 05                    sta $05               ;initialize temp high byte
00F080  1  A5 02                    lda $02               ;get vertical high nybble offset used in block buffer routine
00F082  1  18                       clc
00F083  1  69 20                    adc #$20              ;add 32 pixels for the status bar
00F085  1  0A                       asl
00F086  1  26 05                    rol $05               ;shift and rotate d7 onto d0 and d6 into carry
00F088  1  0A                       asl
00F089  1  26 05                    rol $05               ;shift and rotate d6 onto d0 and d5 into carry
00F08B  1  65 04                    adc $04               ;add low byte of name table and carry to vertical high nybble
00F08D  1  85 04                    sta $04               ;and store here
00F08F  1  A5 05                    lda $05               ;get whatever was in d7 and d6 of vertical high nybble
00F091  1  69 00                    adc #$00              ;add carry
00F093  1  18                       clc
00F094  1  65 03                    adc $03               ;then add high byte of name table
00F096  1  85 05                    sta $05               ;store here
00F098  1  A4 01                    ldy $01               ;get vram buffer offset to be used
00F09A  1  BD 06 F0     RemBridge:  lda BlockGfxData,x    ;write top left and top right
00F09D  1  99 03 03                 sta VRAM_Buffer1+2,y  ;tile numbers into first spot
00F0A0  1  BD 07 F0                 lda BlockGfxData+1,x
00F0A3  1  99 04 03                 sta VRAM_Buffer1+3,y
00F0A6  1  BD 08 F0                 lda BlockGfxData+2,x  ;write bottom left and bottom
00F0A9  1  99 08 03                 sta VRAM_Buffer1+7,y  ;right tiles numbers into
00F0AC  1  BD 09 F0                 lda BlockGfxData+3,x  ;second spot
00F0AF  1  99 09 03                 sta VRAM_Buffer1+8,y
00F0B2  1  A5 04                    lda $04
00F0B4  1  99 01 03                 sta VRAM_Buffer1,y    ;write low byte of name table
00F0B7  1  18                       clc                   ;into first slot as read
00F0B8  1  69 20                    adc #$20              ;add 32 bytes to value
00F0BA  1  99 06 03                 sta VRAM_Buffer1+5,y  ;write low byte of name table
00F0BD  1  A5 05                    lda $05               ;plus 32 bytes into second slot
00F0BF  1  99 00 03                 sta VRAM_Buffer1-1,y  ;write high byte of name
00F0C2  1  99 05 03                 sta VRAM_Buffer1+4,y  ;table address to both slots
00F0C5  1  A9 02                    lda #$02
00F0C7  1  99 02 03                 sta VRAM_Buffer1+1,y  ;put length of 2 in
00F0CA  1  99 07 03                 sta VRAM_Buffer1+6,y  ;both slots
00F0CD  1  A9 00                    lda #$00
00F0CF  1  99 0A 03                 sta VRAM_Buffer1+9,y  ;put null terminator at end
00F0D2  1  A6 00                    ldx $00               ;get offset control bit here
00F0D4  1  60                       rts                   ;and leave
00F0D5  1               
00F0D5  1               
00F0D5  1               ;-------------------------------------------------------------------------------------
00F0D5  1               ;$06-$07 - used as address to block buffer data
00F0D5  1               ;$02 - used as vertical high nybble of block buffer offset
00F0D5  1               
00F0D5  1               VineHeightData:
00F0D5  1  30 60              .byte $30, $60
00F0D7  1               
00F0D7  1               VineObjectHandler:
00F0D7  1  E0 05                   cpx #$05                  ;check enemy offset for special use slot
00F0D9  1  D0 68                   bne ExitVH                ;if not in last slot, branch to leave
00F0DB  1  AC 98 03                ldy VineFlagOffset
00F0DE  1  88                      dey                       ;decrement vine flag in Y, use as offset
00F0DF  1  AD 99 03                lda VineHeight
00F0E2  1  D9 D5 F0                cmp VineHeightData,y      ;if vine has reached certain height,
00F0E5  1  F0 0F                   beq RunVSubs              ;branch ahead to skip this part
00F0E7  1  A5 09                   lda FrameCounter          ;get frame counter
00F0E9  1  4A                      lsr                       ;shift d1 into carry
00F0EA  1  4A                      lsr
00F0EB  1  90 09                   bcc RunVSubs              ;if d1 not set (2 frames every 4) skip this part
00F0ED  1  A5 D4                   lda Enemy_Y_Position+5
00F0EF  1  E9 01                   sbc #$01                  ;subtract vertical position of vine
00F0F1  1  85 D4                   sta Enemy_Y_Position+5    ;one pixel every frame it's time
00F0F3  1  EE 99 03                inc VineHeight            ;increment vine height
00F0F6  1  AD 99 03     RunVSubs:  lda VineHeight            ;if vine still very small,
00F0F9  1  C9 08                   cmp #$08                  ;branch to leave
00F0FB  1  90 46                   bcc ExitVH
00F0FD  1  20 C2 EC                jsr RelativeEnemyPosition ;get relative coordinates of vine,
00F100  1  20 1F ED                jsr GetEnemyOffscreenBits ;and any offscreen bits
00F103  1  A0 00                   ldy #$00                  ;initialize offset used in draw vine sub
00F105  1  20 C5 DF     VDrawLoop: jsr DrawVine              ;draw vine
00F108  1  C8                      iny                       ;increment offset
00F109  1  CC 98 03                cpy VineFlagOffset        ;if offset in Y and offset here
00F10C  1  D0 F7                   bne VDrawLoop             ;do not yet match, loop back to draw more vine
00F10E  1  AD D1 03                lda Enemy_OffscreenBits
00F111  1  29 0C                   and #%00001100            ;mask offscreen bits
00F113  1  F0 10                   beq WrCMTile              ;if none of the saved offscreen bits set, skip ahead
00F115  1  88                      dey                       ;otherwise decrement Y to get proper offset again
00F116  1  BE 9A 03     KillVine:  ldx VineObjOffset,y       ;get enemy object offset for this vine object
00F119  1  20 A3 C6                jsr EraseEnemyObject      ;kill this vine object
00F11C  1  88                      dey                       ;decrement Y
00F11D  1  10 F7                   bpl KillVine              ;if any vine objects left, loop back to kill it
00F11F  1  8D 98 03                sta VineFlagOffset        ;initialize vine flag/offset
00F122  1  8D 99 03                sta VineHeight            ;initialize vine height
00F125  1  AD 99 03     WrCMTile:  lda VineHeight            ;check vine height
00F128  1  C9 20                   cmp #$20                  ;if vine small (less than 32 pixels tall)
00F12A  1  90 17                   bcc ExitVH                ;then branch ahead to leave
00F12C  1  A2 06                   ldx #$06                  ;set offset in X to last enemy slot
00F12E  1  A9 01                   lda #$01                  ;set A to obtain horizontal in $04, but we don't care
00F130  1  A0 1B                   ldy #$1b                  ;set Y to offset to get block at ($04, $10) of coordinates
00F132  1  20 80 DF                jsr BlockBufferCollision  ;do a sub to get block buffer address set, return contents
00F135  1  A4 02                   ldy $02
00F137  1  C0 D0                   cpy #$d0                  ;if vertical high nybble offset beyond extent of
00F139  1  B0 08                   bcs ExitVH                ;current block buffer, branch to leave, do not write
00F13B  1  B1 06                   lda ($06),y               ;otherwise check contents of block buffer at
00F13D  1  D0 04                   bne ExitVH                ;current offset, if not empty, branch to leave
00F13F  1  A9 26                   lda #$26
00F141  1  91 06                   sta ($06),y               ;otherwise, write climbing metatile to block buffer
00F143  1  A6 08        ExitVH:    ldx ObjectOffset          ;get enemy object offset and leave
00F145  1  60                      rts
00F146  1               
00F146  1               ;-------------------------------------------------------------------------------------
00F146  1               
00F146  1               HammerEnemyOfsData:
00F146  1  04 04 04 05        .byte $04, $04, $04, $05, $05, $05
00F14A  1  05 05        
00F14C  1  06 06 06           .byte $06, $06, $06
00F14F  1               
00F14F  1               HammerXSpdData:
00F14F  1  10 F0              .byte $10, $f0
00F151  1               
00F151  1               SpawnHammerObj:
00F151  1  AD A8 07               lda PseudoRandomBitReg+1 ;get pseudorandom bits from
00F154  1  29 07                  and #%00000111           ;second part of LSFR
00F156  1  D0 05                  bne SetMOfs              ;if any bits are set, branch and use as offset
00F158  1  AD A8 07               lda PseudoRandomBitReg+1
00F15B  1  29 08                  and #%00001000           ;get d3 from same part of LSFR
00F15D  1  A8           SetMOfs:  tay                      ;use either d3 or d2-d0 for offset here
00F15E  1  B9 2A 00               lda Misc_State,y         ;if any values loaded in
00F161  1  D0 19                  bne NoHammer             ;$2a-$32 where offset is then leave with carry clear
00F163  1  BE 46 F1               ldx HammerEnemyOfsData,y ;get offset of enemy slot to check using Y as offset
00F166  1  B5 0F                  lda Enemy_Flag,x         ;check enemy buffer flag at offset
00F168  1  D0 12                  bne NoHammer             ;if buffer flag set, branch to leave with carry clear
00F16A  1  A6 08                  ldx ObjectOffset         ;get original enemy object offset
00F16C  1  8A                     txa
00F16D  1  99 AE 06               sta HammerEnemyOffset,y  ;save here
00F170  1  A9 90                  lda #$90
00F172  1  99 2A 00               sta Misc_State,y         ;save hammer's state here
00F175  1  A9 07                  lda #$07
00F177  1  99 A2 04               sta Misc_BoundBoxCtrl,y  ;set something else entirely, here
00F17A  1  38                     sec                      ;return with carry set
00F17B  1  60                     rts
00F17C  1  A6 08        NoHammer: ldx ObjectOffset         ;get original enemy object offset
00F17E  1  18                     clc                      ;return with carry clear
00F17F  1  60                     rts
00F180  1               
00F180  1                         .include "utils.inc"
00F180  2               .ifndef __UTILS_INC_DEF__
00F180  2               .define __UTILS_INC_DEF__
00F180  2               
00F180  2               AdvanceRandom:
00F180  2  AD A7 07         lda PseudoRandomBitReg    ;get first memory location of LSFR bytes
00F183  2  29 02            and #%00000010            ;mask out all but d1
00F185  2  85 00            sta $00                   ;save here
00F187  2  AD A8 07         lda PseudoRandomBitReg+1  ;get second memory location
00F18A  2  29 02            and #%00000010            ;mask out all but d1
00F18C  2  45 00            eor $00                   ;perform exclusive-OR on d1 from first and second bytes
00F18E  2  18               clc                       ;if neither or both are set, carry will be clear
00F18F  2  F0 01            beq RotPRandomBit
00F191  2  38               sec                       ;if one or the other is set, carry will be set
00F192  2               RotPRandomBit:
00F192  2  6E A7 07         ror PseudoRandomBitReg+0  ;rotate carry into d7, and rotate last bit into carry
00F195  2  6E A8 07         ror PseudoRandomBitReg+1  ;rotate carry into d7, and rotate last bit into carry
00F198  2  6E A9 07         ror PseudoRandomBitReg+2  ;rotate carry into d7, and rotate last bit into carry
00F19B  2  6E AA 07         ror PseudoRandomBitReg+3  ;rotate carry into d7, and rotate last bit into carry
00F19E  2  6E AB 07         ror PseudoRandomBitReg+4  ;rotate carry into d7, and rotate last bit into carry
00F1A1  2  6E AC 07         ror PseudoRandomBitReg+5  ;rotate carry into d7, and rotate last bit into carry
00F1A4  2  6E AD 07         ror PseudoRandomBitReg+6  ;rotate carry into d7, and rotate last bit into carry
00F1A7  2  60               rts
00F1A8  2               
00F1A8  2               MulByTen:
00F1A8  2  0A               asl
00F1A9  2  85 00            sta $0
00F1AB  2  0A               asl
00F1AC  2  0A               asl
00F1AD  2  18               clc
00F1AE  2  65 00            adc $0
00F1B0  2  60               rts
00F1B1  2               
00F1B1  2               .include "div10.inc"
00F1B1  3               .ifndef __DIV10_INC_DEF__
00F1B1  3               .define __DIV10_INC_DEF__
00F1B1  3               
00F1B1  3               DivByTen:
00F1B1  3  A2 00            ldx #$00
00F1B3  3               DivMore:
00F1B3  3  C9 0A            cmp #$0a
00F1B5  3  90 06            bcc DivByTenDone
00F1B7  3  E9 0A            sbc #$0a
00F1B9  3  E8               inx
00F1BA  3  38               sec
00F1BB  3  B0 F6            bcs DivMore
00F1BD  3               DivByTenDone:
00F1BD  3  60               rts
00F1BE  3               
00F1BE  3               .endif
00F1BE  3               
00F1BE  2               
00F1BE  2               .endif
00F1BE  2               
00F1BE  1               
00F1BE  1  EA EA EA EA  practice_callgate
00F1C2  1  EA EA EA EA  
00F1C6  1  EA EA EA EA  
00FEC0  1  EA EA EA EA  control_bank
00FEC4  1  EA EA EA EA  
00FEC8  1  EA EA EA EA  
010000  1               
010000  1               
