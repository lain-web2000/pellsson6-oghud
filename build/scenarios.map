ca65 V2.19 - Git b993d8833
Main file   : scen/scenarios.asm
Current file: scen/scenarios.asm

000000r 1               ;SMBDIS.ASM - A COMPREHENSIVE SUPER MARIO BROS. DISASSEMBLY
000000r 1               ;by doppelganger (doppelheathen@gmail.com)
000000r 1               
000000r 1               ;This file is provided for your own use as-is.  It will require the character rom data
000000r 1               ;and an iNES file header to get it to work.
000000r 1               
000000r 1               ;There are so many people I have to thank for this, that taking all the credit for
000000r 1               ;myself would be an unforgivable act of arrogance. Without their help this would
000000r 1               ;probably not be possible.  So I thank all the peeps in the nesdev scene whose insight into
000000r 1               ;the 6502 and the NES helped me learn how it works (you guys know who you are, there's no
000000r 1               ;way I could have done this without your help), as well as the authors of x816 and SMB
000000r 1               ;Utility, and the reverse-engineers who did the original Super Mario Bros. Hacking Project,
000000r 1               ;which I compared notes with but did not copy from.  Last but certainly not least, I thank
000000r 1               ;Nintendo for creating this game and the NES, without which this disassembly would
000000r 1               ;only be theory.
000000r 1               
000000r 1               ;Assembles with x816.
000000r 1               
000000r 1               ;-------------------------------------------------------------------------------------
000000r 1               ;DEFINES
000000r 1               
000000r 1               ;NES specific hardware defines
000000r 1                   .include "org.inc"
000000r 2               CHR_SMB = 0
000000r 2               CHR_PRACTICE = 2
000000r 2               CHR_FPG = 4
000000r 2               CHR_LOADER = 6
000000r 2               
000000r 2               ;
000000r 2               ; FPG vars
000000r 2               ;
000000r 2               FpgRuleset = $0717		; DemoAction
000000r 2               FpgSelected = $075a		; NumberOfLives
000000r 2               FpgFlags  = $0761		; OffScr_NumberofLives
000000r 2               FpgLastInput = $0762	; OffScr_HalfwayPage
000000r 2               FpgScrollTo = $07d7 	; TopScoreDisplay+0
000000r 2               FpgError = $07d8		; TopScoreDisplay+1
000000r 2               FpgErrorParam = $07d9	; TopScoreDisplay+2
000000r 2               FpgOldFlags = $07da		; TopScoreDisplay+3
000000r 2               
000000r 2               ;
000000r 2               ; Practice vars
000000r 2               ;
000000r 2               ;
000000r 2               ; RAM vars
000000r 2               ;
000000r 2               PowerUpFrames				= $04	; Anywhere thats temporary
000000r 2               LastInputBits				= $075a ; Previously NumberOfLives
000000r 2               MenuSelection				= $077a ; Previously NumberOfPlayers
000000r 2               ;SaveStateFlags				= $07fc ; Previously WorldSelectEnableFlag
000000r 2               SavedEnterTimer				= $07f7
000000r 2               
000000r 2               STATUS_BAR_OFFSET = $02
000000r 2               RULE_COUNT_OFFSET = $0b
000000r 2               FRAME_NUMBER_OFFSET = $15
000000r 2               FRAMES_REMAIN_OFFSET = $0e
000000r 2               POSITION_OFFSET = $12
000000r 2               
000000r 2               
000000r 2               
000000r 1                   .include "mario.inc"
000000r 2               PPU_CTRL_REG1         = $2000
000000r 2               PPU_CTRL_REG2         = $2001
000000r 2               PPU_STATUS            = $2002
000000r 2               PPU_SPR_ADDR          = $2003
000000r 2               PPU_SPR_DATA          = $2004
000000r 2               PPU_SCROLL_REG        = $2005
000000r 2               PPU_ADDRESS           = $2006
000000r 2               PPU_DATA              = $2007
000000r 2               
000000r 2               SND_REGISTER          = $4000
000000r 2               SND_SQUARE1_REG       = $4000
000000r 2               SND_SQUARE2_REG       = $4004
000000r 2               SND_TRIANGLE_REG      = $4008
000000r 2               SND_NOISE_REG         = $400c
000000r 2               SND_DELTA_REG         = $4010
000000r 2               SND_MASTERCTRL_REG    = $4015
000000r 2               SND_VOLENV_REG        = $4080
000000r 2               SND_FDS0_REG          = $4040
000000r 2               SND_FDS1_REG          = $4041
000000r 2               SND_PULSE_4002_REG    = $4002
000000r 2               SND_PULSE_4003_REG    = $4003
000000r 2               SND_PULSE_4004_REG    = $4004
000000r 2               SND_PULSE_4005_REG    = $4005
000000r 2               SND_PULSE_4006_REG    = $4006
000000r 2               SND_TRIANGLE_400A_REG = $400A
000000r 2               SND_TRIANGLE_400B_REG = $400B
000000r 2               SND_NOISE_400E_REG    = $400E
000000r 2               SND_NOISE_400F_REG    = $400F
000000r 2               
000000r 2               SPR_DMA               = $4014
000000r 2               JOYPAD_PORT           = $4016
000000r 2               JOYPAD_PORT1          = $4016
000000r 2               JOYPAD_PORT2          = $4017
000000r 2               
000000r 2               ; GAME SPECIFIC DEFINES
000000r 2               
000000r 2               ObjectOffset          = $08
000000r 2               
000000r 2               FrameCounter          = $09
000000r 2               
000000r 2               SavedJoypadBits       = $06fc
000000r 2               SavedJoypad1Bits      = $06fc
000000r 2               SavedJoypad2Bits      = $06fd
000000r 2               JoypadBitMask         = $074a
000000r 2               JoypadOverride        = $0758
000000r 2               
000000r 2               A_B_Buttons           = $0a
000000r 2               PreviousA_B_Buttons   = $0d
000000r 2               Up_Down_Buttons       = $0b
000000r 2               Left_Right_Buttons    = $0c
000000r 2               
000000r 2               GameEngineSubroutine  = $0e
000000r 2               
000000r 2               Mirror_PPU_CTRL_REG1  = $0778
000000r 2               Mirror_PPU_CTRL_REG2  = $0779
000000r 2               
000000r 2               OperMode              = $0770
000000r 2               OperMode_Task         = $0772
000000r 2               ScreenRoutineTask     = $073c
000000r 2               
000000r 2               GamePauseStatus       = $0776
000000r 2               GamePauseTimer        = $0777
000000r 2               
000000r 2               DemoAction            = $0717
000000r 2               DemoActionTimer       = $0718
000000r 2               
000000r 2               TimerControl          = $0747
000000r 2               IntervalTimerControl  = $077f
000000r 2               
000000r 2               Timers                = $0780
000000r 2               SelectTimer           = $0780
000000r 2               PlayerAnimTimer       = $0781
000000r 2               JumpSwimTimer         = $0782
000000r 2               RunningTimer          = $0783
000000r 2               BlockBounceTimer      = $0784
000000r 2               SideCollisionTimer    = $0785
000000r 2               JumpspringTimer       = $0786
000000r 2               GameTimerCtrlTimer    = $0787
000000r 2               ClimbSideTimer        = $0789
000000r 2               EnemyFrameTimer       = $078a
000000r 2               FrenzyEnemyTimer      = $078f
000000r 2               BowserFireBreathTimer = $0790
000000r 2               StompTimer            = $0791
000000r 2               AirBubbleTimer        = $0792
000000r 2               ScrollIntervalTimer   = $0795
000000r 2               EnemyIntervalTimer    = $0796
000000r 2               BrickCoinTimer        = $079d
000000r 2               InjuryTimer           = $079e
000000r 2               StarInvincibleTimer   = $079f
000000r 2               ScreenTimer           = $07a0
000000r 2               WorldEndTimer         = $07a1
000000r 2               DemoTimer             = $07a2
000000r 2               
000000r 2               Sprite_Data           = $0200
000000r 2               
000000r 2               Sprite_Y_Position     = $0200
000000r 2               Sprite_Tilenumber     = $0201
000000r 2               Sprite_Attributes     = $0202
000000r 2               Sprite_X_Position     = $0203
000000r 2               
000000r 2               ScreenEdge_PageLoc    = $071a
000000r 2               ScreenEdge_X_Pos      = $071c
000000r 2               ScreenLeft_PageLoc    = $071a
000000r 2               ScreenRight_PageLoc   = $071b
000000r 2               ScreenLeft_X_Pos      = $071c
000000r 2               ScreenRight_X_Pos     = $071d
000000r 2               
000000r 2               PlayerFacingDir       = $33
000000r 2               DestinationPageLoc    = $34
000000r 2               VictoryWalkControl    = $35
000000r 2               ScrollFractional      = $0768
000000r 2               PrimaryMsgCounter     = $0719
000000r 2               SecondaryMsgCounter   = $0749
000000r 2               
000000r 2               HorizontalScroll      = $073f
000000r 2               VerticalScroll        = $0740
000000r 2               ScrollLock            = $0723
000000r 2               ScrollThirtyTwo       = $073d
000000r 2               Player_X_Scroll       = $06ff
000000r 2               Player_Pos_ForScroll  = $0755
000000r 2               ScrollAmount          = $0775
000000r 2               
000000r 2               AreaData              = $e7
000000r 2               AreaDataLow           = $e7
000000r 2               AreaDataHigh          = $e8
000000r 2               EnemyData             = $e9
000000r 2               EnemyDataLow          = $e9
000000r 2               EnemyDataHigh         = $ea
000000r 2               
000000r 2               AreaParserTaskNum     = $071f
000000r 2               ColumnSets            = $071e
000000r 2               CurrentPageLoc        = $0725
000000r 2               CurrentColumnPos      = $0726
000000r 2               BackloadingFlag       = $0728
000000r 2               BehindAreaParserFlag  = $0729
000000r 2               AreaObjectPageLoc     = $072a
000000r 2               AreaObjectPageSel     = $072b
000000r 2               AreaDataOffset        = $072c
000000r 2               AreaObjOffsetBuffer   = $072d
000000r 2               AreaObjectLength      = $0730
000000r 2               StaircaseControl      = $0734
000000r 2               AreaObjectHeight      = $0735
000000r 2               MushroomLedgeHalfLen  = $0736
000000r 2               EnemyDataOffset       = $0739
000000r 2               EnemyObjectPageLoc    = $073a
000000r 2               EnemyObjectPageSel    = $073b
000000r 2               MetatileBuffer        = $06a1
000000r 2               BlockBufferColumnPos  = $06a0
000000r 2               CurrentNTAddr_Low     = $0721
000000r 2               CurrentNTAddr_High    = $0720
000000r 2               AttributeBuffer       = $03f9
000000r 2               
000000r 2               LoopCommand           = $0745
000000r 2               
000000r 2               DisplayDigits         = $07d7
000000r 2               TopScoreDisplay       = $07d7
000000r 2               ScoreAndCoinDisplay   = $07dd
000000r 2               PlayerScoreDisplay    = $07dd
000000r 2               GameTimerDisplay      = $07f8
000000r 2               DigitModifier         = $0134
000000r 2               
000000r 2               VerticalFlipFlag      = $0109
000000r 2               FloateyNum_Control    = $0110
000000r 2               ShellChainCounter     = $0125
000000r 2               FloateyNum_Timer      = $012c
000000r 2               FloateyNum_X_Pos      = $0117
000000r 2               FloateyNum_Y_Pos      = $011e
000000r 2               FlagpoleFNum_Y_Pos    = $010d
000000r 2               FlagpoleFNum_YMFDummy = $010e
000000r 2               FlagpoleScore         = $010f
000000r 2               FlagpoleCollisionYPos = $070f
000000r 2               StompChainCounter     = $0484
000000r 2               
000000r 2               VRAM_Buffer1_Offset   = $0300
000000r 2               VRAM_Buffer1          = $0301
000000r 2               VRAM_Buffer2_Offset   = $0340
000000r 2               VRAM_Buffer2          = $0341
000000r 2               VRAM_Buffer_AddrCtrl  = $0773
000000r 2               Sprite0HitDetectFlag  = $0722
000000r 2               IRQUpdateFlag         = $0722
000000r 2               IRQAckFlag            = $077b
000000r 2               DisableScreenFlag     = $0774
000000r 2               DisableIntermediate   = $0769
000000r 2               ColorRotateOffset     = $06d4
000000r 2               
000000r 2               TerrainControl        = $0727
000000r 2               AreaStyle             = $0733
000000r 2               ForegroundScenery     = $0741
000000r 2               BackgroundScenery     = $0742
000000r 2               CloudTypeOverride     = $0743
000000r 2               BackgroundColorCtrl   = $0744
000000r 2               AreaType              = $074e
000000r 2               AreaAddrsLOffset      = $074f
000000r 2               AreaPointer           = $0750
000000r 2               
000000r 2               PlayerEntranceCtrl    = $0710
000000r 2               GameTimerSetting      = $0715
000000r 2               AltEntranceControl    = $0752
000000r 2               EntrancePage          = $0751
000000r 2               NumberOfPlayers       = $077a
000000r 2               UseNtBase2400 		  = $077a
000000r 2               WarpZoneControl       = $06d6
000000r 2               ChangeAreaTimer       = $06de
000000r 2               
000000r 2               MultiLoopCorrectCntr  = $06d9
000000r 2               MultiLoopPassCntr     = $06da
000000r 2               
000000r 2               FetchNewGameTimerFlag = $0757
000000r 2               GameTimerExpiredFlag  = $0759
000000r 2               
000000r 2               PrimaryHardMode       = $076a
000000r 2               SecondaryHardMode     = $06cc
000000r 2               WorldSelectNumber     = $076b
000000r 2               WorldSelectEnableFlag = $07fc
000000r 2               ContinueWorld         = $07fd
000000r 2               
000000r 2               .define IsPlayingLuigi CurrentPlayer
000000r 2               
000000r 2               CurrentPlayer         = $0753
000000r 2               PlayerSize            = $0754
000000r 2               PlayerStatus          = $0756
000000r 2               
000000r 2               ;OnscreenPlayerInfo    = $075a
000000r 2               ;NumberofLives         = $075a ;used by current player
000000r 2               HalfwayPage           = $075b
000000r 2               LevelNumber           = $075c ;the actual dash number
000000r 2               Hidden1UpFlag         = $075d
000000r 2               CoinTally             = $075e
000000r 2               WorldNumber           = $075f
000000r 2               AreaNumber            = $0760 ;internal number used to find areas
000000r 2               
000000r 2               CoinTallyFor1Ups      = $0748
000000r 2               
000000r 2               OffscreenPlayerInfo   = $0761
000000r 2               OffScr_NumberofLives  = $0761 ;used by offscreen player
000000r 2               OffScr_HalfwayPage    = $0762
000000r 2               OffScr_LevelNumber    = $0763
000000r 2               OffScr_Hidden1UpFlag  = $0764
000000r 2               OffScr_CoinTally      = $0765
000000r 2               OffScr_WorldNumber    = $0766
000000r 2               OffScr_AreaNumber     = $0767
000000r 2               
000000r 2               BalPlatformAlignment  = $03a0
000000r 2               Platform_X_Scroll     = $03a1
000000r 2               PlatformCollisionFlag = $03a2
000000r 2               YPlatformTopYPos      = $0401
000000r 2               YPlatformCenterYPos   = $58
000000r 2               
000000r 2               BrickCoinTimerFlag    = $06bc
000000r 2               StarFlagTaskControl   = $0746
000000r 2               
000000r 2               PseudoRandomBitReg    = $07a7
000000r 2               
000000r 2               SprShuffleAmtOffset   = $06e0
000000r 2               SprShuffleAmt         = $06e1
000000r 2               SprDataOffset         = $06e4
000000r 2               Player_SprDataOffset  = $06e4
000000r 2               Enemy_SprDataOffset   = $06e5
000000r 2               Block_SprDataOffset   = $06ec
000000r 2               Alt_SprDataOffset     = $06ec
000000r 2               Bubble_SprDataOffset  = $06ee
000000r 2               FBall_SprDataOffset   = $06f1
000000r 2               Misc_SprDataOffset    = $06f3
000000r 2               SprDataOffset_Ctrl    = $03ee
000000r 2               
000000r 2               Player_State          = $1d
000000r 2               Enemy_State           = $1e
000000r 2               Fireball_State        = $24
000000r 2               Block_State           = $26
000000r 2               Misc_State            = $2a
000000r 2               
000000r 2               Player_MovingDir      = $45
000000r 2               Enemy_MovingDir       = $46
000000r 2               
000000r 2               SprObject_X_Speed     = $57
000000r 2               Player_X_Speed        = $57
000000r 2               Enemy_X_Speed         = $58
000000r 2               Fireball_X_Speed      = $5e
000000r 2               Block_X_Speed         = $60
000000r 2               Misc_X_Speed          = $64
000000r 2               
000000r 2               Jumpspring_FixedYPos  = $58
000000r 2               JumpspringAnimCtrl    = $070e
000000r 2               JumpspringForce       = $06db
000000r 2               
000000r 2               SprObject_PageLoc     = $6d
000000r 2               Player_PageLoc        = $6d
000000r 2               Enemy_PageLoc         = $6e
000000r 2               Fireball_PageLoc      = $74
000000r 2               Block_PageLoc         = $76
000000r 2               Misc_PageLoc          = $7a
000000r 2               Bubble_PageLoc        = $83
000000r 2               
000000r 2               SprObject_X_Position  = $86
000000r 2               Player_X_Position     = $86
000000r 2               Enemy_X_Position      = $87
000000r 2               Fireball_X_Position   = $8d
000000r 2               Block_X_Position      = $8f
000000r 2               Misc_X_Position       = $93
000000r 2               Bubble_X_Position     = $9c
000000r 2               
000000r 2               SprObject_Y_Speed     = $9f
000000r 2               Player_Y_Speed        = $9f
000000r 2               Enemy_Y_Speed         = $a0
000000r 2               Fireball_Y_Speed      = $a6
000000r 2               Block_Y_Speed         = $a8
000000r 2               Misc_Y_Speed          = $ac
000000r 2               
000000r 2               SprObject_Y_HighPos   = $b5
000000r 2               Player_Y_HighPos      = $b5
000000r 2               Enemy_Y_HighPos       = $b6
000000r 2               Fireball_Y_HighPos    = $bc
000000r 2               Block_Y_HighPos       = $be
000000r 2               Misc_Y_HighPos        = $c2
000000r 2               Bubble_Y_HighPos      = $cb
000000r 2               
000000r 2               SprObject_Y_Position  = $ce
000000r 2               Player_Y_Position     = $ce
000000r 2               Enemy_Y_Position      = $cf
000000r 2               Fireball_Y_Position   = $d5
000000r 2               Block_Y_Position      = $d7
000000r 2               Misc_Y_Position       = $db
000000r 2               Bubble_Y_Position     = $e4
000000r 2               
000000r 2               SprObject_Rel_XPos    = $03ad
000000r 2               Player_Rel_XPos       = $03ad
000000r 2               Enemy_Rel_XPos        = $03ae
000000r 2               Fireball_Rel_XPos     = $03af
000000r 2               Bubble_Rel_XPos       = $03b0
000000r 2               Block_Rel_XPos        = $03b1
000000r 2               Misc_Rel_XPos         = $03b3
000000r 2               
000000r 2               SprObject_Rel_YPos    = $03b8
000000r 2               Player_Rel_YPos       = $03b8
000000r 2               Enemy_Rel_YPos        = $03b9
000000r 2               Fireball_Rel_YPos     = $03ba
000000r 2               Bubble_Rel_YPos       = $03bb
000000r 2               Block_Rel_YPos        = $03bc
000000r 2               Misc_Rel_YPos         = $03be
000000r 2               
000000r 2               SprObject_SprAttrib   = $03c4
000000r 2               Player_SprAttrib      = $03c4
000000r 2               Enemy_SprAttrib       = $03c5
000000r 2               
000000r 2               SprObject_X_MoveForce = $0400
000000r 2               Enemy_X_MoveForce     = $0401
000000r 2               
000000r 2               SprObject_YMF_Dummy   = $0416
000000r 2               Player_YMF_Dummy      = $0416
000000r 2               Enemy_YMF_Dummy       = $0417
000000r 2               Bubble_YMF_Dummy      = $042c
000000r 2               
000000r 2               SprObject_Y_MoveForce = $0433
000000r 2               Player_Y_MoveForce    = $0433
000000r 2               Enemy_Y_MoveForce     = $0434
000000r 2               Block_Y_MoveForce     = $043c
000000r 2               
000000r 2               DisableCollisionDet   = $0716
000000r 2               Player_CollisionBits  = $0490
000000r 2               Enemy_CollisionBits   = $0491
000000r 2               
000000r 2               SprObj_BoundBoxCtrl   = $0499
000000r 2               Player_BoundBoxCtrl   = $0499
000000r 2               Enemy_BoundBoxCtrl    = $049a
000000r 2               Fireball_BoundBoxCtrl = $04a0
000000r 2               Misc_BoundBoxCtrl     = $04a2
000000r 2               
000000r 2               EnemyFrenzyBuffer     = $06cb
000000r 2               EnemyFrenzyQueue      = $06cd
000000r 2               Enemy_Flag            = $0f
000000r 2               Enemy_ID              = $16
000000r 2               
000000r 2               PlayerGfxOffset       = $06d5
000000r 2               Player_XSpeedAbsolute = $0700
000000r 2               FrictionAdderHigh     = $0701
000000r 2               FrictionAdderLow      = $0702
000000r 2               RunningSpeed          = $0703
000000r 2               SwimmingFlag          = $0704
000000r 2               Player_X_MoveForce    = $0705
000000r 2               DiffToHaltJump        = $0706
000000r 2               JumpOrigin_Y_HighPos  = $0707
000000r 2               JumpOrigin_Y_Position = $0708
000000r 2               VerticalForce         = $0709
000000r 2               VerticalForceDown     = $070a
000000r 2               PlayerChangeSizeFlag  = $070b
000000r 2               PlayerAnimTimerSet    = $070c
000000r 2               PlayerAnimCtrl        = $070d
000000r 2               DeathMusicLoaded      = $0712
000000r 2               FlagpoleSoundQueue    = $0713
000000r 2               CrouchingFlag         = $0714
000000r 2               MaximumLeftSpeed      = $0450
000000r 2               MaximumRightSpeed     = $0456
000000r 2               
000000r 2               SprObject_OffscrBits  = $03d0
000000r 2               Player_OffscreenBits  = $03d0
000000r 2               Enemy_OffscreenBits   = $03d1
000000r 2               FBall_OffscreenBits   = $03d2
000000r 2               Bubble_OffscreenBits  = $03d3
000000r 2               Block_OffscreenBits   = $03d4
000000r 2               Misc_OffscreenBits    = $03d6
000000r 2               EnemyOffscrBitsMasked = $03d8
000000r 2               
000000r 2               Cannon_Offset         = $046a
000000r 2               Cannon_PageLoc        = $046b
000000r 2               Cannon_X_Position     = $0471
000000r 2               Cannon_Y_Position     = $0477
000000r 2               Cannon_Timer          = $047d
000000r 2               
000000r 2               Whirlpool_Offset      = $046a
000000r 2               Whirlpool_PageLoc     = $046b
000000r 2               Whirlpool_LeftExtent  = $0471
000000r 2               Whirlpool_Length      = $0477
000000r 2               Whirlpool_Flag        = $047d
000000r 2               
000000r 2               VineFlagOffset        = $0398
000000r 2               VineHeight            = $0399
000000r 2               VineObjOffset         = $039a
000000r 2               VineStart_Y_Position  = $039d
000000r 2               
000000r 2               Block_Orig_YPos       = $03e4
000000r 2               Block_BBuf_Low        = $03e6
000000r 2               Block_Metatile        = $03e8
000000r 2               Block_PageLoc2        = $03ea
000000r 2               Block_RepFlag         = $03ec
000000r 2               Block_ResidualCounter = $03f0
000000r 2               Block_Orig_XPos       = $03f1
000000r 2               
000000r 2               BoundingBox_UL_XPos   = $04ac
000000r 2               BoundingBox_UL_YPos   = $04ad
000000r 2               BoundingBox_DR_XPos   = $04ae
000000r 2               BoundingBox_DR_YPos   = $04af
000000r 2               BoundingBox_UL_Corner = $04ac
000000r 2               BoundingBox_LR_Corner = $04ae
000000r 2               EnemyBoundingBoxCoord = $04b0
000000r 2               
000000r 2               PowerUpType           = $39
000000r 2               
000000r 2               FireballBouncingFlag  = $3a
000000r 2               FireballCounter       = $06ce
000000r 2               FireballThrowingTimer = $0711
000000r 2               
000000r 2               HammerEnemyOffset     = $06ae
000000r 2               JumpCoinMiscOffset    = $06b7
000000r 2               
000000r 2               Block_Buffer_1        = $0500
000000r 2               Block_Buffer_2        = $05d0
000000r 2               
000000r 2               HammerThrowingTimer   = $03a2
000000r 2               HammerBroJumpTimer    = $3c
000000r 2               Misc_Collision_Flag   = $06be
000000r 2               
000000r 2               RedPTroopaOrigXPos    = $0401
000000r 2               RedPTroopaCenterYPos  = $58
000000r 2               
000000r 2               XMovePrimaryCounter   = $a0
000000r 2               XMoveSecondaryCounter = $58
000000r 2               
000000r 2               CheepCheepMoveMFlag   = $58
000000r 2               CheepCheepOrigYPos    = $0434
000000r 2               BitMFilter            = $06dd
000000r 2               
000000r 2               LakituReappearTimer   = $06d1
000000r 2               LakituMoveSpeed       = $58
000000r 2               LakituMoveDirection   = $a0
000000r 2               
000000r 2               FirebarSpinState_Low  = $58
000000r 2               FirebarSpinState_High = $a0
000000r 2               FirebarSpinSpeed      = $0388
000000r 2               FirebarSpinDirection  = $34
000000r 2               
000000r 2               DuplicateObj_Offset   = $06cf
000000r 2               NumberofGroupEnemies  = $06d3
000000r 2               
000000r 2               BlooperMoveCounter    = $a0
000000r 2               BlooperMoveSpeed      = $58
000000r 2               
000000r 2               BowserBodyControls    = $0363
000000r 2               BowserFeetCounter     = $0364
000000r 2               BowserMovementSpeed   = $0365
000000r 2               BowserOrigXPos        = $0366
000000r 2               BowserFlameTimerCtrl  = $0367
000000r 2               BowserFront_Offset    = $0368
000000r 2               BridgeCollapseOffset  = $0369
000000r 2               BowserGfxFlag         = $036a
000000r 2               BowserHitPoints       = $0483
000000r 2               MaxRangeFromOrigin    = $06dc
000000r 2               
000000r 2               BowserFlamePRandomOfs = $0417
000000r 2               
000000r 2               PiranhaPlantUpYPos    = $0417
000000r 2               PiranhaPlantDownYPos  = $0434
000000r 2               PiranhaPlant_Y_Speed  = $58
000000r 2               PiranhaPlant_MoveFlag = $a0
000000r 2               
000000r 2               FireworksCounter      = $06d7
000000r 2               ExplosionGfxCounter   = $58
000000r 2               ExplosionTimerCounter = $a0
000000r 2               
000000r 2               ;sound related defines
000000r 2               Squ2_NoteLenBuffer    = $07b3
000000r 2               Squ2_NoteLenCounter   = $07b4
000000r 2               Squ2_EnvelopeDataCtrl = $07b5
000000r 2               Squ1_NoteLenCounter   = $07b6
000000r 2               Squ1_EnvelopeDataCtrl = $07b7
000000r 2               Tri_NoteLenBuffer     = $07b8
000000r 2               Tri_NoteLenCounter    = $07b9
000000r 2               Noise_BeatLenCounter  = $07ba
000000r 2               Squ1_SfxLenCounter    = $07bb
000000r 2               Squ2_SfxLenCounter    = $07bd
000000r 2               Sfx_SecondaryCounter  = $07be
000000r 2               Noise_SfxLenCounter   = $07bf
000000r 2               
000000r 2               PauseSoundQueue       = $fa
000000r 2               Square1SoundQueue     = $ff
000000r 2               Square2SoundQueue     = $fe
000000r 2               NoiseSoundQueue       = $fd
000000r 2               AreaMusicQueue        = $fb
000000r 2               EventMusicQueue       = $fc
000000r 2               
000000r 2               Square1SoundBuffer    = $f1
000000r 2               Square2SoundBuffer    = $f2
000000r 2               NoiseSoundBuffer      = $f3
000000r 2               AreaMusicBuffer       = $f4
000000r 2               EventMusicBuffer      = $07b1
000000r 2               PauseSoundBuffer      = $07b2
000000r 2               
000000r 2               MusicData             = $f5
000000r 2               MusicDataLow          = $f5
000000r 2               MusicDataHigh         = $f6
000000r 2               MusicOffset_Square2   = $f7
000000r 2               MusicOffset_Square1   = $f8
000000r 2               MusicOffset_Triangle  = $f9
000000r 2               MusicOffset_Noise     = $07b0
000000r 2               
000000r 2               NoteLenLookupTblOfs   = $f0
000000r 2               DAC_Counter           = $07c0
000000r 2               NoiseDataLoopbackOfs  = $07c1
000000r 2               NoteLengthTblAdder    = $07c4
000000r 2               AreaMusicBuffer_Alt   = $07c5
000000r 2               PauseModeFlag         = $07c6
000000r 2               GroundMusicHeaderOfs  = $07c7
000000r 2               AltRegContentFlag     = $07ca
000000r 2               
000000r 2               ;-------------------------------------------------------------------------------------
000000r 2               ;CONSTANTS
000000r 2               
000000r 2               ;sound effects constants
000000r 2               Sfx_SmallJump         = %10000000
000000r 2               Sfx_Flagpole          = %01000000
000000r 2               Sfx_Fireball          = %00100000
000000r 2               Sfx_PipeDown_Injury   = %00010000
000000r 2               Sfx_EnemySmack        = %00001000
000000r 2               Sfx_EnemyStomp        = %00000100
000000r 2               Sfx_Bump              = %00000010
000000r 2               Sfx_BigJump           = %00000001
000000r 2               
000000r 2               Sfx_BowserFall        = %10000000
000000r 2               Sfx_ExtraLife         = %01000000
000000r 2               Sfx_PowerUpGrab       = %00100000
000000r 2               Sfx_TimerTick         = %00010000
000000r 2               Sfx_Blast             = %00001000
000000r 2               Sfx_GrowVine          = %00000100
000000r 2               Sfx_GrowPowerUp       = %00000010
000000r 2               Sfx_CoinGrab          = %00000001
000000r 2               
000000r 2               Sfx_BowserFlame       = %00000010
000000r 2               Sfx_BrickShatter      = %00000001
000000r 2               
000000r 2               ;music constants
000000r 2               Silence               = %10000000
000000r 2               
000000r 2               StarPowerMusic        = %01000000
000000r 2               PipeIntroMusic        = %00100000
000000r 2               CloudMusic            = %00010000
000000r 2               CastleMusic           = %00001000
000000r 2               UndergroundMusic      = %00000100
000000r 2               WaterMusic            = %00000010
000000r 2               GroundMusic           = %00000001
000000r 2               
000000r 2               TimeRunningOutMusic   = %01000000
000000r 2               EndOfLevelMusic       = %00100000
000000r 2               AltGameOverMusic      = %00010000
000000r 2               EndOfCastleMusic      = %00001000
000000r 2               VictoryMusic          = %00000100
000000r 2               GameOverMusic         = %00000010
000000r 2               DeathMusic            = %00000001
000000r 2               
000000r 2               ;enemy object constants
000000r 2               GreenKoopa            = $00
000000r 2               BuzzyBeetle           = $02
000000r 2               RedKoopa              = $03
000000r 2               HammerBro             = $05
000000r 2               Goomba                = $06
000000r 2               Bloober               = $07
000000r 2               BulletBill_FrenzyVar  = $08
000000r 2               GreyCheepCheep        = $0a
000000r 2               RedCheepCheep         = $0b
000000r 2               Podoboo               = $0c
000000r 2               PiranhaPlant          = $0d
000000r 2               GreenParatroopaJump   = $0e
000000r 2               RedParatroopa         = $0f
000000r 2               GreenParatroopaFly    = $10
000000r 2               Lakitu                = $11
000000r 2               Spiny                 = $12
000000r 2               FlyCheepCheepFrenzy   = $14
000000r 2               FlyingCheepCheep      = $14
000000r 2               BowserFlame           = $15
000000r 2               Fireworks             = $16
000000r 2               BBill_CCheep_Frenzy   = $17
000000r 2               Stop_Frenzy           = $18
000000r 2               Bowser                = $2d
000000r 2               PowerUpObject         = $2e
000000r 2               VineObject            = $2f
000000r 2               FlagpoleFlagObject    = $30
000000r 2               StarFlagObject        = $31
000000r 2               JumpspringObject      = $32
000000r 2               BulletBill_CannonVar  = $33
000000r 2               RetainerObject        = $35
000000r 2               TallEnemy             = $09
000000r 2               
000000r 2               ;other constants
000000r 2               World1 = 0
000000r 2               World2 = 1
000000r 2               World3 = 2
000000r 2               World4 = 3
000000r 2               World5 = 4
000000r 2               World6 = 5
000000r 2               World7 = 6
000000r 2               World8 = 7
000000r 2               Level1 = 0
000000r 2               Level2 = 1
000000r 2               Level3 = 2
000000r 2               Level4 = 3
000000r 2               
000000r 2               WarmBootOffset        = <$07d6
000000r 2               ColdBootOffset        = <$07fe
000000r 2               TitleScreenDataOffset = $1ec0
000000r 2               SoundMemory           = $07b0
000000r 2               
000000r 2               .define SwimTileRepOffset		PlayerGraphicsTable + $9e
000000r 2               .define MusicHeaderOffsetData	MusicHeaderData - 1
000000r 2               .define MHD 					MusicHeaderData
000000r 2               
000000r 2               A_Button              = %10000000
000000r 2               B_Button              = %01000000
000000r 2               Select_Button         = %00100000
000000r 2               Start_Button          = %00010000
000000r 2               Up_Dir                = %00001000
000000r 2               Down_Dir              = %00000100
000000r 2               Left_Dir              = %00000010
000000r 2               Right_Dir             = %00000001
000000r 2               
000000r 2               TitleScreenModeValue  = 0
000000r 2               GameModeValue         = 1
000000r 2               VictoryModeValue      = 2
000000r 2               GameOverModeValue     = 3
000000r 2               
000000r 1                   .include "shared.inc"
000000r 2               BANK_SELECTED = $07ff
000000r 2               
000000r 2               .define PF_SockMode $01 ; Todo move elsewhere...
000000r 2               .define PF_SaveState $02
000000r 2               .define PF_LoadState $04
000000r 2               .define PF_RestartLevel $08
000000r 2               .define PF_LevelEntrySaved $10
000000r 2               .define PF_DisablePracticeInfo $20
000000r 2               .define PF_EnableInputDisplay $40
000000r 2               
000000r 2               .macro PF_SetToLevelEnd_A
000000r 2               	lda WRAM_PracticeFlags
000000r 2               	and #(PF_LevelEntrySaved^$FF)
000000r 2               	sta WRAM_PracticeFlags
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MACRO_ThrowFrameImpl
000000r 2               ThrowFrame:
000000r 2               		lda Mirror_PPU_CTRL_REG2
000000r 2               		sta PPU_CTRL_REG2
000000r 2               		lda Mirror_PPU_CTRL_REG1
000000r 2               		and #$FC
000000r 2               		sta Mirror_PPU_CTRL_REG1
000000r 2               		sta PPU_CTRL_REG1 ; Force NT-0 (in case no button was pressed)
000000r 2               
000000r 2               		;
000000r 2               		; Wait for sprite 0
000000r 2               		;
000000r 2               		lda Sprite0HitDetectFlag  ;check for flag here
000000r 2               		beq @SkipSprite0
000000r 2               		ldx #0
000000r 2               		stx PPU_SPR_ADDR
000000r 2               		lda Sprite0Data
000000r 2               		sta PPU_SPR_DATA
000000r 2               		lda Sprite0Data+1
000000r 2               		sta PPU_SPR_DATA
000000r 2               		lda Sprite0Data+2
000000r 2               		sta PPU_SPR_DATA
000000r 2               		lda Sprite0Data+3
000000r 2               		sta PPU_SPR_DATA
000000r 2               		lda PPU_STATUS
000000r 2               		stx PPU_SCROLL_REG
000000r 2               		stx PPU_SCROLL_REG
000000r 2               @Sprite0Clr:
000000r 2               		lda PPU_STATUS
000000r 2               		and #$40
000000r 2               		bne @Sprite0Clr
000000r 2               @Sprite0Hit:
000000r 2               		lda PPU_STATUS
000000r 2               		and #$40
000000r 2               		beq @Sprite0Hit
000000r 2               		ldy #$14
000000r 2               @HBlankDelay:
000000r 2               		dey
000000r 2               		bne @HBlankDelay
000000r 2               @SkipSprite0:
000000r 2               		lda PPU_STATUS
000000r 2               		lda HorizontalScroll
000000r 2               		sta PPU_SCROLL_REG
000000r 2               		lda VerticalScroll
000000r 2               		sta PPU_SCROLL_REG
000000r 2               
000000r 2               		lda ScreenLeft_PageLoc
000000r 2               		lsr Mirror_PPU_CTRL_REG1
000000r 2               		and #$01
000000r 2               		ror
000000r 2               		rol Mirror_PPU_CTRL_REG1
000000r 2               		lda Mirror_PPU_CTRL_REG1
000000r 2               		sta PPU_CTRL_REG1
000000r 2               
000000r 2               		lda WRAM_SlowMotion
000000r 2               		cmp #4
000000r 2               		bne @done
000000r 2               		;
000000r 2               		; Latch controllers.
000000r 2               		;
000000r 2               		ldx #1
000000r 2               		stx $4016
000000r 2               		dex
000000r 2               		stx $4016
000000r 2               		;
000000r 2               		; Check A
000000r 2               		;
000000r 2               		lda $4017
000000r 2               		lsr
000000r 2               		bcs @done ; A pressed. Advance next frame
000000r 2               		lda $4017 ; B
000000r 2               		lda $4017 ; Select
000000r 2               		lda $4017 ; Start
000000r 2               		lsr
000000r 2               		bcc @VBlank0
000000r 2               		;
000000r 2               		; Start pressed - Exit frame advance mode.
000000r 2               		;
000000r 2               		stx WRAM_SlowMotion
000000r 2               		jmp @done ; Exit out of this.
000000r 2               @VBlank0:
000000r 2               		lda PPU_STATUS ; Wait for VBlank
000000r 2               		bpl @VBlank0
000000r 2               		jmp ThrowFrame
000000r 2               @done:
000000r 2               		lda Mirror_PPU_CTRL_REG1
000000r 2               		ora #$80 ; NMI
000000r 2               		sta PPU_CTRL_REG1
000000r 2               		jmp Enter_SoundEngine
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MACRO_RunSlowMo gm
000000r 2               		dec WRAM_SlowMotionLeft
000000r 2               		bmi @allow_frame
000000r 2               		lda DisableScreenFlag
000000r 2               		bne @allow_frame
000000r 2               		lda GamePauseStatus
000000r 2               		and #3
000000r 2               		bne @allow_frame
000000r 2               		ldx OperMode
000000r 2               		dex
000000r 2               		bne @allow_frame
000000r 2               		lda OperMode_Task
000000r 2               		cmp #gm
000000r 2               		bne @allow_frame
000000r 2               		jsr ThrowFrame
000000r 2               		rti
000000r 2               @allow_frame:
000000r 2               		lda WRAM_SlowMotion
000000r 2               		sta WRAM_SlowMotionLeft
000000r 2               .endmacro
000000r 2               
000000r 2               .define MMC5_MAKE_PRGBANK(id) ((id)*4)
000000r 2               .define MAKE_MMC5_CHRBANK(id) ((id)*1)
000000r 2               
000000r 2               TITLE_INIT		= $01
000000r 2               
000000r 2               BANK_LOADER		= MMC5_MAKE_PRGBANK(0)
000000r 2               BANK_CHR		= MMC5_MAKE_PRGBANK(1)
000000r 2               BANK_ORG		= MMC5_MAKE_PRGBANK(2)
000000r 2               BANK_COMMON		= MMC5_MAKE_PRGBANK(3)
000000r 2               BANK_SCEN		= MMC5_MAKE_PRGBANK(4)
000000r 2               BANK_SCEN_DATA	= MMC5_MAKE_PRGBANK(5)
000000r 2               BANK_SMBLL		= MMC5_MAKE_PRGBANK(6)
000000r 2               BANK_LLDATA		= MMC5_MAKE_PRGBANK(7)
000000r 2               
000000r 2               
000000r 2               CHR_ORG_SPR = MAKE_MMC5_CHRBANK(0)
000000r 2               CHR_ORG_BG = MAKE_MMC5_CHRBANK(1)
000000r 2               CHR_ORG_BG_ALTFONT = MAKE_MMC5_CHRBANK(2)
000000r 2               CHR_LOST_SPR = MAKE_MMC5_CHRBANK(3)
000000r 2               CHR_LOST_BG = MAKE_MMC5_CHRBANK(4)
000000r 2               CHR_LOST_BG_ALTFONT = MAKE_MMC5_CHRBANK(5)
000000r 2               CHR_PEACH_SPR = MAKE_MMC5_CHRBANK(6)
000000r 2               CHR_INTRO_BG = MAKE_MMC5_CHRBANK(7)
000000r 2               CHR_INTRO_SPR0 = MAKE_MMC5_CHRBANK(8)
000000r 2               
000000r 2               CHR_SET_BANK = $A000
000000r 2               
000000r 2               SavedRule = $07d9
000000r 2               RuleIndex = $0717 ; Previously DemoAction (can be changed to temp?)
000000r 2               PowerUps = $07e3 ; Previously unused
000000r 2               CurrentRule = $7df
000000r 2               
000000r 2               .ifndef RESTART_LEVEL_BUTTONS
000000r 2               	.define RESTART_LEVEL_BUTTONS Select_Button|Up_Dir
000000r 2               .endif
000000r 2               
000000r 2               .ifndef RESTART_GAME_BUTTONS
000000r 2               	.define RESTART_GAME_BUTTONS Select_Button|Down_Dir
000000r 2               .endif
000000r 2               
000000r 2               .ifndef SAVE_STATE_BUTTONS
000000r 2               	.define SAVE_STATE_BUTTONS Select_Button|Right_Dir
000000r 2               .endif
000000r 2               
000000r 2               .ifndef LOAD_STATE_BUTTONS
000000r 2               	.define LOAD_STATE_BUTTONS Select_Button|Left_Dir
000000r 2               .endif
000000r 2               
000000r 2               
000000r 1                   .include "macros.inc"
000000r 2               .macro lsr_by n
000000r 2               	.repeat n, i
000000r 2               		lsr
000000r 2               	.endrep
000000r 2               .endmacro
000000r 2               
000000r 2               .macro DoUpdateSockHash
000000r 2               		.local @dont_render
000000r 2               		lda WRAM_PracticeFlags
000000r 2               		and #PF_SockMode
000000r 2               		bne @dont_render
000000r 2               		lda IntervalTimerControl
000000r 2               		and #3
000000r 2               		cmp #2
000000r 2               		bne @dont_render
000000r 2               		jsr Enter_ForceUpdateSockHash
000000r 2               	@dont_render:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro practice_callgate
000000r 2               	.res $FE00 - *, $EA
000000r 2               
000000r 2               	Enter_EndOfCastle:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp EndOfCastle
000000r 2               
000000r 2               	Enter_RenderIntermediateTime:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp RenderIntermediateTime
000000r 2               
000000r 2               	Enter_FrameToTime:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp FrameToTime
000000r 2               
000000r 2               	Enter_UpdateGameTimer:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp UpdateGameTimer
000000r 2               
000000r 2               	Enter_InitializeWRAM:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp InitializeWRAM
000000r 2               
000000r 2               	Enter_SetDefaultWRAM:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp SetDefaultWRAM
000000r 2               
000000r 2               	Enter_FactoryResetWRAM:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp FactoryResetWRAM
000000r 2               
000000r 2               	Enter_RedrawSockTimer:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp RedrawSockTimer
000000r 2               
000000r 2               	Enter_PracticeInit:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp PracticeInit
000000r 2               
000000r 2               	Enter_ForceUpdateSockHash:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp ForceUpdateSockHash
000000r 2               
000000r 2               	Enter_PracticeOnFrame:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp PracticeOnFrame
000000r 2               
000000r 2               	Enter_PracticeTitleMenu:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp PracticeTitleMenu
000000r 2               
000000r 2               	Enter_UpdateFrameRule:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp UpdateFrameRule
000000r 2               
000000r 2               	Enter_WritePracticeTop:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp WritePracticeTop
000000r 2               
000000r 2               	Enter_RedrawUserVars:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp RedrawUserVars
000000r 2               
000000r 2               	Enter_RedrawAll:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp RedrawAll
000000r 2               
000000r 2               	Enter_RedrawFrameNumbers:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp RedrawFrameNumbers
000000r 2               
000000r 2               	Enter_ProcessLevelLoad:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp ProcessLevelLoad
000000r 2               
000000r 2               	Enter_LoadPhysicsData:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp LoadPhysicsData
000000r 2               
000000r 2               	Enter_LoadMarioPhysics:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp LoadMarioPhysics
000000r 2               
000000r 2               	Enter_LL_LoadWarpzone:
000000r 2               		lda #BANK_LLDATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp LoadWarpzone
000000r 2               
000000r 2               	Enter_LL_GetAreaDataAddrs:
000000r 2               		lda #BANK_LLDATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp GetAreaDataAddrs
000000r 2               
000000r 2               	Enter_LL_LoadAreaPointer:
000000r 2               		lda #BANK_LLDATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp LoadAreaPointer
000000r 2               
000000r 2               	Enter_LL_WriteHalfwayPages:
000000r 2               		lda #BANK_LLDATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp WriteHalfwayPages
000000r 2               
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro scenarios_callgate
000000r 2               	.res $FE00 - *, $EA
000000r 2               	Enter_ScenLoadArea:
000000r 2               		lda #BANK_SCEN_DATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp ScenLoadArea
000000r 2               
000000r 2               	Enter_ScenReset:
000000r 2               		lda #BANK_SCEN_DATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp ScenReset
000000r 2               
000000r 2               	Enter_ScenUpdateSelected:
000000r 2               		lda #BANK_SCEN_DATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp ScenUpdateSelected
000000r 2               
000000r 2               	Enter_ScenValidate:
000000r 2               		lda #BANK_SCEN_DATA
000000r 2               		jsr SetBankFromA
000000r 2               		jmp ScenValidate
000000r 2               
000000r 2               .endmacro
000000r 2               
000000r 2               MMC5_PRGMode          = $5100
000000r 2               MMC5_CHRMode          = $5101
000000r 2               MMC5_RAMProtect1      = $5102
000000r 2               MMC5_RAMProtect2      = $5103
000000r 2               MMC5_ExRamMode        = $5104
000000r 2               MMC5_Nametables       = $5105
000000r 2               MMC5_FillTile         = $5106
000000r 2               MMC5_CHRBank          = $5120
000000r 2               MMC5_PRGBank          = $5113
000000r 2               MMC5_VSplitMode       = $5200
000000r 2               MMC5_VSplitScroll     = $5201
000000r 2               MMC5_VSplitBank       = $5202
000000r 2               MMC5_SLCompare        = $5203
000000r 2               MMC5_SLIRQ            = $5204
000000r 2               MMC5_ExRamOfs         = $3C00
000000r 2               
000000r 2               ;
000000r 2               ; Lower banks
000000r 2               ;
000000r 2               .macro control_bank
000000r 2               	.res $FF00 - *, $EA
000000r 2               
000000r 2               	Enter_SoundEngine:
000000r 2               		lda #BANK_COMMON
000000r 2               		jsr SetBankFromA
000000r 2               		jmp SoundEngineExternal
000000r 2               
000000r 2               	ReturnBank:
000000r 2               		lda BANK_SELECTED
000000r 2               		jmp SetBankFromA
000000r 2               
000000r 2               	SetChrBank0FromA:
000000r 2               		sta MMC5_CHRBank+3
000000r 2               		rts
000000r 2               
000000r 2               	SetChrBank1FromA:
000000r 2               		sta MMC5_CHRBank+7
000000r 2               		rts
000000r 2               
000000r 2               	SetChrBanksFromAX:
000000r 2               		jsr SetChrBank0FromA
000000r 2               		txa
000000r 2               		jmp SetChrBank1FromA
000000r 2               
000000r 2               	SetBankFromA:
000000r 2               		clc
000000r 2               		ora #$82			; mark as prg-rom
000000r 2               		sta MMC5_PRGBank+4
000000r 2               		rts
000000r 2               
000000r 2               	MapperReset:
000000r 2               		;
000000r 2               		; clear mapper state
000000r 2               		;
000000r 2               		sei
000000r 2               		cld ;absolutely useless :)
000000r 2               		ldx #$FF
000000r 2               		txs
000000r 2               		lda #%01000000         ; disable apu irq
000000r 2               		sta $4017
000000r 2               		lda #%10
000000r 2               		sta MMC5_RAMProtect1
000000r 2               		lda #%01
000000r 2               		sta MMC5_RAMProtect2
000000r 2               		lda #1
000000r 2               		sta MMC5_CHRMode       ; use 1kb chr banking
000000r 2               		lda #0
000000r 2               		sta MMC5_PRGMode       ; use 32kb prg banking
000000r 2               		lsr a
000000r 2               		sta MMC5_PRGBank       ; use bank 0 for prg-ram
000000r 2               		lda #%11
000000r 2               		sta MMC5_ExRamMode
000000r 2               		lda #BANK_LOADER
000000r 2               		sta BANK_SELECTED
000000r 2               		jsr SetBankFromA       ; set startup bank
000000r 2               		lda #$44
000000r 2               		sta MMC5_Nametables    ; set vertical mirroring
000000r 2               		jmp $8000
000000r 2               
000000r 2               	StartBank:
000000r 2               		;
000000r 2               		; 0 Bank selected
000000r 2               		;
000000r 2               		sta BANK_SELECTED
000000r 2               		ldx #$00
000000r 2               		stx PPU_CTRL_REG1
000000r 2               		stx PPU_CTRL_REG2
000000r 2               		jsr SetBankFromA
000000r 2               		jmp Start
000000r 2               
000000r 2               	IRQ:
000000r 2               		sei
000000r 2               		php
000000r 2               		pha
000000r 2               		lda MMC5_SLIRQ
000000r 2               		lda Mirror_PPU_CTRL_REG1      ; waste some time to get to the end of the scanline
000000r 2               		lda Mirror_PPU_CTRL_REG1      ; waste some time to get to the end of the scanline
000000r 2               		lda Mirror_PPU_CTRL_REG1      ; waste some time to get to the end of the scanline
000000r 2               		lda Mirror_PPU_CTRL_REG1
000000r 2               		and #%11110110           ;mask out sprite address and nametable
000000r 2               		ora UseNtBase2400
000000r 2               		sta Mirror_PPU_CTRL_REG1      ;update the register and its mirror
000000r 2               		sta PPU_CTRL_REG1
000000r 2               		lda HorizontalScroll
000000r 2               		sta PPU_SCROLL_REG           ;set scroll regs for the screen under the status bar
000000r 2               		lda #$00
000000r 2               		sta PPU_SCROLL_REG
000000r 2               		sta IRQAckFlag           ;indicate IRQ was acknowledged
000000r 2               		tya                      ; waste some time to match 2j irq
000000r 2               		ldy #$18                 ; ...
000000r 2               	:   dey                      ; ...
000000r 2               		bne :-                   ; ...
000000r 2               		tay                      ; ...
000000r 2               		pla
000000r 2               		plp
000000r 2               		cli
000000r 2               		rti
000000r 2               
000000r 2               		.res $FFFA - *, $ea
000000r 2               		;
000000r 2               		; Interrupt table
000000r 2               		;
000000r 2               		.word NonMaskableInterrupt
000000r 2               		.word MapperReset
000000r 2               		.word IRQ
000000r 2               
000000r 2               .endmacro
000000r 2               
000000r 1                   .segment "bank5"
000000r 1                   .org $8000
008000  1               
008000  1               Start:
008000  1  A9 10                     lda #%00010000               ;init PPU control register 1
008002  1  8D 00 20                  sta PPU_CTRL_REG1
008005  1  A9 00                     lda #0
008007  1  8D 01 20                  sta PPU_CTRL_REG2
00800A  1  A2 FF                     ldx #$ff                     ;reset stack pointer
00800C  1  9A                        txs
00800D  1  AD 02 20     VBlank1:     lda PPU_STATUS               ;wait two frames
008010  1  10 FB                     bpl VBlank1
008012  1  AD 02 20     VBlank2:     lda PPU_STATUS
008015  1  10 FB                     bpl VBlank2
008017  1                            ;
008017  1                            ; Load correct CHR rom
008017  1                            ;
008017  1  A0 D6                     ldy #WarmBootOffset          ;if passed both, load warm boot pointer
008019  1  20 BD BA     ColdBoot:    jsr InitializeMemory         ;clear memory using pointer in Y
00801C  1  8D 11 40                  sta SND_DELTA_REG+1          ;reset delta counter load register
00801F  1  8D 70 07                  sta OperMode                 ;reset primary mode of operation
008022  1               
008022  1  A9 00                     lda #CHR_ORG_SPR
008024  1  A2 01                     ldx #CHR_ORG_BG
008026  1  20 16 FF                  jsr SetChrBanksFromAX
008029  1               
008029  1  A9 A5                     lda #$a5                     ;set warm boot flag
00802B  1  8D A7 07                  sta PseudoRandomBitReg       ;set seed for pseudorandom register
00802E  1  A9 0F                     lda #%00001111
008030  1  8D 15 40                  sta SND_MASTERCTRL_REG       ;enable all sound channels except dmc
008033  1  A9 06                     lda #%00000110
008035  1  8D 01 20                  sta PPU_CTRL_REG2            ;turn off clipping for OAM and background
008038  1  20 BD BB                  jsr MoveAllSpritesOffscreen
00803B  1  20 44 BB                  jsr InitializeNameTables     ;initialize both name tables
00803E  1  EE 74 07                  inc DisableScreenFlag        ;set flag to disable screen output
008041  1  AD 78 07                  lda Mirror_PPU_CTRL_REG1
008044  1  09 80                     ora #%10000000               ;enable NMIs
008046  1  20 3D BB                  jsr WritePPUReg1
008049  1  4C 49 80     EndlessLoop: jmp EndlessLoop              ;endless loop, need I say more?
00804C  1               
00804C  1               ;-------------------------------------------------------------------------------------
00804C  1               
00804C  1               ;-----------------------------------------------------------------
00804C  1               
00804C  1               NonMaskableInterrupt:
00804C  1  AD 78 07                    lda Mirror_PPU_CTRL_REG1  ;disable NMIs in mirror reg
00804F  1  29 7F                       and #%01111111            ;save all other bits
008051  1  8D 78 07                    sta Mirror_PPU_CTRL_REG1
008054  1  29 7E                       and #%01111110            ;alter name table address to be $2800
008056  1  8D 00 20                    sta PPU_CTRL_REG1         ;(essentially $2000) but save other bits
008059  1  AD 79 07                    lda Mirror_PPU_CTRL_REG2  ;disable OAM and background display by default
00805C  1  29 E6                       and #%11100110
00805E  1  AC 74 07                    ldy DisableScreenFlag     ;get screen disable flag
008061  1  D0 05                       bne ScreenOff             ;if set, used bits as-is
008063  1  AD 79 07                    lda Mirror_PPU_CTRL_REG2  ;otherwise reenable bits and save them
008066  1  09 1E                       ora #%00011110
008068  1  8D 79 07     ScreenOff:     sta Mirror_PPU_CTRL_REG2  ;save bits for later but not in register at the moment
00806B  1  29 E7                       and #%11100111            ;disable screen for now
00806D  1  8D 01 20                    sta PPU_CTRL_REG2
008070  1  AE 02 20                    ldx PPU_STATUS            ;reset flip-flop and reset scroll registers to zero
008073  1  A9 00                       lda #$00
008075  1  20 36 BB                    jsr InitScroll
008078  1  8D 03 20                    sta PPU_SPR_ADDR          ;reset spr-ram address register
00807B  1  A9 02                       lda #$02                  ;perform spr-ram DMA access on $0200-$02ff
00807D  1  8D 14 40                    sta SPR_DMA
008080  1  AE 73 07                    ldx VRAM_Buffer_AddrCtrl  ;load control for pointer to buffer contents
008083  1  BD 73 81                    lda VRAM_AddrTable_Low,x  ;set indirect at $00 to pointer
008086  1  85 00                       sta $00
008088  1  BD 86 81                    lda VRAM_AddrTable_High,x
00808B  1  85 01                       sta $01
00808D  1  20 2D BB                    jsr UpdateScreen          ;update screen with buffer contents
008090  1  A0 00                       ldy #$00
008092  1  AE 73 07                    ldx VRAM_Buffer_AddrCtrl  ;check for usage of $0341
008095  1  E0 06                       cpx #$06
008097  1  D0 01                       bne InitBuffer
008099  1  C8                          iny                       ;get offset based on usage
00809A  1  BE 99 81     InitBuffer:    ldx VRAM_Buffer_Offset,y
00809D  1  A9 00                       lda #$00                  ;clear buffer header at last location
00809F  1  9D 00 03                    sta VRAM_Buffer1_Offset,x
0080A2  1  9D 01 03                    sta VRAM_Buffer1,x
0080A5  1  8D 73 07                    sta VRAM_Buffer_AddrCtrl  ;reinit address control to $0301
0080A8  1  AD 79 07                    lda Mirror_PPU_CTRL_REG2  ;copy mirror of $2001 to register
0080AB  1  8D 01 20                    sta PPU_CTRL_REG2
0080AE  1  20 00 FF                    jsr Enter_SoundEngine      ;play sound
0080B1  1  20 87 BB                    jsr ReadJoypads           ;read joypads
0080B4  1  AD 61 07                    lda FpgFlags
0080B7  1  0A                          asl
0080B8  1  B0 48                       bcs PauseSkip
0080BA  1  F0 04                       beq RunPreInit
0080BC  1  29 04                       and #$04 ; really 0x02 but shifted (this is so dumb)
0080BE  1  F0 42                       beq PauseSkip
0080C0  1               RunPreInit:
0080C0  1  AD 47 07                    lda TimerControl          ;if master timer control not set, decrement
0080C3  1  F0 05                       beq DecTimers             ;all frame and interval timers
0080C5  1  CE 47 07                    dec TimerControl
0080C8  1  D0 19                       bne NoDecTimers
0080CA  1  A2 14        DecTimers:     ldx #$14                  ;load end offset for end of frame timers
0080CC  1  CE 7F 07                    dec IntervalTimerControl  ;decrement interval timer control,
0080CF  1  10 07                       bpl DecTimersLoop         ;if not expired, only frame timers will decrement
0080D1  1  A9 14                       lda #$14
0080D3  1  8D 7F 07                    sta IntervalTimerControl  ;if control for interval timers expired,
0080D6  1  A2 23                       ldx #$23                  ;interval timers will decrement along with frame timers
0080D8  1  BD 80 07     DecTimersLoop: lda Timers,x              ;check current timer
0080DB  1  F0 03                       beq SkipExpTimer          ;if current timer expired, branch to skip,
0080DD  1  DE 80 07                    dec Timers,x              ;otherwise decrement the current timer
0080E0  1  CA           SkipExpTimer:  dex                       ;move onto next timer
0080E1  1  10 F5                       bpl DecTimersLoop         ;do this until all timers are dealt with
0080E3  1  E6 09        NoDecTimers:   inc FrameCounter          ;increment frame counter
0080E5  1  A2 00                       ldx #$00
0080E7  1  A0 07                       ldy #$07
0080E9  1  AD A7 07                    lda PseudoRandomBitReg    ;get first memory location of LSFR bytes
0080EC  1  29 02                       and #%00000010            ;mask out all but d1
0080EE  1  85 00                       sta $00                   ;save here
0080F0  1  AD A8 07                    lda PseudoRandomBitReg+1  ;get second memory location
0080F3  1  29 02                       and #%00000010            ;mask out all but d1
0080F5  1  45 00                       eor $00                   ;perform exclusive-OR on d1 from first and second bytes
0080F7  1  18                          clc                       ;if neither or both are set, carry will be clear
0080F8  1  F0 01                       beq RotPRandomBit
0080FA  1  38                          sec                       ;if one or the other is set, carry will be set
0080FB  1  7E A7 07     RotPRandomBit: ror PseudoRandomBitReg,x  ;rotate carry into d7, and rotate last bit into carry
0080FE  1  E8                          inx                       ;increment to next byte
0080FF  1  88                          dey                       ;decrement for loop
008100  1  D0 F9                       bne RotPRandomBit
008102  1               PauseSkip:
008102  1  AD 74 07                    lda DisableScreenFlag
008105  1  D0 24                       bne SkipSprite0
008107  1  AD 22 07                    lda Sprite0HitDetectFlag  ;check for flag here
00810A  1  F0 1F                       beq SkipSprite0
00810C  1  AD 02 20     Sprite0Clr:    lda PPU_STATUS            ;wait for sprite 0 flag to clear, which will
00810F  1  29 40                       and #%01000000            ;not happen until vblank has ended
008111  1  D0 F9                       bne Sprite0Clr
008113  1  AD 61 07                    lda FpgFlags
008116  1  0A                          asl
008117  1  B0 06                       bcs Sprite0Hit
008119  1  20 C0 BB                    jsr MoveSpritesOffscreen
00811C  1  20 9B 81                    jsr SpriteShuffler
00811F  1  AD 02 20     Sprite0Hit:    lda PPU_STATUS            ;do sprite #0 hit detection
008122  1  29 40                       and #%01000000
008124  1  F0 F9                       beq Sprite0Hit
008126  1  A0 14                       ldy #$14                  ;small delay, to wait until we hit horizontal blank time
008128  1  88           HBlankDelay:   dey
008129  1  D0 FD                       bne HBlankDelay
00812B  1  AD 3F 07     SkipSprite0:   lda HorizontalScroll      ;set scroll registers from variables
00812E  1  8D 05 20                    sta PPU_SCROLL_REG
008131  1  AD 40 07                    lda VerticalScroll
008134  1  8D 05 20                    sta PPU_SCROLL_REG
008137  1  AD 78 07                    lda Mirror_PPU_CTRL_REG1  ;load saved mirror of $2000
00813A  1  48                          pha
00813B  1  8D 00 20                    sta PPU_CTRL_REG1
00813E  1  AD 61 07                    lda FpgFlags
008141  1  0A                          asl
008142  1  B0 0D                       bcs CheckFpgResetKey
008144  1  20 E7 81                    jsr OperModeExecutionTree ;otherwise do one of many, many possible subroutines
008147  1  AD 02 20     SkipMainOper:  lda PPU_STATUS            ;reset flip-flop
00814A  1  68                          pla
00814B  1  09 80                       ora #%10000000            ;reactivate NMIs
00814D  1  8D 00 20                    sta PPU_CTRL_REG1
008150  1  40                          rti                       ;we are done until the next frame!
008151  1               CheckFpgResetKey:
008151  1  AD FC 06                   lda SavedJoypadBits
008154  1  0D 4A 07                   ora JoypadBitMask
008157  1  29 20                      and #Select_Button
008159  1  F0 06                      beq DeathRedrawShit
00815B  1  20 1F 82                   jsr RestartFpg
00815E  1  4C 47 81                   jmp SkipMainOper
008161  1               DeathRedrawShit:
008161  1  AD 62 07                   lda FpgLastInput
008164  1  8D FC 06                   sta SavedJoypadBits
008167  1  20 EC A8                   jsr UpdateStatusInput
00816A  1  20 F7 A8                   jsr UpdateStatusSpeed
00816D  1  20 CD 84                   jsr WriteFpgError
008170  1  4C 47 81                   jmp SkipMainOper
008173  1               
008173  1               ;-------------------------------------------------------------------------------------
008173  1               ;$00 - vram buffer address table low, also used for pseudorandom bit
008173  1               ;$01 - vram buffer address table high
008173  1               
008173  1               VRAM_AddrTable_Low:
008173  1  01 9D C1           .byte <VRAM_Buffer1, <WaterPaletteData, <GroundPaletteData
008176  1  E5 09 00           .byte <UndergroundPaletteData, <CastlePaletteData, <VRAM_Buffer1_Offset
008179  1  41 41 45           .byte <VRAM_Buffer2, <VRAM_Buffer2, <BowserPaletteData
00817C  1  2D 35 3D           .byte <DaySnowPaletteData, <NightSnowPaletteData, <MushroomPaletteData
00817F  1  4D 61 75           .byte <MarioThanksMessage, <LuigiThanksMessage, <MushroomRetainerSaved
008182  1  A1 B8 D7           .byte <PrincessSaved1, <PrincessSaved2, <WorldSelectMessage1
008185  1  E8                 .byte <WorldSelectMessage2
008186  1               
008186  1               VRAM_AddrTable_High:
008186  1  03 89 89           .byte >VRAM_Buffer1, >WaterPaletteData, >GroundPaletteData
008189  1  89 8A 03           .byte >UndergroundPaletteData, >CastlePaletteData, >VRAM_Buffer1_Offset
00818C  1  03 03 8A           .byte >VRAM_Buffer2, >VRAM_Buffer2, >BowserPaletteData
00818F  1  8A 8A 8A           .byte >DaySnowPaletteData, >NightSnowPaletteData, >MushroomPaletteData
008192  1  8A 8A 8A           .byte >MarioThanksMessage, >LuigiThanksMessage, >MushroomRetainerSaved
008195  1  8A 8A 8A           .byte >PrincessSaved1, >PrincessSaved2, >WorldSelectMessage1
008198  1  8A                 .byte >WorldSelectMessage2
008199  1               
008199  1               VRAM_Buffer_Offset:
008199  1  00 40              .byte <VRAM_Buffer1_Offset, <VRAM_Buffer2_Offset
00819B  1               
00819B  1               ;-------------------------------------------------------------------------------------
00819B  1               ;$00 - used for preset value
00819B  1               
00819B  1               SpriteShuffler:
00819B  1  AC 4E 07                    ldy AreaType                ;load level type, likely residual code
00819E  1  A9 28                       lda #$28                    ;load preset value which will put it at
0081A0  1  85 00                       sta $00                     ;sprite #10
0081A2  1  A2 0E                       ldx #$0e                    ;start at the end of OAM data offsets
0081A4  1  BD E4 06     ShuffleLoop:   lda SprDataOffset,x         ;check for offset value against
0081A7  1  C5 00                       cmp $00                     ;the preset value
0081A9  1  90 0F                       bcc NextSprOffset           ;if less, skip this part
0081AB  1  AC E0 06                    ldy SprShuffleAmtOffset     ;get current offset to preset value we want to add
0081AE  1  18                          clc
0081AF  1  79 E1 06                    adc SprShuffleAmt,y         ;get shuffle amount, add to current sprite offset
0081B2  1  90 03                       bcc StrSprOffset            ;if not exceeded $ff, skip second add
0081B4  1  18                          clc
0081B5  1  65 00                       adc $00                     ;otherwise add preset value $28 to offset
0081B7  1  9D E4 06     StrSprOffset:  sta SprDataOffset,x         ;store new offset here or old one if branched to here
0081BA  1  CA           NextSprOffset: dex                         ;move backwards to next one
0081BB  1  10 E7                       bpl ShuffleLoop
0081BD  1  AE E0 06                    ldx SprShuffleAmtOffset     ;load offset
0081C0  1  E8                          inx
0081C1  1  E0 03                       cpx #$03                    ;check if offset + 1 goes to 3
0081C3  1  D0 02                       bne SetAmtOffset            ;if offset + 1 not 3, store
0081C5  1  A2 00                       ldx #$00                    ;otherwise, init to 0
0081C7  1  8E E0 06     SetAmtOffset:  stx SprShuffleAmtOffset
0081CA  1  A2 08                       ldx #$08                    ;load offsets for values and storage
0081CC  1  A0 02                       ldy #$02
0081CE  1  B9 E9 06     SetMiscOffset: lda SprDataOffset+5,y       ;load one of three OAM data offsets
0081D1  1  9D F1 06                    sta Misc_SprDataOffset-2,x  ;store first one unmodified, but
0081D4  1  18                          clc                         ;add eight to the second and eight
0081D5  1  69 08                       adc #$08                    ;more to the third one
0081D7  1  9D F2 06                    sta Misc_SprDataOffset-1,x  ;note that due to the way X is set up,
0081DA  1  18                          clc                         ;this code loads into the misc sprite offsets
0081DB  1  69 08                       adc #$08
0081DD  1  9D F3 06                    sta Misc_SprDataOffset,x
0081E0  1  CA                          dex
0081E1  1  CA                          dex
0081E2  1  CA                          dex
0081E3  1  88                          dey
0081E4  1  10 E8                       bpl SetMiscOffset           ;do this until all misc spr offsets are loaded
0081E6  1  60                          rts
0081E7  1               
0081E7  1               ;-------------------------------------------------------------------------------------
0081E7  1               
0081E7  1               OperModeExecutionTree:
0081E7  1  AD 70 07           lda OperMode     ;this is the heart of the entire program,
0081EA  1  20 A8 BA           jsr JumpEngine   ;most of what goes on starts here
0081ED  1               
0081ED  1  F5 81              .word TitleScreenMode
0081EF  1  78 A8              .word GameMode
0081F1  1  9C 82              .word VictoryMode
0081F3  1  00 8D              .word GameOverMode
0081F5  1               
0081F5  1               ;-------------------------------------------------------------------------------------
0081F5  1               
0081F5  1               TitleScreenMode:
0081F5  1  AD 72 07           lda OperMode_Task
0081F8  1  20 A8 BA           jsr JumpEngine
0081FB  1               
0081FB  1  F6 B8              .word InitializeGame
0081FD  1  6C 84              .word ScreenRoutines
0081FF  1  B3 8B              .word PrimaryGameSetup
008201  1  03 82              .word GameMenuRoutine
008203  1               
008203  1               ;-------------------------------------------------------------------------------------
008203  1               
008203  1               GameMenuRoutine:
008203  1  A9 00            lda #$0
008205  1  8D 74 07         sta DisableScreenFlag
008208  1  AD FC 06         lda SavedJoypad1Bits
00820B  1  CD 62 07         cmp FpgLastInput
00820E  1  F0 45            beq PrintFpgName
008210  1  8D 62 07         sta FpgLastInput
008213  1               
008213  1  C9 01            cmp #Right_Dir
008215  1  F0 3B            beq FpgSelRight
008217  1  C9 02            cmp #Left_Dir
008219  1  F0 31            beq FpgSelLeft
00821B  1  C9 10            cmp #Start_Button
00821D  1  D0 36            bne PrintFpgName
00821F  1                   ;
00821F  1                   ; Start it...
00821F  1                   ;
00821F  1               RestartFpg:
00821F  1  A2 00            ldx #0              ; nuke v?
008221  1  8E 5C 07         stx LevelNumber
008224  1  8E 5F 07         stx WorldNumber
008227  1  8E 60 07         stx AreaNumber
00822A  1  8E 72 07         stx OperMode_Task
00822D  1  8E D8 07         stx FpgError
008230  1  8E 17 07         stx FpgRuleset
008233  1  E8               inx
008234  1  8E 5D 07         stx Hidden1UpFlag
008237  1  8E 64 07         stx OffScr_Hidden1UpFlag
00823A  1  8E 57 07         stx FetchNewGameTimerFlag
00823D  1  8E 70 07         stx OperMode
008240  1  8E 74 07         stx DisableScreenFlag
008243  1  20 CE BB         jsr LoadAreaPointer ; nuke ^?
008246  1  A9 40            lda #$40
008248  1  8D 61 07         sta FpgFlags
00824B  1  60               rts
00824C  1               
00824C  1               FpgSelLeft:
00824C  1  CE 5A 07         dec FpgSelected
00824F  1  CE 5A 07         dec FpgSelected ; To negate the inc...
008252  1               FpgSelRight:
008252  1  EE 5A 07         inc FpgSelected
008255  1               PrintFpgName:
008255  1  AE 00 03         ldx VRAM_Buffer1_Offset
008258  1  A9 22            lda #$22
00825A  1  9D 01 03         sta VRAM_Buffer1+0, x
00825D  1  A9 4B            lda #$4b
00825F  1  9D 02 03         sta VRAM_Buffer1+1, x
008262  1  A9 08            lda #$08
008264  1  9D 03 03         sta VRAM_Buffer1+2, x
008267  1  20 10 FE         jsr Enter_ScenUpdateSelected
00826A  1  A9 00            lda #0
00826C  1  9D 0C 03         sta VRAM_Buffer1+11, x
00826F  1  A9 0B            lda #11
008271  1  18               clc
008272  1  6D 00 03         adc VRAM_Buffer1_Offset
008275  1  8D 00 03         sta VRAM_Buffer1_Offset
008278  1  60               rts
008279  1               
008279  1               ;-------------------------------------------------------------------------------------
008279  1               
008279  1               
008279  1               MushroomIconData:
008279  1  07 22 49 83        .byte $07, $22, $49, $83, $ce, $24, $24, $00
00827D  1  CE 24 24 00  
008281  1               
008281  1               DrawMushroomIcon:
008281  1  A0 07                      ldy #$07                ;read eight bytes to be read by transfer routine
008283  1  B9 79 82     IconDataRead: lda MushroomIconData,y  ;note that the default position is set for a
008286  1  99 00 03                   sta VRAM_Buffer1-1,y    ;1-player game
008289  1  88                         dey
00828A  1  10 F7                      bpl IconDataRead
00828C  1  AD 7A 07                   lda NumberOfPlayers     ;check number of players
00828F  1  F0 0A                      beq ExitIcon            ;if set to 1-player game, we're done
008291  1  A9 24                      lda #$24                ;otherwise, load blank tile in 1-player position
008293  1  8D 04 03                   sta VRAM_Buffer1+3
008296  1  A9 CE                      lda #$ce                ;then load shroom icon tile in 2-player position
008298  1  8D 06 03                   sta VRAM_Buffer1+5
00829B  1  60           ExitIcon:     rts
00829C  1               
00829C  1               ;-------------------------------------------------------------------------------------
00829C  1               
00829C  1               VictoryMode:
00829C  1  20 B1 82                 jsr VictoryModeSubroutines  ;run victory mode subroutines
00829F  1  AD 72 07                 lda OperMode_Task           ;get current task of victory mode
0082A2  1  F0 07                    beq AutoPlayer              ;if on bridge collapse, skip enemy processing
0082A4  1  A2 00                    ldx #$00
0082A6  1  86 08                    stx ObjectOffset            ;otherwise reset enemy object offset
0082A8  1  20 19 B5                 jsr EnemiesAndLoopsCore     ;and run enemy code
0082AB  1  20 C2 EB     AutoPlayer: jsr RelativePlayerPosition  ;get player's relative coordinates
0082AE  1  4C A1 E9                 jmp PlayerGfxHandler        ;draw the player, then leave
0082B1  1               
0082B1  1               VictoryModeSubroutines:
0082B1  1  AD 72 07           lda OperMode_Task
0082B4  1  20 A8 BA           jsr JumpEngine
0082B7  1               
0082B7  1  22 CC              .word BridgeCollapse
0082B9  1  C1 82              .word SetupVictoryMode
0082BB  1  CE 82              .word PlayerVictoryWalk
0082BD  1  07 83              .word PrintVictoryMessages
0082BF  1  72 83              .word PlayerEndWorld
0082C1  1               
0082C1  1               ;-------------------------------------------------------------------------------------
0082C1  1               
0082C1  1               SetupVictoryMode:
0082C1  1  AE 1B 07           ldx ScreenRight_PageLoc  ;get page location of right side of screen
0082C4  1  E8                 inx                      ;increment to next page
0082C5  1  86 34              stx DestinationPageLoc   ;store here
0082C7  1  A9 08              lda #EndOfCastleMusic
0082C9  1  85 FC              sta EventMusicQueue      ;play win castle music
0082CB  1  4C DA 85           jmp IncModeTask_B        ;jump to set next major task in victory mode
0082CE  1               
0082CE  1               ;-------------------------------------------------------------------------------------
0082CE  1               
0082CE  1               PlayerVictoryWalk:
0082CE  1  A0 00                     ldy #$00                ;set value here to not walk player by default
0082D0  1  84 35                     sty VictoryWalkControl
0082D2  1  A5 6D                     lda Player_PageLoc      ;get player's page location
0082D4  1  C5 34                     cmp DestinationPageLoc  ;compare with destination page location
0082D6  1  D0 06                     bne PerformWalk         ;if page locations don't match, branch
0082D8  1  A5 86                     lda Player_X_Position   ;otherwise get player's horizontal position
0082DA  1  C9 60                     cmp #$60                ;compare with preset horizontal position
0082DC  1  B0 03                     bcs DontWalk            ;if still on other page, branch ahead
0082DE  1  E6 35        PerformWalk: inc VictoryWalkControl  ;otherwise increment value and Y
0082E0  1  C8                        iny                     ;note Y will be used to walk the player
0082E1  1  98           DontWalk:    tya                     ;put contents of Y in A and
0082E2  1  20 EC AA                  jsr AutoControlPlayer   ;use A to move player to the right or not
0082E5  1  AD 1A 07                  lda ScreenLeft_PageLoc  ;check page location of left side of screen
0082E8  1  C5 34                     cmp DestinationPageLoc  ;against set value here
0082EA  1  F0 16                     beq ExitVWalk           ;branch if equal to change modes if necessary
0082EC  1  AD 68 07                  lda ScrollFractional
0082EF  1  18                        clc                     ;do fixed point math on fractional part of scroll
0082F0  1  69 80                     adc #$80
0082F2  1  8D 68 07                  sta ScrollFractional    ;save fractional movement amount
0082F5  1  A9 01                     lda #$01                ;set 1 pixel per frame
0082F7  1  69 00                     adc #$00                ;add carry from previous addition
0082F9  1  A8                        tay                     ;use as scroll amount
0082FA  1  20 54 AA                  jsr ScrollScreen        ;do sub to scroll the screen
0082FD  1  20 FF A9                  jsr UpdScrollVar        ;do another sub to update screen and scroll variables
008300  1  E6 35                     inc VictoryWalkControl  ;increment value to stay in this routine
008302  1  A5 35        ExitVWalk:   lda VictoryWalkControl  ;load value set here
008304  1  F0 68                     beq IncModeTask_A       ;if zero, branch to change modes
008306  1  60                        rts                     ;otherwise leave
008307  1               
008307  1               ;-------------------------------------------------------------------------------------
008307  1               
008307  1               PrintVictoryMessages:
008307  1  AD 49 07                    lda SecondaryMsgCounter   ;load secondary message counter
00830A  1  D0 48                       bne IncMsgCounter         ;if set, branch to increment message counters
00830C  1  AD 19 07                    lda PrimaryMsgCounter     ;otherwise load primary message counter
00830F  1  F0 18                       beq ThankPlayer           ;if set to zero, branch to print first message
008311  1  C9 09                       cmp #$09                  ;if at 9 or above, branch elsewhere (this comparison
008313  1  B0 3F                       bcs IncMsgCounter         ;is residual code, counter never reaches 9)
008315  1  AC 5F 07                    ldy WorldNumber           ;check world number
008318  1  C0 07                       cpy #World8
00831A  1  D0 09                       bne MRetainerMsg          ;if not at world 8, skip to next part
00831C  1  C9 03                       cmp #$03                  ;check primary message counter again
00831E  1  90 34                       bcc IncMsgCounter         ;if not at 3 yet (world 8 only), branch to increment
008320  1  E9 01                       sbc #$01                  ;otherwise subtract one
008322  1  4C 29 83                    jmp ThankPlayer           ;and skip to next part
008325  1  C9 02        MRetainerMsg:  cmp #$02                  ;check primary message counter
008327  1  90 2B                       bcc IncMsgCounter         ;if not at 2 yet (world 1-7 only), branch
008329  1  A8           ThankPlayer:   tay                       ;put primary message counter into Y
00832A  1  D0 08                       bne SecondPartMsg         ;if counter nonzero, skip this part, do not print first message
00832C  1  AD 53 07                    lda CurrentPlayer         ;otherwise get player currently on the screen
00832F  1  F0 14                       beq EvalForMusic          ;if mario, branch
008331  1  C8                          iny                       ;otherwise increment Y once for luigi and
008332  1  D0 11                       bne EvalForMusic          ;do an unconditional branch to the same place
008334  1  C8           SecondPartMsg: iny                       ;increment Y to do world 8's message
008335  1  AD 5F 07                    lda WorldNumber
008338  1  C9 07                       cmp #World8               ;check world number
00833A  1  F0 09                       beq EvalForMusic          ;if at world 8, branch to next part
00833C  1  88                          dey                       ;otherwise decrement Y for world 1-7's message
00833D  1  C0 04                       cpy #$04                  ;if counter at 4 (world 1-7 only)
00833F  1  B0 26                       bcs SetEndTimer           ;branch to set victory end timer
008341  1  C0 03                       cpy #$03                  ;if counter at 3 (world 1-7 only)
008343  1  B0 0F                       bcs IncMsgCounter         ;branch to keep counting
008345  1  C0 03        EvalForMusic:  cpy #$03                  ;if counter not yet at 3 (world 8 only), branch
008347  1  D0 04                       bne PrintMsg              ;to print message only (note world 1-7 will only
008349  1  A9 04                       lda #VictoryMusic         ;reach this code if counter = 0, and will always branch)
00834B  1  85 FC                       sta EventMusicQueue       ;otherwise load victory music first (world 8 only)
00834D  1  98           PrintMsg:      tya                       ;put primary message counter in A
00834E  1  18                          clc                       ;add $0c or 12 to counter thus giving an appropriate value,
00834F  1  69 0C                       adc #$0c                  ;($0c-$0d = first), ($0e = world 1-7's), ($0f-$12 = world 8's)
008351  1  8D 73 07                    sta VRAM_Buffer_AddrCtrl  ;write message counter to vram address controller
008354  1  AD 49 07     IncMsgCounter: lda SecondaryMsgCounter
008357  1  18                          clc
008358  1  69 04                       adc #$04                      ;add four to secondary message counter
00835A  1  8D 49 07                    sta SecondaryMsgCounter
00835D  1  AD 19 07                    lda PrimaryMsgCounter
008360  1  69 00                       adc #$00                      ;add carry to primary message counter
008362  1  8D 19 07                    sta PrimaryMsgCounter
008365  1  C9 07                       cmp #$07                      ;check primary counter one more time
008367  1  90 08        SetEndTimer:   bcc ExitMsgs                  ;if not reached value yet, branch to leave
008369  1  A9 06                       lda #$06
00836B  1  8D A1 07                    sta WorldEndTimer             ;otherwise set world end timer
00836E  1  EE 72 07     IncModeTask_A: inc OperMode_Task             ;move onto next task in mode
008371  1  60           ExitMsgs:      rts                           ;leave
008372  1               
008372  1               ;-------------------------------------------------------------------------------------
008372  1               
008372  1               PlayerEndWorld:
008372  1  AD A1 07                    lda WorldEndTimer          ;check to see if world end timer expired
008375  1  D0 20                       bne EndExitOne             ;branch to leave if not
008377  1  AC 5F 07                    ldy WorldNumber            ;check world number
00837A  1  C0 07                       cpy #World8                ;if on world 8, player is done with game,
00837C  1  B0 1A                       bcs EndChkBButton          ;thus branch to read controller
00837E  1  A9 00                       lda #$00
008380  1  8D 60 07                    sta AreaNumber             ;otherwise initialize area number used as offset
008383  1  8D 5C 07                    sta LevelNumber            ;and level number control to start at area 1
008386  1  8D 72 07                    sta OperMode_Task          ;initialize secondary mode of operation
008389  1  EE 5F 07                    inc WorldNumber            ;increment world number to move onto the next world
00838C  1  20 CE BB                    jsr LoadAreaPointer        ;get area address offset for the next area
00838F  1  EE 57 07                    inc FetchNewGameTimerFlag  ;set flag to load game timer from header
008392  1  A9 01                       lda #GameModeValue
008394  1  8D 70 07                    sta OperMode               ;set mode of operation to game mode
008397  1  60           EndExitOne:    rts                        ;and leave
008398  1  AD FC 06     EndChkBButton: lda SavedJoypad1Bits
00839B  1  0D FD 06                    ora SavedJoypad2Bits       ;check to see if B button was pressed on
00839E  1  29 40                       and #B_Button              ;either controller
0083A0  1  F0 08                       beq EndExitTwo             ;branch to leave if not
0083A2  1  A9 01                       lda #$01                   ;otherwise set world selection flag
0083A4  1  8D FC 07                    sta WorldSelectEnableFlag
0083A7  1  20 30 8D                    jsr TerminateGame          ;do sub to continue other player or end game
0083AA  1  60           EndExitTwo:    rts                        ;leave
0083AB  1               
0083AB  1               ;-------------------------------------------------------------------------------------
0083AB  1               
0083AB  1               ;data is used as tiles for numbers
0083AB  1               ;that appear when you defeat enemies
0083AB  1               FloateyNumTileData:
0083AB  1  FF FF              .byte $ff, $ff ;dummy
0083AD  1  F6 FB              .byte $f6, $fb ; "100"
0083AF  1  F7 FB              .byte $f7, $fb ; "200"
0083B1  1  F8 FB              .byte $f8, $fb ; "400"
0083B3  1  F9 FB              .byte $f9, $fb ; "500"
0083B5  1  FA FB              .byte $fa, $fb ; "800"
0083B7  1  F6 50              .byte $f6, $50 ; "1000"
0083B9  1  F7 50              .byte $f7, $50 ; "2000"
0083BB  1  F8 50              .byte $f8, $50 ; "4000"
0083BD  1  F9 50              .byte $f9, $50 ; "5000"
0083BF  1  FA 50              .byte $fa, $50 ; "8000"
0083C1  1  FD FE              .byte $fd, $fe ; "1-UP"
0083C3  1               
0083C3  1               ;high nybble is digit number, low nybble is number to
0083C3  1               ;add to the digit of the player's score
0083C3  1               ScoreUpdateData:
0083C3  1  FF                 .byte $ff ;dummy
0083C4  1  41 42 44 45        .byte $41, $42, $44, $45, $48
0083C8  1  48           
0083C9  1  31 32 34 35        .byte $31, $32, $34, $35, $38, $00
0083CD  1  38 00        
0083CF  1               
0083CF  1               FloateyNumbersRoutine:
0083CF  1  BD 10 01                   lda FloateyNum_Control,x     ;load control for floatey number
0083D2  1  F0 C3                      beq EndExitOne               ;if zero, branch to leave
0083D4  1  C9 0B                      cmp #$0b                     ;if less than $0b, branch
0083D6  1  90 05                      bcc ChkNumTimer
0083D8  1  A9 0B                      lda #$0b                     ;otherwise set to $0b, thus keeping
0083DA  1  9D 10 01                   sta FloateyNum_Control,x     ;it in range
0083DD  1  A8           ChkNumTimer:  tay                          ;use as Y
0083DE  1  BD 2C 01                   lda FloateyNum_Timer,x       ;check value here
0083E1  1  D0 04                      bne DecNumTimer              ;if nonzero, branch ahead
0083E3  1  9D 10 01                   sta FloateyNum_Control,x     ;initialize floatey number control and leave
0083E6  1  60                         rts
0083E7  1  DE 2C 01     DecNumTimer:  dec FloateyNum_Timer,x       ;decrement value here
0083EA  1  C9 2B                      cmp #$2b                     ;if not reached a certain point, branch
0083EC  1  D0 17                      bne ChkTallEnemy
0083EE  1  C0 0B                      cpy #$0b                     ;check offset for $0b
0083F0  1  D0 00                      bne LoadNumTiles             ;branch ahead if not found
0083F2  1  B9 C3 83     LoadNumTiles: lda ScoreUpdateData,y        ;load point value here
0083F5  1  4A                         lsr                          ;move high nybble to low
0083F6  1  4A                         lsr
0083F7  1  4A                         lsr
0083F8  1  4A                         lsr
0083F9  1  AA                         tax                          ;use as X offset, essentially the digit
0083FA  1  B9 C3 83                   lda ScoreUpdateData,y        ;load again and this time
0083FD  1  29 0F                      and #%00001111               ;mask out the high nybble
0083FF  1  9D 34 01                   sta DigitModifier,x          ;store as amount to add to the digit
008402  1  20 11 B4                   jsr AddToScore           ;update the score accordingly
008405  1  BC E5 06     ChkTallEnemy: ldy Enemy_SprDataOffset,x    ;get OAM data offset for enemy object
008408  1  B5 16                      lda Enemy_ID,x               ;get enemy object identifier
00840A  1  C9 12                      cmp #Spiny
00840C  1  F0 22                      beq FloateyPart              ;branch if spiny
00840E  1  C9 0D                      cmp #PiranhaPlant
008410  1  F0 1E                      beq FloateyPart              ;branch if piranha plant
008412  1  C9 05                      cmp #HammerBro
008414  1  F0 12                      beq GetAltOffset             ;branch elsewhere if hammer bro
008416  1  C9 0A                      cmp #GreyCheepCheep
008418  1  F0 16                      beq FloateyPart              ;branch if cheep-cheep of either color
00841A  1  C9 0B                      cmp #RedCheepCheep
00841C  1  F0 12                      beq FloateyPart
00841E  1  C9 09                      cmp #TallEnemy
008420  1  B0 06                      bcs GetAltOffset             ;branch elsewhere if enemy object => $09
008422  1  B5 1E                      lda Enemy_State,x
008424  1  C9 02                      cmp #$02                     ;if enemy state defeated or otherwise
008426  1  B0 08                      bcs FloateyPart              ;$02 or greater, branch beyond this part
008428  1  AE EE 03     GetAltOffset: ldx SprDataOffset_Ctrl       ;load some kind of control bit
00842B  1  BC EC 06                   ldy Alt_SprDataOffset,x      ;get alternate OAM data offset
00842E  1  A6 08                      ldx ObjectOffset             ;get enemy object offset again
008430  1  BD 1E 01     FloateyPart:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate for
008433  1  C9 18                      cmp #$18                     ;floatey number, if coordinate in the
008435  1  90 05                      bcc SetupNumSpr              ;status bar, branch
008437  1  E9 01                      sbc #$01
008439  1  9D 1E 01                   sta FloateyNum_Y_Pos,x       ;otherwise subtract one and store as new
00843C  1  BD 1E 01     SetupNumSpr:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate
00843F  1  E9 08                      sbc #$08                     ;subtract eight and dump into the
008441  1  20 79 E0                   jsr DumpTwoSpr               ;left and right sprite's Y coordinates
008444  1  BD 17 01                   lda FloateyNum_X_Pos,x       ;get horizontal coordinate
008447  1  99 03 02                   sta Sprite_X_Position,y      ;store into X coordinate of left sprite
00844A  1  18                         clc
00844B  1  69 08                      adc #$08                     ;add eight pixels and store into X
00844D  1  99 07 02                   sta Sprite_X_Position+4,y    ;coordinate of right sprite
008450  1  A9 02                      lda #$02
008452  1  99 02 02                   sta Sprite_Attributes,y      ;set palette control in attribute bytes
008455  1  99 06 02                   sta Sprite_Attributes+4,y    ;of left and right sprites
008458  1  BD 10 01                   lda FloateyNum_Control,x
00845B  1  0A                         asl                          ;multiply our floatey number control by 2
00845C  1  AA                         tax                          ;and use as offset for look-up table
00845D  1  BD AB 83                   lda FloateyNumTileData,x
008460  1  99 01 02                   sta Sprite_Tilenumber,y      ;display first half of number of points
008463  1  BD AC 83                   lda FloateyNumTileData+1,x
008466  1  99 05 02                   sta Sprite_Tilenumber+4,y    ;display the second half
008469  1  A6 08                      ldx ObjectOffset             ;get enemy object offset and leave
00846B  1  60                         rts
00846C  1               
00846C  1               ;-------------------------------------------------------------------------------------
00846C  1               
00846C  1               ScreenRoutines:
00846C  1  AD 3C 07           lda ScreenRoutineTask        ;run one of the following subroutines
00846F  1  20 A8 BA           jsr JumpEngine
008472  1               
008472  1  90 84              .word InitScreen
008474  1  A3 84              .word SetupIntermediate
008476  1  E3 84              .word WriteTopStatusLine
008478  1  05 85              .word WriteBottomStatusLine
00847A  1  21 85              .word DisplayTimeUp
00847C  1  65 86              .word ResetSpritesAndScreenTimer
00847E  1  36 85              .word DisplayIntermediate
008480  1  65 86              .word ResetSpritesAndScreenTimer
008482  1  77 85              .word AreaParserTaskControl
008484  1  BC ED              .word GetAreaPalette
008486  1  E0 ED              .word GetBackgroundColor
008488  1  40 EE              .word GetAlternatePalette1
00848A  1  90 85              .word DrawTitleScreen
00848C  1  C3 85              .word ClearBuffersDrawIcon
00848E  1  DA 85              .word WriteTopScore
008490  1               
008490  1               ;-------------------------------------------------------------------------------------
008490  1               
008490  1               InitScreen:
008490  1  20 BD BB           jsr MoveAllSpritesOffscreen ;initialize all sprites including sprite #0
008493  1  20 44 BB           jsr InitializeNameTables    ;and erase both name and attribute tables
008496  1  AD 70 07           lda OperMode
008499  1  F0 05              beq NextSubtask             ;if mode still 0, do not load
00849B  1  A2 03              ldx #$03                    ;into buffer pointer
00849D  1  4C C2 ED           jmp SetVRAMAddr_A
0084A0  1               NextSubtask:
0084A0  1  4C 4C EE           jmp IncSubtask           ;move onto next task
0084A3  1               
0084A3  1               ;-------------------------------------------------------------------------------------
0084A3  1               
0084A3  1               SetupIntermediate:
0084A3  1  AD 44 07           lda BackgroundColorCtrl  ;save current background color control
0084A6  1  48                 pha                      ;and player status to stack
0084A7  1  AD 56 07           lda PlayerStatus
0084AA  1  48                 pha
0084AB  1  A9 00              lda #$00                 ;set background color to black
0084AD  1  8D 56 07           sta PlayerStatus         ;and player status to not fiery
0084B0  1  A9 02              lda #$02                 ;this is the ONLY time background color control
0084B2  1  8D 44 07           sta BackgroundColorCtrl  ;is set to less than 4
0084B5  1  20 EE ED           jsr GetPlayerColors
0084B8  1  68                 pla                      ;we only execute this routine for
0084B9  1  8D 56 07           sta PlayerStatus         ;the intermediate lives display
0084BC  1  68                 pla                      ;and once we're done, we return bg
0084BD  1  8D 44 07           sta BackgroundColorCtrl  ;color ctrl and player status from stack
0084C0  1  4C 4C EE           jmp IncSubtask           ;then move onto the next task
0084C3  1               
0084C3  1               ;-------------------------------------------------------------------------------------
0084C3  1               WriteFpgErrorWantInput:
0084C3  1  A9 20              lda #$20
0084C5  1  A2 47              ldx #$47
0084C7  1  AC D9 07           ldy FpgErrorParam
0084CA  1  4C 86 A8           jmp DrawInputButtons
0084CD  1               
0084CD  1               WriteFpgError:
0084CD  1  AE D8 07           ldx FpgError
0084D0  1  E0 03              cpx #$03
0084D2  1  D0 03              bne WTFWTFWTF
0084D4  1  20 C3 84           jsr WriteFpgErrorWantInput
0084D7  1               WTFWTFWTF:
0084D7  1  AE D8 07           ldx FpgError
0084DA  1  E8                 inx
0084DB  1  BD 3F 86           lda GameTextOffsets, x
0084DE  1  AA                 tax
0084DF  1  20 45 86           jsr DrawTilesFF
0084E2  1  60                 rts
0084E3  1               
0084E3  1               WriteTopStatusLine:
0084E3  1  20 CD 84           jsr WriteFpgError
0084E6  1  A2 00              ldx #$00          ; Sprite0 Crap
0084E8  1  20 45 86           jsr DrawTilesFF
0084EB  1  4C 4C EE           jmp IncSubtask    ;onto the next task
0084EE  1               
0084EE  1               ;-------------------------------------------------------------------------------------
0084EE  1               
0084EE  1               InputText:
0084EE  1  20 61 0A 12    .byte $20, $61, $0A, $12, $17, $19, $1e, $1d, $24, $28, $28, $28, $28 ; INPUT
0084F2  1  17 19 1E 1D  
0084F6  1  24 28 28 28  
0084FB  1  20 6D 06 21    .byte $20, $6D, $06, $21, $1c, $19, $0e, $0e, $0d  ; X-Speed
0084FF  1  1C 19 0E 0E  
008503  1  0D           
008504  1  00             .byte $00
008505  1               
008505  1               WriteBottomStatusLine:
008505  1  A2 00            ldx #0
008507  1  AC 00 03         ldy VRAM_Buffer1_Offset
00850A  1               
00850A  1               Rollerscates:
00850A  1  BD EE 84         lda InputText, x
00850D  1  99 01 03         sta VRAM_Buffer1, y
008510  1  F0 04            beq InputTextCopied
008512  1  E8               inx
008513  1  C8               iny
008514  1  D0 F4            bne Rollerscates;
008516  1               InputTextCopied:
008516  1  98               tya
008517  1  18               clc
008518  1  6D 00 03         adc VRAM_Buffer1_Offset
00851B  1  8D 00 03         sta VRAM_Buffer1_Offset
00851E  1  4C 4C EE         jmp IncSubtask
008521  1               
008521  1               ;-------------------------------------------------------------------------------------
008521  1               
008521  1               DisplayTimeUp:
008521  1  AD 59 07               lda GameTimerExpiredFlag  ;if game timer not expired, increment task
008524  1  F0 0A                  beq NoTimeUp              ;control 2 tasks forward, otherwise, stay here
008526  1  A9 00                  lda #$00
008528  1  8D 59 07               sta GameTimerExpiredFlag  ;reset timer expiration flag
00852B  1  A9 02                  lda #$02                  ;output time-up screen to buffer
00852D  1  4C 58 85               jmp OutputInter
008530  1  EE 3C 07     NoTimeUp: inc ScreenRoutineTask     ;increment control task 2 tasks forward
008533  1  4C 4C EE               jmp IncSubtask
008536  1               
008536  1               ;-------------------------------------------------------------------------------------
008536  1               
008536  1               DisplayIntermediate:
008536  1  4C 71 85                    jmp NoInter
008539  1  AD 70 07                    lda OperMode                 ;check primary mode of operation
00853C  1  F0 33                       beq NoInter                  ;if in title screen mode, skip this
00853E  1  C9 03                       cmp #GameOverModeValue       ;are we in game over mode?
008540  1  F0 22                       beq GameOverInter            ;if so, proceed to display game over screen
008542  1  AD 52 07                    lda AltEntranceControl       ;otherwise check for mode of alternate entry
008545  1  D0 2A                       bne NoInter                  ;and branch if found
008547  1  AC 4E 07                    ldy AreaType                 ;check if we are on castle level
00854A  1  C0 03                       cpy #$03                     ;and if so, branch (possibly residual)
00854C  1  F0 05                       beq PlayerInter
00854E  1  AD 69 07                    lda DisableIntermediate      ;if this flag is set, skip intermediate lives display
008551  1  D0 1E                       bne NoInter                  ;and jump to specific task, otherwise
008553  1  20 DC B8     PlayerInter:   jsr DrawPlayer_Intermediate  ;put player in appropriate place for
008556  1  A9 01                       lda #$01                     ;lives display, then output lives display to buffer
008558  1  20 64 86     OutputInter:   jsr WriteGameText
00855B  1  20 6D 86                    jsr ResetScreenTimer
00855E  1  A9 00                       lda #$00
008560  1  8D 74 07                    sta DisableScreenFlag        ;reenable screen output
008563  1  60                          rts
008564  1  A9 12        GameOverInter: lda #$12                     ;set screen timer
008566  1  8D A0 07                    sta ScreenTimer
008569  1  A9 03                       lda #$03                     ;output game over screen to buffer
00856B  1  20 64 86                    jsr WriteGameText
00856E  1  4C DA 85                    jmp IncModeTask_B
008571  1  A9 08        NoInter:       lda #$08                     ;set for specific task and leave
008573  1  8D 3C 07                    sta ScreenRoutineTask
008576  1  60                          rts
008577  1               
008577  1               ;-------------------------------------------------------------------------------------
008577  1               
008577  1               AreaParserTaskControl:
008577  1  EE 74 07                inc DisableScreenFlag     ;turn off screen
00857A  1  20 58 8D     TaskLoop:  jsr AreaParserTaskHandler ;render column set of current area
00857D  1  AD 1F 07                lda AreaParserTaskNum     ;check number of tasks
008580  1  D0 F8                   bne TaskLoop              ;if tasks still not all done, do another one
008582  1  CE 1E 07                dec ColumnSets            ;do we need to render more column sets?
008585  1  10 03                   bpl OutputCol
008587  1  EE 3C 07                inc ScreenRoutineTask     ;if not, move on to the next task
00858A  1  A9 06        OutputCol: lda #$06                  ;set vram buffer to output rendered column set
00858C  1  8D 73 07                sta VRAM_Buffer_AddrCtrl  ;on next NMI
00858F  1  60                      rts
008590  1               
008590  1               ;-------------------------------------------------------------------------------------
008590  1               
008590  1               ;$00 - vram buffer address table low
008590  1               ;$01 - vram buffer address table high
008590  1               
008590  1               DrawTitleScreen:
008590  1  AD 70 07                 lda OperMode                 ;are we in title screen mode?
008593  1  D0 45                    bne IncModeTask_B            ;if not, exit
008595  1  A9 1E                    lda #>TitleScreenDataOffset  ;load address $1ec0 into
008597  1  8D 06 20                 sta PPU_ADDRESS              ;the vram address register
00859A  1  A9 C0                    lda #<TitleScreenDataOffset
00859C  1  8D 06 20                 sta PPU_ADDRESS
00859F  1  A9 03                    lda #$03                     ;put address $0300 into
0085A1  1  85 01                    sta $01                      ;the indirect at $00
0085A3  1  A0 00                    ldy #$00
0085A5  1  84 00                    sty $00
0085A7  1  AD 07 20                 lda PPU_DATA                 ;do one garbage read
0085AA  1  AD 07 20     OutputTScr: lda PPU_DATA                 ;get title screen from chr-rom
0085AD  1  91 00                    sta ($00),y                  ;store 256 bytes into buffer
0085AF  1  C8                       iny
0085B0  1  D0 02                    bne ChkHiByte                ;if not past 256 bytes, do not increment
0085B2  1  E6 01                    inc $01                      ;otherwise increment high byte of indirect
0085B4  1  A5 01        ChkHiByte:  lda $01                      ;check high byte?
0085B6  1  C9 04                    cmp #$04                     ;at $0400?
0085B8  1  D0 F0                    bne OutputTScr               ;if not, loop back and do another
0085BA  1  C0 3A                    cpy #$3a                     ;check if offset points past end of data
0085BC  1  90 EC                    bcc OutputTScr               ;if not, loop back and do another
0085BE  1  A9 05                    lda #$05                     ;set buffer transfer control to $0300,
0085C0  1  4C 49 EE                 jmp SetVRAMAddr_B            ;increment task and exit
0085C3  1               
0085C3  1               ;-------------------------------------------------------------------------------------
0085C3  1               
0085C3  1               ClearBuffersDrawIcon:
0085C3  1  AD 70 07                  lda OperMode               ;check game mode
0085C6  1  D0 12                     bne IncModeTask_B          ;if not title screen mode, leave
0085C8  1  A2 00                     ldx #$00                   ;otherwise, clear buffer space
0085CA  1  9D 00 03     TScrClear:   sta VRAM_Buffer1-1,x
0085CD  1  9D 00 04                  sta VRAM_Buffer1-1+$100,x
0085D0  1  CA                        dex
0085D1  1  D0 F7                     bne TScrClear
0085D3  1  20 81 82                  jsr DrawMushroomIcon       ;draw player select icon
0085D6  1  EE 3C 07                  inc ScreenRoutineTask      ;move onto next task
0085D9  1  60                        rts
0085DA  1               
0085DA  1               ;-------------------------------------------------------------------------------------
0085DA  1               
0085DA  1               WriteTopScore:
0085DA  1  EE 72 07     IncModeTask_B: inc OperMode_Task  ;move onto next mode
0085DD  1  60                          rts
0085DE  1               
0085DE  1               ;-------------------------------------------------------------------------------------
0085DE  1               
0085DE  1               GameText:
0085DE  1               TopStatusBarLine:
0085DE  1  20 68 05 24    .byte $20, $68, $05, $24, $24, $24, $2e, $24 ; score trailing digit and coin display
0085E2  1  24 24 2E 24  
0085E6  1  23 C0 7F AA    .byte $23, $c0, $7f, $aa ; attribute table data, clears name table 0 to palette 2
0085EA  1                 ; .byte $23, $c2, $01, $ea ; attribute table data, used for coin icon in status bar
0085EA  1  FF             .byte $ff ; end of data block
0085EB  1               FpgDefault:
0085EB  1  20 41 0A 10    .byte $20, $41, $0a, $10, $18, $18, $0d, $24, $15, $1e, $0c, $14, $2b, $ff
0085EF  1  18 18 0D 24  
0085F3  1  15 1E 0C 14  
0085F9  1               FpgBadXPosition:
0085F9  1  20 41 0E 0B    .byte $20, $41, $0e, $0b, $0a, $0d, $24, $21, $24, $19, $18, $1c, $12, $1d, $12, $18, $17, $ff
0085FD  1  0A 0D 24 21  
008601  1  24 19 18 1C  
00860B  1               FpgBadYPosition:
00860B  1  20 41 0E 0B    .byte $20, $41, $0e, $0b, $0a, $0d, $24, $22, $24, $19, $18, $1c, $12, $1d, $12, $18, $17, $ff
00860F  1  0A 0D 24 22  
008613  1  24 19 18 1C  
00861D  1               FpgWant:
00861D  1  20 41 06 24    .byte $20, $41, $06, $24, $20, $0a, $17, $1d, $24, $ff
008621  1  20 0A 17 1D  
008625  1  24 FF        
008627  1               FpgWin:
008627  1  20 41 14 22    .byte $20, $41, $14, $22, $18, $1e, $24, $0a, $1b, $0e, $24, $1c, $1e, $19, $0e, $1b, $24, $19, $15, $0a, $22, $0e, $1b, $ff
00862B  1  18 1E 24 0A  
00862F  1  1B 0E 24 1C  
00863F  1               
00863F  1               
00863F  1               GameTextOffsets:
00863F  1  00             .byte TopStatusBarLine - GameText
008640  1  0D             .byte FpgDefault - GameText   ; 0
008641  1  1B             .byte FpgBadXPosition - GameText ; 1
008642  1  2D             .byte FpgBadYPosition - GameText ; 2
008643  1  3F             .byte FpgWant - GameText ; 3
008644  1  49             .byte FpgWin - GameText     ; 4
008645  1               
008645  1               DrawTilesFF:
008645  1  AC 00 03         ldy VRAM_Buffer1_Offset
008648  1               GameTextLoop:
008648  1  BD DE 85         lda GameText, x
00864B  1  C9 FF            cmp #$ff
00864D  1  F0 07            beq EndGameText
00864F  1  99 01 03         sta VRAM_Buffer1, y
008652  1  E8               inx
008653  1  C8               iny
008654  1  D0 F2            bne GameTextLoop         ;do this for 256 bytes if no terminator found
008656  1               EndGameText:
008656  1  A9 00            lda #$00
008658  1  99 01 03         sta VRAM_Buffer1, y
00865B  1  98               tya
00865C  1  18               clc
00865D  1  6D 00 03         adc VRAM_Buffer1_Offset
008660  1  8D 00 03         sta VRAM_Buffer1_Offset
008663  1  60               rts
008664  1               
008664  1               WriteGameText:
008664  1  60               rts
008665  1               
008665  1               ;-------------------------------------------------------------------------------------
008665  1               
008665  1               ResetSpritesAndScreenTimer:
008665  1  AD A0 07              lda ScreenTimer             ;check if screen timer has expired
008668  1  D0 0B                 bne NoReset                 ;if not, branch to leave
00866A  1  20 BD BB              jsr MoveAllSpritesOffscreen ;otherwise reset sprites now
00866D  1               
00866D  1               ResetScreenTimer:
00866D  1  A9 07                 lda #$07                    ;reset timer again
00866F  1  8D A0 07              sta ScreenTimer
008672  1  EE 3C 07              inc ScreenRoutineTask       ;move onto next task
008675  1  60           NoReset: rts
008676  1               
008676  1               ;-------------------------------------------------------------------------------------
008676  1               ;$00 - temp vram buffer offset
008676  1               ;$01 - temp metatile buffer offset
008676  1               ;$02 - temp metatile graphics table offset
008676  1               ;$03 - used to store attribute bits
008676  1               ;$04 - used to determine attribute table row
008676  1               ;$05 - used to determine attribute table column
008676  1               ;$06 - metatile graphics table address low
008676  1               ;$07 - metatile graphics table address high
008676  1               
008676  1               RenderAreaGraphics:
008676  1  AD 26 07                 lda CurrentColumnPos         ;store LSB of where we're at
008679  1  29 01                    and #$01
00867B  1  85 05                    sta $05
00867D  1  AC 40 03                 ldy VRAM_Buffer2_Offset      ;store vram buffer offset
008680  1  84 00                    sty $00
008682  1  AD 21 07                 lda CurrentNTAddr_Low        ;get current name table address we're supposed to render
008685  1  99 42 03                 sta VRAM_Buffer2+1,y
008688  1  AD 20 07                 lda CurrentNTAddr_High
00868B  1  99 41 03                 sta VRAM_Buffer2,y
00868E  1  A9 9A                    lda #$9a                     ;store length byte of 26 here with d7 set
008690  1  99 43 03                 sta VRAM_Buffer2+2,y         ;to increment by 32 (in columns)
008693  1  A9 00                    lda #$00                     ;init attribute row
008695  1  85 04                    sta $04
008697  1  AA                       tax
008698  1  86 01        DrawMTLoop: stx $01                      ;store init value of 0 or incremented offset for buffer
00869A  1  BD A1 06                 lda MetatileBuffer,x         ;get first metatile number, and mask out all but 2 MSB
00869D  1  29 C0                    and #%11000000
00869F  1  85 03                    sta $03                      ;store attribute table bits here
0086A1  1  0A                       asl                          ;note that metatile format is:
0086A2  1  2A                       rol                          ;%xx000000 - attribute table bits,
0086A3  1  2A                       rol                          ;%00xxxxxx - metatile number
0086A4  1  A8                       tay                          ;rotate bits to d1-d0 and use as offset here
0086A5  1  B9 01 88                 lda MetatileGraphics_Low,y   ;get address to graphics table from here
0086A8  1  85 06                    sta $06
0086AA  1  B9 05 88                 lda MetatileGraphics_High,y
0086AD  1  85 07                    sta $07
0086AF  1  BD A1 06                 lda MetatileBuffer,x         ;get metatile number again
0086B2  1  0A                       asl                          ;multiply by 4 and use as tile offset
0086B3  1  0A                       asl
0086B4  1  85 02                    sta $02
0086B6  1  AD 1F 07                 lda AreaParserTaskNum        ;get current task number for level processing and
0086B9  1  29 01                    and #%00000001               ;mask out all but LSB, then invert LSB, multiply by 2
0086BB  1  49 01                    eor #%00000001               ;to get the correct column position in the metatile,
0086BD  1  0A                       asl                          ;then add to the tile offset so we can draw either side
0086BE  1  65 02                    adc $02                      ;of the metatiles
0086C0  1  A8                       tay
0086C1  1  A6 00                    ldx $00                      ;use vram buffer offset from before as X
0086C3  1  B1 06                    lda ($06),y
0086C5  1  9D 44 03                 sta VRAM_Buffer2+3,x         ;get first tile number (top left or top right) and store
0086C8  1  C8                       iny
0086C9  1  B1 06                    lda ($06),y                  ;now get the second (bottom left or bottom right) and store
0086CB  1  9D 45 03                 sta VRAM_Buffer2+4,x
0086CE  1  A4 04                    ldy $04                      ;get current attribute row
0086D0  1  A5 05                    lda $05                      ;get LSB of current column where we're at, and
0086D2  1  D0 0E                    bne RightCheck               ;branch if set (clear = left attrib, set = right)
0086D4  1  A5 01                    lda $01                      ;get current row we're rendering
0086D6  1  4A                       lsr                          ;branch if LSB set (clear = top left, set = bottom left)
0086D7  1  B0 19                    bcs LLeft
0086D9  1  26 03                    rol $03                      ;rotate attribute bits 3 to the left
0086DB  1  26 03                    rol $03                      ;thus in d1-d0, for upper left square
0086DD  1  26 03                    rol $03
0086DF  1  4C F8 86                 jmp SetAttrib
0086E2  1  A5 01        RightCheck: lda $01                      ;get LSB of current row we're rendering
0086E4  1  4A                       lsr                          ;branch if set (clear = top right, set = bottom right)
0086E5  1  B0 0F                    bcs NextMTRow
0086E7  1  46 03                    lsr $03                      ;shift attribute bits 4 to the right
0086E9  1  46 03                    lsr $03                      ;thus in d3-d2, for upper right square
0086EB  1  46 03                    lsr $03
0086ED  1  46 03                    lsr $03
0086EF  1  4C F8 86                 jmp SetAttrib
0086F2  1  46 03        LLeft:      lsr $03                      ;shift attribute bits 2 to the right
0086F4  1  46 03                    lsr $03                      ;thus in d5-d4 for lower left square
0086F6  1  E6 04        NextMTRow:  inc $04                      ;move onto next attribute row
0086F8  1  B9 F9 03     SetAttrib:  lda AttributeBuffer,y        ;get previously saved bits from before
0086FB  1  05 03                    ora $03                      ;if any, and put new bits, if any, onto
0086FD  1  99 F9 03                 sta AttributeBuffer,y        ;the old, and store
008700  1  E6 00                    inc $00                      ;increment vram buffer offset by 2
008702  1  E6 00                    inc $00
008704  1  A6 01                    ldx $01                      ;get current gfx buffer row, and check for
008706  1  E8                       inx                          ;the bottom of the screen
008707  1  E0 0D                    cpx #$0d
008709  1  90 8D                    bcc DrawMTLoop               ;if not there yet, loop back
00870B  1  A4 00                    ldy $00                      ;get current vram buffer offset, increment by 3
00870D  1  C8                       iny                          ;(for name table address and length bytes)
00870E  1  C8                       iny
00870F  1  C8                       iny
008710  1  A9 00                    lda #$00
008712  1  99 41 03                 sta VRAM_Buffer2,y           ;put null terminator at end of data for name table
008715  1  8C 40 03                 sty VRAM_Buffer2_Offset      ;store new buffer offset
008718  1  EE 21 07                 inc CurrentNTAddr_Low        ;increment name table address low
00871B  1  AD 21 07                 lda CurrentNTAddr_Low        ;check current low byte
00871E  1  29 1F                    and #%00011111               ;if no wraparound, just skip this part
008720  1  D0 0D                    bne ExitDrawM
008722  1  A9 80                    lda #$80                     ;if wraparound occurs, make sure low byte stays
008724  1  8D 21 07                 sta CurrentNTAddr_Low        ;just under the status bar
008727  1  AD 20 07                 lda CurrentNTAddr_High       ;and then invert d2 of the name table address high
00872A  1  49 04                    eor #%00000100               ;to move onto the next appropriate name table
00872C  1  8D 20 07                 sta CurrentNTAddr_High
00872F  1  4C 85 87     ExitDrawM:  jmp SetVRAMCtrl              ;jump to set buffer to $0341 and leave
008732  1               
008732  1               ;-------------------------------------------------------------------------------------
008732  1               ;$00 - temp attribute table address high (big endian order this time!)
008732  1               ;$01 - temp attribute table address low
008732  1               
008732  1               RenderAttributeTables:
008732  1  AD 21 07                  lda CurrentNTAddr_Low    ;get low byte of next name table address
008735  1  29 1F                     and #%00011111           ;to be written to, mask out all but 5 LSB,
008737  1  38                        sec                      ;subtract four
008738  1  E9 04                     sbc #$04
00873A  1  29 1F                     and #%00011111           ;mask out bits again and store
00873C  1  85 01                     sta $01
00873E  1  AD 20 07                  lda CurrentNTAddr_High   ;get high byte and branch if borrow not set
008741  1  B0 02                     bcs SetATHigh
008743  1  49 04                     eor #%00000100           ;otherwise invert d2
008745  1  29 04        SetATHigh:   and #%00000100           ;mask out all other bits
008747  1  09 23                     ora #$23                 ;add $2300 to the high byte and store
008749  1  85 00                     sta $00
00874B  1  A5 01                     lda $01                  ;get low byte - 4, divide by 4, add offset for
00874D  1  4A                        lsr                      ;attribute table and store
00874E  1  4A                        lsr
00874F  1  69 C0                     adc #$c0                 ;we should now have the appropriate block of
008751  1  85 01                     sta $01                  ;attribute table in our temp address
008753  1  A2 00                     ldx #$00
008755  1  AC 40 03                  ldy VRAM_Buffer2_Offset  ;get buffer offset
008758  1  A5 00        AttribLoop:  lda $00
00875A  1  99 41 03                  sta VRAM_Buffer2,y       ;store high byte of attribute table address
00875D  1  A5 01                     lda $01
00875F  1  18                        clc                      ;get low byte, add 8 because we want to start
008760  1  69 08                     adc #$08                 ;below the status bar, and store
008762  1  99 42 03                  sta VRAM_Buffer2+1,y
008765  1  85 01                     sta $01                  ;also store in temp again
008767  1  BD F9 03                  lda AttributeBuffer,x    ;fetch current attribute table byte and store
00876A  1  99 44 03                  sta VRAM_Buffer2+3,y     ;in the buffer
00876D  1  A9 01                     lda #$01
00876F  1  99 43 03                  sta VRAM_Buffer2+2,y     ;store length of 1 in buffer
008772  1  4A                        lsr
008773  1  9D F9 03                  sta AttributeBuffer,x    ;clear current byte in attribute buffer
008776  1  C8                        iny                      ;increment buffer offset by 4 bytes
008777  1  C8                        iny
008778  1  C8                        iny
008779  1  C8                        iny
00877A  1  E8                        inx                      ;increment attribute offset and check to see
00877B  1  E0 07                     cpx #$07                 ;if we're at the end yet
00877D  1  90 D9                     bcc AttribLoop
00877F  1  99 41 03                  sta VRAM_Buffer2,y       ;put null terminator at the end
008782  1  8C 40 03                  sty VRAM_Buffer2_Offset  ;store offset in case we want to do any more
008785  1  A9 06        SetVRAMCtrl: lda #$06
008787  1  8D 73 07                  sta VRAM_Buffer_AddrCtrl ;set buffer to $0341 and leave
00878A  1  60                        rts
00878B  1               
00878B  1               ;-------------------------------------------------------------------------------------
00878B  1               
00878B  1               ;$00 - used as temporary counter in ColorRotation
00878B  1               
00878B  1               ColorRotatePalette:
00878B  1  27 27 27 17         .byte $27, $27, $27, $17, $07, $17
00878F  1  07 17        
008791  1               
008791  1               BlankPalette:
008791  1  3F 0C 04 FF         .byte $3f, $0c, $04, $ff, $ff, $ff, $ff, $00
008795  1  FF FF FF 00  
008799  1               
008799  1               ;used based on area type
008799  1               Palette3Data:
008799  1  0F 07 12 0F         .byte $0f, $07, $12, $0f
00879D  1  0F 07 17 0F         .byte $0f, $07, $17, $0f
0087A1  1  0F 07 17 1C         .byte $0f, $07, $17, $1c
0087A5  1  0F 07 17 00         .byte $0f, $07, $17, $00
0087A9  1               
0087A9  1               ColorRotation:
0087A9  1  A5 09                      lda FrameCounter         ;get frame counter
0087AB  1  29 07                      and #$07                 ;mask out all but three LSB
0087AD  1  D0 51                      bne ExitColorRot         ;branch if not set to zero to do this every eighth frame
0087AF  1  AE 00 03                   ldx VRAM_Buffer1_Offset  ;check vram buffer offset
0087B2  1  E0 31                      cpx #$31
0087B4  1  B0 4A                      bcs ExitColorRot         ;if offset over 48 bytes, branch to leave
0087B6  1  A8                         tay                      ;otherwise use frame counter's 3 LSB as offset here
0087B7  1  B9 91 87     GetBlankPal:  lda BlankPalette,y       ;get blank palette for palette 3
0087BA  1  9D 01 03                   sta VRAM_Buffer1,x       ;store it in the vram buffer
0087BD  1  E8                         inx                      ;increment offsets
0087BE  1  C8                         iny
0087BF  1  C0 08                      cpy #$08
0087C1  1  90 F4                      bcc GetBlankPal          ;do this until all bytes are copied
0087C3  1  AE 00 03                   ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
0087C6  1  A9 03                      lda #$03
0087C8  1  85 00                      sta $00                  ;set counter here
0087CA  1  AD 4E 07                   lda AreaType             ;get area type
0087CD  1  0A                         asl                      ;multiply by 4 to get proper offset
0087CE  1  0A                         asl
0087CF  1  A8                         tay                      ;save as offset here
0087D0  1  B9 99 87     GetAreaPal:   lda Palette3Data,y       ;fetch palette to be written based on area type
0087D3  1  9D 04 03                   sta VRAM_Buffer1+3,x     ;store it to overwrite blank palette in vram buffer
0087D6  1  C8                         iny
0087D7  1  E8                         inx
0087D8  1  C6 00                      dec $00                  ;decrement counter
0087DA  1  10 F4                      bpl GetAreaPal           ;do this until the palette is all copied
0087DC  1  AE 00 03                   ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
0087DF  1  AC D4 06                   ldy ColorRotateOffset    ;get color cycling offset
0087E2  1  B9 8B 87                   lda ColorRotatePalette,y
0087E5  1  9D 05 03                   sta VRAM_Buffer1+4,x     ;get and store current color in second slot of palette
0087E8  1  AD 00 03                   lda VRAM_Buffer1_Offset
0087EB  1  18                         clc                      ;add seven bytes to vram buffer offset
0087EC  1  69 07                      adc #$07
0087EE  1  8D 00 03                   sta VRAM_Buffer1_Offset
0087F1  1  EE D4 06                   inc ColorRotateOffset    ;increment color cycling offset
0087F4  1  AD D4 06                   lda ColorRotateOffset
0087F7  1  C9 06                      cmp #$06                 ;check to see if it's still in range
0087F9  1  90 05                      bcc ExitColorRot         ;if so, branch to leave
0087FB  1  A9 00                      lda #$00
0087FD  1  8D D4 06                   sta ColorRotateOffset    ;otherwise, init to keep it in range
008800  1  60           ExitColorRot: rts                      ;leave
008801  1               
008801  1               ;-------------------------------------------------------------------------------------
008801  1               ;METATILE GRAPHICS TABLE
008801  1               
008801  1               MetatileGraphics_Low:
008801  1  09 A5 5D 85    .byte <Palette0_MTiles, <Palette1_MTiles, <Palette2_MTiles, <Palette3_MTiles
008805  1               
008805  1               MetatileGraphics_High:
008805  1  88 88 89 89    .byte >Palette0_MTiles, >Palette1_MTiles, >Palette2_MTiles, >Palette3_MTiles
008809  1               
008809  1               Palette0_MTiles:
008809  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank
00880D  1  27 27 27 27    .byte $27, $27, $27, $27 ;black metatile
008811  1  24 24 24 35    .byte $24, $24, $24, $35 ;bush left
008815  1  36 25 37 25    .byte $36, $25, $37, $25 ;bush middle
008819  1  24 38 24 24    .byte $24, $38, $24, $24 ;bush right
00881D  1  24 30 30 26    .byte $24, $30, $30, $26 ;mountain left
008821  1  26 26 34 26    .byte $26, $26, $34, $26 ;mountain left bottom/middle center
008825  1  24 31 24 32    .byte $24, $31, $24, $32 ;mountain middle top
008829  1  33 26 24 33    .byte $33, $26, $24, $33 ;mountain right
00882D  1  34 26 26 26    .byte $34, $26, $26, $26 ;mountain right bottom
008831  1  26 26 26 26    .byte $26, $26, $26, $26 ;mountain middle bottom
008835  1  24 C0 24 C0    .byte $24, $c0, $24, $c0 ;bridge guardrail
008839  1  24 7F 7F 24    .byte $24, $7f, $7f, $24 ;chain
00883D  1  B8 BA B9 BB    .byte $b8, $ba, $b9, $bb ;tall tree top, top half
008841  1  B8 BC B9 BD    .byte $b8, $bc, $b9, $bd ;short tree top
008845  1  BA BC BB BD    .byte $ba, $bc, $bb, $bd ;tall tree top, bottom half
008849  1  60 64 61 65    .byte $60, $64, $61, $65 ;warp pipe end left, points up
00884D  1  62 66 63 67    .byte $62, $66, $63, $67 ;warp pipe end right, points up
008851  1  60 64 61 65    .byte $60, $64, $61, $65 ;decoration pipe end left, points up
008855  1  62 66 63 67    .byte $62, $66, $63, $67 ;decoration pipe end right, points up
008859  1  68 68 69 69    .byte $68, $68, $69, $69 ;pipe shaft left
00885D  1  26 26 6A 6A    .byte $26, $26, $6a, $6a ;pipe shaft right
008861  1  4B 4C 4D 4E    .byte $4b, $4c, $4d, $4e ;tree ledge left edge
008865  1  4D 4F 4D 4F    .byte $4d, $4f, $4d, $4f ;tree ledge middle
008869  1  4D 4E 50 51    .byte $4d, $4e, $50, $51 ;tree ledge right edge
00886D  1  6B 70 2C 2D    .byte $6b, $70, $2c, $2d ;mushroom left edge
008871  1  6C 71 6D 72    .byte $6c, $71, $6d, $72 ;mushroom middle
008875  1  6E 73 6F 74    .byte $6e, $73, $6f, $74 ;mushroom right edge
008879  1  86 8A 87 8B    .byte $86, $8a, $87, $8b ;sideways pipe end top
00887D  1  88 8C 88 8C    .byte $88, $8c, $88, $8c ;sideways pipe shaft top
008881  1  89 8D 69 69    .byte $89, $8d, $69, $69 ;sideways pipe joint top
008885  1  8E 91 8F 92    .byte $8e, $91, $8f, $92 ;sideways pipe end bottom
008889  1  26 93 26 93    .byte $26, $93, $26, $93 ;sideways pipe shaft bottom
00888D  1  90 94 69 69    .byte $90, $94, $69, $69 ;sideways pipe joint bottom
008891  1  A4 E9 EA EB    .byte $a4, $e9, $ea, $eb ;seaplant
008895  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank, used on bricks or blocks that are hit
008899  1  24 2F 24 3D    .byte $24, $2f, $24, $3d ;flagpole ball
00889D  1  A2 A2 A3 A3    .byte $a2, $a2, $a3, $a3 ;flagpole shaft
0088A1  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank, used in conjunction with vines
0088A5  1               
0088A5  1               Palette1_MTiles:
0088A5  1  A2 A2 A3 A3    .byte $a2, $a2, $a3, $a3 ;vertical rope
0088A9  1  99 24 99 24    .byte $99, $24, $99, $24 ;horizontal rope
0088AD  1  24 A2 3E 3F    .byte $24, $a2, $3e, $3f ;left pulley
0088B1  1  5B 5C 24 A3    .byte $5b, $5c, $24, $a3 ;right pulley
0088B5  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank used for balance rope
0088B9  1  9D 47 9E 47    .byte $9d, $47, $9e, $47 ;castle top
0088BD  1  47 47 27 27    .byte $47, $47, $27, $27 ;castle window left
0088C1  1  47 47 47 47    .byte $47, $47, $47, $47 ;castle brick wall
0088C5  1  27 27 47 47    .byte $27, $27, $47, $47 ;castle window right
0088C9  1  A9 47 AA 47    .byte $a9, $47, $aa, $47 ;castle top w/ brick
0088CD  1  9B 27 9C 27    .byte $9b, $27, $9c, $27 ;entrance top
0088D1  1  27 27 27 27    .byte $27, $27, $27, $27 ;entrance bottom
0088D5  1  52 52 52 52    .byte $52, $52, $52, $52 ;green ledge stump
0088D9  1  80 A0 81 A1    .byte $80, $a0, $81, $a1 ;fence
0088DD  1  BE BE BF BF    .byte $be, $be, $bf, $bf ;tree trunk
0088E1  1  75 BA 76 BB    .byte $75, $ba, $76, $bb ;mushroom stump top
0088E5  1  BA BA BB BB    .byte $ba, $ba, $bb, $bb ;mushroom stump bottom
0088E9  1  45 47 45 47    .byte $45, $47, $45, $47 ;breakable brick w/ line
0088ED  1  47 47 47 47    .byte $47, $47, $47, $47 ;breakable brick
0088F1  1  45 47 45 47    .byte $45, $47, $45, $47 ;breakable brick (not used)
0088F5  1  B4 B6 B5 B7    .byte $b4, $b6, $b5, $b7 ;cracked rock terrain
0088F9  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (power-up)
0088FD  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (vine)
008901  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (star)
008905  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (coins)
008909  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (1-up)
00890D  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (power-up)
008911  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (vine)
008915  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (star)
008919  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (coins)
00891D  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (1-up)
008921  1  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (1 coin)
008925  1  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (1-up)
008929  1  AB AC AD AE    .byte $ab, $ac, $ad, $ae ;solid block (3-d block)
00892D  1  5D 5E 5D 5E    .byte $5d, $5e, $5d, $5e ;solid block (white wall)
008931  1  C1 24 C1 24    .byte $c1, $24, $c1, $24 ;bridge
008935  1  C6 C8 C7 C9    .byte $c6, $c8, $c7, $c9 ;bullet bill cannon barrel
008939  1  CA CC CB CD    .byte $ca, $cc, $cb, $cd ;bullet bill cannon top
00893D  1  2A 2A 40 40    .byte $2a, $2a, $40, $40 ;bullet bill cannon bottom
008941  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank used for jumpspring
008945  1  24 47 24 47    .byte $24, $47, $24, $47 ;half brick used for jumpspring
008949  1  82 83 84 85    .byte $82, $83, $84, $85 ;solid block (water level, green rock)
00894D  1  24 47 24 47    .byte $24, $47, $24, $47 ;half brick (???)
008951  1  86 8A 87 8B    .byte $86, $8a, $87, $8b ;water pipe top
008955  1  8E 91 8F 92    .byte $8e, $91, $8f, $92 ;water pipe bottom
008959  1  24 2F 24 3D    .byte $24, $2f, $24, $3d ;flag ball (residual object)
00895D  1               
00895D  1               Palette2_MTiles:
00895D  1  24 24 24 35    .byte $24, $24, $24, $35 ;cloud left
008961  1  36 25 37 25    .byte $36, $25, $37, $25 ;cloud middle
008965  1  24 38 24 24    .byte $24, $38, $24, $24 ;cloud right
008969  1  24 24 39 24    .byte $24, $24, $39, $24 ;cloud bottom left
00896D  1  3A 24 3B 24    .byte $3a, $24, $3b, $24 ;cloud bottom middle
008971  1  3C 24 24 24    .byte $3c, $24, $24, $24 ;cloud bottom right
008975  1  41 26 41 26    .byte $41, $26, $41, $26 ;water/lava top
008979  1  26 26 26 26    .byte $26, $26, $26, $26 ;water/lava
00897D  1  B0 B1 B2 B3    .byte $b0, $b1, $b2, $b3 ;cloud level terrain
008981  1  77 79 77 79    .byte $77, $79, $77, $79 ;bowser's bridge
008985  1               
008985  1               Palette3_MTiles:
008985  1  53 55 54 56    .byte $53, $55, $54, $56 ;question block (coin)
008989  1  53 55 54 56    .byte $53, $55, $54, $56 ;question block (power-up)
00898D  1  A5 A7 A6 A8    .byte $a5, $a7, $a6, $a8 ;coin
008991  1  C2 C4 C3 C5    .byte $c2, $c4, $c3, $c5 ;underwater coin
008995  1  57 59 58 5A    .byte $57, $59, $58, $5a ;empty block
008999  1  7B 7D 7C 7E    .byte $7b, $7d, $7c, $7e ;axe
00899D  1               
00899D  1               ;-------------------------------------------------------------------------------------
00899D  1               ;VRAM BUFFER DATA FOR LOCATIONS IN PRG-ROM
00899D  1               
00899D  1               WaterPaletteData:
00899D  1  3F 00 20       .byte $3f, $00, $20
0089A0  1  0F 15 12 25    .byte $0f, $15, $12, $25
0089A4  1  0F 3A 1A 0F    .byte $0f, $3a, $1a, $0f
0089A8  1  0F 30 12 0F    .byte $0f, $30, $12, $0f
0089AC  1  0F 27 12 0F    .byte $0f, $27, $12, $0f
0089B0  1  22 16 27 18    .byte $22, $16, $27, $18
0089B4  1  0F 10 30 27    .byte $0f, $10, $30, $27
0089B8  1  0F 16 30 27    .byte $0f, $16, $30, $27
0089BC  1  0F 0F 30 10    .byte $0f, $0f, $30, $10
0089C0  1  00             .byte $00
0089C1  1               
0089C1  1               GroundPaletteData:
0089C1  1  3F 00 20       .byte $3f, $00, $20
0089C4  1  0F 29 1A 0F    .byte $0f, $29, $1a, $0f
0089C8  1  0F 36 17 0F    .byte $0f, $36, $17, $0f
0089CC  1  0F 30 21 0F    .byte $0f, $30, $21, $0f
0089D0  1  0F 27 17 0F    .byte $0f, $27, $17, $0f
0089D4  1  0F 16 27 18    .byte $0f, $16, $27, $18
0089D8  1  0F 1A 30 27    .byte $0f, $1a, $30, $27
0089DC  1  0F 16 30 27    .byte $0f, $16, $30, $27
0089E0  1  0F 0F 36 17    .byte $0f, $0f, $36, $17
0089E4  1  00             .byte $00
0089E5  1               
0089E5  1               UndergroundPaletteData:
0089E5  1  3F 00 20       .byte $3f, $00, $20
0089E8  1  0F 29 1A 09    .byte $0f, $29, $1a, $09
0089EC  1  0F 3C 1C 0F    .byte $0f, $3c, $1c, $0f
0089F0  1  0F 30 21 1C    .byte $0f, $30, $21, $1c
0089F4  1  0F 27 17 1C    .byte $0f, $27, $17, $1c
0089F8  1  0F 16 27 18    .byte $0f, $16, $27, $18
0089FC  1  0F 1C 36 17    .byte $0f, $1c, $36, $17
008A00  1  0F 16 30 27    .byte $0f, $16, $30, $27
008A04  1  0F 0C 3C 1C    .byte $0f, $0c, $3c, $1c
008A08  1  00             .byte $00
008A09  1               
008A09  1               CastlePaletteData:
008A09  1  3F 00 20       .byte $3f, $00, $20
008A0C  1  0F 30 10 00    .byte $0f, $30, $10, $00
008A10  1  0F 30 10 00    .byte $0f, $30, $10, $00
008A14  1  0F 30 16 00    .byte $0f, $30, $16, $00
008A18  1  0F 27 17 00    .byte $0f, $27, $17, $00
008A1C  1  0F 16 27 18    .byte $0f, $16, $27, $18
008A20  1  0F 1C 36 17    .byte $0f, $1c, $36, $17
008A24  1  0F 16 30 27    .byte $0f, $16, $30, $27
008A28  1  0F 00 30 10    .byte $0f, $00, $30, $10
008A2C  1  00             .byte $00
008A2D  1               
008A2D  1               DaySnowPaletteData:
008A2D  1  3F 00 04       .byte $3f, $00, $04
008A30  1  22 30 00 10    .byte $22, $30, $00, $10
008A34  1  00             .byte $00
008A35  1               
008A35  1               NightSnowPaletteData:
008A35  1  3F 00 04       .byte $3f, $00, $04
008A38  1  0F 30 00 10    .byte $0f, $30, $00, $10
008A3C  1  00             .byte $00
008A3D  1               
008A3D  1               MushroomPaletteData:
008A3D  1  3F 00 04       .byte $3f, $00, $04
008A40  1  22 27 16 0F    .byte $22, $27, $16, $0f
008A44  1  00             .byte $00
008A45  1               
008A45  1               BowserPaletteData:
008A45  1  3F 14 04       .byte $3f, $14, $04
008A48  1  0F 1A 30 27    .byte $0f, $1a, $30, $27
008A4C  1  00             .byte $00
008A4D  1               
008A4D  1               MarioThanksMessage:
008A4D  1               ;"THANK YOU MARIO!"
008A4D  1  25 48 10       .byte $25, $48, $10
008A50  1  1D 11 0A 17    .byte $1d, $11, $0a, $17, $14, $24
008A54  1  14 24        
008A56  1  22 18 1E 24    .byte $22, $18, $1e, $24
008A5A  1  16 0A 1B 12    .byte $16, $0a, $1b, $12, $18, $2b
008A5E  1  18 2B        
008A60  1  00             .byte $00
008A61  1               
008A61  1               LuigiThanksMessage:
008A61  1               ;"THANK YOU LUIGI!"
008A61  1  25 48 10       .byte $25, $48, $10
008A64  1  1D 11 0A 17    .byte $1d, $11, $0a, $17, $14, $24
008A68  1  14 24        
008A6A  1  22 18 1E 24    .byte $22, $18, $1e, $24
008A6E  1  15 1E 12 10    .byte $15, $1e, $12, $10, $12, $2b
008A72  1  12 2B        
008A74  1  00             .byte $00
008A75  1               
008A75  1               MushroomRetainerSaved:
008A75  1               ;"BUT OUR PRINCESS IS IN"
008A75  1  25 C5 16       .byte $25, $c5, $16
008A78  1  0B 1E 1D 24    .byte $0b, $1e, $1d, $24, $18, $1e, $1b, $24
008A7C  1  18 1E 1B 24  
008A80  1  19 1B 12 17    .byte $19, $1b, $12, $17, $0c, $0e, $1c, $1c, $24
008A84  1  0C 0E 1C 1C  
008A88  1  24           
008A89  1  12 1C 24 12    .byte $12, $1c, $24, $12, $17
008A8D  1  17           
008A8E  1               ;"ANOTHER CASTLE!"
008A8E  1  26 05 0F       .byte $26, $05, $0f
008A91  1  0A 17 18 1D    .byte $0a, $17, $18, $1d, $11, $0e, $1b, $24
008A95  1  11 0E 1B 24  
008A99  1  0C 0A 1C 1D    .byte $0c, $0a, $1c, $1d, $15, $0e, $2b, $00
008A9D  1  15 0E 2B 00  
008AA1  1               
008AA1  1               PrincessSaved1:
008AA1  1               ;"YOUR QUEST IS OVER."
008AA1  1  25 A7 13       .byte $25, $a7, $13
008AA4  1  22 18 1E 1B    .byte $22, $18, $1e, $1b, $24
008AA8  1  24           
008AA9  1  1A 1E 0E 1C    .byte $1a, $1e, $0e, $1c, $1d, $24
008AAD  1  1D 24        
008AAF  1  12 1C 24 18    .byte $12, $1c, $24, $18, $1f, $0e, $1b, $af
008AB3  1  1F 0E 1B AF  
008AB7  1  00             .byte $00
008AB8  1               
008AB8  1               PrincessSaved2:
008AB8  1               ;"WE PRESENT YOU A NEW QUEST."
008AB8  1  25 E3 1B       .byte $25, $e3, $1b
008ABB  1  20 0E 24       .byte $20, $0e, $24
008ABE  1  19 1B 0E 1C    .byte $19, $1b, $0e, $1c, $0e, $17, $1d, $24
008AC2  1  0E 17 1D 24  
008AC6  1  22 18 1E 24    .byte $22, $18, $1e, $24, $0a, $24, $17, $0e, $20, $24
008ACA  1  0A 24 17 0E  
008ACE  1  20 24        
008AD0  1  1A 1E 0E 1C    .byte $1a, $1e, $0e, $1c, $1d, $af
008AD4  1  1D AF        
008AD6  1  00             .byte $00
008AD7  1               
008AD7  1               WorldSelectMessage1:
008AD7  1               ;"PUSH BUTTON B"
008AD7  1  26 4A 0D       .byte $26, $4a, $0d
008ADA  1  19 1E 1C 11    .byte $19, $1e, $1c, $11, $24
008ADE  1  24           
008ADF  1  0B 1E 1D 1D    .byte $0b, $1e, $1d, $1d, $18, $17, $24, $0b
008AE3  1  18 17 24 0B  
008AE7  1  00             .byte $00
008AE8  1               
008AE8  1               WorldSelectMessage2:
008AE8  1               ;"TO SELECT A WORLD"
008AE8  1  26 88 11       .byte $26, $88, $11
008AEB  1  1D 18 24 1C    .byte $1d, $18, $24, $1c, $0e, $15, $0e, $0c, $1d, $24
008AEF  1  0E 15 0E 0C  
008AF3  1  1D 24        
008AF5  1  0A 24 20 18    .byte $0a, $24, $20, $18, $1b, $15, $0d
008AF9  1  1B 15 0D     
008AFC  1  00             .byte $00
008AFD  1               
008AFD  1               ;-------------------------------------------------------------------------------------
008AFD  1               ;$00 - used to store status bar nybbles
008AFD  1               ;$02 - used as temp vram offset
008AFD  1               ;$03 - used to store length of status bar number
008AFD  1               
008AFD  1               ;status bar name table offset and length data
008AFD  1               StatusBarData:
008AFD  1  F0 06              .byte $f0, $06 ; top score display on title screen
008AFF  1  62 06              .byte $62, $06 ; player score
008B01  1  62 06              .byte $62, $06
008B03  1  6D 02              .byte $6d, $02 ; coin tally
008B05  1  6D 02              .byte $6d, $02
008B07  1  7A 03              .byte $7a, $03 ; game timer
008B09  1               
008B09  1               StatusBarOffset:
008B09  1  06 0C 12 18        .byte $06, $0c, $12, $18, $1e, $24
008B0D  1  1E 24        
008B0F  1               
008B0F  1               PrintStatusBarNumbers:
008B0F  1  85 00              sta $00            ;store player-specific offset
008B11  1  20 1A 8B           jsr OutputNumbers  ;use first nybble to print the coin display
008B14  1  A5 00              lda $00            ;move high nybble to low
008B16  1  4A                 lsr                ;and print to score display
008B17  1  4A                 lsr
008B18  1  4A                 lsr
008B19  1  4A                 lsr
008B1A  1               
008B1A  1               OutputNumbers:
008B1A  1  18                        clc                      ;add 1 to low nybble
008B1B  1  69 01                     adc #$01
008B1D  1  29 0F                     and #%00001111           ;mask out high nybble
008B1F  1  C9 06                     cmp #$06
008B21  1  B0 44                     bcs ExitOutputN
008B23  1  48                        pha                      ;save incremented value to stack for now and
008B24  1  0A                        asl                      ;shift to left and use as offset
008B25  1  A8                        tay
008B26  1  AE 00 03                  ldx VRAM_Buffer1_Offset  ;get current buffer pointer
008B29  1  A9 20                     lda #$20                 ;put at top of screen by default
008B2B  1  C0 00                     cpy #$00                 ;are we writing top score on title screen?
008B2D  1  D0 02                     bne SetupNums
008B2F  1  A9 22                     lda #$22                 ;if so, put further down on the screen
008B31  1  9D 01 03     SetupNums:   sta VRAM_Buffer1,x
008B34  1  B9 FD 8A                  lda StatusBarData,y      ;write low vram address and length of thing
008B37  1  9D 02 03                  sta VRAM_Buffer1+1,x     ;we're printing to the buffer
008B3A  1  B9 FE 8A                  lda StatusBarData+1,y
008B3D  1  9D 03 03                  sta VRAM_Buffer1+2,x
008B40  1  85 03                     sta $03                  ;save length byte in counter
008B42  1  86 02                     stx $02                  ;and buffer pointer elsewhere for now
008B44  1  68                        pla                      ;pull original incremented value from stack
008B45  1  AA                        tax
008B46  1  BD 09 8B                  lda StatusBarOffset,x    ;load offset to value we want to write
008B49  1  38                        sec
008B4A  1  F9 FE 8A                  sbc StatusBarData+1,y    ;subtract from length byte we read before
008B4D  1  A8                        tay                      ;use value as offset to display digits
008B4E  1  A6 02                     ldx $02
008B50  1  B9 D7 07     DigitPLoop:  lda DisplayDigits,y      ;write digits to the buffer
008B53  1  9D 04 03                  sta VRAM_Buffer1+3,x
008B56  1  E8                        inx
008B57  1  C8                        iny
008B58  1  C6 03                     dec $03                  ;do this until all the digits are written
008B5A  1  D0 F4                     bne DigitPLoop
008B5C  1  A9 00                     lda #$00                 ;put null terminator at end
008B5E  1  9D 04 03                  sta VRAM_Buffer1+3,x
008B61  1  E8                        inx                      ;increment buffer pointer by 3
008B62  1  E8                        inx
008B63  1  E8                        inx
008B64  1  8E 00 03                  stx VRAM_Buffer1_Offset  ;store it in case we want to use it again
008B67  1  60           ExitOutputN: rts
008B68  1               
008B68  1               ;-------------------------------------------------------------------------------------
008B68  1               
008B68  1               DigitsMathRoutine:
008B68  1  AD 70 07                 lda OperMode              ;check mode of operation
008B6B  1  C9 00                    cmp #TitleScreenModeValue
008B6D  1  F0 16                    beq EraseDMods            ;if in title screen mode, branch to lock score
008B6F  1  A2 05                    ldx #$05
008B71  1  BD 34 01     AddModLoop: lda DigitModifier,x       ;load digit amount to increment
008B74  1  18                       clc
008B75  1  79 D7 07                 adc DisplayDigits,y       ;add to current digit
008B78  1  30 16                    bmi BorrowOne             ;if result is a negative number, branch to subtract
008B7A  1  C9 0A                    cmp #10
008B7C  1  B0 19                    bcs CarryOne              ;if digit greater than $09, branch to add
008B7E  1  99 D7 07     StoreNewD:  sta DisplayDigits,y       ;store as new score or game timer digit
008B81  1  88                       dey                       ;move onto next digits in score or game timer
008B82  1  CA                       dex                       ;and digit amounts to increment
008B83  1  10 EC                    bpl AddModLoop            ;loop back if we're not done yet
008B85  1  A9 00        EraseDMods: lda #$00                  ;store zero here
008B87  1  A2 06                    ldx #$06                  ;start with the last digit
008B89  1  9D 33 01     EraseMLoop: sta DigitModifier-1,x     ;initialize the digit amounts to increment
008B8C  1  CA                       dex
008B8D  1  10 FA                    bpl EraseMLoop            ;do this until they're all reset, then leave
008B8F  1  60                       rts
008B90  1  DE 33 01     BorrowOne:  dec DigitModifier-1,x     ;decrement the previous digit, then put $09 in
008B93  1  A9 09                    lda #$09                  ;the game timer digit we're currently on to "borrow
008B95  1  D0 E7                    bne StoreNewD             ;the one", then do an unconditional branch back
008B97  1  38           CarryOne:   sec                       ;subtract ten from our digit to make it a
008B98  1  E9 0A                    sbc #10                   ;proper BCD number, then increment the digit
008B9A  1  FE 33 01                 inc DigitModifier-1,x     ;preceding current digit to "carry the one" properly
008B9D  1  4C 7E 8B                 jmp StoreNewD             ;go back to just after we branched here
008BA0  1               
008BA0  1               ;-------------------------------------------------------------------------------------
008BA0  1               
008BA0  1               DefaultSprOffsets:
008BA0  1  04 30 48 60        .byte $04, $30, $48, $60, $78, $90, $a8, $c0
008BA4  1  78 90 A8 C0  
008BA8  1  D8 E8 24 F8        .byte $d8, $e8, $24, $f8, $fc, $28, $2c
008BAC  1  FC 28 2C     
008BAF  1               
008BAF  1               Sprite0Data:
008BAF  1  18 FF 23 58        .byte $18, $ff, $23, $58
008BB3  1               
008BB3  1               ;-------------------------------------------------------------------------------------
008BB3  1               
008BB3  1               PrimaryGameSetup:
008BB3  1  A9 01              lda #$01
008BB5  1  8D 57 07           sta FetchNewGameTimerFlag   ;set flag to load game timer from header
008BB8  1  8D 54 07           sta PlayerSize              ;set player's size to small
008BBB  1               SecondaryGameSetup:
008BBB  1  A9 00                     lda #$00
008BBD  1                            ;sta DisableScreenFlag     ;enable screen output
008BBD  1  A8                        tay
008BBE  1  99 00 03     ClearVRLoop: sta VRAM_Buffer1-1,y      ;clear buffer at $0300-$03ff
008BC1  1  C8                        iny
008BC2  1  D0 FA                     bne ClearVRLoop
008BC4  1  8D 59 07                  sta GameTimerExpiredFlag  ;clear game timer exp flag
008BC7  1  8D 69 07                  sta DisableIntermediate   ;clear skip lives display flag
008BCA  1  8D 28 07                  sta BackloadingFlag       ;clear value here
008BCD  1  A9 FF                     lda #$ff
008BCF  1  8D A0 03                  sta BalPlatformAlignment  ;initialize balance platform assignment flag
008BD2  1  AD 1A 07                  lda ScreenLeft_PageLoc    ;get left side page location
008BD5  1  4E 78 07                  lsr Mirror_PPU_CTRL_REG1  ;shift LSB of ppu register #1 mirror out
008BD8  1  29 01                     and #$01                  ;mask out all but LSB of page location
008BDA  1  6A                        ror                       ;rotate LSB of page location into carry then onto mirror
008BDB  1  2E 78 07                  rol Mirror_PPU_CTRL_REG1  ;this is to set the proper PPU name table
008BDE  1  20 19 8C                  jsr GetAreaMusic          ;load proper music into queue
008BE1  1  A9 38                     lda #$38                  ;load sprite shuffle amounts to be used later
008BE3  1  8D E3 06                  sta SprShuffleAmt+2
008BE6  1  A9 48                     lda #$48
008BE8  1  8D E2 06                  sta SprShuffleAmt+1
008BEB  1  A9 58                     lda #$58
008BED  1  8D E1 06                  sta SprShuffleAmt
008BF0  1  A2 0E                     ldx #$0e                  ;load default OAM offsets into $06e4-$06f2
008BF2  1  BD A0 8B     ShufAmtLoop: lda DefaultSprOffsets,x
008BF5  1  9D E4 06                  sta SprDataOffset,x
008BF8  1  CA                        dex                       ;do this until they're all set
008BF9  1  10 F7                     bpl ShufAmtLoop
008BFB  1  A0 03                     ldy #$03                  ;set up sprite #0
008BFD  1  B9 AF 8B     ISpr0Loop:   lda Sprite0Data,y
008C00  1  99 00 02                  sta Sprite_Data,y
008C03  1  88                        dey
008C04  1  10 F7                     bpl ISpr0Loop
008C06  1  20 57 8D                  jsr DoNothing2            ;these jsrs doesn't do anything useful
008C09  1  20 52 8D                  jsr DoNothing1
008C0C  1  EE 22 07                  inc Sprite0HitDetectFlag  ;set sprite #0 check flag
008C0F  1  EE 72 07                  inc OperMode_Task         ;increment to next task
008C12  1  60                        rts
008C13  1               
008C13  1               ;-------------------------------------------------------------------------------------
008C13  1               
008C13  1               MusicSelectData:
008C13  1  02 01 04 08        .byte WaterMusic, GroundMusic, UndergroundMusic, CastleMusic
008C17  1  10 20              .byte CloudMusic, PipeIntroMusic
008C19  1               
008C19  1               GetAreaMusic:
008C19  1  AD 70 07                  lda OperMode           ;if in title screen mode, leave
008C1C  1  F0 23                     beq ExitGetM
008C1E  1  AD 52 07                  lda AltEntranceControl ;check for specific alternate mode of entry
008C21  1  C9 02                     cmp #$02               ;if found, branch without checking starting position
008C23  1  F0 0D                     beq ChkAreaType        ;from area object data header
008C25  1  A0 05                     ldy #$05               ;select music for pipe intro scene by default
008C27  1  AD 10 07                  lda PlayerEntranceCtrl ;check value from level header for certain values
008C2A  1  C9 06                     cmp #$06
008C2C  1  F0 0E                     beq StoreMusic         ;load music for pipe intro scene if header
008C2E  1  C9 07                     cmp #$07               ;start position either value $06 or $07
008C30  1  F0 0A                     beq StoreMusic
008C32  1  AC 4E 07     ChkAreaType: ldy AreaType           ;load area type as offset for music bit
008C35  1  AD 43 07                  lda CloudTypeOverride
008C38  1  F0 02                     beq StoreMusic         ;check for cloud type override
008C3A  1  A0 04                     ldy #$04               ;select music for cloud type level if found
008C3C  1  B9 13 8C     StoreMusic:  lda MusicSelectData,y  ;otherwise select appropriate music for level type
008C3F  1  85 FB                     sta AreaMusicQueue     ;store in queue and leave
008C41  1  60           ExitGetM:    rts
008C42  1               
008C42  1               ;-------------------------------------------------------------------------------------
008C42  1               
008C42  1               PlayerStarting_X_Pos:
008C42  1  28 18              .byte $28, $18
008C44  1  38 28              .byte $38, $28
008C46  1               
008C46  1               AltYPosOffset:
008C46  1  08 00              .byte $08, $00
008C48  1               
008C48  1               PlayerStarting_Y_Pos:
008C48  1  00 20 B0 50        .byte $00, $20, $b0, $50, $00, $00, $b0, $b0
008C4C  1  00 00 B0 B0  
008C50  1  F0                 .byte $f0
008C51  1               
008C51  1               PlayerBGPriorityData:
008C51  1  00 20 00 00        .byte $00, $20, $00, $00, $00, $00, $00, $00
008C55  1  00 00 00 00  
008C59  1               
008C59  1               GameTimerData:
008C59  1  20                 .byte $20 ;dummy byte, used as part of bg priority data
008C5A  1  04 03 02           .byte $04, $03, $02
008C5D  1               
008C5D  1               Entrance_GameTimerSetup:
008C5D  1                         ;lda ScreenLeft_PageLoc      ;set current page for area objects
008C5D  1                         ;sta Player_PageLoc          ;as page location for player
008C5D  1                         ;lda #$28                    ;store value here
008C5D  1                         ;sta VerticalForceDown       ;for fractional movement downwards if necessary
008C5D  1                         ;lda #$01                    ;set high byte of player position and
008C5D  1                         ;sta PlayerFacingDir         ;set facing direction so that player faces right
008C5D  1                         ;sta Player_Y_HighPos
008C5D  1                         ;lda #$00                    ;set player state to on the ground by default
008C5D  1                         ;sta Player_State
008C5D  1                         ;dec Player_CollisionBits    ;initialize player's collision bits
008C5D  1  A0 00                  ldy #$00                    ;initialize halfway page
008C5F  1  8C 5B 07               sty HalfwayPage
008C62  1  AD 4E 07               lda AreaType                ;check area type
008C65  1  D0 01                  bne ChkStPos                ;if water type, set swimming flag, otherwise do not set
008C67  1  C8                     iny
008C68  1  8C 04 07     ChkStPos: sty SwimmingFlag
008C6B  1  AE 10 07               ldx PlayerEntranceCtrl      ;get starting position loaded from header
008C6E  1  BD 51 8C               lda PlayerBGPriorityData,x
008C71  1  8D C4 03               sta Player_SprAttrib        ;set player sprite attributes using offset in X
008C74  1  20 EE ED               jsr GetPlayerColors         ;get appropriate player palette
008C77  1  AC 15 07               ldy GameTimerSetting        ;get timer control value from header
008C7A  1  F0 1A                  beq ChkOverR                ;if set to zero, branch (do not use dummy byte for this)
008C7C  1  AD 57 07               lda FetchNewGameTimerFlag   ;do we need to set the game timer? if not, use
008C7F  1  F0 15                  beq ChkOverR                ;old game timer setting
008C81  1  B9 59 8C               lda GameTimerData,y         ;if game timer is set and game timer flag is also set,
008C84  1  8D F8 07               sta GameTimerDisplay        ;use value of game timer control for first digit of game timer
008C87  1  A9 01                  lda #$01
008C89  1  8D FA 07               sta GameTimerDisplay+2      ;set last digit of game timer to 1
008C8C  1  4A                     lsr
008C8D  1  8D F9 07               sta GameTimerDisplay+1      ;set second digit of game timer
008C90  1  8D 57 07               sta FetchNewGameTimerFlag   ;clear flag for game timer reset
008C93  1  8D 9F 07               sta StarInvincibleTimer     ;clear star mario timer
008C96  1  AC 58 07     ChkOverR: ldy JoypadOverride          ;if controller bits not set, branch to skip this part
008C99  1  F0 10                  beq ChkSwimE
008C9B  1                         ;lda #$03                    ;set player state to climbing
008C9B  1                         ;sta Player_State
008C9B  1  A2 00                  ldx #$00                    ;set offset for first slot, for block object
008C9D  1  20 66 BD               jsr InitBlock_XY_Pos
008CA0  1  A9 F0                  lda #$f0                    ;set vertical coordinate for block object
008CA2  1  85 D7                  sta Block_Y_Position
008CA4  1  A2 05                  ldx #$05                    ;set offset in X for last enemy object buffer slot
008CA6  1  A0 00                  ldy #$00                    ;set offset in Y for object coordinates used earlier
008CA8  1  20 7B ED               jsr Setup_Vine              ;do a sub to grow vine
008CAB  1  AC 4E 07     ChkSwimE: ldy AreaType                ;if level not water-type,
008CAE  1  D0 03                  bne SetPESub                ;skip this subroutine
008CB0  1  20 29 B1               jsr SetupBubble             ;otherwise, execute sub to set up air bubbles
008CB3  1  A9 07        SetPESub: lda #$07                    ;set to run player entrance subroutine
008CB5  1  85 0E                  sta GameEngineSubroutine    ;on the next frame of game engine
008CB7  1  60                     rts
008CB8  1               
008CB8  1               ;-------------------------------------------------------------------------------------
008CB8  1               
008CB8  1               ;page numbers are in order from -1 to -4
008CB8  1               HalfwayPageNybbles:
008CB8  1  56 40              .byte $56, $40
008CBA  1  65 70              .byte $65, $70
008CBC  1  66 40              .byte $66, $40
008CBE  1  66 40              .byte $66, $40
008CC0  1  66 40              .byte $66, $40
008CC2  1  66 60              .byte $66, $60
008CC4  1  65 70              .byte $65, $70
008CC6  1  00 00              .byte $00, $00
008CC8  1               
008CC8  1               PlayerLoseLife:
008CC8  1  EE 74 07                  inc DisableScreenFlag    ;disable screen and sprite 0 check
008CCB  1  A9 00                     lda #$00
008CCD  1  8D 22 07                  sta Sprite0HitDetectFlag
008CD0  1  A9 80                     lda #Silence             ;silence music
008CD2  1  85 FC                     sta EventMusicQueue
008CD4  1  AD 5F 07     StillInGame: lda WorldNumber          ;multiply world number by 2 and use
008CD7  1  0A                        asl                      ;as offset
008CD8  1  AA                        tax
008CD9  1  AD 5C 07                  lda LevelNumber          ;if in area -3 or -4, increment
008CDC  1  29 02                     and #$02                 ;offset by one byte, otherwise
008CDE  1  F0 01                     beq GetHalfway           ;leave offset alone
008CE0  1  E8                        inx
008CE1  1  BC B8 8C     GetHalfway:  ldy HalfwayPageNybbles,x ;get halfway page number with offset
008CE4  1  AD 5C 07                  lda LevelNumber          ;check area number's LSB
008CE7  1  4A                        lsr
008CE8  1  98                        tya                      ;if in area -2 or -4, use lower nybble
008CE9  1  B0 04                     bcs MaskHPNyb
008CEB  1  4A                        lsr                      ;move higher nybble to lower if area
008CEC  1  4A                        lsr                      ;number is -1 or -3
008CED  1  4A                        lsr
008CEE  1  4A                        lsr
008CEF  1  29 0F        MaskHPNyb:   and #%00001111           ;mask out all but lower nybble
008CF1  1  CD 1A 07                  cmp ScreenLeft_PageLoc
008CF4  1  F0 04                     beq SetHalfway           ;left side of screen must be at the halfway page,
008CF6  1  90 02                     bcc SetHalfway           ;otherwise player must start at the
008CF8  1  A9 00                     lda #$00                 ;beginning of the level
008CFA  1  8D 5B 07     SetHalfway:  sta HalfwayPage          ;store as halfway page for player
008CFD  1  4C 34 8D                  jmp ContinueGame         ;continue the game
008D00  1               
008D00  1               ;-------------------------------------------------------------------------------------
008D00  1               
008D00  1               GameOverMode:
008D00  1  AD 72 07           lda OperMode_Task
008D03  1  20 A8 BA           jsr JumpEngine
008D06  1               
008D06  1  0C 8D              .word SetupGameOver
008D08  1  6C 84              .word ScreenRoutines
008D0A  1  1F 8D              .word RunGameOver
008D0C  1               
008D0C  1               ;-------------------------------------------------------------------------------------
008D0C  1               
008D0C  1               SetupGameOver:
008D0C  1  A9 00              lda #$00                  ;reset screen routine task control for title screen, game,
008D0E  1  8D 3C 07           sta ScreenRoutineTask     ;and game over modes
008D11  1  8D 22 07           sta Sprite0HitDetectFlag  ;disable sprite 0 check
008D14  1  A9 02              lda #GameOverMusic
008D16  1  85 FC              sta EventMusicQueue       ;put game over music in secondary queue
008D18  1  EE 74 07           inc DisableScreenFlag     ;disable screen output
008D1B  1  EE 72 07           inc OperMode_Task         ;set secondary mode to 1
008D1E  1  60                 rts
008D1F  1               
008D1F  1               ;-------------------------------------------------------------------------------------
008D1F  1               
008D1F  1               RunGameOver:
008D1F  1  A9 00              lda #$00              ;reenable screen
008D21  1  8D 74 07           sta DisableScreenFlag
008D24  1  AD FC 06           lda SavedJoypad1Bits  ;check controller for start pressed
008D27  1  29 10              and #Start_Button
008D29  1  D0 05              bne TerminateGame
008D2B  1  AD A0 07           lda ScreenTimer       ;if not pressed, wait for
008D2E  1  D0 21              bne GameIsOn          ;screen timer to expire
008D30  1               TerminateGame:
008D30  1  A9 80              lda #Silence          ;silence music
008D32  1  85 FC              sta EventMusicQueue
008D34  1               ContinueGame:
008D34  1  20 CE BB                jsr LoadAreaPointer       ;update level pointer with
008D37  1  A9 01                   lda #$01                  ;actual world and area numbers, then
008D39  1  8D 54 07                sta PlayerSize            ;reset player's size, status, and
008D3C  1  EE 57 07                inc FetchNewGameTimerFlag ;set game timer flag to reload
008D3F  1  A9 00                   lda #$00                  ;game timer from header
008D41  1  8D 47 07                sta TimerControl          ;also set flag for timers to count again
008D44  1  8D 56 07                sta PlayerStatus
008D47  1  85 0E                   sta GameEngineSubroutine  ;reset task for game core
008D49  1  8D 72 07                sta OperMode_Task         ;set modes and leave
008D4C  1  A9 01                   lda #$01                  ;if in game over mode, switch back to
008D4E  1  8D 70 07                sta OperMode              ;game mode, because game is still on
008D51  1  60           GameIsOn:  rts
008D52  1               
008D52  1               ;-------------------------------------------------------------------------------------
008D52  1               
008D52  1               DoNothing1:
008D52  1  A9 FF              lda #$ff       ;this is residual code, this value is
008D54  1  8D C9 06           sta $06c9      ;not used anywhere in the program
008D57  1               DoNothing2:
008D57  1  60                 rts
008D58  1               
008D58  1               ;-------------------------------------------------------------------------------------
008D58  1               
008D58  1               AreaParserTaskHandler:
008D58  1  AC 1F 07                   ldy AreaParserTaskNum     ;check number of tasks here
008D5B  1  D0 05                      bne DoAPTasks             ;if already set, go ahead
008D5D  1  A0 08                      ldy #$08
008D5F  1  8C 1F 07                   sty AreaParserTaskNum     ;otherwise, set eight by default
008D62  1  88           DoAPTasks:    dey
008D63  1  98                         tya
008D64  1  20 70 8D                   jsr AreaParserTasks
008D67  1  CE 1F 07                   dec AreaParserTaskNum     ;if all tasks not complete do not
008D6A  1  D0 03                      bne SkipATRender          ;render attribute table yet
008D6C  1  20 32 87                   jsr RenderAttributeTables
008D6F  1  60           SkipATRender: rts
008D70  1               
008D70  1               AreaParserTasks:
008D70  1  20 A8 BA           jsr JumpEngine
008D73  1               
008D73  1  83 8D              .word IncrementColumnPos
008D75  1  76 86              .word RenderAreaGraphics
008D77  1  76 86              .word RenderAreaGraphics
008D79  1  A4 8E              .word AreaParserCore
008D7B  1  83 8D              .word IncrementColumnPos
008D7D  1  76 86              .word RenderAreaGraphics
008D7F  1  76 86              .word RenderAreaGraphics
008D81  1  A4 8E              .word AreaParserCore
008D83  1               
008D83  1               ;-------------------------------------------------------------------------------------
008D83  1               
008D83  1               IncrementColumnPos:
008D83  1  EE 26 07                inc CurrentColumnPos     ;increment column where we're at
008D86  1  AD 26 07                lda CurrentColumnPos
008D89  1  29 0F                   and #%00001111           ;mask out higher nybble
008D8B  1  D0 06                   bne NoColWrap
008D8D  1  8D 26 07                sta CurrentColumnPos     ;if no bits left set, wrap back to zero (0-f)
008D90  1  EE 25 07                inc CurrentPageLoc       ;and increment page number where we're at
008D93  1  EE A0 06     NoColWrap: inc BlockBufferColumnPos ;increment column offset where we're at
008D96  1  AD A0 06                lda BlockBufferColumnPos
008D99  1  29 1F                   and #%00011111           ;mask out all but 5 LSB (0-1f)
008D9B  1  8D A0 06                sta BlockBufferColumnPos ;and save
008D9E  1  60                      rts
008D9F  1               
008D9F  1               ;-------------------------------------------------------------------------------------
008D9F  1               ;$00 - used as counter, store for low nybble for background, ceiling byte for terrain
008D9F  1               ;$01 - used to store floor byte for terrain
008D9F  1               ;$07 - used to store terrain metatile
008D9F  1               ;$06-$07 - used to store block buffer address
008D9F  1               
008D9F  1               BSceneDataOffsets:
008D9F  1  00 30 60           .byte $00, $30, $60
008DA2  1               
008DA2  1               BackSceneryData:
008DA2  1  93 00 00 11     .byte $93, $00, $00, $11, $12, $12, $13, $00 ;clouds
008DA6  1  12 12 13 00  
008DAA  1  00 51 52 53     .byte $00, $51, $52, $53, $00, $00, $00, $00
008DAE  1  00 00 00 00  
008DB2  1  00 00 01 02     .byte $00, $00, $01, $02, $02, $03, $00, $00
008DB6  1  02 03 00 00  
008DBA  1  00 00 00 00     .byte $00, $00, $00, $00, $91, $92, $93, $00
008DBE  1  91 92 93 00  
008DC2  1  00 00 00 51     .byte $00, $00, $00, $51, $52, $53, $41, $42
008DC6  1  52 53 41 42  
008DCA  1  43 00 00 00     .byte $43, $00, $00, $00, $00, $00, $91, $92
008DCE  1  00 00 91 92  
008DD2  1               
008DD2  1  97 87 88 89     .byte $97, $87, $88, $89, $99, $00, $00, $00 ;mountains and bushes
008DD6  1  99 00 00 00  
008DDA  1  11 12 13 A4     .byte $11, $12, $13, $a4, $a5, $a5, $a5, $a6
008DDE  1  A5 A5 A5 A6  
008DE2  1  97 98 99 01     .byte $97, $98, $99, $01, $02, $03, $00, $a4
008DE6  1  02 03 00 A4  
008DEA  1  A5 A6 00 11     .byte $a5, $a6, $00, $11, $12, $12, $12, $13
008DEE  1  12 12 12 13  
008DF2  1  00 00 00 00     .byte $00, $00, $00, $00, $01, $02, $02, $03
008DF6  1  01 02 02 03  
008DFA  1  00 A4 A5 A5     .byte $00, $a4, $a5, $a5, $a6, $00, $00, $00
008DFE  1  A6 00 00 00  
008E02  1               
008E02  1  11 12 12 13     .byte $11, $12, $12, $13, $00, $00, $00, $00 ;trees and fences
008E06  1  00 00 00 00  
008E0A  1  00 00 00 9C     .byte $00, $00, $00, $9c, $00, $8b, $aa, $aa
008E0E  1  00 8B AA AA  
008E12  1  AA AA 11 12     .byte $aa, $aa, $11, $12, $13, $8b, $00, $9c
008E16  1  13 8B 00 9C  
008E1A  1  9C 00 00 01     .byte $9c, $00, $00, $01, $02, $03, $11, $12
008E1E  1  02 03 11 12  
008E22  1  12 13 00 00     .byte $12, $13, $00, $00, $00, $00, $aa, $aa
008E26  1  00 00 AA AA  
008E2A  1  9C AA 00 8B     .byte $9c, $aa, $00, $8b, $00, $01, $02, $03
008E2E  1  00 01 02 03  
008E32  1               
008E32  1               BackSceneryMetatiles:
008E32  1  80 83 00        .byte $80, $83, $00 ;cloud left
008E35  1  81 84 00        .byte $81, $84, $00 ;cloud middle
008E38  1  82 85 00        .byte $82, $85, $00 ;cloud right
008E3B  1  02 00 00        .byte $02, $00, $00 ;bush left
008E3E  1  03 00 00        .byte $03, $00, $00 ;bush middle
008E41  1  04 00 00        .byte $04, $00, $00 ;bush right
008E44  1  00 05 06        .byte $00, $05, $06 ;mountain left
008E47  1  07 06 0A        .byte $07, $06, $0a ;mountain middle
008E4A  1  00 08 09        .byte $00, $08, $09 ;mountain right
008E4D  1  4D 00 00        .byte $4d, $00, $00 ;fence
008E50  1  0D 0F 4E        .byte $0d, $0f, $4e ;tall tree
008E53  1  0E 4E 4E        .byte $0e, $4e, $4e ;short tree
008E56  1               
008E56  1               FSceneDataOffsets:
008E56  1  00 0D 1A           .byte $00, $0d, $1a
008E59  1               
008E59  1               ForeSceneryData:
008E59  1  86 87 87 87     .byte $86, $87, $87, $87, $87, $87, $87   ;in water
008E5D  1  87 87 87     
008E60  1  87 87 87 87     .byte $87, $87, $87, $87, $69, $69
008E64  1  69 69        
008E66  1               
008E66  1  00 00 00 00     .byte $00, $00, $00, $00, $00, $45, $47   ;wall
008E6A  1  00 45 47     
008E6D  1  47 47 47 47     .byte $47, $47, $47, $47, $00, $00
008E71  1  00 00        
008E73  1               
008E73  1  00 00 00 00     .byte $00, $00, $00, $00, $00, $00, $00   ;over water
008E77  1  00 00 00     
008E7A  1  00 00 00 00     .byte $00, $00, $00, $00, $86, $87
008E7E  1  86 87        
008E80  1               
008E80  1               TerrainMetatiles:
008E80  1  69 54 52 62        .byte $69, $54, $52, $62
008E84  1               
008E84  1               TerrainRenderBits:
008E84  1  00 00              .byte %00000000, %00000000 ;no ceiling or floor
008E86  1  00 18              .byte %00000000, %00011000 ;no ceiling, floor 2
008E88  1  01 18              .byte %00000001, %00011000 ;ceiling 1, floor 2
008E8A  1  07 18              .byte %00000111, %00011000 ;ceiling 3, floor 2
008E8C  1  0F 18              .byte %00001111, %00011000 ;ceiling 4, floor 2
008E8E  1  FF 18              .byte %11111111, %00011000 ;ceiling 8, floor 2
008E90  1  01 1F              .byte %00000001, %00011111 ;ceiling 1, floor 5
008E92  1  07 1F              .byte %00000111, %00011111 ;ceiling 3, floor 5
008E94  1  0F 1F              .byte %00001111, %00011111 ;ceiling 4, floor 5
008E96  1  81 1F              .byte %10000001, %00011111 ;ceiling 1, floor 6
008E98  1  01 00              .byte %00000001, %00000000 ;ceiling 1, no floor
008E9A  1  8F 1F              .byte %10001111, %00011111 ;ceiling 4, floor 6
008E9C  1  F1 1F              .byte %11110001, %00011111 ;ceiling 1, floor 9
008E9E  1  F9 18              .byte %11111001, %00011000 ;ceiling 1, middle 5, floor 2
008EA0  1  F1 18              .byte %11110001, %00011000 ;ceiling 1, middle 4, floor 2
008EA2  1  FF 1F              .byte %11111111, %00011111 ;completely solid top to bottom
008EA4  1               
008EA4  1               AreaParserCore:
008EA4  1  AD 28 07           lda BackloadingFlag       ;check to see if we are starting right of start
008EA7  1  F0 03              beq RenderSceneryTerrain  ;if not, go ahead and render background, foreground and terrain
008EA9  1  20 B0 8F           jsr ProcessAreaData       ;otherwise skip ahead and load level data
008EAC  1               
008EAC  1               RenderSceneryTerrain:
008EAC  1  A2 0C                  ldx #$0c
008EAE  1  A9 00                  lda #$00
008EB0  1  9D A1 06     ClrMTBuf: sta MetatileBuffer,x       ;clear out metatile buffer
008EB3  1  CA                     dex
008EB4  1  10 FA                  bpl ClrMTBuf
008EB6  1  AC 42 07               ldy BackgroundScenery      ;do we need to render the background scenery?
008EB9  1  F0 42                  beq RendFore               ;if not, skip to check the foreground
008EBB  1  AD 25 07               lda CurrentPageLoc         ;otherwise check for every third page
008EBE  1  C9 03        ThirdP:   cmp #$03
008EC0  1  30 05                  bmi RendBack               ;if less than three we're there
008EC2  1  38                     sec
008EC3  1  E9 03                  sbc #$03                   ;if 3 or more, subtract 3 and
008EC5  1  10 F7                  bpl ThirdP                 ;do an unconditional branch
008EC7  1  0A           RendBack: asl                        ;move results to higher nybble
008EC8  1  0A                     asl
008EC9  1  0A                     asl
008ECA  1  0A                     asl
008ECB  1  79 9E 8D               adc BSceneDataOffsets-1,y  ;add to it offset loaded from here
008ECE  1  6D 26 07               adc CurrentColumnPos       ;add to the result our current column position
008ED1  1  AA                     tax
008ED2  1  BD A2 8D               lda BackSceneryData,x      ;load data from sum of offsets
008ED5  1  F0 26                  beq RendFore               ;if zero, no scenery for that part
008ED7  1  48                     pha
008ED8  1  29 0F                  and #$0f                   ;save to stack and clear high nybble
008EDA  1  38                     sec
008EDB  1  E9 01                  sbc #$01                   ;subtract one (because low nybble is $01-$0c)
008EDD  1  85 00                  sta $00                    ;save low nybble
008EDF  1  0A                     asl                        ;multiply by three (shift to left and add result to old one)
008EE0  1  65 00                  adc $00                    ;note that since d7 was nulled, the carry flag is always clear
008EE2  1  AA                     tax                        ;save as offset for background scenery metatile data
008EE3  1  68                     pla                        ;get high nybble from stack, move low
008EE4  1  4A                     lsr
008EE5  1  4A                     lsr
008EE6  1  4A                     lsr
008EE7  1  4A                     lsr
008EE8  1  A8                     tay                        ;use as second offset (used to determine height)
008EE9  1  A9 03                  lda #$03                   ;use previously saved memory location for counter
008EEB  1  85 00                  sta $00
008EED  1  BD 32 8E     SceLoop1: lda BackSceneryMetatiles,x ;load metatile data from offset of (lsb - 1) * 3
008EF0  1  99 A1 06               sta MetatileBuffer,y       ;store into buffer from offset of (msb / 16)
008EF3  1  E8                     inx
008EF4  1  C8                     iny
008EF5  1  C0 0B                  cpy #$0b                   ;if at this location, leave loop
008EF7  1  F0 04                  beq RendFore
008EF9  1  C6 00                  dec $00                    ;decrement until counter expires, barring exception
008EFB  1  D0 F0                  bne SceLoop1
008EFD  1  AE 41 07     RendFore: ldx ForegroundScenery      ;check for foreground data needed or not
008F00  1  F0 13                  beq RendTerr               ;if not, skip this part
008F02  1  BC 55 8E               ldy FSceneDataOffsets-1,x  ;load offset from location offset by header value, then
008F05  1  A2 00                  ldx #$00                   ;reinit X
008F07  1  B9 59 8E     SceLoop2: lda ForeSceneryData,y      ;load data until counter expires
008F0A  1  F0 03                  beq NoFore                 ;do not store if zero found
008F0C  1  9D A1 06               sta MetatileBuffer,x
008F0F  1  C8           NoFore:   iny
008F10  1  E8                     inx
008F11  1  E0 0D                  cpx #$0d                   ;store up to end of metatile buffer
008F13  1  D0 F2                  bne SceLoop2
008F15  1  AC 4E 07     RendTerr: ldy AreaType               ;check world type for water level
008F18  1  D0 0C                  bne TerMTile               ;if not water level, skip this part
008F1A  1  AD 5F 07               lda WorldNumber            ;check world number, if not world number eight
008F1D  1  C9 07                  cmp #World8                ;then skip this part
008F1F  1  D0 05                  bne TerMTile
008F21  1  A9 62                  lda #$62                   ;if set as water level and world number eight,
008F23  1  4C 30 8F               jmp StoreMT                ;use castle wall metatile as terrain type
008F26  1  B9 80 8E     TerMTile: lda TerrainMetatiles,y     ;otherwise get appropriate metatile for area type
008F29  1  AC 43 07               ldy CloudTypeOverride      ;check for cloud type override
008F2C  1  F0 02                  beq StoreMT                ;if not set, keep value otherwise
008F2E  1  A9 88                  lda #$88                   ;use cloud block terrain
008F30  1  85 07        StoreMT:  sta $07                    ;store value here
008F32  1  A2 00                  ldx #$00                   ;initialize X, use as metatile buffer offset
008F34  1  AD 27 07               lda TerrainControl         ;use yet another value from the header
008F37  1  0A                     asl                        ;multiply by 2 and use as yet another offset
008F38  1  A8                     tay
008F39  1  B9 84 8E     TerrLoop: lda TerrainRenderBits,y    ;get one of the terrain rendering bit data
008F3C  1  85 00                  sta $00
008F3E  1  C8                     iny                        ;increment Y and use as offset next time around
008F3F  1  84 01                  sty $01
008F41  1  AD 43 07               lda CloudTypeOverride      ;skip if value here is zero
008F44  1  F0 0A                  beq NoCloud2
008F46  1  E0 00                  cpx #$00                   ;otherwise, check if we're doing the ceiling byte
008F48  1  F0 06                  beq NoCloud2
008F4A  1  A5 00                  lda $00                    ;if not, mask out all but d3
008F4C  1  29 08                  and #%00001000
008F4E  1  85 00                  sta $00
008F50  1  A0 00        NoCloud2: ldy #$00                   ;start at beginning of bitmasks
008F52  1  B9 3E B7     TerrBChk: lda Bitmasks,y             ;load bitmask, then perform AND on contents of first byte
008F55  1  24 00                  bit $00
008F57  1  F0 05                  beq NextTBit               ;if not set, skip this part (do not write terrain to buffer)
008F59  1  A5 07                  lda $07
008F5B  1  9D A1 06               sta MetatileBuffer,x       ;load terrain type metatile number and store into buffer here
008F5E  1  E8           NextTBit: inx                        ;continue until end of buffer
008F5F  1  E0 0D                  cpx #$0d
008F61  1  F0 18                  beq RendBBuf               ;if we're at the end, break out of this loop
008F63  1  AD 4E 07               lda AreaType               ;check world type for underground area
008F66  1  C9 02                  cmp #$02
008F68  1  D0 08                  bne EndUChk                ;if not underground, skip this part
008F6A  1  E0 0B                  cpx #$0b
008F6C  1  D0 04                  bne EndUChk                ;if we're at the bottom of the screen, override
008F6E  1  A9 54                  lda #$54                   ;old terrain type with ground level terrain type
008F70  1  85 07                  sta $07
008F72  1  C8           EndUChk:  iny                        ;increment bitmasks offset in Y
008F73  1  C0 08                  cpy #$08
008F75  1  D0 DB                  bne TerrBChk               ;if not all bits checked, loop back
008F77  1  A4 01                  ldy $01
008F79  1  D0 BE                  bne TerrLoop               ;unconditional branch, use Y to load next byte
008F7B  1  20 B0 8F     RendBBuf: jsr ProcessAreaData        ;do the area data loading routine now
008F7E  1  AD A0 06               lda BlockBufferColumnPos
008F81  1  20 66 ED               jsr GetBlockBufferAddr     ;get block buffer address from where we're at
008F84  1  A2 00                  ldx #$00
008F86  1  A0 00                  ldy #$00                   ;init index regs and start at beginning of smaller buffer
008F88  1  84 00        ChkMTLow: sty $00
008F8A  1  BD A1 06               lda MetatileBuffer,x       ;load stored metatile number
008F8D  1  29 C0                  and #%11000000             ;mask out all but 2 MSB
008F8F  1  0A                     asl
008F90  1  2A                     rol                        ;make %xx000000 into %000000xx
008F91  1  2A                     rol
008F92  1  A8                     tay                        ;use as offset in Y
008F93  1  BD A1 06               lda MetatileBuffer,x       ;reload original unmasked value here
008F96  1  D9 AC 8F               cmp BlockBuffLowBounds,y   ;check for certain values depending on bits set
008F99  1  B0 02                  bcs StrBlock               ;if equal or greater, branch
008F9B  1  A9 00                  lda #$00                   ;if less, init value before storing
008F9D  1  A4 00        StrBlock: ldy $00                    ;get offset for block buffer
008F9F  1  91 06                  sta ($06),y                ;store value into block buffer
008FA1  1  98                     tya
008FA2  1  18                     clc                        ;add 16 (move down one row) to offset
008FA3  1  69 10                  adc #$10
008FA5  1  A8                     tay
008FA6  1  E8                     inx                        ;increment column value
008FA7  1  E0 0D                  cpx #$0d
008FA9  1  90 DD                  bcc ChkMTLow               ;continue until we pass last row, then leave
008FAB  1  60                     rts
008FAC  1               
008FAC  1               ;numbers lower than these with the same attribute bits
008FAC  1               ;will not be stored in the block buffer
008FAC  1               BlockBuffLowBounds:
008FAC  1  10 51 88 C0        .byte $10, $51, $88, $c0
008FB0  1               
008FB0  1               ;-------------------------------------------------------------------------------------
008FB0  1               ;$00 - used to store area object identifier
008FB0  1               ;$07 - used as adder to find proper area object code
008FB0  1               
008FB0  1               ProcessAreaData:
008FB0  1  A2 02                    ldx #$02                 ;start at the end of area object buffer
008FB2  1  86 08        ProcADLoop: stx ObjectOffset
008FB4  1  A9 00                    lda #$00                 ;reset flag
008FB6  1  8D 29 07                 sta BehindAreaParserFlag
008FB9  1  AC 2C 07                 ldy AreaDataOffset       ;get offset of area data pointer
008FBC  1  B1 E7                    lda (AreaData),y         ;get first byte of area object
008FBE  1  C9 FD                    cmp #$fd                 ;if end-of-area, skip all this crap
008FC0  1  F0 4B                    beq RdyDecode
008FC2  1  BD 30 07                 lda AreaObjectLength,x   ;check area object buffer flag
008FC5  1  10 46                    bpl RdyDecode            ;if buffer not negative, branch, otherwise
008FC7  1  C8                       iny
008FC8  1  B1 E7                    lda (AreaData),y         ;get second byte of area object
008FCA  1  0A                       asl                      ;check for page select bit (d7), branch if not set
008FCB  1  90 0B                    bcc Chk1Row13
008FCD  1  AD 2B 07                 lda AreaObjectPageSel    ;check page select
008FD0  1  D0 06                    bne Chk1Row13
008FD2  1  EE 2B 07                 inc AreaObjectPageSel    ;if not already set, set it now
008FD5  1  EE 2A 07                 inc AreaObjectPageLoc    ;and increment page location
008FD8  1  88           Chk1Row13:  dey
008FD9  1  B1 E7                    lda (AreaData),y         ;reread first byte of level object
008FDB  1  29 0F                    and #$0f                 ;mask out high nybble
008FDD  1  C9 0D                    cmp #$0d                 ;row 13?
008FDF  1  D0 1B                    bne Chk1Row14
008FE1  1  C8                       iny                      ;if so, reread second byte of level object
008FE2  1  B1 E7                    lda (AreaData),y
008FE4  1  88                       dey                      ;decrement to get ready to read first byte
008FE5  1  29 40                    and #%01000000           ;check for d6 set (if not, object is page control)
008FE7  1  D0 1C                    bne CheckRear
008FE9  1  AD 2B 07                 lda AreaObjectPageSel    ;if page select is set, do not reread
008FEC  1  D0 17                    bne CheckRear
008FEE  1  C8                       iny                      ;if d6 not set, reread second byte
008FEF  1  B1 E7                    lda (AreaData),y
008FF1  1  29 1F                    and #%00011111           ;mask out all but 5 LSB and store in page control
008FF3  1  8D 2A 07                 sta AreaObjectPageLoc
008FF6  1  EE 2B 07                 inc AreaObjectPageSel    ;increment page select
008FF9  1  4C 16 90                 jmp NextAObj
008FFC  1  C9 0E        Chk1Row14:  cmp #$0e                 ;row 14?
008FFE  1  D0 05                    bne CheckRear
009000  1  AD 28 07                 lda BackloadingFlag      ;check flag for saved page number and branch if set
009003  1  D0 08                    bne RdyDecode            ;to render the object (otherwise bg might not look right)
009005  1  AD 2A 07     CheckRear:  lda AreaObjectPageLoc    ;check to see if current page of level object is
009008  1  CD 25 07                 cmp CurrentPageLoc       ;behind current page of renderer
00900B  1  90 06                    bcc SetBehind            ;if so branch
00900D  1  20 3D 90     RdyDecode:  jsr DecodeAreaData       ;do sub and do not turn on flag
009010  1  4C 19 90                 jmp ChkLength
009013  1  EE 29 07     SetBehind:  inc BehindAreaParserFlag ;turn on flag if object is behind renderer
009016  1  20 31 90     NextAObj:   jsr IncAreaObjOffset     ;increment buffer offset and move on
009019  1  A6 08        ChkLength:  ldx ObjectOffset         ;get buffer offset
00901B  1  BD 30 07                 lda AreaObjectLength,x   ;check object length for anything stored here
00901E  1  30 03                    bmi ProcLoopb            ;if not, branch to handle loopback
009020  1  DE 30 07                 dec AreaObjectLength,x   ;otherwise decrement length or get rid of it
009023  1  CA           ProcLoopb:  dex                      ;decrement buffer offset
009024  1  10 8C                    bpl ProcADLoop           ;and loopback unless exceeded buffer
009026  1  AD 29 07                 lda BehindAreaParserFlag ;check for flag set if objects were behind renderer
009029  1  D0 85                    bne ProcessAreaData      ;branch if true to load more level data, otherwise
00902B  1  AD 28 07                 lda BackloadingFlag      ;check for flag set if starting right of page $00
00902E  1  D0 80                    bne ProcessAreaData      ;branch if true to load more level data, otherwise leave
009030  1  60           EndAParse:  rts
009031  1               
009031  1               IncAreaObjOffset:
009031  1  EE 2C 07           inc AreaDataOffset    ;increment offset of level pointer
009034  1  EE 2C 07           inc AreaDataOffset
009037  1  A9 00              lda #$00              ;reset page select
009039  1  8D 2B 07           sta AreaObjectPageSel
00903C  1  60                 rts
00903D  1               
00903D  1               DecodeAreaData:
00903D  1  BD 30 07               lda AreaObjectLength,x     ;check current buffer flag
009040  1  30 03                  bmi Chk1stB
009042  1  BC 2D 07               ldy AreaObjOffsetBuffer,x  ;if not, get offset from buffer
009045  1  A2 10        Chk1stB:  ldx #$10                   ;load offset of 16 for special row 15
009047  1  B1 E7                  lda (AreaData),y           ;get first byte of level object again
009049  1  C9 FD                  cmp #$fd
00904B  1  F0 E3                  beq EndAParse              ;if end of level, leave this routine
00904D  1  29 0F                  and #$0f                   ;otherwise, mask out low nybble
00904F  1  C9 0F                  cmp #$0f                   ;row 15?
009051  1  F0 08                  beq ChkRow14               ;if so, keep the offset of 16
009053  1  A2 08                  ldx #$08                   ;otherwise load offset of 8 for special row 12
009055  1  C9 0C                  cmp #$0c                   ;row 12?
009057  1  F0 02                  beq ChkRow14               ;if so, keep the offset value of 8
009059  1  A2 00                  ldx #$00                   ;otherwise nullify value by default
00905B  1  86 07        ChkRow14: stx $07                    ;store whatever value we just loaded here
00905D  1  A6 08                  ldx ObjectOffset           ;get object offset again
00905F  1  C9 0E                  cmp #$0e                   ;row 14?
009061  1  D0 08                  bne ChkRow13
009063  1  A9 00                  lda #$00                   ;if so, load offset with $00
009065  1  85 07                  sta $07
009067  1  A9 2E                  lda #$2e                   ;and load A with another value
009069  1  D0 53                  bne NormObj                ;unconditional branch
00906B  1  C9 0D        ChkRow13: cmp #$0d                   ;row 13?
00906D  1  D0 1B                  bne ChkSRows
00906F  1  A9 22                  lda #$22                   ;if so, load offset with 34
009071  1  85 07                  sta $07
009073  1  C8                     iny                        ;get next byte
009074  1  B1 E7                  lda (AreaData),y
009076  1  29 40                  and #%01000000             ;mask out all but d6 (page control obj bit)
009078  1  F0 63                  beq LeavePar               ;if d6 clear, branch to leave (we handled this earlier)
00907A  1  B1 E7                  lda (AreaData),y           ;otherwise, get byte again
00907C  1  29 7F                  and #%01111111             ;mask out d7
00907E  1  C9 4B                  cmp #$4b                   ;check for loop command in low nybble
009080  1  D0 03                  bne Mask2MSB               ;(plus d6 set for object other than page control)
009082  1  EE 45 07               inc LoopCommand            ;if loop command, set loop command flag
009085  1  29 3F        Mask2MSB: and #%00111111             ;mask out d7 and d6
009087  1  4C BE 90               jmp NormObj                ;and jump
00908A  1  C9 0C        ChkSRows: cmp #$0c                   ;row 12-15?
00908C  1  B0 27                  bcs SpecObj
00908E  1  C8                     iny                        ;if not, get second byte of level object
00908F  1  B1 E7                  lda (AreaData),y
009091  1  29 70                  and #%01110000             ;mask out all but d6-d4
009093  1  D0 0B                  bne LrgObj                 ;if any bits set, branch to handle large object
009095  1  A9 16                  lda #$16
009097  1  85 07                  sta $07                    ;otherwise set offset of 24 for small object
009099  1  B1 E7                  lda (AreaData),y           ;reload second byte of level object
00909B  1  29 0F                  and #%00001111             ;mask out higher nybble and jump
00909D  1  4C BE 90               jmp NormObj
0090A0  1  85 00        LrgObj:   sta $00                    ;store value here (branch for large objects)
0090A2  1  C9 70                  cmp #$70                   ;check for vertical pipe object
0090A4  1  D0 0A                  bne NotWPipe
0090A6  1  B1 E7                  lda (AreaData),y           ;if not, reload second byte
0090A8  1  29 08                  and #%00001000             ;mask out all but d3 (usage control bit)
0090AA  1  F0 04                  beq NotWPipe               ;if d3 clear, branch to get original value
0090AC  1  A9 00                  lda #$00                   ;otherwise, nullify value for warp pipe
0090AE  1  85 00                  sta $00
0090B0  1  A5 00        NotWPipe: lda $00                    ;get value and jump ahead
0090B2  1  4C BA 90               jmp MoveAOId
0090B5  1  C8           SpecObj:  iny                        ;branch here for rows 12-15
0090B6  1  B1 E7                  lda (AreaData),y
0090B8  1  29 70                  and #%01110000             ;get next byte and mask out all but d6-d4
0090BA  1  4A           MoveAOId: lsr                        ;move d6-d4 to lower nybble
0090BB  1  4A                     lsr
0090BC  1  4A                     lsr
0090BD  1  4A                     lsr
0090BE  1  85 00        NormObj:  sta $00                    ;store value here (branch for small objects and rows 13 and 14)
0090C0  1  BD 30 07               lda AreaObjectLength,x     ;is there something stored here already?
0090C3  1  10 42                  bpl RunAObj                ;if so, branch to do its particular sub
0090C5  1  AD 2A 07               lda AreaObjectPageLoc      ;otherwise check to see if the object we've loaded is on the
0090C8  1  CD 25 07               cmp CurrentPageLoc         ;same page as the renderer, and if so, branch
0090CB  1  F0 11                  beq InitRear
0090CD  1  AC 2C 07               ldy AreaDataOffset         ;if not, get old offset of level pointer
0090D0  1  B1 E7                  lda (AreaData),y           ;and reload first byte
0090D2  1  29 0F                  and #%00001111
0090D4  1  C9 0E                  cmp #$0e                   ;row 14?
0090D6  1  D0 05                  bne LeavePar
0090D8  1  AD 28 07               lda BackloadingFlag        ;if so, check backloading flag
0090DB  1  D0 21                  bne StrAObj                ;if set, branch to render object, else leave
0090DD  1  60           LeavePar: rts
0090DE  1  AD 28 07     InitRear: lda BackloadingFlag        ;check backloading flag to see if it's been initialized
0090E1  1  F0 0B                  beq BackColC               ;branch to column-wise check
0090E3  1  A9 00                  lda #$00                   ;if not, initialize both backloading and
0090E5  1  8D 28 07               sta BackloadingFlag        ;behind-renderer flags and leave
0090E8  1  8D 29 07               sta BehindAreaParserFlag
0090EB  1  85 08                  sta ObjectOffset
0090ED  1  60           LoopCmdE: rts
0090EE  1  AC 2C 07     BackColC: ldy AreaDataOffset         ;get first byte again
0090F1  1  B1 E7                  lda (AreaData),y
0090F3  1  29 F0                  and #%11110000             ;mask out low nybble and move high to low
0090F5  1  4A                     lsr
0090F6  1  4A                     lsr
0090F7  1  4A                     lsr
0090F8  1  4A                     lsr
0090F9  1  CD 26 07               cmp CurrentColumnPos       ;is this where we're at?
0090FC  1  D0 DF                  bne LeavePar               ;if not, branch to leave
0090FE  1  AD 2C 07     StrAObj:  lda AreaDataOffset         ;if so, load area obj offset and store in buffer
009101  1  9D 2D 07               sta AreaObjOffsetBuffer,x
009104  1  20 31 90               jsr IncAreaObjOffset       ;do sub to increment to next object data
009107  1  A5 00        RunAObj:  lda $00                    ;get stored value and add offset to it
009109  1  18                     clc                        ;then use the jump engine with current contents of A
00910A  1  65 07                  adc $07
00910C  1  20 A8 BA               jsr JumpEngine
00910F  1               
00910F  1               ;large objects (rows $00-$0b or 00-11, d6-d4 set)
00910F  1  7B 93              .word VerticalPipe         ;used by warp pipes
009111  1  D6 91              .word AreaStyleObject
009113  1  C4 94              .word RowOfBricks
009115  1  D4 94              .word RowOfSolidBlocks
009117  1  88 94              .word RowOfCoins
009119  1  E6 94              .word ColumnOfBricks
00911B  1  EF 94              .word ColumnOfSolidBlocks
00911D  1  7B 93              .word VerticalPipe         ;used by decoration pipes
00911F  1               
00911F  1               ;objects for special row $0c or 12
00911F  1  D7 95              .word Hole_Empty
009121  1  50 92              .word PulleyRopeObject
009123  1  0F 94              .word Bridge_High
009125  1  12 94              .word Bridge_Middle
009127  1  15 94              .word Bridge_Low
009129  1  ED 93              .word Hole_Water
00912B  1  FE 93              .word QuestionBlockRow_High
00912D  1  01 94              .word QuestionBlockRow_Low
00912F  1               
00912F  1               ;objects for special row $0f or 15
00912F  1  66 94              .word EndlessRope
009131  1  6D 94              .word BalancePlatRope
009133  1  9C 92              .word CastleObject
009135  1  4D 95              .word StaircaseObject
009137  1  41 93              .word ExitPipe
009139  1  2A 94              .word FlagBalls_Residual
00913B  1               
00913B  1               ;small objects (rows $00-$0b or 00-11, d6-d4 all clear)
00913B  1  A4 95              .word QuestionBlock     ;power-up
00913D  1  A4 95              .word QuestionBlock     ;coin
00913F  1  A4 95              .word QuestionBlock     ;hidden, coin
009141  1  97 95              .word Hidden1UpBlock    ;hidden, 1-up
009143  1  AF 95              .word BrickWithItem     ;brick, power-up
009145  1  AF 95              .word BrickWithItem     ;brick, vine
009147  1  AF 95              .word BrickWithItem     ;brick, star
009149  1  AA 95              .word BrickWithCoins    ;brick, coins
00914B  1  AF 95              .word BrickWithItem     ;brick, 1-up
00914D  1  05 93              .word WaterPipe
00914F  1  AF 94              .word EmptyBlock
009151  1  69 95              .word Jumpspring
009153  1               
009153  1               ;objects for special row $0d or 13 (d6 set)
009153  1  18 93              .word IntroPipe
009155  1  34 94              .word FlagpoleObject
009157  1  9F 94              .word AxeObj
009159  1  A4 94              .word ChainObj
00915B  1  97 94              .word CastleBridgeObj
00915D  1  9A 91              .word ScrollLockObject_Warp
00915F  1  B5 91              .word ScrollLockObject
009161  1  B5 91              .word ScrollLockObject
009163  1  C1 91              .word AreaFrenzy            ;flying cheep-cheeps
009165  1  C1 91              .word AreaFrenzy            ;bullet bills or swimming cheep-cheeps
009167  1  C1 91              .word AreaFrenzy            ;stop frenzy
009169  1  ED 90              .word LoopCmdE
00916B  1               
00916B  1               ;object for special row $0e or 14
00916B  1  6D 91              .word AlterAreaAttributes
00916D  1               
00916D  1               ;-------------------------------------------------------------------------------------
00916D  1               ;(these apply to all area object subroutines in this section unless otherwise stated)
00916D  1               ;$00 - used to store offset used to find object code
00916D  1               ;$07 - starts with adder from area parser, used to store row offset
00916D  1               
00916D  1               AlterAreaAttributes:
00916D  1  BC 2D 07              ldy AreaObjOffsetBuffer,x ;load offset for level object data saved in buffer
009170  1  C8                    iny                       ;load second byte
009171  1  B1 E7                 lda (AreaData),y
009173  1  48                    pha                       ;save in stack for now
009174  1  29 40                 and #%01000000
009176  1  D0 12                 bne Alter2                ;branch if d6 is set
009178  1  68                    pla
009179  1  48                    pha                       ;pull and push offset to copy to A
00917A  1  29 0F                 and #%00001111            ;mask out high nybble and store as
00917C  1  8D 27 07              sta TerrainControl        ;new terrain height type bits
00917F  1  68                    pla
009180  1  29 30                 and #%00110000            ;pull and mask out all but d5 and d4
009182  1  4A                    lsr                       ;move bits to lower nybble and store
009183  1  4A                    lsr                       ;as new background scenery bits
009184  1  4A                    lsr
009185  1  4A                    lsr
009186  1  8D 42 07              sta BackgroundScenery     ;then leave
009189  1  60                    rts
00918A  1  68           Alter2:  pla
00918B  1  29 07                 and #%00000111            ;mask out all but 3 LSB
00918D  1  C9 04                 cmp #$04                  ;if four or greater, set color control bits
00918F  1  90 05                 bcc SetFore               ;and nullify foreground scenery bits
009191  1  8D 44 07              sta BackgroundColorCtrl
009194  1  A9 00                 lda #$00
009196  1  8D 41 07     SetFore: sta ForegroundScenery     ;otherwise set new foreground scenery bits
009199  1  60                    rts
00919A  1               
00919A  1               ;--------------------------------
00919A  1               
00919A  1               ScrollLockObject_Warp:
00919A  1  A2 04                 ldx #$04            ;load value of 4 for game text routine as default
00919C  1  AD 5F 07              lda WorldNumber     ;warp zone (4-3-2), then check world number
00919F  1  F0 08                 beq WarpNum
0091A1  1  E8                    inx                 ;if world number > 1, increment for next warp zone (5)
0091A2  1  AC 4E 07              ldy AreaType        ;check area type
0091A5  1  88                    dey
0091A6  1  D0 01                 bne WarpNum         ;if ground area type, increment for last warp zone
0091A8  1  E8                    inx                 ;(8-7-6) and move on
0091A9  1  8A           WarpNum: txa
0091AA  1  8D D6 06              sta WarpZoneControl ;store number here to be used by warp zone routine
0091AD  1  20 64 86              jsr WriteGameText   ;print text and warp zone numbers
0091B0  1  A9 0D                 lda #PiranhaPlant
0091B2  1  20 A6 ED              jsr KillEnemies     ;load identifier for piranha plants and do sub
0091B5  1               
0091B5  1               ScrollLockObject:
0091B5  1  AD 23 07           lda ScrollLock      ;invert scroll lock to turn it on
0091B8  1  49 01              eor #%00000001
0091BA  1  8D 23 07           sta ScrollLock
0091BD  1  60                 rts
0091BE  1               
0091BE  1               ;--------------------------------
0091BE  1               
0091BE  1               FrenzyIDData:
0091BE  1  14 17 18           .byte FlyCheepCheepFrenzy, BBill_CCheep_Frenzy, Stop_Frenzy
0091C1  1               
0091C1  1  A6 00        AreaFrenzy:  ldx $00               ;use area object identifier bit as offset
0091C3  1  BD B6 91                  lda FrenzyIDData-8,x  ;note that it starts at 8, thus weird address here
0091C6  1  A0 05                     ldy #$05
0091C8  1  88           FreCompLoop: dey                   ;check regular slots of enemy object buffer
0091C9  1  30 07                     bmi ExitAFrenzy       ;if all slots checked and enemy object not found, branch to store
0091CB  1  D9 16 00                  cmp Enemy_ID,y    ;check for enemy object in buffer versus frenzy object
0091CE  1  D0 F8                     bne FreCompLoop
0091D0  1  A9 00                     lda #$00              ;if enemy object already present, nullify queue and leave
0091D2  1  8D CD 06     ExitAFrenzy: sta EnemyFrenzyQueue  ;store enemy into frenzy queue
0091D5  1  60                        rts
0091D6  1               
0091D6  1               ;--------------------------------
0091D6  1               ;$06 - used by MushroomLedge to store length
0091D6  1               
0091D6  1               AreaStyleObject:
0091D6  1  AD 33 07           lda AreaStyle        ;load level object style and jump to the right sub
0091D9  1  20 A8 BA           jsr JumpEngine
0091DC  1  E2 91              .word TreeLedge        ;also used for cloud type levels
0091DE  1  0E 92              .word MushroomLedge
0091E0  1  FF 94              .word BulletBillCannon
0091E2  1               
0091E2  1               TreeLedge:
0091E2  1  20 51 96               jsr GetLrgObjAttrib     ;get row and length of green ledge
0091E5  1  BD 30 07               lda AreaObjectLength,x  ;check length counter for expiration
0091E8  1  F0 1F                  beq EndTreeL
0091EA  1  10 11                  bpl MidTreeL
0091EC  1  98                     tya
0091ED  1  9D 30 07               sta AreaObjectLength,x  ;store lower nybble into buffer flag as length of ledge
0091F0  1  AD 25 07               lda CurrentPageLoc
0091F3  1  0D 26 07               ora CurrentColumnPos    ;are we at the start of the level?
0091F6  1  F0 05                  beq MidTreeL
0091F8  1  A9 16                  lda #$16                ;render start of tree ledge
0091FA  1  4C 46 92               jmp NoUnder
0091FD  1  A6 07        MidTreeL: ldx $07
0091FF  1  A9 17                  lda #$17                ;render middle of tree ledge
009201  1  9D A1 06               sta MetatileBuffer,x    ;note that this is also used if ledge position is
009204  1  A9 4C                  lda #$4c                ;at the start of level for continuous effect
009206  1  4C 40 92               jmp AllUnder            ;now render the part underneath
009209  1  A9 18        EndTreeL: lda #$18                ;render end of tree ledge
00920B  1  4C 46 92               jmp NoUnder
00920E  1               
00920E  1               MushroomLedge:
00920E  1  20 42 96               jsr ChkLrgObjLength        ;get shroom dimensions
009211  1  84 06                  sty $06                    ;store length here for now
009213  1  90 0C                  bcc EndMushL
009215  1  BD 30 07               lda AreaObjectLength,x     ;divide length by 2 and store elsewhere
009218  1  4A                     lsr
009219  1  9D 36 07               sta MushroomLedgeHalfLen,x
00921C  1  A9 19                  lda #$19                   ;render start of mushroom
00921E  1  4C 46 92               jmp NoUnder
009221  1  A9 1B        EndMushL: lda #$1b                   ;if at the end, render end of mushroom
009223  1  BC 30 07               ldy AreaObjectLength,x
009226  1  F0 1E                  beq NoUnder
009228  1  BD 36 07               lda MushroomLedgeHalfLen,x ;get divided length and store where length
00922B  1  85 06                  sta $06                    ;was stored originally
00922D  1  A6 07                  ldx $07
00922F  1  A9 1A                  lda #$1a
009231  1  9D A1 06               sta MetatileBuffer,x       ;render middle of mushroom
009234  1  C4 06                  cpy $06                    ;are we smack dab in the center?
009236  1  D0 2C                  bne MushLExit              ;if not, branch to leave
009238  1  E8                     inx
009239  1  A9 4F                  lda #$4f
00923B  1  9D A1 06               sta MetatileBuffer,x       ;render stem top of mushroom underneath the middle
00923E  1  A9 50                  lda #$50
009240  1  E8           AllUnder: inx
009241  1  A0 0F                  ldy #$0f                   ;set $0f to render all way down
009243  1  4C 13 96               jmp RenderUnderPart       ;now render the stem of mushroom
009246  1  A6 07        NoUnder:  ldx $07                    ;load row of ledge
009248  1  A0 00                  ldy #$00                   ;set 0 for no bottom on this part
00924A  1  4C 13 96               jmp RenderUnderPart
00924D  1               
00924D  1               ;--------------------------------
00924D  1               
00924D  1               ;tiles used by pulleys and rope object
00924D  1               PulleyRopeMetatiles:
00924D  1  42 41 43           .byte $42, $41, $43
009250  1               
009250  1               PulleyRopeObject:
009250  1  20 42 96                jsr ChkLrgObjLength       ;get length of pulley/rope object
009253  1  A0 00                   ldy #$00                  ;initialize metatile offset
009255  1  B0 07                   bcs RenderPul             ;if starting, render left pulley
009257  1  C8                      iny
009258  1  BD 30 07                lda AreaObjectLength,x    ;if not at the end, render rope
00925B  1  D0 01                   bne RenderPul
00925D  1  C8                      iny                       ;otherwise render right pulley
00925E  1  B9 4D 92     RenderPul: lda PulleyRopeMetatiles,y
009261  1  8D A1 06                sta MetatileBuffer        ;render at the top of the screen
009264  1  60           MushLExit: rts                       ;and leave
009265  1               
009265  1               ;--------------------------------
009265  1               ;$06 - used to store upper limit of rows for CastleObject
009265  1               
009265  1               CastleMetatiles:
009265  1  00 45 45 45        .byte $00, $45, $45, $45, $00
009269  1  00           
00926A  1  00 48 47 46        .byte $00, $48, $47, $46, $00
00926E  1  00           
00926F  1  45 49 49 49        .byte $45, $49, $49, $49, $45
009273  1  45           
009274  1  47 47 4A 47        .byte $47, $47, $4a, $47, $47
009278  1  47           
009279  1  47 47 4B 47        .byte $47, $47, $4b, $47, $47
00927D  1  47           
00927E  1  49 49 49 49        .byte $49, $49, $49, $49, $49
009282  1  49           
009283  1  47 4A 47 4A        .byte $47, $4a, $47, $4a, $47
009287  1  47           
009288  1  47 4B 47 4B        .byte $47, $4b, $47, $4b, $47
00928C  1  47           
00928D  1  47 47 47 47        .byte $47, $47, $47, $47, $47
009291  1  47           
009292  1  4A 47 4A 47        .byte $4a, $47, $4a, $47, $4a
009296  1  4A           
009297  1  4B 47 4B 47        .byte $4b, $47, $4b, $47, $4b
00929B  1  4B           
00929C  1               
00929C  1               CastleObject:
00929C  1  20 51 96                 jsr GetLrgObjAttrib      ;save lower nybble as starting row
00929F  1  84 07                    sty $07                  ;if starting row is above $0a, game will crash!!!
0092A1  1  A0 04                    ldy #$04
0092A3  1  20 45 96                 jsr ChkLrgObjFixedLength ;load length of castle if not already loaded
0092A6  1  8A                       txa
0092A7  1  48                       pha                      ;save obj buffer offset to stack
0092A8  1  BC 30 07                 ldy AreaObjectLength,x   ;use current length as offset for castle data
0092AB  1  A6 07                    ldx $07                  ;begin at starting row
0092AD  1  A9 0B                    lda #$0b
0092AF  1  85 06                    sta $06                  ;load upper limit of number of rows to print
0092B1  1  B9 65 92     CRendLoop:  lda CastleMetatiles,y    ;load current byte using offset
0092B4  1  9D A1 06                 sta MetatileBuffer,x
0092B7  1  E8                       inx                      ;store in buffer and increment buffer offset
0092B8  1  A5 06                    lda $06
0092BA  1  F0 07                    beq ChkCFloor            ;have we reached upper limit yet?
0092BC  1  C8                       iny                      ;if not, increment column-wise
0092BD  1  C8                       iny                      ;to byte in next row
0092BE  1  C8                       iny
0092BF  1  C8                       iny
0092C0  1  C8                       iny
0092C1  1  C6 06                    dec $06                  ;move closer to upper limit
0092C3  1  E0 0B        ChkCFloor:  cpx #$0b                 ;have we reached the row just before floor?
0092C5  1  D0 EA                    bne CRendLoop            ;if not, go back and do another row
0092C7  1  68                       pla
0092C8  1  AA                       tax                      ;get obj buffer offset from before
0092C9  1  AD 25 07                 lda CurrentPageLoc
0092CC  1  F0 36                    beq ExitCastle           ;if we're at page 0, we do not need to do anything else
0092CE  1  BD 30 07                 lda AreaObjectLength,x   ;check length
0092D1  1  C9 01                    cmp #$01                 ;if length almost about to expire, put brick at floor
0092D3  1  F0 2A                    beq PlayerStop
0092D5  1  A4 07                    ldy $07                  ;check starting row for tall castle ($00)
0092D7  1  D0 04                    bne NotTall
0092D9  1  C9 03                    cmp #$03                 ;if found, then check to see if we're at the second column
0092DB  1  F0 22                    beq PlayerStop
0092DD  1  C9 02        NotTall:    cmp #$02                 ;if not tall castle, check to see if we're at the third column
0092DF  1  D0 23                    bne ExitCastle           ;if we aren't and the castle is tall, don't create flag yet
0092E1  1  20 61 96                 jsr GetAreaObjXPosition  ;otherwise, obtain and save horizontal pixel coordinate
0092E4  1  48                       pha
0092E5  1  20 E0 93                 jsr FindEmptyEnemySlot   ;find an empty place on the enemy object buffer
0092E8  1  68                       pla
0092E9  1  95 87                    sta Enemy_X_Position,x   ;then write horizontal coordinate for star flag
0092EB  1  AD 25 07                 lda CurrentPageLoc
0092EE  1  95 6E                    sta Enemy_PageLoc,x      ;set page location for star flag
0092F0  1  A9 01                    lda #$01
0092F2  1  95 B6                    sta Enemy_Y_HighPos,x    ;set vertical high byte
0092F4  1  95 0F                    sta Enemy_Flag,x         ;set flag for buffer
0092F6  1  A9 90                    lda #$90
0092F8  1  95 CF                    sta Enemy_Y_Position,x   ;set vertical coordinate
0092FA  1  A9 31                    lda #StarFlagObject      ;set star flag value in buffer itself
0092FC  1  95 16                    sta Enemy_ID,x
0092FE  1  60                       rts
0092FF  1  A0 52        PlayerStop: ldy #$52                 ;put brick at floor to stop player at end of level
009301  1  8C AB 06                 sty MetatileBuffer+10    ;this is only done if we're on the second column
009304  1  60           ExitCastle: rts
009305  1               
009305  1               ;--------------------------------
009305  1               
009305  1               WaterPipe:
009305  1  20 51 96           jsr GetLrgObjAttrib     ;get row and lower nybble
009308  1  BC 30 07           ldy AreaObjectLength,x  ;get length (residual code, water pipe is 1 col thick)
00930B  1  A6 07              ldx $07                 ;get row
00930D  1  A9 6B              lda #$6b
00930F  1  9D A1 06           sta MetatileBuffer,x    ;draw something here and below it
009312  1  A9 6C              lda #$6c
009314  1  9D A2 06           sta MetatileBuffer+1,x
009317  1  60                 rts
009318  1               
009318  1               ;--------------------------------
009318  1               ;$05 - used to store length of vertical shaft in RenderSidewaysPipe
009318  1               ;$06 - used to store leftover horizontal length in RenderSidewaysPipe
009318  1               ; and vertical length in VerticalPipe and GetPipeHeight
009318  1               
009318  1               IntroPipe:
009318  1  A0 03                       ldy #$03                 ;check if length set, if not set, set it
00931A  1  20 45 96                    jsr ChkLrgObjFixedLength
00931D  1  A0 0A                       ldy #$0a                 ;set fixed value and render the sideways part
00931F  1  20 49 93                    jsr RenderSidewaysPipe
009322  1  B0 10                       bcs NoBlankP             ;if carry flag set, not time to draw vertical pipe part
009324  1  A2 06                       ldx #$06                 ;blank everything above the vertical pipe part
009326  1  A9 00        VPipeSectLoop: lda #$00                 ;all the way to the top of the screen
009328  1  9D A1 06                    sta MetatileBuffer,x     ;because otherwise it will look like exit pipe
00932B  1  CA                          dex
00932C  1  10 F8                       bpl VPipeSectLoop
00932E  1  B9 73 93                    lda VerticalPipeData,y   ;draw the end of the vertical pipe part
009331  1  8D A8 06                    sta MetatileBuffer+7
009334  1  60           NoBlankP:      rts
009335  1               
009335  1               SidePipeShaftData:
009335  1  15 14              .byte $15, $14  ;used to control whether or not vertical pipe shaft
009337  1  00 00              .byte $00, $00  ;is drawn, and if so, controls the metatile number
009339  1               SidePipeTopPart:
009339  1  15 1E              .byte $15, $1e  ;top part of sideways part of pipe
00933B  1  1D 1C              .byte $1d, $1c
00933D  1               SidePipeBottomPart:
00933D  1  15 21              .byte $15, $21  ;bottom part of sideways part of pipe
00933F  1  20 1F              .byte $20, $1f
009341  1               
009341  1               ExitPipe:
009341  1  A0 03              ldy #$03                 ;check if length set, if not set, set it
009343  1  20 45 96           jsr ChkLrgObjFixedLength
009346  1  20 51 96           jsr GetLrgObjAttrib      ;get vertical length, then plow on through RenderSidewaysPipe
009349  1               
009349  1               RenderSidewaysPipe:
009349  1  88                         dey                       ;decrement twice to make room for shaft at bottom
00934A  1  88                         dey                       ;and store here for now as vertical length
00934B  1  84 05                      sty $05
00934D  1  BC 30 07                   ldy AreaObjectLength,x    ;get length left over and store here
009350  1  84 06                      sty $06
009352  1  A6 05                      ldx $05                   ;get vertical length plus one, use as buffer offset
009354  1  E8                         inx
009355  1  B9 35 93                   lda SidePipeShaftData,y   ;check for value $00 based on horizontal offset
009358  1  C9 00                      cmp #$00
00935A  1  F0 08                      beq DrawSidePart          ;if found, do not draw the vertical pipe shaft
00935C  1  A2 00                      ldx #$00
00935E  1  A4 05                      ldy $05                   ;init buffer offset and get vertical length
009360  1  20 13 96                   jsr RenderUnderPart       ;and render vertical shaft using tile number in A
009363  1  18                         clc                       ;clear carry flag to be used by IntroPipe
009364  1  A4 06        DrawSidePart: ldy $06                   ;render side pipe part at the bottom
009366  1  B9 39 93                   lda SidePipeTopPart,y
009369  1  9D A1 06                   sta MetatileBuffer,x      ;note that the pipe parts are stored
00936C  1  B9 3D 93                   lda SidePipeBottomPart,y  ;backwards horizontally
00936F  1  9D A2 06                   sta MetatileBuffer+1,x
009372  1  60                         rts
009373  1               
009373  1               VerticalPipeData:
009373  1  11 10              .byte $11, $10 ;used by pipes that lead somewhere
009375  1  15 14              .byte $15, $14
009377  1  13 12              .byte $13, $12 ;used by decoration pipes
009379  1  15 14              .byte $15, $14
00937B  1               
00937B  1               VerticalPipe:
00937B  1  20 CF 93               jsr GetPipeHeight
00937E  1  A5 00                  lda $00                  ;check to see if value was nullified earlier
009380  1  F0 04                  beq WarpPipe             ;(if d3, the usage control bit of second byte, was set)
009382  1  C8                     iny
009383  1  C8                     iny
009384  1  C8                     iny
009385  1  C8                     iny                      ;add four if usage control bit was not set
009386  1  98           WarpPipe: tya                      ;save value in stack
009387  1  48                     pha
009388  1  AD 60 07               lda AreaNumber
00938B  1  0D 5F 07               ora WorldNumber          ;if at world 1-1, do not add piranha plant ever
00938E  1  F0 2B                  beq DrawPipe
009390  1  BC 30 07               ldy AreaObjectLength,x   ;if on second column of pipe, branch
009393  1  F0 26                  beq DrawPipe             ;(because we only need to do this once)
009395  1  20 E0 93               jsr FindEmptyEnemySlot   ;check for an empty moving data buffer space
009398  1  B0 21                  bcs DrawPipe             ;if not found, too many enemies, thus skip
00939A  1  20 61 96               jsr GetAreaObjXPosition  ;get horizontal pixel coordinate
00939D  1  18                     clc
00939E  1  69 08                  adc #$08                 ;add eight to put the piranha plant in the center
0093A0  1  95 87                  sta Enemy_X_Position,x   ;store as enemy's horizontal coordinate
0093A2  1  AD 25 07               lda CurrentPageLoc       ;add carry to current page number
0093A5  1  69 00                  adc #$00
0093A7  1  95 6E                  sta Enemy_PageLoc,x      ;store as enemy's page coordinate
0093A9  1  A9 01                  lda #$01
0093AB  1  95 B6                  sta Enemy_Y_HighPos,x
0093AD  1  95 0F                  sta Enemy_Flag,x         ;activate enemy flag
0093AF  1  20 69 96               jsr GetAreaObjYPosition  ;get piranha plant's vertical coordinate and store here
0093B2  1  95 CF                  sta Enemy_Y_Position,x
0093B4  1  A9 0D                  lda #PiranhaPlant        ;write piranha plant's value into buffer
0093B6  1  95 16                  sta Enemy_ID,x
0093B8  1  20 C3 C3               jsr InitPiranhaPlant
0093BB  1  68           DrawPipe: pla                      ;get value saved earlier and use as Y
0093BC  1  A8                     tay
0093BD  1  A6 07                  ldx $07                  ;get buffer offset
0093BF  1  B9 73 93               lda VerticalPipeData,y   ;draw the appropriate pipe with the Y we loaded earlier
0093C2  1  9D A1 06               sta MetatileBuffer,x     ;render the top of the pipe
0093C5  1  E8                     inx
0093C6  1  B9 75 93               lda VerticalPipeData+2,y ;render the rest of the pipe
0093C9  1  A4 06                  ldy $06                  ;subtract one from length and render the part underneath
0093CB  1  88                     dey
0093CC  1  4C 13 96               jmp RenderUnderPart
0093CF  1               
0093CF  1               GetPipeHeight:
0093CF  1  A0 01              ldy #$01       ;check for length loaded, if not, load
0093D1  1  20 45 96           jsr ChkLrgObjFixedLength ;pipe length of 2 (horizontal)
0093D4  1  20 51 96           jsr GetLrgObjAttrib
0093D7  1  98                 tya            ;get saved lower nybble as height
0093D8  1  29 07              and #$07       ;save only the three lower bits as
0093DA  1  85 06              sta $06        ;vertical length, then load Y with
0093DC  1  BC 30 07           ldy AreaObjectLength,x    ;length left over
0093DF  1  60                 rts
0093E0  1               
0093E0  1               FindEmptyEnemySlot:
0093E0  1  A2 00                      ldx #$00          ;start at first enemy slot
0093E2  1  18           EmptyChkLoop: clc               ;clear carry flag by default
0093E3  1  B5 0F                      lda Enemy_Flag,x  ;check enemy buffer for nonzero
0093E5  1  F0 05                      beq ExitEmptyChk  ;if zero, leave
0093E7  1  E8                         inx
0093E8  1  E0 05                      cpx #$05          ;if nonzero, check next value
0093EA  1  D0 F6                      bne EmptyChkLoop
0093EC  1  60           ExitEmptyChk: rts               ;if all values nonzero, carry flag is set
0093ED  1               
0093ED  1               ;--------------------------------
0093ED  1               
0093ED  1               Hole_Water:
0093ED  1  20 42 96           jsr ChkLrgObjLength   ;get low nybble and save as length
0093F0  1  A9 86              lda #$86              ;render waves
0093F2  1  8D AB 06           sta MetatileBuffer+10
0093F5  1  A2 0B              ldx #$0b
0093F7  1  A0 01              ldy #$01              ;now render the water underneath
0093F9  1  A9 87              lda #$87
0093FB  1  4C 13 96           jmp RenderUnderPart
0093FE  1               
0093FE  1               ;--------------------------------
0093FE  1               
0093FE  1               QuestionBlockRow_High:
0093FE  1  A9 03              lda #$03    ;start on the fourth row
009400  1  2C                 .byte $2c     ;BIT instruction opcode
009401  1               
009401  1               QuestionBlockRow_Low:
009401  1  A9 07              lda #$07             ;start on the eighth row
009403  1  48                 pha                  ;save whatever row to the stack for now
009404  1  20 42 96           jsr ChkLrgObjLength  ;get low nybble and save as length
009407  1  68                 pla
009408  1  AA                 tax                  ;render question boxes with coins
009409  1  A9 C0              lda #$c0
00940B  1  9D A1 06           sta MetatileBuffer,x
00940E  1  60                 rts
00940F  1               
00940F  1               ;--------------------------------
00940F  1               
00940F  1               Bridge_High:
00940F  1  A9 06              lda #$06  ;start on the seventh row from top of screen
009411  1  2C                 .byte $2c   ;BIT instruction opcode
009412  1               
009412  1               Bridge_Middle:
009412  1  A9 07              lda #$07  ;start on the eighth row
009414  1  2C                 .byte $2c   ;BIT instruction opcode
009415  1               
009415  1               Bridge_Low:
009415  1  A9 09              lda #$09             ;start on the tenth row
009417  1  48                 pha                  ;save whatever row to the stack for now
009418  1  20 42 96           jsr ChkLrgObjLength  ;get low nybble and save as length
00941B  1  68                 pla
00941C  1  AA                 tax                  ;render bridge railing
00941D  1  A9 0B              lda #$0b
00941F  1  9D A1 06           sta MetatileBuffer,x
009422  1  E8                 inx
009423  1  A0 00              ldy #$00             ;now render the bridge itself
009425  1  A9 63              lda #$63
009427  1  4C 13 96           jmp RenderUnderPart
00942A  1               
00942A  1               ;--------------------------------
00942A  1               
00942A  1               FlagBalls_Residual:
00942A  1  20 51 96           jsr GetLrgObjAttrib  ;get low nybble from object byte
00942D  1  A2 02              ldx #$02             ;render flag balls on third row from top
00942F  1  A9 6D              lda #$6d             ;of screen downwards based on low nybble
009431  1  4C 13 96           jmp RenderUnderPart
009434  1               
009434  1               ;--------------------------------
009434  1               
009434  1               FlagpoleObject:
009434  1  A9 24              lda #$24                 ;render flagpole ball on top
009436  1  8D A1 06           sta MetatileBuffer
009439  1  A2 01              ldx #$01                 ;now render the flagpole shaft
00943B  1  A0 08              ldy #$08
00943D  1  A9 25              lda #$25
00943F  1  20 13 96           jsr RenderUnderPart
009442  1  A9 61              lda #$61                 ;render solid block at the bottom
009444  1  8D AB 06           sta MetatileBuffer+10
009447  1  20 61 96           jsr GetAreaObjXPosition
00944A  1  38                 sec                      ;get pixel coordinate of where the flagpole is,
00944B  1  E9 08              sbc #$08                 ;subtract eight pixels and use as horizontal
00944D  1  85 8C              sta Enemy_X_Position+5   ;coordinate for the flag
00944F  1  AD 25 07           lda CurrentPageLoc
009452  1  E9 00              sbc #$00                 ;subtract borrow from page location and use as
009454  1  85 73              sta Enemy_PageLoc+5      ;page location for the flag
009456  1  A9 30              lda #$30
009458  1  85 D4              sta Enemy_Y_Position+5   ;set vertical coordinate for flag
00945A  1  A9 B0              lda #$b0
00945C  1  8D 0D 01           sta FlagpoleFNum_Y_Pos   ;set initial vertical coordinate for flagpole's floatey number
00945F  1  A9 30              lda #FlagpoleFlagObject
009461  1  85 1B              sta Enemy_ID+5           ;set flag identifier, note that identifier and coordinates
009463  1  E6 14              inc Enemy_Flag+5         ;use last space in enemy object buffer
009465  1  60                 rts
009466  1               
009466  1               ;--------------------------------
009466  1               
009466  1               EndlessRope:
009466  1  A2 00              ldx #$00       ;render rope from the top to the bottom of screen
009468  1  A0 0F              ldy #$0f
00946A  1  4C 7F 94           jmp DrawRope
00946D  1               
00946D  1               BalancePlatRope:
00946D  1  8A                     txa                 ;save object buffer offset for now
00946E  1  48                     pha
00946F  1  A2 01                  ldx #$01            ;blank out all from second row to the bottom
009471  1  A0 0F                  ldy #$0f            ;with blank used for balance platform rope
009473  1  A9 44                  lda #$44
009475  1  20 13 96               jsr RenderUnderPart
009478  1  68                     pla                 ;get back object buffer offset
009479  1  AA                     tax
00947A  1  20 51 96               jsr GetLrgObjAttrib ;get vertical length from lower nybble
00947D  1  A2 01                  ldx #$01
00947F  1  A9 40        DrawRope: lda #$40            ;render the actual rope
009481  1  4C 13 96               jmp RenderUnderPart
009484  1               
009484  1               ;--------------------------------
009484  1               
009484  1               CoinMetatileData:
009484  1  C3 C2 C2 C2        .byte $c3, $c2, $c2, $c2
009488  1               
009488  1               RowOfCoins:
009488  1  AC 4E 07           ldy AreaType            ;get area type
00948B  1  B9 84 94           lda CoinMetatileData,y  ;load appropriate coin metatile
00948E  1  4C DA 94           jmp GetRow
009491  1               
009491  1               ;--------------------------------
009491  1               
009491  1               C_ObjectRow:
009491  1  06 07 08           .byte $06, $07, $08
009494  1               
009494  1               C_ObjectMetatile:
009494  1  C5 0C 89           .byte $c5, $0c, $89
009497  1               
009497  1               CastleBridgeObj:
009497  1  A0 0C              ldy #$0c                  ;load length of 13 columns
009499  1  20 45 96           jsr ChkLrgObjFixedLength
00949C  1  4C A4 94           jmp ChainObj
00949F  1               
00949F  1               AxeObj:
00949F  1  A9 08              lda #$08                  ;load bowser's palette into sprite portion of palette
0094A1  1  8D 73 07           sta VRAM_Buffer_AddrCtrl
0094A4  1               
0094A4  1               ChainObj:
0094A4  1  A4 00              ldy $00                   ;get value loaded earlier from decoder
0094A6  1  BE 8F 94           ldx C_ObjectRow-2,y       ;get appropriate row and metatile for object
0094A9  1  B9 92 94           lda C_ObjectMetatile-2,y
0094AC  1  4C B6 94           jmp ColObj
0094AF  1               
0094AF  1               EmptyBlock:
0094AF  1  20 51 96             jsr GetLrgObjAttrib  ;get row location
0094B2  1  A6 07                ldx $07
0094B4  1  A9 C4                lda #$c4
0094B6  1  A0 00        ColObj: ldy #$00             ;column length of 1
0094B8  1  4C 13 96             jmp RenderUnderPart
0094BB  1               
0094BB  1               ;--------------------------------
0094BB  1               
0094BB  1               SolidBlockMetatiles:
0094BB  1  69 61 61 62        .byte $69, $61, $61, $62
0094BF  1               
0094BF  1               BrickMetatiles:
0094BF  1  22 51 52 52        .byte $22, $51, $52, $52
0094C3  1  88                 .byte $88 ;used only by row of bricks object
0094C4  1               
0094C4  1               RowOfBricks:
0094C4  1  AC 4E 07                 ldy AreaType           ;load area type obtained from area offset pointer
0094C7  1  AD 43 07                 lda CloudTypeOverride  ;check for cloud type override
0094CA  1  F0 02                    beq DrawBricks
0094CC  1  A0 04                    ldy #$04               ;if cloud type, override area type
0094CE  1  B9 BF 94     DrawBricks: lda BrickMetatiles,y   ;get appropriate metatile
0094D1  1  4C DA 94                 jmp GetRow             ;and go render it
0094D4  1               
0094D4  1               RowOfSolidBlocks:
0094D4  1  AC 4E 07              ldy AreaType               ;load area type obtained from area offset pointer
0094D7  1  B9 BB 94              lda SolidBlockMetatiles,y  ;get metatile
0094DA  1  48           GetRow:  pha                        ;store metatile here
0094DB  1  20 42 96              jsr ChkLrgObjLength        ;get row number, load length
0094DE  1  A6 07        DrawRow: ldx $07
0094E0  1  A0 00                 ldy #$00                   ;set vertical height of 1
0094E2  1  68                    pla
0094E3  1  4C 13 96              jmp RenderUnderPart        ;render object
0094E6  1               
0094E6  1               ColumnOfBricks:
0094E6  1  AC 4E 07           ldy AreaType          ;load area type obtained from area offset
0094E9  1  B9 BF 94           lda BrickMetatiles,y  ;get metatile (no cloud override as for row)
0094EC  1  4C F5 94           jmp GetRow2
0094EF  1               
0094EF  1               ColumnOfSolidBlocks:
0094EF  1  AC 4E 07              ldy AreaType               ;load area type obtained from area offset
0094F2  1  B9 BB 94              lda SolidBlockMetatiles,y  ;get metatile
0094F5  1  48           GetRow2: pha                        ;save metatile to stack for now
0094F6  1  20 51 96              jsr GetLrgObjAttrib        ;get length and row
0094F9  1  68                    pla                        ;restore metatile
0094FA  1  A6 07                 ldx $07                    ;get starting row
0094FC  1  4C 13 96              jmp RenderUnderPart        ;now render the column
0094FF  1               
0094FF  1               ;--------------------------------
0094FF  1               
0094FF  1               BulletBillCannon:
0094FF  1  20 51 96                  jsr GetLrgObjAttrib      ;get row and length of bullet bill cannon
009502  1  A6 07                     ldx $07                  ;start at first row
009504  1  A9 64                     lda #$64                 ;render bullet bill cannon
009506  1  9D A1 06                  sta MetatileBuffer,x
009509  1  E8                        inx
00950A  1  88                        dey                      ;done yet?
00950B  1  30 0E                     bmi SetupCannon
00950D  1  A9 65                     lda #$65                 ;if not, render middle part
00950F  1  9D A1 06                  sta MetatileBuffer,x
009512  1  E8                        inx
009513  1  88                        dey                      ;done yet?
009514  1  30 05                     bmi SetupCannon
009516  1  A9 66                     lda #$66                 ;if not, render bottom until length expires
009518  1  20 13 96                  jsr RenderUnderPart
00951B  1  AE 6A 04     SetupCannon: ldx Cannon_Offset        ;get offset for data used by cannons and whirlpools
00951E  1  20 69 96                  jsr GetAreaObjYPosition  ;get proper vertical coordinate for cannon
009521  1  9D 77 04                  sta Cannon_Y_Position,x  ;and store it here
009524  1  AD 25 07                  lda CurrentPageLoc
009527  1  9D 6B 04                  sta Cannon_PageLoc,x     ;store page number for cannon here
00952A  1  20 61 96                  jsr GetAreaObjXPosition  ;get proper horizontal coordinate for cannon
00952D  1  9D 71 04                  sta Cannon_X_Position,x  ;and store it here
009530  1  E8                        inx
009531  1  E0 06                     cpx #$06                 ;increment and check offset
009533  1  90 02                     bcc StrCOffset           ;if not yet reached sixth cannon, branch to save offset
009535  1  A2 00                     ldx #$00                 ;otherwise initialize it
009537  1  8E 6A 04     StrCOffset:  stx Cannon_Offset        ;save new offset and leave
00953A  1  60                        rts
00953B  1               
00953B  1               ;--------------------------------
00953B  1               
00953B  1               StaircaseHeightData:
00953B  1  07 07 06 05        .byte $07, $07, $06, $05, $04, $03, $02, $01, $00
00953F  1  04 03 02 01  
009543  1  00           
009544  1               
009544  1               StaircaseRowData:
009544  1  03 03 04 05        .byte $03, $03, $04, $05, $06, $07, $08, $09, $0a
009548  1  06 07 08 09  
00954C  1  0A           
00954D  1               
00954D  1               StaircaseObject:
00954D  1  20 42 96                jsr ChkLrgObjLength       ;check and load length
009550  1  90 05                   bcc NextStair             ;if length already loaded, skip init part
009552  1  A9 09                   lda #$09                  ;start past the end for the bottom
009554  1  8D 34 07                sta StaircaseControl      ;of the staircase
009557  1  CE 34 07     NextStair: dec StaircaseControl      ;move onto next step (or first if starting)
00955A  1  AC 34 07                ldy StaircaseControl
00955D  1  BE 44 95                ldx StaircaseRowData,y    ;get starting row and height to render
009560  1  B9 3B 95                lda StaircaseHeightData,y
009563  1  A8                      tay
009564  1  A9 61                   lda #$61                  ;now render solid block staircase
009566  1  4C 13 96                jmp RenderUnderPart
009569  1               
009569  1               ;--------------------------------
009569  1               
009569  1               Jumpspring:
009569  1  20 51 96           jsr GetLrgObjAttrib
00956C  1  20 E0 93           jsr FindEmptyEnemySlot      ;find empty space in enemy object buffer
00956F  1  20 61 96           jsr GetAreaObjXPosition     ;get horizontal coordinate for jumpspring
009572  1  95 87              sta Enemy_X_Position,x      ;and store
009574  1  AD 25 07           lda CurrentPageLoc          ;store page location of jumpspring
009577  1  95 6E              sta Enemy_PageLoc,x
009579  1  20 69 96           jsr GetAreaObjYPosition     ;get vertical coordinate for jumpspring
00957C  1  95 CF              sta Enemy_Y_Position,x      ;and store
00957E  1  95 58              sta Jumpspring_FixedYPos,x  ;store as permanent coordinate here
009580  1  A9 32              lda #JumpspringObject
009582  1  95 16              sta Enemy_ID,x              ;write jumpspring object to enemy object buffer
009584  1  A0 01              ldy #$01
009586  1  94 B6              sty Enemy_Y_HighPos,x       ;store vertical high byte
009588  1  F6 0F              inc Enemy_Flag,x            ;set flag for enemy object buffer
00958A  1  A6 07              ldx $07
00958C  1  A9 67              lda #$67                    ;draw metatiles in two rows where jumpspring is
00958E  1  9D A1 06           sta MetatileBuffer,x
009591  1  A9 68              lda #$68
009593  1  9D A2 06           sta MetatileBuffer+1,x
009596  1  60                 rts
009597  1               
009597  1               ;--------------------------------
009597  1               ;$07 - used to save ID of brick object
009597  1               
009597  1               Hidden1UpBlock:
009597  1  AD 5D 07           lda Hidden1UpFlag  ;if flag not set, do not render object
00959A  1  F0 36              beq ExitDecBlock
00959C  1  A9 00              lda #$00           ;if set, init for the next one
00959E  1  8D 5D 07           sta Hidden1UpFlag
0095A1  1  4C AF 95           jmp BrickWithItem  ;jump to code shared with unbreakable bricks
0095A4  1               
0095A4  1               QuestionBlock:
0095A4  1  20 CC 95           jsr GetAreaObjectID ;get value from level decoder routine
0095A7  1  4C C2 95           jmp DrawQBlk        ;go to render it
0095AA  1               
0095AA  1               BrickWithCoins:
0095AA  1  A9 00              lda #$00                 ;initialize multi-coin timer flag
0095AC  1  8D BC 06           sta BrickCoinTimerFlag
0095AF  1               
0095AF  1               BrickWithItem:
0095AF  1  20 CC 95               jsr GetAreaObjectID         ;save area object ID
0095B2  1  84 07                  sty $07
0095B4  1  A9 00                  lda #$00                    ;load default adder for bricks with lines
0095B6  1  AC 4E 07               ldy AreaType                ;check level type for ground level
0095B9  1  88                     dey
0095BA  1  F0 02                  beq BWithL                  ;if ground type, do not start with 5
0095BC  1  A9 05                  lda #$05                    ;otherwise use adder for bricks without lines
0095BE  1  18           BWithL:   clc                         ;add object ID to adder
0095BF  1  65 07                  adc $07
0095C1  1  A8                     tay                         ;use as offset for metatile
0095C2  1  B9 CA BD     DrawQBlk: lda BrickQBlockMetatiles,y  ;get appropriate metatile for brick (question block
0095C5  1  48                     pha                         ;if branched to here from question block routine)
0095C6  1  20 51 96               jsr GetLrgObjAttrib         ;get row from location byte
0095C9  1  4C DE 94               jmp DrawRow                 ;now render the object
0095CC  1               
0095CC  1               GetAreaObjectID:
0095CC  1  A5 00                      lda $00    ;get value saved from area parser routine
0095CE  1  38                         sec
0095CF  1  E9 00                      sbc #$00   ;possibly residual code
0095D1  1  A8                         tay        ;save to Y
0095D2  1  60           ExitDecBlock: rts
0095D3  1               
0095D3  1               ;--------------------------------
0095D3  1               
0095D3  1               HoleMetatiles:
0095D3  1  87 00 00 00        .byte $87, $00, $00, $00
0095D7  1               
0095D7  1               Hole_Empty:
0095D7  1  20 42 96                 jsr ChkLrgObjLength          ;get lower nybble and save as length
0095DA  1  90 2D                    bcc NoWhirlP                 ;skip this part if length already loaded
0095DC  1  AD 4E 07                 lda AreaType                 ;check for water type level
0095DF  1  D0 28                    bne NoWhirlP                 ;if not water type, skip this part
0095E1  1  AE 6A 04                 ldx Whirlpool_Offset         ;get offset for data used by cannons and whirlpools
0095E4  1  20 61 96                 jsr GetAreaObjXPosition      ;get proper vertical coordinate of where we're at
0095E7  1  38                       sec
0095E8  1  E9 10                    sbc #$10                     ;subtract 16 pixels
0095EA  1  9D 71 04                 sta Whirlpool_LeftExtent,x   ;store as left extent of whirlpool
0095ED  1  AD 25 07                 lda CurrentPageLoc           ;get page location of where we're at
0095F0  1  E9 00                    sbc #$00                     ;subtract borrow
0095F2  1  9D 6B 04                 sta Whirlpool_PageLoc,x      ;save as page location of whirlpool
0095F5  1  C8                       iny
0095F6  1  C8                       iny                          ;increment length by 2
0095F7  1  98                       tya
0095F8  1  0A                       asl                          ;multiply by 16 to get size of whirlpool
0095F9  1  0A                       asl                          ;note that whirlpool will always be
0095FA  1  0A                       asl                          ;two blocks bigger than actual size of hole
0095FB  1  0A                       asl                          ;and extend one block beyond each edge
0095FC  1  9D 77 04                 sta Whirlpool_Length,x       ;save size of whirlpool here
0095FF  1  E8                       inx
009600  1  E0 05                    cpx #$05                     ;increment and check offset
009602  1  90 02                    bcc StrWOffset               ;if not yet reached fifth whirlpool, branch to save offset
009604  1  A2 00                    ldx #$00                     ;otherwise initialize it
009606  1  8E 6A 04     StrWOffset: stx Whirlpool_Offset         ;save new offset here
009609  1  AE 4E 07     NoWhirlP:   ldx AreaType                 ;get appropriate metatile, then
00960C  1  BD D3 95                 lda HoleMetatiles,x          ;render the hole proper
00960F  1  A2 08                    ldx #$08
009611  1  A0 0F                    ldy #$0f                     ;start at ninth row and go to bottom, run RenderUnderPart
009613  1               
009613  1               ;--------------------------------
009613  1               
009613  1               RenderUnderPart:
009613  1  8C 35 07                  sty AreaObjectHeight  ;store vertical length to render
009616  1  BC A1 06                  ldy MetatileBuffer,x  ;check current spot to see if there's something
009619  1  F0 18                     beq DrawThisRow       ;we need to keep, if nothing, go ahead
00961B  1  C0 17                     cpy #$17
00961D  1  F0 17                     beq WaitOneRow        ;if middle part (tree ledge), wait until next row
00961F  1  C0 1A                     cpy #$1a
009621  1  F0 13                     beq WaitOneRow        ;if middle part (mushroom ledge), wait until next row
009623  1  C0 C0                     cpy #$c0
009625  1  F0 0C                     beq DrawThisRow       ;if question block w/ coin, overwrite
009627  1  C0 C0                     cpy #$c0
009629  1  B0 0B                     bcs WaitOneRow        ;if any other metatile with palette 3, wait until next row
00962B  1  C0 54                     cpy #$54
00962D  1  D0 04                     bne DrawThisRow       ;if cracked rock terrain, overwrite
00962F  1  C9 50                     cmp #$50
009631  1  F0 03                     beq WaitOneRow        ;if stem top of mushroom, wait until next row
009633  1  9D A1 06     DrawThisRow: sta MetatileBuffer,x  ;render contents of A from routine that called this
009636  1  E8           WaitOneRow:  inx
009637  1  E0 0D                     cpx #$0d              ;stop rendering if we're at the bottom of the screen
009639  1  B0 06                     bcs ExitUPartR
00963B  1  AC 35 07                  ldy AreaObjectHeight  ;decrement, and stop rendering if there is no more length
00963E  1  88                        dey
00963F  1  10 D2                     bpl RenderUnderPart
009641  1  60           ExitUPartR:  rts
009642  1               
009642  1               ;--------------------------------
009642  1               
009642  1               ChkLrgObjLength:
009642  1  20 51 96             jsr GetLrgObjAttrib     ;get row location and size (length if branched to from here)
009645  1               
009645  1               ChkLrgObjFixedLength:
009645  1  BD 30 07             lda AreaObjectLength,x  ;check for set length counter
009648  1  18                   clc                     ;clear carry flag for not just starting
009649  1  10 05                bpl LenSet              ;if counter not set, load it, otherwise leave alone
00964B  1  98                   tya                     ;save length into length counter
00964C  1  9D 30 07             sta AreaObjectLength,x
00964F  1  38                   sec                     ;set carry flag if just starting
009650  1  60           LenSet: rts
009651  1               
009651  1               
009651  1               GetLrgObjAttrib:
009651  1  BC 2D 07           ldy AreaObjOffsetBuffer,x ;get offset saved from area obj decoding routine
009654  1  B1 E7              lda (AreaData),y          ;get first byte of level object
009656  1  29 0F              and #%00001111
009658  1  85 07              sta $07                   ;save row location
00965A  1  C8                 iny
00965B  1  B1 E7              lda (AreaData),y          ;get next byte, save lower nybble (length or height)
00965D  1  29 0F              and #%00001111            ;as Y, then leave
00965F  1  A8                 tay
009660  1  60                 rts
009661  1               
009661  1               ;--------------------------------
009661  1               
009661  1               GetAreaObjXPosition:
009661  1  AD 26 07           lda CurrentColumnPos    ;multiply current offset where we're at by 16
009664  1  0A                 asl                     ;to obtain horizontal pixel coordinate
009665  1  0A                 asl
009666  1  0A                 asl
009667  1  0A                 asl
009668  1  60                 rts
009669  1               
009669  1               ;--------------------------------
009669  1               
009669  1               GetAreaObjYPosition:
009669  1  A5 07              lda $07  ;multiply value by 16
00966B  1  0A                 asl
00966C  1  0A                 asl      ;this will give us the proper vertical pixel coordinate
00966D  1  0A                 asl
00966E  1  0A                 asl
00966F  1  18                 clc
009670  1  69 20              adc #32  ;add 32 pixels for the status bar
009672  1  60                 rts
009673  1               
009673  1               ;-------------------------------------------------------------------------------------
009673  1               
009673  1               ;unused space
009673  1  FF FF              .byte $ff, $ff
009675  1               
009675  1               ;-------------------------------------------------------------------------------------
009675  1               
009675  1               AreaDataOfsLoopback:
009675  1  12 36 0E 0E        .byte $12, $36, $0e, $0e, $0e, $32, $32, $32, $0a, $26, $40
009679  1  0E 32 32 32  
00967D  1  0A 26 40     
009680  1               
009680  1               ;bonus area data offsets, included here for comparison purposes
009680  1               ;underground bonus area  - c2
009680  1               ;cloud area 1 (day)      - 2b
009680  1               ;cloud area 2 (night)    - 34
009680  1               ;water area (5-2/6-2)    - 00
009680  1               ;water area (8-4)        - 02
009680  1               ;warp zone area (4-2)    - 2f
009680  1               
009680  1               EnemyDataAddrLow:
009680  1  0C 33 4C 7B        .byte <E_CastleArea1, <E_CastleArea2, <E_CastleArea3, <E_CastleArea4, <E_CastleArea5, <E_CastleArea6
009684  1  A6 BB        
009686  1  F5 1A 37 45        .byte <E_GroundArea1, <E_GroundArea2, <E_GroundArea3, <E_GroundArea4, <E_GroundArea5, <E_GroundArea6
00968A  1  6C 9D        
00968C  1  BB D8 ED 17        .byte <E_GroundArea7, <E_GroundArea8, <E_GroundArea9, <E_GroundArea10, <E_GroundArea11, <E_GroundArea12
009690  1  18 3C        
009692  1  45 6A 8D 96        .byte <E_GroundArea13, <E_GroundArea14, <E_GroundArea15, <E_GroundArea16, <E_GroundArea17, <E_GroundArea18
009696  1  97 D1        
009698  1  FC 2A 46 4F        .byte <E_GroundArea19, <E_GroundArea20, <E_GroundArea21, <E_GroundArea22, <E_UndergroundArea1
00969C  1  74           
00969D  1  A1 CF FC 0D        .byte <E_UndergroundArea2, <E_UndergroundArea3, <E_WaterArea1, <E_WaterArea2, <E_WaterArea3
0096A1  1  37           
0096A2  1               
0096A2  1               EnemyDataAddrHigh:
0096A2  1  97 97 97 97        .byte >E_CastleArea1, >E_CastleArea2, >E_CastleArea3, >E_CastleArea4, >E_CastleArea5, >E_CastleArea6
0096A6  1  97 97        
0096A8  1  97 98 98 98        .byte >E_GroundArea1, >E_GroundArea2, >E_GroundArea3, >E_GroundArea4, >E_GroundArea5, >E_GroundArea6
0096AC  1  98 98        
0096AE  1  98 98 98 99        .byte >E_GroundArea7, >E_GroundArea8, >E_GroundArea9, >E_GroundArea10, >E_GroundArea11, >E_GroundArea12
0096B2  1  99 99        
0096B4  1  99 99 99 99        .byte >E_GroundArea13, >E_GroundArea14, >E_GroundArea15, >E_GroundArea16, >E_GroundArea17, >E_GroundArea18
0096B8  1  99 99        
0096BA  1  99 9A 9A 9A        .byte >E_GroundArea19, >E_GroundArea20, >E_GroundArea21, >E_GroundArea22, >E_UndergroundArea1
0096BE  1  9A           
0096BF  1  9A 9A 9A 9B        .byte >E_UndergroundArea2, >E_UndergroundArea3, >E_WaterArea1, >E_WaterArea2, >E_WaterArea3
0096C3  1  9B           
0096C4  1               
0096C4  1               AreaDataHOffsets:
0096C4  1  00 03 19 1C        .byte $00, $03, $19, $1c
0096C8  1               
0096C8  1               AreaDataAddrLow:
0096C8  1  A2 E1 5C 07        .byte <L_WaterArea1, <L_WaterArea2, <L_WaterArea3, <L_GroundArea1, <L_GroundArea2, <L_GroundArea3
0096CC  1  6A D3        
0096CE  1  26 B5 2A 8F        .byte <L_GroundArea4, <L_GroundArea5, <L_GroundArea6, <L_GroundArea7, <L_GroundArea8, <L_GroundArea9
0096D2  1  E4 69        
0096D4  1  CE D7 16 2B        .byte <L_GroundArea10, <L_GroundArea11, <L_GroundArea12, <L_GroundArea13, <L_GroundArea14, <L_GroundArea15
0096D8  1  92 F7        
0096DA  1  6A 9B 2E A1        .byte <L_GroundArea16, <L_GroundArea17, <L_GroundArea18, <L_GroundArea19, <L_GroundArea20, <L_GroundArea21
0096DE  1  1A 73        
0096E0  1  9E D1 74 15        .byte <L_GroundArea22, <L_UndergroundArea1, <L_UndergroundArea2, <L_UndergroundArea3, <L_CastleArea1
0096E4  1  4B           
0096E5  1  AC 2B 9E 0B        .byte <L_CastleArea2, <L_CastleArea3, <L_CastleArea4, <L_CastleArea5, <L_CastleArea6
0096E9  1  96           
0096EA  1               
0096EA  1               AreaDataAddrHigh:
0096EA  1  A7 A7 A8 9E        .byte >L_WaterArea1, >L_WaterArea2, >L_WaterArea3, >L_GroundArea1, >L_GroundArea2, >L_GroundArea3
0096EE  1  9E 9E        
0096F0  1  9F 9F A0 A0        .byte >L_GroundArea4, >L_GroundArea5, >L_GroundArea6, >L_GroundArea7, >L_GroundArea8, >L_GroundArea9
0096F4  1  A0 A1        
0096F6  1  A1 A1 A2 A2        .byte >L_GroundArea10, >L_GroundArea11, >L_GroundArea12, >L_GroundArea13, >L_GroundArea14, >L_GroundArea15
0096FA  1  A2 A2        
0096FC  1  A3 A3 A4 A4        .byte >L_GroundArea16, >L_GroundArea17, >L_GroundArea18, >L_GroundArea19, >L_GroundArea20, >L_GroundArea21
009700  1  A5 A5        
009702  1  A5 A5 A6 A7        .byte >L_GroundArea22, >L_UndergroundArea1, >L_UndergroundArea2, >L_UndergroundArea3, >L_CastleArea1
009706  1  9B           
009707  1  9B 9C 9C 9D        .byte >L_CastleArea2, >L_CastleArea3, >L_CastleArea4, >L_CastleArea5, >L_CastleArea6
00970B  1  9D           
00970C  1               
00970C  1               ;ENEMY OBJECT DATA
00970C  1               
00970C  1               ;level 1-4/6-4
00970C  1               E_CastleArea1:
00970C  1  76 DD BB 4C        .byte $76, $dd, $bb, $4c, $ea, $1d, $1b, $cc, $56, $5d
009710  1  EA 1D 1B CC  
009714  1  56 5D        
009716  1  16 9D C6 1D        .byte $16, $9d, $c6, $1d, $36, $9d, $c9, $1d, $04, $db
00971A  1  36 9D C9 1D  
00971E  1  04 DB        
009720  1  49 1D 84 1B        .byte $49, $1d, $84, $1b, $c9, $5d, $88, $95, $0f, $08
009724  1  C9 5D 88 95  
009728  1  0F 08        
00972A  1  30 4C 78 2D        .byte $30, $4c, $78, $2d, $a6, $28, $90, $b5
00972E  1  A6 28 90 B5  
009732  1  FF                 .byte $ff
009733  1               
009733  1               ;level 4-4
009733  1               E_CastleArea2:
009733  1  0F 03 56 1B        .byte $0f, $03, $56, $1b, $c9, $1b, $0f, $07, $36, $1b
009737  1  C9 1B 0F 07  
00973B  1  36 1B        
00973D  1  AA 1B 48 95        .byte $aa, $1b, $48, $95, $0f, $0a, $2a, $1b, $5b, $0c
009741  1  0F 0A 2A 1B  
009745  1  5B 0C        
009747  1  78 2D 90 B5        .byte $78, $2d, $90, $b5
00974B  1  FF                 .byte $ff
00974C  1               
00974C  1               ;level 2-4/5-4
00974C  1               E_CastleArea3:
00974C  1  0B 8C 4B 4C        .byte $0b, $8c, $4b, $4c, $77, $5f, $eb, $0c, $bd, $db
009750  1  77 5F EB 0C  
009754  1  BD DB        
009756  1  19 9D 75 1D        .byte $19, $9d, $75, $1d, $7d, $5b, $d9, $1d, $3d, $dd
00975A  1  7D 5B D9 1D  
00975E  1  3D DD        
009760  1  99 1D 26 9D        .byte $99, $1d, $26, $9d, $5a, $2b, $8a, $2c, $ca, $1b
009764  1  5A 2B 8A 2C  
009768  1  CA 1B        
00976A  1  20 95 7B 5C        .byte $20, $95, $7b, $5c, $db, $4c, $1b, $cc, $3b, $cc
00976E  1  DB 4C 1B CC  
009772  1  3B CC        
009774  1  78 2D A6 28        .byte $78, $2d, $a6, $28, $90, $b5
009778  1  90 B5        
00977A  1  FF                 .byte $ff
00977B  1               
00977B  1               ;level 3-4
00977B  1               E_CastleArea4:
00977B  1  0B 8C 3B 1D        .byte $0b, $8c, $3b, $1d, $8b, $1d, $ab, $0c, $db, $1d
00977F  1  8B 1D AB 0C  
009783  1  DB 1D        
009785  1  0F 03 65 1D        .byte $0f, $03, $65, $1d, $6b, $1b, $05, $9d, $0b, $1b
009789  1  6B 1B 05 9D  
00978D  1  0B 1B        
00978F  1  05 9B 0B 1D        .byte $05, $9b, $0b, $1d, $8b, $0c, $1b, $8c, $70, $15
009793  1  8B 0C 1B 8C  
009797  1  70 15        
009799  1  7B 0C DB 0C        .byte $7b, $0c, $db, $0c, $0f, $08, $78, $2d, $a6, $28
00979D  1  0F 08 78 2D  
0097A1  1  A6 28        
0097A3  1  90 B5              .byte $90, $b5
0097A5  1  FF                 .byte $ff
0097A6  1               
0097A6  1               ;level 7-4
0097A6  1               E_CastleArea5:
0097A6  1  27 A9 4B 0C        .byte $27, $a9, $4b, $0c, $68, $29, $0f, $06, $77, $1b
0097AA  1  68 29 0F 06  
0097AE  1  77 1B        
0097B0  1  0F 0B 60 15        .byte $0f, $0b, $60, $15, $4b, $8c, $78, $2d, $90, $b5
0097B4  1  4B 8C 78 2D  
0097B8  1  90 B5        
0097BA  1  FF                 .byte $ff
0097BB  1               
0097BB  1               ;level 8-4
0097BB  1               E_CastleArea6:
0097BB  1  0F 03 8E 65        .byte $0f, $03, $8e, $65, $e1, $bb, $38, $6d, $a8, $3e, $e5, $e7
0097BF  1  E1 BB 38 6D  
0097C3  1  A8 3E E5 E7  
0097C7  1  0F 08 0B 02        .byte $0f, $08, $0b, $02, $2b, $02, $5e, $65, $e1, $bb, $0e
0097CB  1  2B 02 5E 65  
0097CF  1  E1 BB 0E     
0097D2  1  DB 0E BB 8E        .byte $db, $0e, $bb, $8e, $db, $0e, $fe, $65, $ec, $0f, $0d
0097D6  1  DB 0E FE 65  
0097DA  1  EC 0F 0D     
0097DD  1  4E 65 E1 0F        .byte $4e, $65, $e1, $0f, $0e, $4e, $02, $e0, $0f, $10, $fe, $e5, $e1
0097E1  1  0E 4E 02 E0  
0097E5  1  0F 10 FE E5  
0097EA  1  1B 85 7B 0C        .byte $1b, $85, $7b, $0c, $5b, $95, $78, $2d, $90, $b5
0097EE  1  5B 95 78 2D  
0097F2  1  90 B5        
0097F4  1  FF                 .byte $ff
0097F5  1               
0097F5  1               ;level 3-3
0097F5  1               E_GroundArea1:
0097F5  1  A5 86 E4 28        .byte $a5, $86, $e4, $28, $18, $a8, $45, $83, $69, $03
0097F9  1  18 A8 45 83  
0097FD  1  69 03        
0097FF  1  C6 29 9B 83        .byte $c6, $29, $9b, $83, $16, $a4, $88, $24, $e9, $28
009803  1  16 A4 88 24  
009807  1  E9 28        
009809  1  05 A8 7B 28        .byte $05, $a8, $7b, $28, $24, $8f, $c8, $03, $e8, $03
00980D  1  24 8F C8 03  
009811  1  E8 03        
009813  1  46 A8 85 24        .byte $46, $a8, $85, $24, $c8, $24
009817  1  C8 24        
009819  1  FF                 .byte $ff
00981A  1               
00981A  1               ;level 8-3
00981A  1               E_GroundArea2:
00981A  1  EB 8E 0F 03        .byte $eb, $8e, $0f, $03, $fb, $05, $17, $85, $db, $8e
00981E  1  FB 05 17 85  
009822  1  DB 8E        
009824  1  0F 07 57 05        .byte $0f, $07, $57, $05, $7b, $05, $9b, $80, $2b, $85
009828  1  7B 05 9B 80  
00982C  1  2B 85        
00982E  1  FB 05 0F 0B        .byte $fb, $05, $0f, $0b, $1b, $05, $9b, $05
009832  1  1B 05 9B 05  
009836  1  FF                 .byte $ff
009837  1               
009837  1               ;level 4-1
009837  1               E_GroundArea3:
009837  1  2E C2 66 E2        .byte $2e, $c2, $66, $e2, $11, $0f, $07, $02, $11, $0f, $0c
00983B  1  11 0F 07 02  
00983F  1  11 0F 0C     
009842  1  12 11              .byte $12, $11
009844  1  FF                 .byte $ff
009845  1               
009845  1               ;level 6-2
009845  1               E_GroundArea4:
009845  1  0E C2 A8 AB        .byte $0e, $c2, $a8, $ab, $00, $bb, $8e, $6b, $82, $de, $00, $a0
009849  1  00 BB 8E 6B  
00984D  1  82 DE 00 A0  
009851  1  33 86 43 06        .byte $33, $86, $43, $06, $3e, $b4, $a0, $cb, $02, $0f, $07
009855  1  3E B4 A0 CB  
009859  1  02 0F 07     
00985C  1  7E 42 A6 83        .byte $7e, $42, $a6, $83, $02, $0f, $0a, $3b, $02, $cb, $37
009860  1  02 0F 0A 3B  
009864  1  02 CB 37     
009867  1  0F 0C E3 0E        .byte $0f, $0c, $e3, $0e
00986B  1  FF                 .byte $ff
00986C  1               
00986C  1               ;level 3-1
00986C  1               E_GroundArea5:
00986C  1  9B 8E CA 0E        .byte $9b, $8e, $ca, $0e, $ee, $42, $44, $5b, $86, $80, $b8
009870  1  EE 42 44 5B  
009874  1  86 80 B8     
009877  1  1B 80 50 BA        .byte $1b, $80, $50, $ba, $10, $b7, $5b, $00, $17, $85
00987B  1  10 B7 5B 00  
00987F  1  17 85        
009881  1  4B 05 FE 34        .byte $4b, $05, $fe, $34, $40, $b7, $86, $c6, $06, $5b, $80
009885  1  40 B7 86 C6  
009889  1  06 5B 80     
00988C  1  83 00 D0 38        .byte $83, $00, $d0, $38, $5b, $8e, $8a, $0e, $a6, $00
009890  1  5B 8E 8A 0E  
009894  1  A6 00        
009896  1  BB 0E C5 80        .byte $bb, $0e, $c5, $80, $f3, $00
00989A  1  F3 00        
00989C  1  FF                 .byte $ff
00989D  1               
00989D  1               ;level 1-1
00989D  1               E_GroundArea6:
00989D  1  1E C2 00 6B        .byte $1e, $c2, $00, $6b, $06, $8b, $86, $63, $b7, $0f, $05
0098A1  1  06 8B 86 63  
0098A5  1  B7 0F 05     
0098A8  1  03 06 23 06        .byte $03, $06, $23, $06, $4b, $b7, $bb, $00, $5b, $b7
0098AC  1  4B B7 BB 00  
0098B0  1  5B B7        
0098B2  1  FB 37 3B B7        .byte $fb, $37, $3b, $b7, $0f, $0b, $1b, $37
0098B6  1  0F 0B 1B 37  
0098BA  1  FF                 .byte $ff
0098BB  1               
0098BB  1               ;level 1-3/5-3
0098BB  1               E_GroundArea7:
0098BB  1  2B D7 E3 03        .byte $2b, $d7, $e3, $03, $c2, $86, $e2, $06, $76, $a5
0098BF  1  C2 86 E2 06  
0098C3  1  76 A5        
0098C5  1  A3 8F 03 86        .byte $a3, $8f, $03, $86, $2b, $57, $68, $28, $e9, $28
0098C9  1  2B 57 68 28  
0098CD  1  E9 28        
0098CF  1  E5 83 24 8F        .byte $e5, $83, $24, $8f, $36, $a8, $5b, $03
0098D3  1  36 A8 5B 03  
0098D7  1  FF                 .byte $ff
0098D8  1               
0098D8  1               ;level 2-3/7-3
0098D8  1               E_GroundArea8:
0098D8  1  0F 02 78 40        .byte $0f, $02, $78, $40, $48, $ce, $f8, $c3, $f8, $c3
0098DC  1  48 CE F8 C3  
0098E0  1  F8 C3        
0098E2  1  0F 07 7B 43        .byte $0f, $07, $7b, $43, $c6, $d0, $0f, $8a, $c8, $50
0098E6  1  C6 D0 0F 8A  
0098EA  1  C8 50        
0098EC  1  FF                 .byte $ff
0098ED  1               
0098ED  1               ;level 2-1
0098ED  1               E_GroundArea9:
0098ED  1  85 86 0B 80        .byte $85, $86, $0b, $80, $1b, $00, $db, $37, $77, $80
0098F1  1  1B 00 DB 37  
0098F5  1  77 80        
0098F7  1  EB 37 FE 2B        .byte $eb, $37, $fe, $2b, $20, $2b, $80, $7b, $38, $ab, $b8
0098FB  1  20 2B 80 7B  
0098FF  1  38 AB B8     
009902  1  77 86 FE 42        .byte $77, $86, $fe, $42, $20, $49, $86, $8b, $06, $9b, $80
009906  1  20 49 86 8B  
00990A  1  06 9B 80     
00990D  1  7B 8E 5B B7        .byte $7b, $8e, $5b, $b7, $9b, $0e, $bb, $0e, $9b, $80
009911  1  9B 0E BB 0E  
009915  1  9B 80        
009917  1               ;end of data terminator here is also used by pipe intro area
009917  1               E_GroundArea10:
009917  1  FF                 .byte $ff
009918  1               
009918  1               ;level 5-1
009918  1               E_GroundArea11:
009918  1  0B 80 60 38        .byte $0b, $80, $60, $38, $10, $b8, $c0, $3b, $db, $8e
00991C  1  10 B8 C0 3B  
009920  1  DB 8E        
009922  1  40 B8 F0 38        .byte $40, $b8, $f0, $38, $7b, $8e, $a0, $b8, $c0, $b8
009926  1  7B 8E A0 B8  
00992A  1  C0 B8        
00992C  1  FB 00 A0 B8        .byte $fb, $00, $a0, $b8, $30, $bb, $ee, $42, $88, $0f, $0b
009930  1  30 BB EE 42  
009934  1  88 0F 0B     
009937  1  2B 0E 67 0E        .byte $2b, $0e, $67, $0e
00993B  1  FF                 .byte $ff
00993C  1               
00993C  1               ;cloud level used in levels 2-1 and 5-2
00993C  1               E_GroundArea12:
00993C  1  0A AA 0E 28        .byte $0a, $aa, $0e, $28, $2a, $0e, $31, $88
009940  1  2A 0E 31 88  
009944  1  FF                 .byte $ff
009945  1               
009945  1               ;level 4-3
009945  1               E_GroundArea13:
009945  1  C7 83 D7 03        .byte $c7, $83, $d7, $03, $42, $8f, $7a, $03, $05, $a4
009949  1  42 8F 7A 03  
00994D  1  05 A4        
00994F  1  78 24 A6 25        .byte $78, $24, $a6, $25, $e4, $25, $4b, $83, $e3, $03
009953  1  E4 25 4B 83  
009957  1  E3 03        
009959  1  05 A4 89 24        .byte $05, $a4, $89, $24, $b5, $24, $09, $a4, $65, $24
00995D  1  B5 24 09 A4  
009961  1  65 24        
009963  1  C9 24 0F 08        .byte $c9, $24, $0f, $08, $85, $25
009967  1  85 25        
009969  1  FF                 .byte $ff
00996A  1               
00996A  1               ;level 6-3
00996A  1               E_GroundArea14:
00996A  1  CD A5 B5 A8        .byte $cd, $a5, $b5, $a8, $07, $a8, $76, $28, $cc, $25
00996E  1  07 A8 76 28  
009972  1  CC 25        
009974  1  65 A4 A9 24        .byte $65, $a4, $a9, $24, $e5, $24, $19, $a4, $0f, $07
009978  1  E5 24 19 A4  
00997C  1  0F 07        
00997E  1  95 28 E6 24        .byte $95, $28, $e6, $24, $19, $a4, $d7, $29, $16, $a9
009982  1  19 A4 D7 29  
009986  1  16 A9        
009988  1  58 29 97 29        .byte $58, $29, $97, $29
00998C  1  FF                 .byte $ff
00998D  1               
00998D  1               ;level 6-1
00998D  1               E_GroundArea15:
00998D  1  0F 02 02 11        .byte $0f, $02, $02, $11, $0f, $07, $02, $11
009991  1  0F 07 02 11  
009995  1  FF                 .byte $ff
009996  1               
009996  1               ;warp zone area used in level 4-2
009996  1               E_GroundArea16:
009996  1  FF                 .byte $ff
009997  1               
009997  1               ;level 8-1
009997  1               E_GroundArea17:
009997  1  2B 82 AB 38        .byte $2b, $82, $ab, $38, $de, $42, $e2, $1b, $b8, $eb
00999B  1  DE 42 E2 1B  
00999F  1  B8 EB        
0099A1  1  3B DB 80 8B        .byte $3b, $db, $80, $8b, $b8, $1b, $82, $fb, $b8, $7b
0099A5  1  B8 1B 82 FB  
0099A9  1  B8 7B        
0099AB  1  80 FB 3C 5B        .byte $80, $fb, $3c, $5b, $bc, $7b, $b8, $1b, $8e, $cb
0099AF  1  BC 7B B8 1B  
0099B3  1  8E CB        
0099B5  1  0E 1B 8E 0F        .byte $0e, $1b, $8e, $0f, $0d, $2b, $3b, $bb, $b8, $eb, $82
0099B9  1  0D 2B 3B BB  
0099BD  1  B8 EB 82     
0099C0  1  4B B8 BB 38        .byte $4b, $b8, $bb, $38, $3b, $b7, $bb, $02, $0f, $13
0099C4  1  3B B7 BB 02  
0099C8  1  0F 13        
0099CA  1  1B 00 CB 80        .byte $1b, $00, $cb, $80, $6b, $bc
0099CE  1  6B BC        
0099D0  1  FF                 .byte $ff
0099D1  1               
0099D1  1               ;level 5-2
0099D1  1               E_GroundArea18:
0099D1  1  7B 80 AE 00        .byte $7b, $80, $ae, $00, $80, $8b, $8e, $e8, $05, $f9, $86
0099D5  1  80 8B 8E E8  
0099D9  1  05 F9 86     
0099DC  1  17 86 16 85        .byte $17, $86, $16, $85, $4e, $2b, $80, $ab, $8e, $87, $85
0099E0  1  4E 2B 80 AB  
0099E4  1  8E 87 85     
0099E7  1  C3 05 8B 82        .byte $c3, $05, $8b, $82, $9b, $02, $ab, $02, $bb, $86
0099EB  1  9B 02 AB 02  
0099EF  1  BB 86        
0099F1  1  CB 06 D3 03        .byte $cb, $06, $d3, $03, $3b, $8e, $6b, $0e, $a7, $8e
0099F5  1  3B 8E 6B 0E  
0099F9  1  A7 8E        
0099FB  1  FF                 .byte $ff
0099FC  1               
0099FC  1               ;level 8-2
0099FC  1               E_GroundArea19:
0099FC  1  29 8E 52 11        .byte $29, $8e, $52, $11, $83, $0e, $0f, $03, $9b, $0e
009A00  1  83 0E 0F 03  
009A04  1  9B 0E        
009A06  1  2B 8E 5B 0E        .byte $2b, $8e, $5b, $0e, $cb, $8e, $fb, $0e, $fb, $82
009A0A  1  CB 8E FB 0E  
009A0E  1  FB 82        
009A10  1  9B 82 BB 02        .byte $9b, $82, $bb, $02, $fe, $42, $e8, $bb, $8e, $0f, $0a
009A14  1  FE 42 E8 BB  
009A18  1  8E 0F 0A     
009A1B  1  AB 0E CB 0E        .byte $ab, $0e, $cb, $0e, $f9, $0e, $88, $86, $a6, $06
009A1F  1  F9 0E 88 86  
009A23  1  A6 06        
009A25  1  DB 02 B6 8E        .byte $db, $02, $b6, $8e
009A29  1  FF                 .byte $ff
009A2A  1               
009A2A  1               ;level 7-1
009A2A  1               E_GroundArea20:
009A2A  1  AB CE DE 42        .byte $ab, $ce, $de, $42, $c0, $cb, $ce, $5b, $8e, $1b, $ce
009A2E  1  C0 CB CE 5B  
009A32  1  8E 1B CE     
009A35  1  4B 85 67 45        .byte $4b, $85, $67, $45, $0f, $07, $2b, $00, $7b, $85
009A39  1  0F 07 2B 00  
009A3D  1  7B 85        
009A3F  1  97 05 0F 0A        .byte $97, $05, $0f, $0a, $92, $02
009A43  1  92 02        
009A45  1  FF                 .byte $ff
009A46  1               
009A46  1               ;cloud level used in levels 3-1 and 6-2
009A46  1               E_GroundArea21:
009A46  1  0A AA 0E 24        .byte $0a, $aa, $0e, $24, $4a, $1e, $23, $aa
009A4A  1  4A 1E 23 AA  
009A4E  1  FF                 .byte $ff
009A4F  1               
009A4F  1               ;level 3-2
009A4F  1               E_GroundArea22:
009A4F  1  1B 80 BB 38        .byte $1b, $80, $bb, $38, $4b, $bc, $eb, $3b, $0f, $04
009A53  1  4B BC EB 3B  
009A57  1  0F 04        
009A59  1  2B 00 AB 38        .byte $2b, $00, $ab, $38, $eb, $00, $cb, $8e, $fb, $80
009A5D  1  EB 00 CB 8E  
009A61  1  FB 80        
009A63  1  AB B8 6B 80        .byte $ab, $b8, $6b, $80, $fb, $3c, $9b, $bb, $5b, $bc
009A67  1  FB 3C 9B BB  
009A6B  1  5B BC        
009A6D  1  FB 00 6B B8        .byte $fb, $00, $6b, $b8, $fb, $38
009A71  1  FB 38        
009A73  1  FF                 .byte $ff
009A74  1               
009A74  1               ;level 1-2
009A74  1               E_UndergroundArea1:
009A74  1  0B 86 1A 06        .byte $0b, $86, $1a, $06, $db, $06, $de, $c2, $02, $f0, $3b
009A78  1  DB 06 DE C2  
009A7C  1  02 F0 3B     
009A7F  1  BB 80 EB 06        .byte $bb, $80, $eb, $06, $0b, $86, $93, $06, $f0, $39
009A83  1  0B 86 93 06  
009A87  1  F0 39        
009A89  1  0F 06 60 B8        .byte $0f, $06, $60, $b8, $1b, $86, $a0, $b9, $b7, $27
009A8D  1  1B 86 A0 B9  
009A91  1  B7 27        
009A93  1  BD 27 2B 83        .byte $bd, $27, $2b, $83, $a1, $26, $a9, $26, $ee, $25, $0b
009A97  1  A1 26 A9 26  
009A9B  1  EE 25 0B     
009A9E  1  27 B4              .byte $27, $b4
009AA0  1  FF                 .byte $ff
009AA1  1               
009AA1  1               ;level 4-2
009AA1  1               E_UndergroundArea2:
009AA1  1  0F 02 1E 2F        .byte $0f, $02, $1e, $2f, $60, $e0, $3a, $a5, $a7, $db, $80
009AA5  1  60 E0 3A A5  
009AA9  1  A7 DB 80     
009AAC  1  3B 82 8B 02        .byte $3b, $82, $8b, $02, $fe, $42, $68, $70, $bb, $25, $a7
009AB0  1  FE 42 68 70  
009AB4  1  BB 25 A7     
009AB7  1  2C 27 B2 26        .byte $2c, $27, $b2, $26, $b9, $26, $9b, $80, $a8, $82
009ABB  1  B9 26 9B 80  
009ABF  1  A8 82        
009AC1  1  B5 27 BC 27        .byte $b5, $27, $bc, $27, $b0, $bb, $3b, $82, $87, $34
009AC5  1  B0 BB 3B 82  
009AC9  1  87 34        
009ACB  1  EE 25 6B           .byte $ee, $25, $6b
009ACE  1  FF                 .byte $ff
009ACF  1               
009ACF  1               ;underground bonus rooms area used in many levels
009ACF  1               E_UndergroundArea3:
009ACF  1  1E A5 0A 2E        .byte $1e, $a5, $0a, $2e, $28, $27, $2e, $33, $c7, $0f, $03, $1e, $40, $07
009AD3  1  28 27 2E 33  
009AD7  1  C7 0F 03 1E  
009ADD  1  2E 30 E7 0F        .byte $2e, $30, $e7, $0f, $05, $1e, $24, $44, $0f, $07, $1e, $22, $6a
009AE1  1  05 1E 24 44  
009AE5  1  0F 07 1E 22  
009AEA  1  2E 23 AB 0F        .byte $2e, $23, $ab, $0f, $09, $1e, $41, $68, $1e, $2a, $8a, $2e, $23, $a2
009AEE  1  09 1E 41 68  
009AF2  1  1E 2A 8A 2E  
009AF8  1  2E 32 EA           .byte $2e, $32, $ea
009AFB  1  FF                 .byte $ff
009AFC  1               
009AFC  1               ;water area used in levels 5-2 and 6-2
009AFC  1               E_WaterArea1:
009AFC  1  3B 87 66 27        .byte $3b, $87, $66, $27, $cc, $27, $ee, $31, $87, $ee, $23, $a7
009B00  1  CC 27 EE 31  
009B04  1  87 EE 23 A7  
009B08  1  3B 87 DB 07        .byte $3b, $87, $db, $07
009B0C  1  FF                 .byte $ff
009B0D  1               
009B0D  1               ;level 2-2/7-2
009B0D  1               E_WaterArea2:
009B0D  1  0F 01 2E 25        .byte $0f, $01, $2e, $25, $2b, $2e, $25, $4b, $4e, $25, $cb, $6b, $07
009B11  1  2B 2E 25 4B  
009B15  1  4E 25 CB 6B  
009B1A  1  97 47 E9 87        .byte $97, $47, $e9, $87, $47, $c7, $7a, $07, $d6, $c7
009B1E  1  47 C7 7A 07  
009B22  1  D6 C7        
009B24  1  78 07 38 87        .byte $78, $07, $38, $87, $ab, $47, $e3, $07, $9b, $87
009B28  1  AB 47 E3 07  
009B2C  1  9B 87        
009B2E  1  0F 09 68 47        .byte $0f, $09, $68, $47, $db, $c7, $3b, $c7
009B32  1  DB C7 3B C7  
009B36  1  FF                 .byte $ff
009B37  1               
009B37  1               ;water area used in level 8-4
009B37  1               E_WaterArea3:
009B37  1  47 9B CB 07        .byte $47, $9b, $cb, $07, $fa, $1d, $86, $9b, $3a, $87
009B3B  1  FA 1D 86 9B  
009B3F  1  3A 87        
009B41  1  56 07 88 1B        .byte $56, $07, $88, $1b, $07, $9d, $2e, $65, $f0
009B45  1  07 9D 2E 65  
009B49  1  F0           
009B4A  1  FF                 .byte $ff
009B4B  1               
009B4B  1               ;AREA OBJECT DATA
009B4B  1               
009B4B  1               ;level 1-4/6-4
009B4B  1               L_CastleArea1:
009B4B  1  9B 07              .byte $9b, $07
009B4D  1  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $ce, $03, $dc, $51
009B51  1  07 34 CE 03  
009B55  1  DC 51        
009B57  1  EE 07 73 E0        .byte $ee, $07, $73, $e0, $74, $0a, $7e, $06, $9e, $0a
009B5B  1  74 0A 7E 06  
009B5F  1  9E 0A        
009B61  1  CE 06 E4 00        .byte $ce, $06, $e4, $00, $e8, $0a, $fe, $0a, $2e, $89
009B65  1  E8 0A FE 0A  
009B69  1  2E 89        
009B6B  1  4E 0B 54 0A        .byte $4e, $0b, $54, $0a, $14, $8a, $c4, $0a, $34, $8a
009B6F  1  14 8A C4 0A  
009B73  1  34 8A        
009B75  1  7E 06 C7 0A        .byte $7e, $06, $c7, $0a, $01, $e0, $02, $0a, $47, $0a
009B79  1  01 E0 02 0A  
009B7D  1  47 0A        
009B7F  1  81 60 82 0A        .byte $81, $60, $82, $0a, $c7, $0a, $0e, $87, $7e, $02
009B83  1  C7 0A 0E 87  
009B87  1  7E 02        
009B89  1  A7 02 B3 02        .byte $a7, $02, $b3, $02, $d7, $02, $e3, $02, $07, $82
009B8D  1  D7 02 E3 02  
009B91  1  07 82        
009B93  1  13 02 3E 06        .byte $13, $02, $3e, $06, $7e, $02, $ae, $07, $fe, $0a
009B97  1  7E 02 AE 07  
009B9B  1  FE 0A        
009B9D  1  0D C4 CD 43        .byte $0d, $c4, $cd, $43, $ce, $09, $de, $0b, $dd, $42
009BA1  1  CE 09 DE 0B  
009BA5  1  DD 42        
009BA7  1  FE 02 5D C7        .byte $fe, $02, $5d, $c7
009BAB  1  FD                 .byte $fd
009BAC  1               
009BAC  1               ;level 4-4
009BAC  1               L_CastleArea2:
009BAC  1  5B 07              .byte $5b, $07
009BAE  1  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $5e, $0a, $68, $64
009BB2  1  07 34 5E 0A  
009BB6  1  68 64        
009BB8  1  98 64 A8 64        .byte $98, $64, $a8, $64, $ce, $06, $fe, $02, $0d, $01
009BBC  1  CE 06 FE 02  
009BC0  1  0D 01        
009BC2  1  1E 0E 7E 02        .byte $1e, $0e, $7e, $02, $94, $63, $b4, $63, $d4, $63
009BC6  1  94 63 B4 63  
009BCA  1  D4 63        
009BCC  1  F4 63 14 E3        .byte $f4, $63, $14, $e3, $2e, $0e, $5e, $02, $64, $35
009BD0  1  2E 0E 5E 02  
009BD4  1  64 35        
009BD6  1  88 72 BE 0E        .byte $88, $72, $be, $0e, $0d, $04, $ae, $02, $ce, $08
009BDA  1  0D 04 AE 02  
009BDE  1  CE 08        
009BE0  1  CD 4B FE 02        .byte $cd, $4b, $fe, $02, $0d, $05, $68, $31, $7e, $0a
009BE4  1  0D 05 68 31  
009BE8  1  7E 0A        
009BEA  1  96 31 A9 63        .byte $96, $31, $a9, $63, $a8, $33, $d5, $30, $ee, $02
009BEE  1  A8 33 D5 30  
009BF2  1  EE 02        
009BF4  1  E6 62 F4 61        .byte $e6, $62, $f4, $61, $04, $b1, $08, $3f, $44, $33
009BF8  1  04 B1 08 3F  
009BFC  1  44 33        
009BFE  1  94 63 A4 31        .byte $94, $63, $a4, $31, $e4, $31, $04, $bf, $08, $3f
009C02  1  E4 31 04 BF  
009C06  1  08 3F        
009C08  1  04 BF 08 3F        .byte $04, $bf, $08, $3f, $cd, $4b, $03, $e4, $0e, $03
009C0C  1  CD 4B 03 E4  
009C10  1  0E 03        
009C12  1  2E 01 7E 06        .byte $2e, $01, $7e, $06, $be, $02, $de, $06, $fe, $0a
009C16  1  BE 02 DE 06  
009C1A  1  FE 0A        
009C1C  1  0D C4 CD 43        .byte $0d, $c4, $cd, $43, $ce, $09, $de, $0b, $dd, $42
009C20  1  CE 09 DE 0B  
009C24  1  DD 42        
009C26  1  FE 02 5D C7        .byte $fe, $02, $5d, $c7
009C2A  1  FD                 .byte $fd
009C2B  1               
009C2B  1               ;level 2-4/5-4
009C2B  1               L_CastleArea3:
009C2B  1  9B 07              .byte $9b, $07
009C2D  1  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $fe, $00, $27, $b1
009C31  1  07 34 FE 00  
009C35  1  27 B1        
009C37  1  65 32 75 0A        .byte $65, $32, $75, $0a, $71, $00, $b7, $31, $08, $e4
009C3B  1  71 00 B7 31  
009C3F  1  08 E4        
009C41  1  18 64 1E 04        .byte $18, $64, $1e, $04, $57, $3b, $bb, $0a, $17, $8a
009C45  1  57 3B BB 0A  
009C49  1  17 8A        
009C4B  1  27 3A 73 0A        .byte $27, $3a, $73, $0a, $7b, $0a, $d7, $0a, $e7, $3a
009C4F  1  7B 0A D7 0A  
009C53  1  E7 3A        
009C55  1  3B 8A 97 0A        .byte $3b, $8a, $97, $0a, $fe, $08, $24, $8a, $2e, $00
009C59  1  FE 08 24 8A  
009C5D  1  2E 00        
009C5F  1  3E 40 38 64        .byte $3e, $40, $38, $64, $6f, $00, $9f, $00, $be, $43
009C63  1  6F 00 9F 00  
009C67  1  BE 43        
009C69  1  C8 0A C9 63        .byte $c8, $0a, $c9, $63, $ce, $07, $fe, $07, $2e, $81
009C6D  1  CE 07 FE 07  
009C71  1  2E 81        
009C73  1  66 42 6A 42        .byte $66, $42, $6a, $42, $79, $0a, $be, $00, $c8, $64
009C77  1  79 0A BE 00  
009C7B  1  C8 64        
009C7D  1  F8 64 08 E4        .byte $f8, $64, $08, $e4, $2e, $07, $7e, $03, $9e, $07
009C81  1  2E 07 7E 03  
009C85  1  9E 07        
009C87  1  BE 03 DE 07        .byte $be, $03, $de, $07, $fe, $0a, $03, $a5, $0d, $44
009C8B  1  FE 0A 03 A5  
009C8F  1  0D 44        
009C91  1  CD 43 CE 09        .byte $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02
009C95  1  DD 42 DE 0B  
009C99  1  FE 02        
009C9B  1  5D C7              .byte $5d, $c7
009C9D  1  FD                 .byte $fd
009C9E  1               
009C9E  1               ;level 3-4
009C9E  1               L_CastleArea4:
009C9E  1  9B 07              .byte $9b, $07
009CA0  1  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $fe, $06, $0c, $81
009CA4  1  07 34 FE 06  
009CA8  1  0C 81        
009CAA  1  39 0A 5C 01        .byte $39, $0a, $5c, $01, $89, $0a, $ac, $01, $d9, $0a
009CAE  1  89 0A AC 01  
009CB2  1  D9 0A        
009CB4  1  FC 01 2E 83        .byte $fc, $01, $2e, $83, $a7, $01, $b7, $00, $c7, $01
009CB8  1  A7 01 B7 00  
009CBC  1  C7 01        
009CBE  1  DE 0A FE 02        .byte $de, $0a, $fe, $02, $4e, $83, $5a, $32, $63, $0a
009CC2  1  4E 83 5A 32  
009CC6  1  63 0A        
009CC8  1  69 0A 7E 02        .byte $69, $0a, $7e, $02, $ee, $03, $fa, $32, $03, $8a
009CCC  1  EE 03 FA 32  
009CD0  1  03 8A        
009CD2  1  09 0A 1E 02        .byte $09, $0a, $1e, $02, $ee, $03, $fa, $32, $03, $8a
009CD6  1  EE 03 FA 32  
009CDA  1  03 8A        
009CDC  1  09 0A 14 42        .byte $09, $0a, $14, $42, $1e, $02, $7e, $0a, $9e, $07
009CE0  1  1E 02 7E 0A  
009CE4  1  9E 07        
009CE6  1  FE 0A 2E 86        .byte $fe, $0a, $2e, $86, $5e, $0a, $8e, $06, $be, $0a
009CEA  1  5E 0A 8E 06  
009CEE  1  BE 0A        
009CF0  1  EE 07 3E 83        .byte $ee, $07, $3e, $83, $5e, $07, $fe, $0a, $0d, $c4
009CF4  1  5E 07 FE 0A  
009CF8  1  0D C4        
009CFA  1  41 52 51 52        .byte $41, $52, $51, $52, $cd, $43, $ce, $09, $de, $0b
009CFE  1  CD 43 CE 09  
009D02  1  DE 0B        
009D04  1  DD 42 FE 02        .byte $dd, $42, $fe, $02, $5d, $c7
009D08  1  5D C7        
009D0A  1  FD                 .byte $fd
009D0B  1               
009D0B  1               ;level 7-4
009D0B  1               L_CastleArea5:
009D0B  1  5B 07              .byte $5b, $07
009D0D  1  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $fe, $0a, $ae, $86
009D11  1  07 34 FE 0A  
009D15  1  AE 86        
009D17  1  BE 07 FE 02        .byte $be, $07, $fe, $02, $0d, $02, $27, $32, $46, $61
009D1B  1  0D 02 27 32  
009D1F  1  46 61        
009D21  1  55 62 5E 0E        .byte $55, $62, $5e, $0e, $1e, $82, $68, $3c, $74, $3a
009D25  1  1E 82 68 3C  
009D29  1  74 3A        
009D2B  1  7D 4B 5E 8E        .byte $7d, $4b, $5e, $8e, $7d, $4b, $7e, $82, $84, $62
009D2F  1  7D 4B 7E 82  
009D33  1  84 62        
009D35  1  94 61 A4 31        .byte $94, $61, $a4, $31, $bd, $4b, $ce, $06, $fe, $02
009D39  1  BD 4B CE 06  
009D3D  1  FE 02        
009D3F  1  0D 06 34 31        .byte $0d, $06, $34, $31, $3e, $0a, $64, $32, $75, $0a
009D43  1  3E 0A 64 32  
009D47  1  75 0A        
009D49  1  7B 61 A4 33        .byte $7b, $61, $a4, $33, $ae, $02, $de, $0e, $3e, $82
009D4D  1  AE 02 DE 0E  
009D51  1  3E 82        
009D53  1  64 32 78 32        .byte $64, $32, $78, $32, $b4, $36, $c8, $36, $dd, $4b
009D57  1  B4 36 C8 36  
009D5B  1  DD 4B        
009D5D  1  44 B2 58 32        .byte $44, $b2, $58, $32, $94, $63, $a4, $3e, $ba, $30
009D61  1  94 63 A4 3E  
009D65  1  BA 30        
009D67  1  C9 61 CE 06        .byte $c9, $61, $ce, $06, $dd, $4b, $ce, $86, $dd, $4b
009D6B  1  DD 4B CE 86  
009D6F  1  DD 4B        
009D71  1  FE 02 2E 86        .byte $fe, $02, $2e, $86, $5e, $02, $7e, $06, $fe, $02
009D75  1  5E 02 7E 06  
009D79  1  FE 02        
009D7B  1  1E 86 3E 02        .byte $1e, $86, $3e, $02, $5e, $06, $7e, $02, $9e, $06
009D7F  1  5E 06 7E 02  
009D83  1  9E 06        
009D85  1  FE 0A 0D C4        .byte $fe, $0a, $0d, $c4, $cd, $43, $ce, $09, $de, $0b
009D89  1  CD 43 CE 09  
009D8D  1  DE 0B        
009D8F  1  DD 42 FE 02        .byte $dd, $42, $fe, $02, $5d, $c7
009D93  1  5D C7        
009D95  1  FD                 .byte $fd
009D96  1               
009D96  1               ;level 8-4
009D96  1               L_CastleArea6:
009D96  1  5B 06              .byte $5b, $06
009D98  1  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $5e, $0a, $ae, $02
009D9C  1  07 34 5E 0A  
009DA0  1  AE 02        
009DA2  1  0D 01 39 73        .byte $0d, $01, $39, $73, $0d, $03, $39, $7b, $4d, $4b
009DA6  1  0D 03 39 7B  
009DAA  1  4D 4B        
009DAC  1  DE 06 1E 8A        .byte $de, $06, $1e, $8a, $ae, $06, $c4, $33, $16, $fe
009DB0  1  AE 06 C4 33  
009DB4  1  16 FE        
009DB6  1  A5 77 FE 02        .byte $a5, $77, $fe, $02, $fe, $82, $0d, $07, $39, $73
009DBA  1  FE 82 0D 07  
009DBE  1  39 73        
009DC0  1  A8 74 ED 4B        .byte $a8, $74, $ed, $4b, $49, $fb, $e8, $74, $fe, $0a
009DC4  1  49 FB E8 74  
009DC8  1  FE 0A        
009DCA  1  2E 82 67 02        .byte $2e, $82, $67, $02, $84, $7a, $87, $31, $0d, $0b
009DCE  1  84 7A 87 31  
009DD2  1  0D 0B        
009DD4  1  FE 02 0D 0C        .byte $fe, $02, $0d, $0c, $39, $73, $5e, $06, $c6, $76
009DD8  1  39 73 5E 06  
009DDC  1  C6 76        
009DDE  1  45 FF BE 0A        .byte $45, $ff, $be, $0a, $dd, $48, $fe, $06, $3d, $cb
009DE2  1  DD 48 FE 06  
009DE6  1  3D CB        
009DE8  1  46 7E AD 4A        .byte $46, $7e, $ad, $4a, $fe, $82, $39, $f3, $a9, $7b
009DEC  1  FE 82 39 F3  
009DF0  1  A9 7B        
009DF2  1  4E 8A 9E 07        .byte $4e, $8a, $9e, $07, $fe, $0a, $0d, $c4, $cd, $43
009DF6  1  FE 0A 0D C4  
009DFA  1  CD 43        
009DFC  1  CE 09 DE 0B        .byte $ce, $09, $de, $0b, $dd, $42, $fe, $02, $5d, $c7
009E00  1  DD 42 FE 02  
009E04  1  5D C7        
009E06  1  FD                 .byte $fd
009E07  1               
009E07  1               ;level 3-3
009E07  1               L_GroundArea1:
009E07  1  94 11              .byte $94, $11
009E09  1  0F 26 FE 10        .byte $0f, $26, $fe, $10, $28, $94, $65, $15, $eb, $12
009E0D  1  28 94 65 15  
009E11  1  EB 12        
009E13  1  FA 41 4A 96        .byte $fa, $41, $4a, $96, $54, $40, $a4, $42, $b7, $13
009E17  1  54 40 A4 42  
009E1B  1  B7 13        
009E1D  1  E9 19 F5 15        .byte $e9, $19, $f5, $15, $11, $80, $47, $42, $71, $13
009E21  1  11 80 47 42  
009E25  1  71 13        
009E27  1  80 41 15 92        .byte $80, $41, $15, $92, $1b, $1f, $24, $40, $55, $12
009E2B  1  1B 1F 24 40  
009E2F  1  55 12        
009E31  1  64 40 95 12        .byte $64, $40, $95, $12, $a4, $40, $d2, $12, $e1, $40
009E35  1  A4 40 D2 12  
009E39  1  E1 40        
009E3B  1  13 C0 2C 17        .byte $13, $c0, $2c, $17, $2f, $12, $49, $13, $83, $40
009E3F  1  2F 12 49 13  
009E43  1  83 40        
009E45  1  9F 14 A3 40        .byte $9f, $14, $a3, $40, $17, $92, $83, $13, $92, $41
009E49  1  17 92 83 13  
009E4D  1  92 41        
009E4F  1  B9 14 C5 12        .byte $b9, $14, $c5, $12, $c8, $40, $d4, $40, $4b, $92
009E53  1  C8 40 D4 40  
009E57  1  4B 92        
009E59  1  78 1B 9C 94        .byte $78, $1b, $9c, $94, $9f, $11, $df, $14, $fe, $11
009E5D  1  9F 11 DF 14  
009E61  1  FE 11        
009E63  1  7D C1 9E 42        .byte $7d, $c1, $9e, $42, $cf, $20
009E67  1  CF 20        
009E69  1  FD                 .byte $fd
009E6A  1               
009E6A  1               ;level 8-3
009E6A  1               L_GroundArea2:
009E6A  1  90 B1              .byte $90, $b1
009E6C  1  0F 26 29 91        .byte $0f, $26, $29, $91, $7e, $42, $fe, $40, $28, $92
009E70  1  7E 42 FE 40  
009E74  1  28 92        
009E76  1  4E 42 2E C0        .byte $4e, $42, $2e, $c0, $57, $73, $c3, $25, $c7, $27
009E7A  1  57 73 C3 25  
009E7E  1  C7 27        
009E80  1  23 84 33 20        .byte $23, $84, $33, $20, $5c, $01, $77, $63, $88, $62
009E84  1  5C 01 77 63  
009E88  1  88 62        
009E8A  1  99 61 AA 60        .byte $99, $61, $aa, $60, $bc, $01, $ee, $42, $4e, $c0
009E8E  1  BC 01 EE 42  
009E92  1  4E C0        
009E94  1  69 11 7E 42        .byte $69, $11, $7e, $42, $de, $40, $f8, $62, $0e, $c2
009E98  1  DE 40 F8 62  
009E9C  1  0E C2        
009E9E  1  AE 40 D7 63        .byte $ae, $40, $d7, $63, $e7, $63, $33, $a7, $37, $27
009EA2  1  E7 63 33 A7  
009EA6  1  37 27        
009EA8  1  43 04 CC 01        .byte $43, $04, $cc, $01, $e7, $73, $0c, $81, $3e, $42
009EAC  1  E7 73 0C 81  
009EB0  1  3E 42        
009EB2  1  0D 0A 5E 40        .byte $0d, $0a, $5e, $40, $88, $72, $be, $42, $e7, $87
009EB6  1  88 72 BE 42  
009EBA  1  E7 87        
009EBC  1  FE 40 39 E1        .byte $fe, $40, $39, $e1, $4e, $00, $69, $60, $87, $60
009EC0  1  4E 00 69 60  
009EC4  1  87 60        
009EC6  1  A5 60 C3 31        .byte $a5, $60, $c3, $31, $fe, $31, $6d, $c1, $be, $42
009ECA  1  FE 31 6D C1  
009ECE  1  BE 42        
009ED0  1  EF 20              .byte $ef, $20
009ED2  1  FD                 .byte $fd
009ED3  1               
009ED3  1               ;level 4-1
009ED3  1               L_GroundArea3:
009ED3  1  52 21              .byte $52, $21
009ED5  1  0F 20 6E 40        .byte $0f, $20, $6e, $40, $58, $f2, $93, $01, $97, $00
009ED9  1  58 F2 93 01  
009EDD  1  97 00        
009EDF  1  0C 81 97 40        .byte $0c, $81, $97, $40, $a6, $41, $c7, $40, $0d, $04
009EE3  1  A6 41 C7 40  
009EE7  1  0D 04        
009EE9  1  03 01 07 01        .byte $03, $01, $07, $01, $23, $01, $27, $01, $ec, $03
009EED  1  23 01 27 01  
009EF1  1  EC 03        
009EF3  1  AC F3 C3 03        .byte $ac, $f3, $c3, $03, $78, $e2, $94, $43, $47, $f3
009EF7  1  78 E2 94 43  
009EFB  1  47 F3        
009EFD  1  74 43 47 FB        .byte $74, $43, $47, $fb, $74, $43, $2c, $f1, $4c, $63
009F01  1  74 43 2C F1  
009F05  1  4C 63        
009F07  1  47 00 57 21        .byte $47, $00, $57, $21, $5c, $01, $7c, $72, $39, $f1
009F0B  1  5C 01 7C 72  
009F0F  1  39 F1        
009F11  1  EC 02 4C 81        .byte $ec, $02, $4c, $81, $d8, $62, $ec, $01, $0d, $0d
009F15  1  D8 62 EC 01  
009F19  1  0D 0D        
009F1B  1  0F 38 C7 07        .byte $0f, $38, $c7, $07, $ed, $4a, $1d, $c1, $5f, $26
009F1F  1  ED 4A 1D C1  
009F23  1  5F 26        
009F25  1  FD                 .byte $fd
009F26  1               
009F26  1               ;level 6-2
009F26  1               L_GroundArea4:
009F26  1  54 21              .byte $54, $21
009F28  1  0F 26 A7 22        .byte $0f, $26, $a7, $22, $37, $fb, $73, $20, $83, $07
009F2C  1  37 FB 73 20  
009F30  1  83 07        
009F32  1  87 02 93 20        .byte $87, $02, $93, $20, $c7, $73, $04, $f1, $06, $31
009F36  1  C7 73 04 F1  
009F3A  1  06 31        
009F3C  1  39 71 59 71        .byte $39, $71, $59, $71, $e7, $73, $37, $a0, $47, $04
009F40  1  E7 73 37 A0  
009F44  1  47 04        
009F46  1  86 7C E5 71        .byte $86, $7c, $e5, $71, $e7, $31, $33, $a4, $39, $71
009F4A  1  E7 31 33 A4  
009F4E  1  39 71        
009F50  1  A9 71 D3 23        .byte $a9, $71, $d3, $23, $08, $f2, $13, $05, $27, $02
009F54  1  08 F2 13 05  
009F58  1  27 02        
009F5A  1  49 71 75 75        .byte $49, $71, $75, $75, $e8, $72, $67, $f3, $99, $71
009F5E  1  E8 72 67 F3  
009F62  1  99 71        
009F64  1  E7 20 F4 72        .byte $e7, $20, $f4, $72, $f7, $31, $17, $a0, $33, $20
009F68  1  F7 31 17 A0  
009F6C  1  33 20        
009F6E  1  39 71 73 28        .byte $39, $71, $73, $28, $bc, $05, $39, $f1, $79, $71
009F72  1  BC 05 39 F1  
009F76  1  79 71        
009F78  1  A6 21 C3 06        .byte $a6, $21, $c3, $06, $d3, $20, $dc, $00, $fc, $00
009F7C  1  D3 20 DC 00  
009F80  1  FC 00        
009F82  1  07 A2 13 21        .byte $07, $a2, $13, $21, $5f, $32, $8c, $00, $98, $7a
009F86  1  5F 32 8C 00  
009F8A  1  98 7A        
009F8C  1  C7 63 D9 61        .byte $c7, $63, $d9, $61, $03, $a2, $07, $22, $74, $72
009F90  1  03 A2 07 22  
009F94  1  74 72        
009F96  1  77 31 E7 73        .byte $77, $31, $e7, $73, $39, $f1, $58, $72, $77, $73
009F9A  1  39 F1 58 72  
009F9E  1  77 73        
009FA0  1  D8 72 7F B1        .byte $d8, $72, $7f, $b1, $97, $73, $b6, $64, $c5, $65
009FA4  1  97 73 B6 64  
009FA8  1  C5 65        
009FAA  1  D4 66 E3 67        .byte $d4, $66, $e3, $67, $f3, $67, $8d, $c1, $cf, $26
009FAE  1  F3 67 8D C1  
009FB2  1  CF 26        
009FB4  1  FD                 .byte $fd
009FB5  1               
009FB5  1               ;level 3-1
009FB5  1               L_GroundArea5:
009FB5  1  52 31              .byte $52, $31
009FB7  1  0F 20 6E 66        .byte $0f, $20, $6e, $66, $07, $81, $36, $01, $66, $00
009FBB  1  07 81 36 01  
009FBF  1  66 00        
009FC1  1  A7 22 08 F2        .byte $a7, $22, $08, $f2, $67, $7b, $dc, $02, $98, $f2
009FC5  1  67 7B DC 02  
009FC9  1  98 F2        
009FCB  1  D7 20 39 F1        .byte $d7, $20, $39, $f1, $9f, $33, $dc, $27, $dc, $57
009FCF  1  9F 33 DC 27  
009FD3  1  DC 57        
009FD5  1  23 83 57 63        .byte $23, $83, $57, $63, $6c, $51, $87, $63, $99, $61
009FD9  1  6C 51 87 63  
009FDD  1  99 61        
009FDF  1  A3 06 B3 21        .byte $a3, $06, $b3, $21, $77, $f3, $f3, $21, $f7, $2a
009FE3  1  77 F3 F3 21  
009FE7  1  F7 2A        
009FE9  1  13 81 23 22        .byte $13, $81, $23, $22, $53, $00, $63, $22, $e9, $0b
009FED  1  53 00 63 22  
009FF1  1  E9 0B        
009FF3  1  0C 83 13 21        .byte $0c, $83, $13, $21, $16, $22, $33, $05, $8f, $35
009FF7  1  16 22 33 05  
009FFB  1  8F 35        
009FFD  1  EC 01 63 A0        .byte $ec, $01, $63, $a0, $67, $20, $73, $01, $77, $01
00A001  1  67 20 73 01  
00A005  1  77 01        
00A007  1  83 20 87 20        .byte $83, $20, $87, $20, $b3, $20, $b7, $20, $c3, $01
00A00B  1  B3 20 B7 20  
00A00F  1  C3 01        
00A011  1  C7 00 D3 20        .byte $c7, $00, $d3, $20, $d7, $20, $67, $a0, $77, $07
00A015  1  D7 20 67 A0  
00A019  1  77 07        
00A01B  1  87 22 E8 62        .byte $87, $22, $e8, $62, $f5, $65, $1c, $82, $7f, $38
00A01F  1  F5 65 1C 82  
00A023  1  7F 38        
00A025  1  8D C1 CF 26        .byte $8d, $c1, $cf, $26
00A029  1  FD                 .byte $fd
00A02A  1               
00A02A  1               ;level 1-1
00A02A  1               L_GroundArea6:
00A02A  1  50 21              .byte $50, $21
00A02C  1  07 81 47 24        .byte $07, $81, $47, $24, $57, $00, $63, $01, $77, $01
00A030  1  57 00 63 01  
00A034  1  77 01        
00A036  1  C9 71 68 F2        .byte $c9, $71, $68, $f2, $e7, $73, $97, $fb, $06, $83
00A03A  1  E7 73 97 FB  
00A03E  1  06 83        
00A040  1  5C 01 D7 22        .byte $5c, $01, $d7, $22, $e7, $00, $03, $a7, $6c, $02
00A044  1  E7 00 03 A7  
00A048  1  6C 02        
00A04A  1  B3 22 E3 01        .byte $b3, $22, $e3, $01, $e7, $07, $47, $a0, $57, $06
00A04E  1  E7 07 47 A0  
00A052  1  57 06        
00A054  1  A7 01 D3 00        .byte $a7, $01, $d3, $00, $d7, $01, $07, $81, $67, $20
00A058  1  D7 01 07 81  
00A05C  1  67 20        
00A05E  1  93 22 03 A3        .byte $93, $22, $03, $a3, $1c, $61, $17, $21, $6f, $33
00A062  1  1C 61 17 21  
00A066  1  6F 33        
00A068  1  C7 63 D8 62        .byte $c7, $63, $d8, $62, $e9, $61, $fa, $60, $4f, $b3
00A06C  1  E9 61 FA 60  
00A070  1  4F B3        
00A072  1  87 63 9C 01        .byte $87, $63, $9c, $01, $b7, $63, $c8, $62, $d9, $61
00A076  1  B7 63 C8 62  
00A07A  1  D9 61        
00A07C  1  EA 60 39 F1        .byte $ea, $60, $39, $f1, $87, $21, $a7, $01, $b7, $20
00A080  1  87 21 A7 01  
00A084  1  B7 20        
00A086  1  39 F1 5F 38        .byte $39, $f1, $5f, $38, $6d, $c1, $af, $26
00A08A  1  6D C1 AF 26  
00A08E  1  FD                 .byte $fd
00A08F  1               
00A08F  1               ;level 1-3/5-3
00A08F  1               L_GroundArea7:
00A08F  1  90 11              .byte $90, $11
00A091  1  0F 26 FE 10        .byte $0f, $26, $fe, $10, $2a, $93, $87, $17, $a3, $14
00A095  1  2A 93 87 17  
00A099  1  A3 14        
00A09B  1  B2 42 0A 92        .byte $b2, $42, $0a, $92, $19, $40, $36, $14, $50, $41
00A09F  1  19 40 36 14  
00A0A3  1  50 41        
00A0A5  1  82 16 2B 93        .byte $82, $16, $2b, $93, $24, $41, $bb, $14, $b8, $00
00A0A9  1  24 41 BB 14  
00A0AD  1  B8 00        
00A0AF  1  C2 43 C3 13        .byte $c2, $43, $c3, $13, $1b, $94, $67, $12, $c4, $15
00A0B3  1  1B 94 67 12  
00A0B7  1  C4 15        
00A0B9  1  53 C1 D2 41        .byte $53, $c1, $d2, $41, $12, $c1, $29, $13, $85, $17
00A0BD  1  12 C1 29 13  
00A0C1  1  85 17        
00A0C3  1  1B 92 1A 42        .byte $1b, $92, $1a, $42, $47, $13, $83, $41, $a7, $13
00A0C7  1  47 13 83 41  
00A0CB  1  A7 13        
00A0CD  1  0E 91 A7 63        .byte $0e, $91, $a7, $63, $b7, $63, $c5, $65, $d5, $65
00A0D1  1  B7 63 C5 65  
00A0D5  1  D5 65        
00A0D7  1  DD 4A E3 67        .byte $dd, $4a, $e3, $67, $f3, $67, $8d, $c1, $ae, $42
00A0DB  1  F3 67 8D C1  
00A0DF  1  AE 42        
00A0E1  1  DF 20              .byte $df, $20
00A0E3  1  FD                 .byte $fd
00A0E4  1               
00A0E4  1               ;level 2-3/7-3
00A0E4  1               L_GroundArea8:
00A0E4  1  90 11              .byte $90, $11
00A0E6  1  0F 26 6E 10        .byte $0f, $26, $6e, $10, $8b, $17, $af, $32, $d8, $62
00A0EA  1  8B 17 AF 32  
00A0EE  1  D8 62        
00A0F0  1  E8 62 FC 3F        .byte $e8, $62, $fc, $3f, $ad, $c8, $f8, $64, $0c, $be
00A0F4  1  AD C8 F8 64  
00A0F8  1  0C BE        
00A0FA  1  43 43 F8 64        .byte $43, $43, $f8, $64, $0c, $bf, $73, $40, $84, $40
00A0FE  1  0C BF 73 40  
00A102  1  84 40        
00A104  1  93 40 A4 40        .byte $93, $40, $a4, $40, $b3, $40, $f8, $64, $48, $e4
00A108  1  B3 40 F8 64  
00A10C  1  48 E4        
00A10E  1  5C 39 83 40        .byte $5c, $39, $83, $40, $92, $41, $b3, $40, $f8, $64
00A112  1  92 41 B3 40  
00A116  1  F8 64        
00A118  1  48 E4 5C 39        .byte $48, $e4, $5c, $39, $f8, $64, $13, $c2, $37, $65
00A11C  1  F8 64 13 C2  
00A120  1  37 65        
00A122  1  4C 24 63 00        .byte $4c, $24, $63, $00, $97, $65, $c3, $42, $0b, $97
00A126  1  97 65 C3 42  
00A12A  1  0B 97        
00A12C  1  AC 32 F8 64        .byte $ac, $32, $f8, $64, $0c, $be, $53, $45, $9d, $48
00A130  1  0C BE 53 45  
00A134  1  9D 48        
00A136  1  F8 64 2A E2        .byte $f8, $64, $2a, $e2, $3c, $47, $56, $43, $ba, $62
00A13A  1  3C 47 56 43  
00A13E  1  BA 62        
00A140  1  F8 64 0C B7        .byte $f8, $64, $0c, $b7, $88, $64, $bc, $31, $d4, $45
00A144  1  88 64 BC 31  
00A148  1  D4 45        
00A14A  1  FC 31 3C B1        .byte $fc, $31, $3c, $b1, $78, $64, $8c, $38, $0b, $9c
00A14E  1  78 64 8C 38  
00A152  1  0B 9C        
00A154  1  1A 33 18 61        .byte $1a, $33, $18, $61, $28, $61, $39, $60, $5d, $4a
00A158  1  28 61 39 60  
00A15C  1  5D 4A        
00A15E  1  EE 11 0F B8        .byte $ee, $11, $0f, $b8, $1d, $c1, $3e, $42, $6f, $20
00A162  1  1D C1 3E 42  
00A166  1  6F 20        
00A168  1  FD                 .byte $fd
00A169  1               
00A169  1               ;level 2-1
00A169  1               L_GroundArea9:
00A169  1  52 31              .byte $52, $31
00A16B  1  0F 20 6E 40        .byte $0f, $20, $6e, $40, $f7, $20, $07, $84, $17, $20
00A16F  1  F7 20 07 84  
00A173  1  17 20        
00A175  1  4F 34 C3 03        .byte $4f, $34, $c3, $03, $c7, $02, $d3, $22, $27, $e3
00A179  1  C7 02 D3 22  
00A17D  1  27 E3        
00A17F  1  39 61 E7 73        .byte $39, $61, $e7, $73, $5c, $e4, $57, $00, $6c, $73
00A183  1  5C E4 57 00  
00A187  1  6C 73        
00A189  1  47 A0 53 06        .byte $47, $a0, $53, $06, $63, $22, $a7, $73, $fc, $73
00A18D  1  63 22 A7 73  
00A191  1  FC 73        
00A193  1  13 A1 33 05        .byte $13, $a1, $33, $05, $43, $21, $5c, $72, $c3, $23
00A197  1  43 21 5C 72  
00A19B  1  C3 23        
00A19D  1  CC 03 77 FB        .byte $cc, $03, $77, $fb, $ac, $02, $39, $f1, $a7, $73
00A1A1  1  AC 02 39 F1  
00A1A5  1  A7 73        
00A1A7  1  D3 04 E8 72        .byte $d3, $04, $e8, $72, $e3, $22, $26, $f4, $bc, $02
00A1AB  1  E3 22 26 F4  
00A1AF  1  BC 02        
00A1B1  1  8C 81 A8 62        .byte $8c, $81, $a8, $62, $17, $87, $43, $24, $a7, $01
00A1B5  1  17 87 43 24  
00A1B9  1  A7 01        
00A1BB  1  C3 04 08 F2        .byte $c3, $04, $08, $f2, $97, $21, $a3, $02, $c9, $0b
00A1BF  1  97 21 A3 02  
00A1C3  1  C9 0B        
00A1C5  1  E1 69 F1 69        .byte $e1, $69, $f1, $69, $8d, $c1, $cf, $26
00A1C9  1  8D C1 CF 26  
00A1CD  1  FD                 .byte $fd
00A1CE  1               
00A1CE  1               ;pipe intro area
00A1CE  1               L_GroundArea10:
00A1CE  1  38 11              .byte $38, $11
00A1D0  1  0F 26 AD 40        .byte $0f, $26, $ad, $40, $3d, $c7
00A1D4  1  3D C7        
00A1D6  1  FD                 .byte $fd
00A1D7  1               
00A1D7  1               ;level 5-1
00A1D7  1               L_GroundArea11:
00A1D7  1  95 B1              .byte $95, $b1
00A1D9  1  0F 26 0D 02        .byte $0f, $26, $0d, $02, $c8, $72, $1c, $81, $38, $72
00A1DD  1  C8 72 1C 81  
00A1E1  1  38 72        
00A1E3  1  0D 05 97 34        .byte $0d, $05, $97, $34, $98, $62, $a3, $20, $b3, $06
00A1E7  1  98 62 A3 20  
00A1EB  1  B3 06        
00A1ED  1  C3 20 CC 03        .byte $c3, $20, $cc, $03, $f9, $91, $2c, $81, $48, $62
00A1F1  1  F9 91 2C 81  
00A1F5  1  48 62        
00A1F7  1  0D 09 37 63        .byte $0d, $09, $37, $63, $47, $03, $57, $21, $8c, $02
00A1FB  1  47 03 57 21  
00A1FF  1  8C 02        
00A201  1  C5 79 C7 31        .byte $c5, $79, $c7, $31, $f9, $11, $39, $f1, $a9, $11
00A205  1  F9 11 39 F1  
00A209  1  A9 11        
00A20B  1  6F B4 D3 65        .byte $6f, $b4, $d3, $65, $e3, $65, $7d, $c1, $bf, $26
00A20F  1  E3 65 7D C1  
00A213  1  BF 26        
00A215  1  FD                 .byte $fd
00A216  1               
00A216  1               ;cloud level used in levels 2-1 and 5-2
00A216  1               L_GroundArea12:
00A216  1  00 C1              .byte $00, $c1
00A218  1  4C 00 F4 4F        .byte $4c, $00, $f4, $4f, $0d, $02, $02, $42, $43, $4f
00A21C  1  0D 02 02 42  
00A220  1  43 4F        
00A222  1  52 C2 DE 00        .byte $52, $c2, $de, $00, $5a, $c2, $4d, $c7
00A226  1  5A C2 4D C7  
00A22A  1  FD                 .byte $fd
00A22B  1               
00A22B  1               ;level 4-3
00A22B  1               L_GroundArea13:
00A22B  1  90 51              .byte $90, $51
00A22D  1  0F 26 EE 10        .byte $0f, $26, $ee, $10, $0b, $94, $33, $14, $42, $42
00A231  1  0B 94 33 14  
00A235  1  42 42        
00A237  1  77 16 86 44        .byte $77, $16, $86, $44, $02, $92, $4a, $16, $69, $42
00A23B  1  02 92 4A 16  
00A23F  1  69 42        
00A241  1  73 14 B0 00        .byte $73, $14, $b0, $00, $c7, $12, $05, $c0, $1c, $17
00A245  1  C7 12 05 C0  
00A249  1  1C 17        
00A24B  1  1F 11 36 12        .byte $1f, $11, $36, $12, $8f, $14, $91, $40, $1b, $94
00A24F  1  8F 14 91 40  
00A253  1  1B 94        
00A255  1  35 12 34 42        .byte $35, $12, $34, $42, $60, $42, $61, $12, $87, $12
00A259  1  60 42 61 12  
00A25D  1  87 12        
00A25F  1  96 40 A3 14        .byte $96, $40, $a3, $14, $1c, $98, $1f, $11, $47, $12
00A263  1  1C 98 1F 11  
00A267  1  47 12        
00A269  1  9F 15 CC 15        .byte $9f, $15, $cc, $15, $cf, $11, $05, $c0, $1f, $15
00A26D  1  CF 11 05 C0  
00A271  1  1F 15        
00A273  1  39 12 7C 16        .byte $39, $12, $7c, $16, $7f, $11, $82, $40, $98, $12
00A277  1  7F 11 82 40  
00A27B  1  98 12        
00A27D  1  DF 15 16 C4        .byte $df, $15, $16, $c4, $17, $14, $54, $12, $9b, $16
00A281  1  17 14 54 12  
00A285  1  9B 16        
00A287  1  28 94 CE 01        .byte $28, $94, $ce, $01, $3d, $c1, $5e, $42, $8f, $20
00A28B  1  3D C1 5E 42  
00A28F  1  8F 20        
00A291  1  FD                 .byte $fd
00A292  1               
00A292  1               ;level 6-3
00A292  1               L_GroundArea14:
00A292  1  97 11              .byte $97, $11
00A294  1  0F 26 FE 10        .byte $0f, $26, $fe, $10, $2b, $92, $57, $12, $8b, $12
00A298  1  2B 92 57 12  
00A29C  1  8B 12        
00A29E  1  C0 41 F7 13        .byte $c0, $41, $f7, $13, $5b, $92, $69, $0b, $bb, $12
00A2A2  1  5B 92 69 0B  
00A2A6  1  BB 12        
00A2A8  1  B2 46 19 93        .byte $b2, $46, $19, $93, $71, $00, $17, $94, $7c, $14
00A2AC  1  71 00 17 94  
00A2B0  1  7C 14        
00A2B2  1  7F 11 93 41        .byte $7f, $11, $93, $41, $bf, $15, $fc, $13, $ff, $11
00A2B6  1  BF 15 FC 13  
00A2BA  1  FF 11        
00A2BC  1  2F 95 50 42        .byte $2f, $95, $50, $42, $51, $12, $58, $14, $a6, $12
00A2C0  1  51 12 58 14  
00A2C4  1  A6 12        
00A2C6  1  DB 12 1B 93        .byte $db, $12, $1b, $93, $46, $43, $7b, $12, $8d, $49
00A2CA  1  46 43 7B 12  
00A2CE  1  8D 49        
00A2D0  1  B7 14 1B 94        .byte $b7, $14, $1b, $94, $49, $0b, $bb, $12, $fc, $13
00A2D4  1  49 0B BB 12  
00A2D8  1  FC 13        
00A2DA  1  FF 12 03 C1        .byte $ff, $12, $03, $c1, $2f, $15, $43, $12, $4b, $13
00A2DE  1  2F 15 43 12  
00A2E2  1  4B 13        
00A2E4  1  77 13 9D 4A        .byte $77, $13, $9d, $4a, $15, $c1, $a1, $41, $c3, $12
00A2E8  1  15 C1 A1 41  
00A2EC  1  C3 12        
00A2EE  1  FE 01 7D C1        .byte $fe, $01, $7d, $c1, $9e, $42, $cf, $20
00A2F2  1  9E 42 CF 20  
00A2F6  1  FD                 .byte $fd
00A2F7  1               
00A2F7  1               ;level 6-1
00A2F7  1               L_GroundArea15:
00A2F7  1  52 21              .byte $52, $21
00A2F9  1  0F 20 6E 44        .byte $0f, $20, $6e, $44, $0c, $f1, $4c, $01, $aa, $35
00A2FD  1  0C F1 4C 01  
00A301  1  AA 35        
00A303  1  D9 34 EE 20        .byte $d9, $34, $ee, $20, $08, $b3, $37, $32, $43, $04
00A307  1  08 B3 37 32  
00A30B  1  43 04        
00A30D  1  4E 21 53 20        .byte $4e, $21, $53, $20, $7c, $01, $97, $21, $b7, $07
00A311  1  7C 01 97 21  
00A315  1  B7 07        
00A317  1  9C 81 E7 42        .byte $9c, $81, $e7, $42, $5f, $b3, $97, $63, $ac, $02
00A31B  1  5F B3 97 63  
00A31F  1  AC 02        
00A321  1  C5 41 49 E0        .byte $c5, $41, $49, $e0, $58, $61, $76, $64, $85, $65
00A325  1  58 61 76 64  
00A329  1  85 65        
00A32B  1  94 66 A4 22        .byte $94, $66, $a4, $22, $a6, $03, $c8, $22, $dc, $02
00A32F  1  A6 03 C8 22  
00A333  1  DC 02        
00A335  1  68 F2 96 42        .byte $68, $f2, $96, $42, $13, $82, $17, $02, $af, $34
00A339  1  13 82 17 02  
00A33D  1  AF 34        
00A33F  1  F6 21 FC 06        .byte $f6, $21, $fc, $06, $26, $80, $2a, $24, $36, $01
00A343  1  26 80 2A 24  
00A347  1  36 01        
00A349  1  8C 00 FF 35        .byte $8c, $00, $ff, $35, $4e, $a0, $55, $21, $77, $20
00A34D  1  4E A0 55 21  
00A351  1  77 20        
00A353  1  87 07 89 22        .byte $87, $07, $89, $22, $ae, $21, $4c, $82, $9f, $34
00A357  1  AE 21 4C 82  
00A35B  1  9F 34        
00A35D  1  EC 01 03 E7        .byte $ec, $01, $03, $e7, $13, $67, $8d, $4a, $ad, $41
00A361  1  13 67 8D 4A  
00A365  1  AD 41        
00A367  1  0F A6              .byte $0f, $a6
00A369  1  FD                 .byte $fd
00A36A  1               
00A36A  1               ;warp zone area used in level 4-2
00A36A  1               L_GroundArea16:
00A36A  1  10 51              .byte $10, $51
00A36C  1  4C 00 C7 12        .byte $4c, $00, $c7, $12, $c6, $42, $03, $92, $02, $42
00A370  1  C6 42 03 92  
00A374  1  02 42        
00A376  1  29 12 63 12        .byte $29, $12, $63, $12, $62, $42, $69, $14, $a5, $12
00A37A  1  62 42 69 14  
00A37E  1  A5 12        
00A380  1  A4 42 E2 14        .byte $a4, $42, $e2, $14, $e1, $44, $f8, $16, $37, $c1
00A384  1  E1 44 F8 16  
00A388  1  37 C1        
00A38A  1  8F 38 02 BB        .byte $8f, $38, $02, $bb, $28, $7a, $68, $7a, $a8, $7a
00A38E  1  28 7A 68 7A  
00A392  1  A8 7A        
00A394  1  E0 6A F0 6A        .byte $e0, $6a, $f0, $6a, $6d, $c5
00A398  1  6D C5        
00A39A  1  FD                 .byte $fd
00A39B  1               
00A39B  1               ;level 8-1
00A39B  1               L_GroundArea17:
00A39B  1  92 31              .byte $92, $31
00A39D  1  0F 20 6E 40        .byte $0f, $20, $6e, $40, $0d, $02, $37, $73, $ec, $00
00A3A1  1  0D 02 37 73  
00A3A5  1  EC 00        
00A3A7  1  0C 80 3C 00        .byte $0c, $80, $3c, $00, $6c, $00, $9c, $00, $06, $c0
00A3AB  1  6C 00 9C 00  
00A3AF  1  06 C0        
00A3B1  1  C7 73 06 83        .byte $c7, $73, $06, $83, $28, $72, $96, $40, $e7, $73
00A3B5  1  28 72 96 40  
00A3B9  1  E7 73        
00A3BB  1  26 C0 87 7B        .byte $26, $c0, $87, $7b, $d2, $41, $39, $f1, $c8, $f2
00A3BF  1  D2 41 39 F1  
00A3C3  1  C8 F2        
00A3C5  1  97 E3 A3 23        .byte $97, $e3, $a3, $23, $e7, $02, $e3, $07, $f3, $22
00A3C9  1  E7 02 E3 07  
00A3CD  1  F3 22        
00A3CF  1  37 E3 9C 00        .byte $37, $e3, $9c, $00, $bc, $00, $ec, $00, $0c, $80
00A3D3  1  BC 00 EC 00  
00A3D7  1  0C 80        
00A3D9  1  3C 00 86 21        .byte $3c, $00, $86, $21, $a6, $06, $b6, $24, $5c, $80
00A3DD  1  A6 06 B6 24  
00A3E1  1  5C 80        
00A3E3  1  7C 00 9C 00        .byte $7c, $00, $9c, $00, $29, $e1, $dc, $05, $f6, $41
00A3E7  1  29 E1 DC 05  
00A3EB  1  F6 41        
00A3ED  1  DC 80 E8 72        .byte $dc, $80, $e8, $72, $0c, $81, $27, $73, $4c, $01
00A3F1  1  0C 81 27 73  
00A3F5  1  4C 01        
00A3F7  1  66 74 0D 11        .byte $66, $74, $0d, $11, $3f, $35, $b6, $41, $2c, $82
00A3FB  1  3F 35 B6 41  
00A3FF  1  2C 82        
00A401  1  36 40 7C 02        .byte $36, $40, $7c, $02, $86, $40, $f9, $61, $39, $e1
00A405  1  86 40 F9 61  
00A409  1  39 E1        
00A40B  1  AC 04 C6 41        .byte $ac, $04, $c6, $41, $0c, $83, $16, $41, $88, $f2
00A40F  1  0C 83 16 41  
00A413  1  88 F2        
00A415  1  39 F1 7C 00        .byte $39, $f1, $7c, $00, $89, $61, $9c, $00, $a7, $63
00A419  1  89 61 9C 00  
00A41D  1  A7 63        
00A41F  1  BC 00 C5 65        .byte $bc, $00, $c5, $65, $dc, $00, $e3, $67, $f3, $67
00A423  1  DC 00 E3 67  
00A427  1  F3 67        
00A429  1  8D C1 CF 26        .byte $8d, $c1, $cf, $26
00A42D  1  FD                 .byte $fd
00A42E  1               
00A42E  1               ;level 5-2
00A42E  1               L_GroundArea18:
00A42E  1  55 B1              .byte $55, $b1
00A430  1  0F 26 CF 33        .byte $0f, $26, $cf, $33, $07, $b2, $15, $11, $52, $42
00A434  1  07 B2 15 11  
00A438  1  52 42        
00A43A  1  99 0B AC 02        .byte $99, $0b, $ac, $02, $d3, $24, $d6, $42, $d7, $25
00A43E  1  D3 24 D6 42  
00A442  1  D7 25        
00A444  1  23 84 CF 33        .byte $23, $84, $cf, $33, $07, $e3, $19, $61, $78, $7a
00A448  1  07 E3 19 61  
00A44C  1  78 7A        
00A44E  1  EF 33 2C 81        .byte $ef, $33, $2c, $81, $46, $64, $55, $65, $65, $65
00A452  1  46 64 55 65  
00A456  1  65 65        
00A458  1  EC 74 47 82        .byte $ec, $74, $47, $82, $53, $05, $63, $21, $62, $41
00A45C  1  53 05 63 21  
00A460  1  62 41        
00A462  1  96 22 9A 41        .byte $96, $22, $9a, $41, $cc, $03, $b9, $91, $39, $f1
00A466  1  CC 03 B9 91  
00A46A  1  39 F1        
00A46C  1  63 26 67 27        .byte $63, $26, $67, $27, $d3, $06, $fc, $01, $18, $e2
00A470  1  D3 06 FC 01  
00A474  1  18 E2        
00A476  1  D9 07 E9 04        .byte $d9, $07, $e9, $04, $0c, $86, $37, $22, $93, $24
00A47A  1  0C 86 37 22  
00A47E  1  93 24        
00A480  1  87 84 AC 02        .byte $87, $84, $ac, $02, $c2, $41, $c3, $23, $d9, $71
00A484  1  C2 41 C3 23  
00A488  1  D9 71        
00A48A  1  FC 01 7F B1        .byte $fc, $01, $7f, $b1, $9c, $00, $a7, $63, $b6, $64
00A48E  1  9C 00 A7 63  
00A492  1  B6 64        
00A494  1  CC 00 D4 66        .byte $cc, $00, $d4, $66, $e3, $67, $f3, $67, $8d, $c1
00A498  1  E3 67 F3 67  
00A49C  1  8D C1        
00A49E  1  CF 26              .byte $cf, $26
00A4A0  1  FD                 .byte $fd
00A4A1  1               
00A4A1  1               ;level 8-2
00A4A1  1               L_GroundArea19:
00A4A1  1  50 B1              .byte $50, $b1
00A4A3  1  0F 26 FC 00        .byte $0f, $26, $fc, $00, $1f, $b3, $5c, $00, $65, $65
00A4A7  1  1F B3 5C 00  
00A4AB  1  65 65        
00A4AD  1  74 66 83 67        .byte $74, $66, $83, $67, $93, $67, $dc, $73, $4c, $80
00A4B1  1  93 67 DC 73  
00A4B5  1  4C 80        
00A4B7  1  B3 20 C9 0B        .byte $b3, $20, $c9, $0b, $c3, $08, $d3, $2f, $dc, $00
00A4BB  1  C3 08 D3 2F  
00A4BF  1  DC 00        
00A4C1  1  2C 80 4C 00        .byte $2c, $80, $4c, $00, $8c, $00, $d3, $2e, $ed, $4a
00A4C5  1  8C 00 D3 2E  
00A4C9  1  ED 4A        
00A4CB  1  FC 00 D7 A1        .byte $fc, $00, $d7, $a1, $ec, $01, $4c, $80, $59, $11
00A4CF  1  EC 01 4C 80  
00A4D3  1  59 11        
00A4D5  1  D8 11 DA 10        .byte $d8, $11, $da, $10, $37, $a0, $47, $04, $99, $11
00A4D9  1  37 A0 47 04  
00A4DD  1  99 11        
00A4DF  1  E7 21 3A 90        .byte $e7, $21, $3a, $90, $67, $20, $76, $10, $77, $60
00A4E3  1  67 20 76 10  
00A4E7  1  77 60        
00A4E9  1  87 07 D8 12        .byte $87, $07, $d8, $12, $39, $f1, $ac, $00, $e9, $71
00A4ED  1  39 F1 AC 00  
00A4F1  1  E9 71        
00A4F3  1  0C 80 2C 00        .byte $0c, $80, $2c, $00, $4c, $05, $c7, $7b, $39, $f1
00A4F7  1  4C 05 C7 7B  
00A4FB  1  39 F1        
00A4FD  1  EC 00 F9 11        .byte $ec, $00, $f9, $11, $0c, $82, $6f, $34, $f8, $11
00A501  1  0C 82 6F 34  
00A505  1  F8 11        
00A507  1  FA 10 7F B2        .byte $fa, $10, $7f, $b2, $ac, $00, $b6, $64, $cc, $01
00A50B  1  AC 00 B6 64  
00A50F  1  CC 01        
00A511  1  E3 67 F3 67        .byte $e3, $67, $f3, $67, $8d, $c1, $cf, $26
00A515  1  8D C1 CF 26  
00A519  1  FD                 .byte $fd
00A51A  1               
00A51A  1               ;level 7-1
00A51A  1               L_GroundArea20:
00A51A  1  52 B1              .byte $52, $b1
00A51C  1  0F 20 6E 45        .byte $0f, $20, $6e, $45, $39, $91, $b3, $04, $c3, $21
00A520  1  39 91 B3 04  
00A524  1  C3 21        
00A526  1  C8 11 CA 10        .byte $c8, $11, $ca, $10, $49, $91, $7c, $73, $e8, $12
00A52A  1  49 91 7C 73  
00A52E  1  E8 12        
00A530  1  88 91 8A 10        .byte $88, $91, $8a, $10, $e7, $21, $05, $91, $07, $30
00A534  1  E7 21 05 91  
00A538  1  07 30        
00A53A  1  17 07 27 20        .byte $17, $07, $27, $20, $49, $11, $9c, $01, $c8, $72
00A53E  1  49 11 9C 01  
00A542  1  C8 72        
00A544  1  23 A6 27 26        .byte $23, $a6, $27, $26, $d3, $03, $d8, $7a, $89, $91
00A548  1  D3 03 D8 7A  
00A54C  1  89 91        
00A54E  1  D8 72 39 F1        .byte $d8, $72, $39, $f1, $a9, $11, $09, $f1, $63, $24
00A552  1  A9 11 09 F1  
00A556  1  63 24        
00A558  1  67 24 D8 62        .byte $67, $24, $d8, $62, $28, $91, $2a, $10, $56, $21
00A55C  1  28 91 2A 10  
00A560  1  56 21        
00A562  1  70 04 79 0B        .byte $70, $04, $79, $0b, $8c, $00, $94, $21, $9f, $35
00A566  1  8C 00 94 21  
00A56A  1  9F 35        
00A56C  1  2F B8 3D C1        .byte $2f, $b8, $3d, $c1, $7f, $26
00A570  1  7F 26        
00A572  1  FD                 .byte $fd
00A573  1               
00A573  1               ;cloud level used in levels 3-1 and 6-2
00A573  1               L_GroundArea21:
00A573  1  06 C1              .byte $06, $c1
00A575  1  4C 00 F4 4F        .byte $4c, $00, $f4, $4f, $0d, $02, $06, $20, $24, $4f
00A579  1  0D 02 06 20  
00A57D  1  24 4F        
00A57F  1  35 A0 36 20        .byte $35, $a0, $36, $20, $53, $46, $d5, $20, $d6, $20
00A583  1  53 46 D5 20  
00A587  1  D6 20        
00A589  1  34 A1 73 49        .byte $34, $a1, $73, $49, $74, $20, $94, $20, $b4, $20
00A58D  1  74 20 94 20  
00A591  1  B4 20        
00A593  1  D4 20 F4 20        .byte $d4, $20, $f4, $20, $2e, $80, $59, $42, $4d, $c7
00A597  1  2E 80 59 42  
00A59B  1  4D C7        
00A59D  1  FD                 .byte $fd
00A59E  1               
00A59E  1               ;level 3-2
00A59E  1               L_GroundArea22:
00A59E  1  96 31              .byte $96, $31
00A5A0  1  0F 26 0D 03        .byte $0f, $26, $0d, $03, $1a, $60, $77, $42, $c4, $00
00A5A4  1  1A 60 77 42  
00A5A8  1  C4 00        
00A5AA  1  C8 62 B9 E1        .byte $c8, $62, $b9, $e1, $d3, $06, $d7, $07, $f9, $61
00A5AE  1  D3 06 D7 07  
00A5B2  1  F9 61        
00A5B4  1  0C 81 4E B1        .byte $0c, $81, $4e, $b1, $8e, $b1, $bc, $01, $e4, $50
00A5B8  1  8E B1 BC 01  
00A5BC  1  E4 50        
00A5BE  1  E9 61 0C 81        .byte $e9, $61, $0c, $81, $0d, $0a, $84, $43, $98, $72
00A5C2  1  0D 0A 84 43  
00A5C6  1  98 72        
00A5C8  1  0D 0C 0F 38        .byte $0d, $0c, $0f, $38, $1d, $c1, $5f, $26
00A5CC  1  1D C1 5F 26  
00A5D0  1  FD                 .byte $fd
00A5D1  1               
00A5D1  1               ;level 1-2
00A5D1  1               L_UndergroundArea1:
00A5D1  1  48 0F              .byte $48, $0f
00A5D3  1  0E 01 5E 02        .byte $0e, $01, $5e, $02, $a7, $00, $bc, $73, $1a, $e0
00A5D7  1  A7 00 BC 73  
00A5DB  1  1A E0        
00A5DD  1  39 61 58 62        .byte $39, $61, $58, $62, $77, $63, $97, $63, $b8, $62
00A5E1  1  77 63 97 63  
00A5E5  1  B8 62        
00A5E7  1  D6 07 F8 62        .byte $d6, $07, $f8, $62, $19, $e1, $75, $52, $86, $40
00A5EB  1  19 E1 75 52  
00A5EF  1  86 40        
00A5F1  1  87 50 95 52        .byte $87, $50, $95, $52, $93, $43, $a5, $21, $c5, $52
00A5F5  1  93 43 A5 21  
00A5F9  1  C5 52        
00A5FB  1  D6 40 D7 20        .byte $d6, $40, $d7, $20, $e5, $06, $e6, $51, $3e, $8d
00A5FF  1  E5 06 E6 51  
00A603  1  3E 8D        
00A605  1  5E 03 67 52        .byte $5e, $03, $67, $52, $77, $52, $7e, $02, $9e, $03
00A609  1  77 52 7E 02  
00A60D  1  9E 03        
00A60F  1  A6 43 A7 23        .byte $a6, $43, $a7, $23, $de, $05, $fe, $02, $1e, $83
00A613  1  DE 05 FE 02  
00A617  1  1E 83        
00A619  1  33 54 46 40        .byte $33, $54, $46, $40, $47, $21, $56, $04, $5e, $02
00A61D  1  47 21 56 04  
00A621  1  5E 02        
00A623  1  83 54 93 52        .byte $83, $54, $93, $52, $96, $07, $97, $50, $be, $03
00A627  1  96 07 97 50  
00A62B  1  BE 03        
00A62D  1  C7 23 FE 02        .byte $c7, $23, $fe, $02, $0c, $82, $43, $45, $45, $24
00A631  1  0C 82 43 45  
00A635  1  45 24        
00A637  1  46 24 90 08        .byte $46, $24, $90, $08, $95, $51, $78, $fa, $d7, $73
00A63B  1  95 51 78 FA  
00A63F  1  D7 73        
00A641  1  39 F1 8C 01        .byte $39, $f1, $8c, $01, $a8, $52, $b8, $52, $cc, $01
00A645  1  A8 52 B8 52  
00A649  1  CC 01        
00A64B  1  5F B3 97 63        .byte $5f, $b3, $97, $63, $9e, $00, $0e, $81, $16, $24
00A64F  1  9E 00 0E 81  
00A653  1  16 24        
00A655  1  66 04 8E 00        .byte $66, $04, $8e, $00, $fe, $01, $08, $d2, $0e, $06
00A659  1  FE 01 08 D2  
00A65D  1  0E 06        
00A65F  1  6F 47 9E 0F        .byte $6f, $47, $9e, $0f, $0e, $82, $2d, $47, $28, $7a
00A663  1  0E 82 2D 47  
00A667  1  28 7A        
00A669  1  68 7A A8 7A        .byte $68, $7a, $a8, $7a, $ae, $01, $de, $0f, $6d, $c5
00A66D  1  AE 01 DE 0F  
00A671  1  6D C5        
00A673  1  FD                 .byte $fd
00A674  1               
00A674  1               ;level 4-2
00A674  1               L_UndergroundArea2:
00A674  1  48 0F              .byte $48, $0f
00A676  1  0E 01 5E 02        .byte $0e, $01, $5e, $02, $bc, $01, $fc, $01, $2c, $82
00A67A  1  BC 01 FC 01  
00A67E  1  2C 82        
00A680  1  41 52 4E 04        .byte $41, $52, $4e, $04, $67, $25, $68, $24, $69, $24
00A684  1  67 25 68 24  
00A688  1  69 24        
00A68A  1  BA 42 C7 04        .byte $ba, $42, $c7, $04, $de, $0b, $b2, $87, $fe, $02
00A68E  1  DE 0B B2 87  
00A692  1  FE 02        
00A694  1  2C E1 2C 71        .byte $2c, $e1, $2c, $71, $67, $01, $77, $00, $87, $01
00A698  1  67 01 77 00  
00A69C  1  87 01        
00A69E  1  8E 00 EE 01        .byte $8e, $00, $ee, $01, $f6, $02, $03, $85, $05, $02
00A6A2  1  F6 02 03 85  
00A6A6  1  05 02        
00A6A8  1  13 21 16 02        .byte $13, $21, $16, $02, $27, $02, $2e, $02, $88, $72
00A6AC  1  27 02 2E 02  
00A6B0  1  88 72        
00A6B2  1  C7 20 D7 07        .byte $c7, $20, $d7, $07, $e4, $76, $07, $a0, $17, $06
00A6B6  1  E4 76 07 A0  
00A6BA  1  17 06        
00A6BC  1  48 7A 76 20        .byte $48, $7a, $76, $20, $98, $72, $79, $e1, $88, $62
00A6C0  1  98 72 79 E1  
00A6C4  1  88 62        
00A6C6  1  9C 01 B7 73        .byte $9c, $01, $b7, $73, $dc, $01, $f8, $62, $fe, $01
00A6CA  1  DC 01 F8 62  
00A6CE  1  FE 01        
00A6D0  1  08 E2 0E 00        .byte $08, $e2, $0e, $00, $6e, $02, $73, $20, $77, $23
00A6D4  1  6E 02 73 20  
00A6D8  1  77 23        
00A6DA  1  83 04 93 20        .byte $83, $04, $93, $20, $ae, $00, $fe, $0a, $0e, $82
00A6DE  1  AE 00 FE 0A  
00A6E2  1  0E 82        
00A6E4  1  39 71 A8 72        .byte $39, $71, $a8, $72, $e7, $73, $0c, $81, $8f, $32
00A6E8  1  E7 73 0C 81  
00A6EC  1  8F 32        
00A6EE  1  AE 00 FE 04        .byte $ae, $00, $fe, $04, $04, $d1, $17, $04, $26, $49
00A6F2  1  04 D1 17 04  
00A6F6  1  26 49        
00A6F8  1  27 29 DF 33        .byte $27, $29, $df, $33, $fe, $02, $44, $f6, $7c, $01
00A6FC  1  FE 02 44 F6  
00A700  1  7C 01        
00A702  1  8E 06 BF 47        .byte $8e, $06, $bf, $47, $ee, $0f, $4d, $c7, $0e, $82
00A706  1  EE 0F 4D C7  
00A70A  1  0E 82        
00A70C  1  68 7A AE 01        .byte $68, $7a, $ae, $01, $de, $0f, $6d, $c5
00A710  1  DE 0F 6D C5  
00A714  1  FD                 .byte $fd
00A715  1               
00A715  1               ;underground bonus rooms area used in many levels
00A715  1               L_UndergroundArea3:
00A715  1  48 01              .byte $48, $01
00A717  1  0E 01 00 5A        .byte $0e, $01, $00, $5a, $3e, $06, $45, $46, $47, $46
00A71B  1  3E 06 45 46  
00A71F  1  47 46        
00A721  1  53 44 AE 01        .byte $53, $44, $ae, $01, $df, $4a, $4d, $c7, $0e, $81
00A725  1  DF 4A 4D C7  
00A729  1  0E 81        
00A72B  1  00 5A 2E 04        .byte $00, $5a, $2e, $04, $37, $28, $3a, $48, $46, $47
00A72F  1  37 28 3A 48  
00A733  1  46 47        
00A735  1  C7 07 CE 0F        .byte $c7, $07, $ce, $0f, $df, $4a, $4d, $c7, $0e, $81
00A739  1  DF 4A 4D C7  
00A73D  1  0E 81        
00A73F  1  00 5A 33 53        .byte $00, $5a, $33, $53, $43, $51, $46, $40, $47, $50
00A743  1  43 51 46 40  
00A747  1  47 50        
00A749  1  53 04 55 40        .byte $53, $04, $55, $40, $56, $50, $62, $43, $64, $40
00A74D  1  56 50 62 43  
00A751  1  64 40        
00A753  1  65 50 71 41        .byte $65, $50, $71, $41, $73, $51, $83, $51, $94, $40
00A757  1  73 51 83 51  
00A75B  1  94 40        
00A75D  1  95 50 A3 50        .byte $95, $50, $a3, $50, $a5, $40, $a6, $50, $b3, $51
00A761  1  A5 40 A6 50  
00A765  1  B3 51        
00A767  1  B6 40 B7 50        .byte $b6, $40, $b7, $50, $c3, $53, $df, $4a, $4d, $c7
00A76B  1  C3 53 DF 4A  
00A76F  1  4D C7        
00A771  1  0E 81 00 5A        .byte $0e, $81, $00, $5a, $2e, $02, $36, $47, $37, $52
00A775  1  2E 02 36 47  
00A779  1  37 52        
00A77B  1  3A 49 47 25        .byte $3a, $49, $47, $25, $a7, $52, $d7, $04, $df, $4a
00A77F  1  A7 52 D7 04  
00A783  1  DF 4A        
00A785  1  4D C7 0E 81        .byte $4d, $c7, $0e, $81, $00, $5a, $3e, $02, $44, $51
00A789  1  00 5A 3E 02  
00A78D  1  44 51        
00A78F  1  53 44 54 44        .byte $53, $44, $54, $44, $55, $24, $a1, $54, $ae, $01
00A793  1  55 24 A1 54  
00A797  1  AE 01        
00A799  1  B4 21 DF 4A        .byte $b4, $21, $df, $4a, $e5, $07, $4d, $c7
00A79D  1  E5 07 4D C7  
00A7A1  1  FD                 .byte $fd
00A7A2  1               
00A7A2  1               ;water area used in levels 5-2 and 6-2
00A7A2  1               L_WaterArea1:
00A7A2  1  41 01              .byte $41, $01
00A7A4  1  B4 34 C8 52        .byte $b4, $34, $c8, $52, $f2, $51, $47, $d3, $6c, $03
00A7A8  1  F2 51 47 D3  
00A7AC  1  6C 03        
00A7AE  1  65 49 9E 07        .byte $65, $49, $9e, $07, $be, $01, $cc, $03, $fe, $07
00A7B2  1  BE 01 CC 03  
00A7B6  1  FE 07        
00A7B8  1  0D C9 1E 01        .byte $0d, $c9, $1e, $01, $6c, $01, $62, $35, $63, $53
00A7BC  1  6C 01 62 35  
00A7C0  1  63 53        
00A7C2  1  8A 41 AC 01        .byte $8a, $41, $ac, $01, $b3, $53, $e9, $51, $26, $c3
00A7C6  1  B3 53 E9 51  
00A7CA  1  26 C3        
00A7CC  1  27 33 63 43        .byte $27, $33, $63, $43, $64, $33, $ba, $60, $c9, $61
00A7D0  1  64 33 BA 60  
00A7D4  1  C9 61        
00A7D6  1  CE 0B E5 09        .byte $ce, $0b, $e5, $09, $ee, $0f, $7d, $ca, $7d, $47
00A7DA  1  EE 0F 7D CA  
00A7DE  1  7D 47        
00A7E0  1  FD                 .byte $fd
00A7E1  1               
00A7E1  1               ;level 2-2/7-2
00A7E1  1               L_WaterArea2:
00A7E1  1  41 01              .byte $41, $01
00A7E3  1  B8 52 EA 41        .byte $b8, $52, $ea, $41, $27, $b2, $b3, $42, $16, $d4
00A7E7  1  27 B2 B3 42  
00A7EB  1  16 D4        
00A7ED  1  4A 42 A5 51        .byte $4a, $42, $a5, $51, $a7, $31, $27, $d3, $08, $e2
00A7F1  1  A7 31 27 D3  
00A7F5  1  08 E2        
00A7F7  1  16 64 2C 04        .byte $16, $64, $2c, $04, $38, $42, $76, $64, $88, $62
00A7FB  1  38 42 76 64  
00A7FF  1  88 62        
00A801  1  DE 07 FE 01        .byte $de, $07, $fe, $01, $0d, $c9, $23, $32, $31, $51
00A805  1  0D C9 23 32  
00A809  1  31 51        
00A80B  1  98 52 0D C9        .byte $98, $52, $0d, $c9, $59, $42, $63, $53, $67, $31
00A80F  1  59 42 63 53  
00A813  1  67 31        
00A815  1  14 C2 36 31        .byte $14, $c2, $36, $31, $87, $53, $17, $e3, $29, $61
00A819  1  87 53 17 E3  
00A81D  1  29 61        
00A81F  1  30 62 3C 08        .byte $30, $62, $3c, $08, $42, $37, $59, $40, $6a, $42
00A823  1  42 37 59 40  
00A827  1  6A 42        
00A829  1  99 40 C9 61        .byte $99, $40, $c9, $61, $d7, $63, $39, $d1, $58, $52
00A82D  1  D7 63 39 D1  
00A831  1  58 52        
00A833  1  C3 67 D3 31        .byte $c3, $67, $d3, $31, $dc, $06, $f7, $42, $fa, $42
00A837  1  DC 06 F7 42  
00A83B  1  FA 42        
00A83D  1  23 B1 43 67        .byte $23, $b1, $43, $67, $c3, $34, $c7, $34, $d1, $51
00A841  1  C3 34 C7 34  
00A845  1  D1 51        
00A847  1  43 B3 47 33        .byte $43, $b3, $47, $33, $9a, $30, $a9, $61, $b8, $62
00A84B  1  9A 30 A9 61  
00A84F  1  B8 62        
00A851  1  BE 0B D5 09        .byte $be, $0b, $d5, $09, $de, $0f, $0d, $ca, $7d, $47
00A855  1  DE 0F 0D CA  
00A859  1  7D 47        
00A85B  1  FD                 .byte $fd
00A85C  1               
00A85C  1               ;water area used in level 8-4
00A85C  1               L_WaterArea3:
00A85C  1  49 0F              .byte $49, $0f
00A85E  1  1E 01 39 73        .byte $1e, $01, $39, $73, $5e, $07, $ae, $0b, $1e, $82
00A862  1  5E 07 AE 0B  
00A866  1  1E 82        
00A868  1  6E 88 9E 02        .byte $6e, $88, $9e, $02, $0d, $04, $2e, $0b, $45, $09
00A86C  1  0D 04 2E 0B  
00A870  1  45 09        
00A872  1  4E 0F ED 47        .byte $4e, $0f, $ed, $47
00A876  1  FD                 .byte $fd
00A877  1               
00A877  1               ;-------------------------------------------------------------------------------------
00A877  1               
00A877  1               ;unused space
00A877  1  FF                 .byte $ff
00A878  1               
00A878  1               ;-------------------------------------------------------------------------------------
00A878  1               
00A878  1               ;indirect jump routine called when
00A878  1               ;$0770 is set to 1
00A878  1               GameMode:
00A878  1  AD 72 07           lda OperMode_Task
00A87B  1  20 A8 BA           jsr JumpEngine
00A87E  1               
00A87E  1  03 B9              .word InitializeArea
00A880  1  6C 84              .word ScreenRoutines
00A882  1  BB 8B              .word SecondaryGameSetup
00A884  1  46 A9              .word GameCoreRoutine
00A886  1               
00A886  1               ;-------------------------------------------------------------------------------------
00A886  1               
00A886  1               DrawInputButtons:
00A886  1  84 03            sty $03
00A888  1  AC 00 03         ldy VRAM_Buffer1_Offset
00A88B  1  99 01 03         sta VRAM_Buffer1+0, y
00A88E  1  8A               txa
00A88F  1  99 02 03         sta VRAM_Buffer1+1, y
00A892  1  A9 04            lda #$04
00A894  1  99 03 03         sta VRAM_Buffer1+2, y
00A897  1                       ;
00A897  1                   ; Left
00A897  1                   ;
00A897  1  A5 03            lda $03
00A899  1  29 02            and #Left_Dir
00A89B  1  F0 05            beq NoLeftStatus
00A89D  1  A9 15            lda #$15
00A89F  1  4C A4 A8         jmp WriteLeft
00A8A2  1               NoLeftStatus:
00A8A2  1  A9 28            lda #$28
00A8A4  1               WriteLeft:
00A8A4  1  99 04 03         sta VRAM_Buffer1+3, y
00A8A7  1                   ;
00A8A7  1                   ; Right
00A8A7  1                   ;
00A8A7  1  A5 03            lda $03
00A8A9  1  29 01            and #Right_Dir
00A8AB  1  F0 05            beq NoRightStatus
00A8AD  1  A9 1B            lda #$1b
00A8AF  1  4C B4 A8         jmp WriteRight
00A8B2  1               NoRightStatus:
00A8B2  1  A9 28            lda #$28
00A8B4  1               WriteRight:
00A8B4  1  99 05 03         sta VRAM_Buffer1+4, y
00A8B7  1                   ;
00A8B7  1                   ; B
00A8B7  1                   ;
00A8B7  1  A5 03            lda $03
00A8B9  1  29 40            and #B_Button
00A8BB  1  F0 05            beq NoBStatus
00A8BD  1  A9 0B            lda #$0b
00A8BF  1  4C C4 A8         jmp WriteB
00A8C2  1               NoBStatus:
00A8C2  1  A9 28            lda #$28
00A8C4  1               WriteB:
00A8C4  1  99 06 03         sta VRAM_Buffer1+5, y
00A8C7  1                   ;
00A8C7  1                   ; A
00A8C7  1                   ;
00A8C7  1  A5 03            lda $03
00A8C9  1  29 80            and #A_Button
00A8CB  1  F0 05            beq NoAStatus
00A8CD  1  A9 0A            lda #$0a
00A8CF  1  4C D4 A8         jmp WriteA
00A8D2  1               NoAStatus:
00A8D2  1  A9 28            lda #$28
00A8D4  1               WriteA:
00A8D4  1  99 07 03         sta VRAM_Buffer1+6, y
00A8D7  1  A9 00            lda #$00
00A8D9  1  99 08 03         sta VRAM_Buffer1+7, y
00A8DC  1  AD 00 03         lda VRAM_Buffer1_Offset
00A8DF  1  18               clc
00A8E0  1  69 07            adc #$7
00A8E2  1  8D 00 03         sta VRAM_Buffer1_Offset
00A8E5  1  60               rts
00A8E6  1               
00A8E6  1               
00A8E6  1               RedrawStatusBar:
00A8E6  1  A5 09            lda FrameCounter
00A8E8  1  29 01            and #1
00A8EA  1  F0 0B            beq UpdateStatusSpeed
00A8EC  1               UpdateStatusInput:
00A8EC  1  A9 20            lda #$20
00A8EE  1  A2 67            ldx #$67
00A8F0  1  AC FC 06         ldy SavedJoypad1Bits
00A8F3  1  20 86 A8         jsr DrawInputButtons
00A8F6  1  60               rts
00A8F7  1                   ;
00A8F7  1                   ; Draw frame!
00A8F7  1                   ;
00A8F7  1               UpdateStatusSpeed:
00A8F7  1  AC 00 03         ldy VRAM_Buffer1_Offset
00A8FA  1  A9 20            lda #$20
00A8FC  1  99 01 03         sta VRAM_Buffer1, y
00A8FF  1  A9 74            lda #$74
00A901  1  99 02 03         sta VRAM_Buffer1+1, y
00A904  1  A9 03            lda #$3
00A906  1  99 03 03         sta VRAM_Buffer1+2, y
00A909  1               
00A909  1  AD 00 04         lda SprObject_X_MoveForce
00A90C  1  20 90 F0         jsr DivByTen
00A90F  1  99 06 03         sta VRAM_Buffer1+5, y
00A912  1  8A               txa
00A913  1  20 90 F0         jsr DivByTen
00A916  1  99 05 03         sta VRAM_Buffer1+4, y
00A919  1  8A               txa
00A91A  1  99 04 03         sta VRAM_Buffer1+3, y
00A91D  1                   ;
00A91D  1                   ; Finalize write command.
00A91D  1                   ;
00A91D  1  A9 00            lda #0
00A91F  1  99 07 03         sta VRAM_Buffer1+6, y
00A922  1  98               tya
00A923  1  18               clc
00A924  1  69 06            adc #6
00A926  1  8D 00 03         sta VRAM_Buffer1_Offset
00A929  1  60               rts
00A92A  1               
00A92A  1               ;-------------------------------------------------------------------------------------
00A92A  1               
00A92A  1               FpgInitialize:
00A92A  1  A9 01              lda #$1
00A92C  1  0D 61 07           ora FpgFlags
00A92F  1  8D 61 07           sta FpgFlags
00A932  1  A9 0C              lda #<E_CastleArea1
00A934  1  85 02              sta $2
00A936  1  A9 97              lda #>E_CastleArea1
00A938  1  85 03              sta $3
00A93A  1  20 08 FE           jsr Enter_ScenReset
00A93D  1  A9 00              lda #$0
00A93F  1  8D 74 07           sta DisableScreenFlag
00A942  1               DoRenderPassOrSomeShit:
00A942  1  60                 rts
00A943  1               
00A943  1               FpgSelectScenario:
00A943  1  4C 00 80           jmp Start
00A946  1               
00A946  1               GameCoreRoutine:
00A946  1  AD FC 06           lda SavedJoypadBits
00A949  1  C9 10              cmp #Start_Button
00A94B  1  F0 F6              beq FpgSelectScenario
00A94D  1  AD 61 07           lda FpgFlags
00A950  1  8D DA 07           sta FpgOldFlags
00A953  1  29 01              and #$1
00A955  1  D0 03              bne FpgIsInitialized
00A957  1  20 2A A9           jsr FpgInitialize
00A95A  1               FpgIsInitialized:
00A95A  1  AE 53 07           ldx CurrentPlayer          ;get which player is on the screen
00A95D  1  AD 61 07           lda FpgFlags
00A960  1  0A                 asl
00A961  1  B0 19              bcs FpgNoPlayerUpdates
00A963  1  AD FC 06           lda SavedJoypadBits
00A966  1  C9 20              cmp #Select_Button
00A968  1  D0 03              bne NoRestartFpg
00A96A  1  4C 1F 82           jmp RestartFpg
00A96D  1               NoRestartFpg:
00A96D  1  8D 62 07           sta FpgLastInput
00A970  1  20 18 FE           jsr Enter_ScenValidate
00A973  1  AD 61 07           lda FpgFlags
00A976  1  0A                 asl
00A977  1  B0 03              bcs FpgNoPlayerUpdates
00A979  1  20 C8 AA           jsr GameRoutines           ;execute one of many possible subs
00A97C  1               FpgNoPlayerUpdates:
00A97C  1  AD 72 07           lda OperMode_Task          ;check major task of operating mode
00A97F  1  C9 03              cmp #$03                   ;if we are supposed to be here,
00A981  1  B0 01              bcs DoGameEngine             ;branch to the game engine itself
00A983  1               FpgKeepGoing:
00A983  1  60                 rts
00A984  1               DoGameEngine:
00A984  1  AD 61 07                   lda FpgFlags
00A987  1  29 82                      and #$82
00A989  1  49 02                      eor #$02
00A98B  1  8D 47 07                   sta TimerControl
00A98E  1               GameEngine:
00A98E  1  20 42 B0                   jsr ProcFireball_Bubble    ;process fireballs and air bubbles
00A991  1  A2 00                      ldx #$00
00A993  1  86 08        ProcELoop:    stx ObjectOffset           ;put incremented offset in X as enemy object offset
00A995  1  20 19 B5                   jsr EnemiesAndLoopsCore    ;process enemy objects
00A998  1  20 CF 83                   jsr FloateyNumbersRoutine  ;process floatey numbers
00A99B  1  E8                         inx
00A99C  1  E0 06                      cpx #$06                   ;do these two subroutines until the whole buffer is done
00A99E  1  D0 F3                      bne ProcELoop
00A9A0  1  20 18 EC                   jsr GetPlayerOffscreenBits ;get offscreen bits for player object
00A9A3  1  20 C2 EB                   jsr RelativePlayerPosition ;get relative coordinates for player object
00A9A6  1  20 A1 E9                   jsr PlayerGfxHandler       ;draw the player
00A9A9  1  20 B6 BE                   jsr BlockObjMT_Updater     ;replace block objects with metatiles if necessary
00A9AC  1  20 E6 A8                   jsr RedrawStatusBar
00A9AF  1  A2 01                      ldx #$01
00A9B1  1  86 08                      stx ObjectOffset           ;set offset for second
00A9B3  1  20 52 BE                   jsr BlockObjectsCore       ;process second block object
00A9B6  1  CA                         dex
00A9B7  1  86 08                      stx ObjectOffset           ;set offset for first
00A9B9  1  20 52 BE                   jsr BlockObjectsCore       ;process first block object
00A9BC  1  20 AF B3                   jsr MiscObjectsCore        ;process misc objects (hammer, jumping coins)
00A9BF  1  20 6D B2                   jsr ProcessCannons         ;process bullet bill cannons
00A9C2  1  20 6D B1                   jsr ProcessWhirlpools      ;process whirlpools
00A9C5  1  20 0A B2                   jsr FlagpoleRoutine        ;process the flagpole
00A9C8  1  20 A9 87                   jsr ColorRotation          ;cycle one of the background colors
00A9CB  1  A5 B5                      lda Player_Y_HighPos
00A9CD  1  C9 02                      cmp #$02                   ;if player is below the screen, don't bother with the music
00A9CF  1  10 11                      bpl NoChgMus
00A9D1  1  AD 9F 07                   lda StarInvincibleTimer    ;if star mario invincibility timer at zero,
00A9D4  1  F0 1E                      beq ClrPlrPal              ;skip this part
00A9D6  1  C9 04                      cmp #$04
00A9D8  1  D0 08                      bne NoChgMus               ;if not yet at a certain point, continue
00A9DA  1  AD 7F 07                   lda IntervalTimerControl   ;if interval timer not yet expired,
00A9DD  1  D0 03                      bne NoChgMus               ;branch ahead, don't bother with the music
00A9DF  1  20 19 8C                   jsr GetAreaMusic           ;to re-attain appropriate level music
00A9E2  1  AC 9F 07     NoChgMus:     ldy StarInvincibleTimer    ;get invincibility timer
00A9E5  1  A5 09                      lda FrameCounter           ;get frame counter
00A9E7  1  C0 08                      cpy #$08                   ;if timer still above certain point,
00A9E9  1  B0 02                      bcs CycleTwo               ;branch to cycle player's palette quickly
00A9EB  1  4A                         lsr                        ;otherwise, divide by 8 to cycle every eighth frame
00A9EC  1  4A                         lsr
00A9ED  1  4A           CycleTwo:     lsr                        ;if branched here, divide by 2 to cycle every other frame
00A9EE  1  20 A6 AC                   jsr CyclePlayerPalette     ;do sub to cycle the palette (note: shares fire flower code)
00A9F1  1  4C F7 A9                   jmp SaveAB                 ;then skip this sub to finish up the game engine
00A9F4  1  20 B8 AC     ClrPlrPal:    jsr ResetPalStar           ;do sub to clear player's palette bits in attributes
00A9F7  1  A5 0A        SaveAB:       lda A_B_Buttons            ;save current A and B button
00A9F9  1  85 0D                      sta PreviousA_B_Buttons    ;into temp variable to be used on next frame
00A9FB  1  A9 00                      lda #$00
00A9FD  1  85 0C                      sta Left_Right_Buttons     ;nullify left and right buttons temp variable
00A9FF  1  AD 73 07     UpdScrollVar: lda VRAM_Buffer_AddrCtrl
00AA02  1  C9 06                      cmp #$06                   ;if vram address controller set to 6 (one of two $0341s)
00AA04  1  F0 1C                      beq ExitEng                ;then branch to leave
00AA06  1  AD 1F 07                   lda AreaParserTaskNum      ;otherwise check number of tasks
00AA09  1  D0 14                      bne RunParser
00AA0B  1  AD 3D 07                   lda ScrollThirtyTwo        ;get horizontal scroll in 0-31 or $00-$20 range
00AA0E  1  C9 20                      cmp #$20                   ;check to see if exceeded $21
00AA10  1  30 10                      bmi ExitEng                ;branch to leave if not
00AA12  1  AD 3D 07                   lda ScrollThirtyTwo
00AA15  1  E9 20                      sbc #$20                   ;otherwise subtract $20 to set appropriately
00AA17  1  8D 3D 07                   sta ScrollThirtyTwo        ;and store
00AA1A  1  A9 00                      lda #$00                   ;reset vram buffer offset used in conjunction with
00AA1C  1  8D 40 03                   sta VRAM_Buffer2_Offset    ;level graphics buffer at $0341-$035f
00AA1F  1  20 58 8D     RunParser:    jsr AreaParserTaskHandler  ;update the name table with more level graphics
00AA22  1  60           ExitEng:      rts                        ;and after all that, we're finally done!
00AA23  1               
00AA23  1               ;-------------------------------------------------------------------------------------
00AA23  1               
00AA23  1               ScrollHandler:
00AA23  1  AD FF 06                 lda Player_X_Scroll       ;load value saved here
00AA26  1  18                       clc
00AA27  1  6D A1 03                 adc Platform_X_Scroll     ;add value used by left/right platforms
00AA2A  1  8D FF 06                 sta Player_X_Scroll       ;save as new value here to impose force on scroll
00AA2D  1  AD 23 07                 lda ScrollLock            ;check scroll lock flag
00AA30  1  D0 59                    bne InitScrlAmt           ;skip a bunch of code here if set
00AA32  1  AD 55 07                 lda Player_Pos_ForScroll
00AA35  1  C9 50                    cmp #$50                  ;check player's horizontal screen position
00AA37  1  90 52                    bcc InitScrlAmt           ;if less than 80 pixels to the right, branch
00AA39  1  AD 85 07                 lda SideCollisionTimer    ;if timer related to player's side collision
00AA3C  1  D0 4D                    bne InitScrlAmt           ;not expired, branch
00AA3E  1  AC FF 06                 ldy Player_X_Scroll       ;get value and decrement by one
00AA41  1  88                       dey                       ;if value originally set to zero or otherwise
00AA42  1  30 47                    bmi InitScrlAmt           ;negative for left movement, branch
00AA44  1  C8                       iny
00AA45  1  C0 02                    cpy #$02                  ;if value $01, branch and do not decrement
00AA47  1  90 01                    bcc ChkNearMid
00AA49  1  88                       dey                       ;otherwise decrement by one
00AA4A  1  AD 55 07     ChkNearMid: lda Player_Pos_ForScroll
00AA4D  1  C9 70                    cmp #$70                  ;check player's horizontal screen position
00AA4F  1  90 03                    bcc ScrollScreen          ;if less than 112 pixels to the right, branch
00AA51  1  AC FF 06                 ldy Player_X_Scroll       ;otherwise get original value undecremented
00AA54  1               
00AA54  1               ScrollScreen:
00AA54  1  98                         tya
00AA55  1  8D 75 07                   sta ScrollAmount          ;save value here
00AA58  1  18                         clc
00AA59  1  6D 3D 07                   adc ScrollThirtyTwo       ;add to value already set here
00AA5C  1  8D 3D 07                   sta ScrollThirtyTwo       ;save as new value here
00AA5F  1  98                         tya
00AA60  1  18                         clc
00AA61  1  6D 1C 07                   adc ScreenLeft_X_Pos      ;add to left side coordinate
00AA64  1  8D 1C 07                   sta ScreenLeft_X_Pos      ;save as new left side coordinate
00AA67  1  8D 3F 07                   sta HorizontalScroll      ;save here also
00AA6A  1  AD 1A 07                   lda ScreenLeft_PageLoc
00AA6D  1  69 00                      adc #$00                  ;add carry to page location for left
00AA6F  1  8D 1A 07                   sta ScreenLeft_PageLoc    ;side of the screen
00AA72  1  29 01                      and #$01                  ;get LSB of page location
00AA74  1  85 00                      sta $00                   ;save as temp variable for PPU register 1 mirror
00AA76  1  AD 78 07                   lda Mirror_PPU_CTRL_REG1  ;get PPU register 1 mirror
00AA79  1  29 FE                      and #%11111110            ;save all bits except d0
00AA7B  1  05 00                      ora $00                   ;get saved bit here and save in PPU register 1
00AA7D  1  8D 78 07                   sta Mirror_PPU_CTRL_REG1  ;mirror to be used to set name table later
00AA80  1  20 19 BC                   jsr GetScreenPosition     ;figure out where the right side is
00AA83  1  A9 08                      lda #$08
00AA85  1  8D 95 07                   sta ScrollIntervalTimer   ;set scroll timer (residual, not used elsewhere)
00AA88  1  4C 90 AA                   jmp ChkPOffscr            ;skip this part
00AA8B  1  A9 00        InitScrlAmt:  lda #$00
00AA8D  1  8D 75 07                   sta ScrollAmount          ;initialize value here
00AA90  1  A2 00        ChkPOffscr:   ldx #$00                  ;set X for player offset
00AA92  1  20 8E EC                   jsr GetXOffscreenBits     ;get horizontal offscreen bits for player
00AA95  1  85 00                      sta $00                   ;save them here
00AA97  1  A0 00                      ldy #$00                  ;load default offset (left side)
00AA99  1  0A                         asl                       ;if d7 of offscreen bits are set,
00AA9A  1  B0 07                      bcs KeepOnscr             ;branch with default offset
00AA9C  1  C8                         iny                         ;otherwise use different offset (right side)
00AA9D  1  A5 00                      lda $00
00AA9F  1  29 20                      and #%00100000              ;check offscreen bits for d5 set
00AAA1  1  F0 1B                      beq InitPlatScrl            ;if not set, branch ahead of this part
00AAA3  1  B9 1C 07     KeepOnscr:    lda ScreenEdge_X_Pos,y      ;get left or right side coordinate based on offset
00AAA6  1  38                         sec
00AAA7  1  F9 C4 AA                   sbc X_SubtracterData,y      ;subtract amount based on offset
00AAAA  1  85 86                      sta Player_X_Position       ;store as player position to prevent movement further
00AAAC  1  B9 1A 07                   lda ScreenEdge_PageLoc,y    ;get left or right page location based on offset
00AAAF  1  E9 00                      sbc #$00                    ;subtract borrow
00AAB1  1  85 6D                      sta Player_PageLoc          ;save as player's page location
00AAB3  1  A5 0C                      lda Left_Right_Buttons      ;check saved controller bits
00AAB5  1  D9 C6 AA                   cmp OffscrJoypadBitsData,y  ;against bits based on offset
00AAB8  1  F0 04                      beq InitPlatScrl            ;if not equal, branch
00AABA  1  A9 00                      lda #$00
00AABC  1  85 57                      sta Player_X_Speed          ;otherwise nullify horizontal speed of player
00AABE  1  A9 00        InitPlatScrl: lda #$00                    ;nullify platform force imposed on scroll
00AAC0  1  8D A1 03                   sta Platform_X_Scroll
00AAC3  1  60                         rts
00AAC4  1               
00AAC4  1               X_SubtracterData:
00AAC4  1  00 10              .byte $00, $10
00AAC6  1               
00AAC6  1               OffscrJoypadBitsData:
00AAC6  1  01 02              .byte $01, $02
00AAC8  1               
00AAC8  1               ;-------------------------------------------------------------------------------------
00AAC8  1               
00AAC8  1               GameRoutines:
00AAC8  1  A5 0E              lda GameEngineSubroutine  ;run routine based on number (a few of these routines are
00AACA  1  20 A8 BA           jsr JumpEngine            ;merely placeholders as conditions for other routines)
00AACD  1               
00AACD  1  5D 8C              .word Entrance_GameTimerSetup
00AACF  1  E5 AB              .word Vine_AutoClimb
00AAD1  1  24 AC              .word SideExitPipeEntry
00AAD3  1  03 AC              .word VerticalPipeEntry
00AAD5  1  C2 AC              .word FlagpoleSlide
00AAD7  1  E8 AC              .word PlayerEndLevel
00AAD9  1  C8 8C              .word PlayerLoseLife
00AADB  1  E7 AA              .word PlayerEntrance
00AADD  1  EF AA              .word PlayerCtrlRoutine
00AADF  1  51 AC              .word PlayerChangeSize
00AAE1  1  63 AC              .word PlayerInjuryBlink
00AAE3  1  87 AC              .word PlayerDeath
00AAE5  1  9B AC              .word PlayerFireFlower
00AAE7  1               
00AAE7  1               ;-------------------------------------------------------------------------------------
00AAE7  1               
00AAE7  1               PlayerEntrance:
00AAE7  1  A9 08        PlayerRdy:  lda #$08                  ;set routine to be executed by game engine next frame
00AAE9  1  85 0E                    sta GameEngineSubroutine
00AAEB  1  60           ExitEntr:   rts                       ;leave!
00AAEC  1               
00AAEC  1               ;-------------------------------------------------------------------------------------
00AAEC  1               ;$07 - used to hold upper limit of high byte when player falls down hole
00AAEC  1               
00AAEC  1               AutoControlPlayer:
00AAEC  1  8D FC 06           sta SavedJoypadBits         ;override controller bits with contents of A if executing here
00AAEF  1               
00AAEF  1               PlayerCtrlRoutine:
00AAEF  1  AD 61 07                 lda FpgFlags
00AAF2  1  29 02                    and #$02
00AAF4  1  D0 11                    bne ProcessUserInputs
00AAF6  1  AD FC 06                 lda SavedJoypadBits
00AAF9  1  29 03                    and #Left_Dir|Right_Dir
00AAFB  1  F0 EE                    beq ExitEntr
00AAFD  1  AD 61 07                 lda FpgFlags
00AB00  1  09 02                    ora #$02
00AB02  1  8D 61 07                 sta FpgFlags
00AB05  1  E6 09        			inc FrameCounter ; We acutally played on this frame, so increment it.
00AB07  1               ProcessUserInputs:
00AB07  1  A5 0E                    lda GameEngineSubroutine    ;check task here
00AB09  1  C9 0B                    cmp #$0b                    ;if certain value is set, branch to skip controller bit loading
00AB0B  1  F0 3C                    beq SizeChk
00AB0D  1  AD 4E 07                 lda AreaType                ;are we in a water type area?
00AB10  1  D0 10                    bne SaveJoyp                ;if not, branch
00AB12  1  A4 B5                    ldy Player_Y_HighPos
00AB14  1  88                       dey                         ;if not in vertical area between
00AB15  1  D0 06                    bne DisJoyp                 ;status bar and bottom, branch
00AB17  1  A5 CE                    lda Player_Y_Position
00AB19  1  C9 D0                    cmp #$d0                    ;if nearing the bottom of the screen or
00AB1B  1  90 05                    bcc SaveJoyp                ;not in the vertical area between status bar or bottom,
00AB1D  1  A9 00        DisJoyp:    lda #$00                    ;disable controller bits
00AB1F  1  8D FC 06                 sta SavedJoypadBits
00AB22  1  AD FC 06     SaveJoyp:   lda SavedJoypadBits         ;otherwise store A and B buttons in $0a
00AB25  1  29 C0                    and #%11000000
00AB27  1  85 0A                    sta A_B_Buttons
00AB29  1  AD FC 06                 lda SavedJoypadBits         ;store left and right buttons in $0c
00AB2C  1  29 03                    and #%00000011
00AB2E  1  85 0C                    sta Left_Right_Buttons
00AB30  1  AD FC 06                 lda SavedJoypadBits         ;store up and down buttons in $0b
00AB33  1  29 0C                    and #%00001100
00AB35  1  85 0B                    sta Up_Down_Buttons
00AB37  1  29 04                    and #%00000100              ;check for pressing down
00AB39  1  F0 0E                    beq SizeChk                 ;if not, branch
00AB3B  1  A5 1D                    lda Player_State            ;check player's state
00AB3D  1  D0 0A                    bne SizeChk                 ;if not on the ground, branch
00AB3F  1  A4 0C                    ldy Left_Right_Buttons      ;check left and right
00AB41  1  F0 06                    beq SizeChk                 ;if neither pressed, branch
00AB43  1  A9 00                    lda #$00
00AB45  1  85 0C                    sta Left_Right_Buttons      ;if pressing down while on the ground,
00AB47  1  85 0B                    sta Up_Down_Buttons         ;nullify directional bits
00AB49  1  20 47 AD     SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
00AB4C  1  A0 01                    ldy #$01                    ;is player small?
00AB4E  1  AD 54 07                 lda PlayerSize
00AB51  1  D0 09                    bne ChkMoveDir
00AB53  1  A0 00                    ldy #$00                    ;check for if crouching
00AB55  1  AD 14 07                 lda CrouchingFlag
00AB58  1  F0 02                    beq ChkMoveDir              ;if not, branch ahead
00AB5A  1  A0 02                    ldy #$02                    ;if big and crouching, load y with 2
00AB5C  1  8C 99 04     ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
00AB5F  1  A9 01                    lda #$01                    ;set moving direction to right by default
00AB61  1  A4 57                    ldy Player_X_Speed          ;check player's horizontal speed
00AB63  1  F0 05                    beq PlayerSubs              ;if not moving at all horizontally, skip this part
00AB65  1  10 01                    bpl SetMoveDir              ;if moving to the right, use default moving direction
00AB67  1  0A                       asl                         ;otherwise change to move to the left
00AB68  1  85 45        SetMoveDir: sta Player_MovingDir        ;set moving direction
00AB6A  1  20 23 AA     PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
00AB6D  1  20 18 EC                 jsr GetPlayerOffscreenBits  ;get player's offscreen bits
00AB70  1  20 C2 EB                 jsr RelativePlayerPosition  ;get coordinates relative to the screen
00AB73  1  A2 00                    ldx #$00                    ;set offset for player object
00AB75  1  20 54 DD                 jsr BoundingBoxCore         ;get player's bounding box coordinates
00AB78  1  20 7F D7                 jsr PlayerBGCollision       ;do collision detection and process
00AB7B  1  A5 CE                    lda Player_Y_Position
00AB7D  1  C9 40                    cmp #$40                    ;check to see if player is higher than 64th pixel
00AB7F  1  90 16                    bcc PlayerHole              ;if so, branch ahead
00AB81  1  A5 0E                    lda GameEngineSubroutine
00AB83  1  C9 05                    cmp #$05                    ;if running end-of-level routine, branch ahead
00AB85  1  F0 10                    beq PlayerHole
00AB87  1  C9 07                    cmp #$07                    ;if running player entrance routine, branch ahead
00AB89  1  F0 0C                    beq PlayerHole
00AB8B  1  C9 04                    cmp #$04                    ;if running routines $00-$03, branch ahead
00AB8D  1  90 08                    bcc PlayerHole
00AB8F  1  AD C4 03                 lda Player_SprAttrib
00AB92  1  29 DF                    and #%11011111              ;otherwise nullify player's
00AB94  1  8D C4 03                 sta Player_SprAttrib        ;background priority flag
00AB97  1  A5 B5        PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
00AB99  1  C9 02                    cmp #$02                    ;for below the screen
00AB9B  1  30 3B                    bmi ExitCtrl                ;branch to leave if not that far down
00AB9D  1  A2 01                    ldx #$01
00AB9F  1  8E 23 07                 stx ScrollLock              ;set scroll lock
00ABA2  1  A0 04                    ldy #$04
00ABA4  1  84 07                    sty $07                     ;set value here
00ABA6  1  A2 00                    ldx #$00                    ;use X as flag, and clear for cloud level
00ABA8  1  AC 59 07                 ldy GameTimerExpiredFlag    ;check game timer expiration flag
00ABAB  1  D0 05                    bne HoleDie                 ;if set, branch
00ABAD  1  AC 43 07                 ldy CloudTypeOverride       ;check for cloud type override
00ABB0  1  D0 16                    bne ChkHoleX                ;skip to last part if found
00ABB2  1  E8           HoleDie:    inx                         ;set flag in X for player death
00ABB3  1  A4 0E                    ldy GameEngineSubroutine
00ABB5  1  C0 0B                    cpy #$0b                    ;check for some other routine running
00ABB7  1  F0 0F                    beq ChkHoleX                ;if so, branch ahead
00ABB9  1  AC 12 07                 ldy DeathMusicLoaded        ;check value here
00ABBC  1  D0 06                    bne HoleBottom              ;if already set, branch to next part
00ABBE  1  C8                       iny
00ABBF  1  84 FC                    sty EventMusicQueue         ;otherwise play death music
00ABC1  1  8C 12 07                 sty DeathMusicLoaded        ;and set value here
00ABC4  1  A0 06        HoleBottom: ldy #$06
00ABC6  1  84 07                    sty $07                     ;change value here
00ABC8  1  C5 07        ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
00ABCA  1  30 0C                    bmi ExitCtrl                ;if less, branch to leave
00ABCC  1  CA                       dex                         ;otherwise decrement flag in X
00ABCD  1  30 0A                    bmi CloudExit               ;if flag was clear, branch to set modes and other values
00ABCF  1  AC B1 07                 ldy EventMusicBuffer        ;check to see if music is still playing
00ABD2  1  D0 04                    bne ExitCtrl                ;branch to leave if so
00ABD4  1  A9 06                    lda #$06                    ;otherwise set to run lose life routine
00ABD6  1  85 0E                    sta GameEngineSubroutine    ;on next frame
00ABD8  1  60           ExitCtrl:   rts                         ;leave
00ABD9  1               
00ABD9  1               CloudExit:
00ABD9  1  A9 00              lda #$00
00ABDB  1  8D 58 07           sta JoypadOverride      ;clear controller override bits if any are set
00ABDE  1  20 FB AB           jsr SetEntr             ;do sub to set secondary mode
00ABE1  1  EE 52 07           inc AltEntranceControl  ;set mode of entry to 3
00ABE4  1  60                 rts
00ABE5  1               
00ABE5  1               ;-------------------------------------------------------------------------------------
00ABE5  1               
00ABE5  1               Vine_AutoClimb:
00ABE5  1  A5 B5                   lda Player_Y_HighPos   ;check to see whether player reached position
00ABE7  1  D0 06                   bne AutoClimb          ;above the status bar yet and if so, set modes
00ABE9  1  A5 CE                   lda Player_Y_Position
00ABEB  1  C9 E4                   cmp #$e4
00ABED  1  90 0C                   bcc SetEntr
00ABEF  1  A9 08        AutoClimb: lda #%00001000         ;set controller bits override to up
00ABF1  1  8D 58 07                sta JoypadOverride
00ABF4  1  A0 03                   ldy #$03               ;set player state to climbing
00ABF6  1  84 1D                   sty Player_State
00ABF8  1  4C EC AA                jmp AutoControlPlayer
00ABFB  1  A9 02        SetEntr:   lda #$02               ;set starting position to override
00ABFD  1  8D 52 07                sta AltEntranceControl
00AC00  1  4C 31 AC                jmp ChgAreaMode        ;set modes
00AC03  1               
00AC03  1               ;-------------------------------------------------------------------------------------
00AC03  1               
00AC03  1               VerticalPipeEntry:
00AC03  1  A9 01              lda #$01             ;set 1 as movement amount
00AC05  1  20 1E AC           jsr MovePlayerYAxis  ;do sub to move player downwards
00AC08  1  20 23 AA           jsr ScrollHandler    ;do sub to scroll screen with saved force if necessary
00AC0B  1  A0 00              ldy #$00             ;load default mode of entry
00AC0D  1  AD D6 06           lda WarpZoneControl  ;check warp zone control variable/flag
00AC10  1  D0 17              bne ChgAreaPipe      ;if set, branch to use mode 0
00AC12  1  C8                 iny
00AC13  1  AD 4E 07           lda AreaType         ;check for castle level type
00AC16  1  C9 03              cmp #$03
00AC18  1  D0 0F              bne ChgAreaPipe      ;if not castle type level, use mode 1
00AC1A  1  C8                 iny
00AC1B  1  4C 29 AC           jmp ChgAreaPipe      ;otherwise use mode 2
00AC1E  1               
00AC1E  1               MovePlayerYAxis:
00AC1E  1  18                 clc
00AC1F  1  65 CE              adc Player_Y_Position ;add contents of A to player position
00AC21  1  85 CE              sta Player_Y_Position
00AC23  1  60                 rts
00AC24  1               
00AC24  1               ;-------------------------------------------------------------------------------------
00AC24  1               
00AC24  1               SideExitPipeEntry:
00AC24  1  20 3D AC                  jsr EnterSidePipe         ;execute sub to move player to the right
00AC27  1  A0 02                     ldy #$02
00AC29  1  CE DE 06     ChgAreaPipe: dec ChangeAreaTimer       ;decrement timer for change of area
00AC2C  1  D0 0E                     bne ExitCAPipe
00AC2E  1  8C 52 07                  sty AltEntranceControl    ;when timer expires set mode of alternate entry
00AC31  1  EE 74 07     ChgAreaMode: inc DisableScreenFlag     ;set flag to disable screen output
00AC34  1  A9 00                     lda #$00
00AC36  1  8D 72 07                  sta OperMode_Task         ;set secondary mode of operation
00AC39  1  8D 22 07                  sta Sprite0HitDetectFlag  ;disable sprite 0 check
00AC3C  1  60           ExitCAPipe:  rts                       ;leave
00AC3D  1               
00AC3D  1               EnterSidePipe:
00AC3D  1  A9 08                   lda #$08               ;set player's horizontal speed
00AC3F  1  85 57                   sta Player_X_Speed
00AC41  1  A0 01                   ldy #$01               ;set controller right button by default
00AC43  1  A5 86                   lda Player_X_Position  ;mask out higher nybble of player's
00AC45  1  29 0F                   and #%00001111         ;horizontal position
00AC47  1  D0 03                   bne RightPipe
00AC49  1  85 57                   sta Player_X_Speed     ;if lower nybble = 0, set as horizontal speed
00AC4B  1  A8                      tay                    ;and nullify controller bit override here
00AC4C  1  98           RightPipe: tya                    ;use contents of Y to
00AC4D  1  20 EC AA                jsr AutoControlPlayer  ;execute player control routine with ctrl bits nulled
00AC50  1  60                      rts
00AC51  1               
00AC51  1               ;-------------------------------------------------------------------------------------
00AC51  1               
00AC51  1               PlayerChangeSize:
00AC51  1  AD 47 07                  lda TimerControl    ;check master timer control
00AC54  1  C9 F8                     cmp #$f8            ;for specific moment in time
00AC56  1  D0 03                     bne EndChgSize      ;branch if before or after that point
00AC58  1  4C 73 AC                  jmp InitChangeSize  ;otherwise run code to get growing/shrinking going
00AC5B  1  C9 C4        EndChgSize:  cmp #$c4            ;check again for another specific moment
00AC5D  1  D0 03                     bne ExitChgSize     ;and branch to leave if before or after that point
00AC5F  1  20 91 AC                  jsr DonePlayerTask  ;otherwise do sub to init timer control and set routine
00AC62  1  60           ExitChgSize: rts                 ;and then leave
00AC63  1               
00AC63  1               ;-------------------------------------------------------------------------------------
00AC63  1               
00AC63  1               PlayerInjuryBlink:
00AC63  1  AD 47 07                lda TimerControl       ;check master timer control
00AC66  1  C9 F0                   cmp #$f0               ;for specific moment in time
00AC68  1  B0 07                   bcs ExitBlink          ;branch if before that point
00AC6A  1  C9 C8                   cmp #$c8               ;check again for another specific point
00AC6C  1  F0 23                   beq DonePlayerTask     ;branch if at that point, and not before or after
00AC6E  1  4C EF AA                jmp PlayerCtrlRoutine  ;otherwise run player control routine
00AC71  1  D0 13        ExitBlink: bne ExitBoth           ;do unconditional branch to leave
00AC73  1               
00AC73  1               InitChangeSize:
00AC73  1  AC 0B 07               ldy PlayerChangeSizeFlag  ;if growing/shrinking flag already set
00AC76  1  D0 0E                  bne ExitBoth              ;then branch to leave
00AC78  1  8C 0D 07               sty PlayerAnimCtrl        ;otherwise initialize player's animation frame control
00AC7B  1  EE 0B 07               inc PlayerChangeSizeFlag  ;set growing/shrinking flag
00AC7E  1  AD 54 07               lda PlayerSize
00AC81  1  49 01                  eor #$01                  ;invert player's size
00AC83  1  8D 54 07               sta PlayerSize
00AC86  1  60           ExitBoth: rts                       ;leave
00AC87  1               
00AC87  1               ;-------------------------------------------------------------------------------------
00AC87  1               ;$00 - used in CyclePlayerPalette to store current palette to cycle
00AC87  1               
00AC87  1               PlayerDeath:
00AC87  1  AD 47 07           lda TimerControl       ;check master timer control
00AC8A  1  C9 F0              cmp #$f0               ;for specific moment in time
00AC8C  1  B0 33              bcs ExitDeath          ;branch to leave if before that point
00AC8E  1  4C EF AA           jmp PlayerCtrlRoutine  ;otherwise run player control routine
00AC91  1               
00AC91  1               DonePlayerTask:
00AC91  1  A9 00              lda #$00
00AC93  1  8D 47 07           sta TimerControl          ;initialize master timer control to continue timers
00AC96  1  A9 08              lda #$08
00AC98  1  85 0E              sta GameEngineSubroutine  ;set player control routine to run next frame
00AC9A  1  60                 rts                       ;leave
00AC9B  1               
00AC9B  1               PlayerFireFlower:
00AC9B  1  AD 47 07           lda TimerControl       ;check master timer control
00AC9E  1  C9 C0              cmp #$c0               ;for specific moment in time
00ACA0  1  F0 13              beq ResetPalFireFlower ;branch if at moment, not before or after
00ACA2  1  A5 09              lda FrameCounter       ;get frame counter
00ACA4  1  4A                 lsr
00ACA5  1  4A                 lsr                    ;divide by four to change every four frames
00ACA6  1               
00ACA6  1               CyclePlayerPalette:
00ACA6  1  29 03              and #$03              ;mask out all but d1-d0 (previously d3-d2)
00ACA8  1  85 00              sta $00               ;store result here to use as palette bits
00ACAA  1  AD C4 03           lda Player_SprAttrib  ;get player attributes
00ACAD  1  29 FC              and #%11111100        ;save any other bits but palette bits
00ACAF  1  05 00              ora $00               ;add palette bits
00ACB1  1  8D C4 03           sta Player_SprAttrib  ;store as new player attributes
00ACB4  1  60                 rts                   ;and leave
00ACB5  1               
00ACB5  1               ResetPalFireFlower:
00ACB5  1  20 91 AC           jsr DonePlayerTask    ;do sub to init timer control and run player control routine
00ACB8  1               
00ACB8  1               ResetPalStar:
00ACB8  1  AD C4 03           lda Player_SprAttrib  ;get player attributes
00ACBB  1  29 FC              and #%11111100        ;mask out palette bits to force palette 0
00ACBD  1  8D C4 03           sta Player_SprAttrib  ;store as new player attributes
00ACC0  1  60                 rts                   ;and leave
00ACC1  1               
00ACC1  1               ExitDeath:
00ACC1  1  60                 rts          ;leave from death routine
00ACC2  1               
00ACC2  1               ;-------------------------------------------------------------------------------------
00ACC2  1               
00ACC2  1               FlagpoleSlide:
00ACC2  1  A5 1B                     lda Enemy_ID+5           ;check special use enemy slot
00ACC4  1  C9 30                     cmp #FlagpoleFlagObject  ;for flagpole flag object
00ACC6  1  D0 15                     bne NoFPObj              ;if not found, branch to something residual
00ACC8  1  AD 13 07                  lda FlagpoleSoundQueue   ;load flagpole sound
00ACCB  1  85 FF                     sta Square1SoundQueue    ;into square 1's sfx queue
00ACCD  1  A9 00                     lda #$00
00ACCF  1  8D 13 07                  sta FlagpoleSoundQueue   ;init flagpole sound queue
00ACD2  1  A4 CE                     ldy Player_Y_Position
00ACD4  1  C0 9E                     cpy #$9e                 ;check to see if player has slid down
00ACD6  1  B0 02                     bcs SlidePlayer          ;far enough, and if so, branch with no controller bits set
00ACD8  1  A9 04                     lda #$04                 ;otherwise force player to climb down (to slide)
00ACDA  1  4C EC AA     SlidePlayer: jmp AutoControlPlayer    ;jump to player control routine
00ACDD  1  E6 0E        NoFPObj:     inc GameEngineSubroutine ;increment to next routine (this may
00ACDF  1  60                        rts                      ;be residual code)
00ACE0  1               
00ACE0  1               ;-------------------------------------------------------------------------------------
00ACE0  1               
00ACE0  1               Hidden1UpCoinAmts:
00ACE0  1  15 23 16 1B        .byte $15, $23, $16, $1b, $17, $18, $23, $63
00ACE4  1  17 18 23 63  
00ACE8  1               
00ACE8  1               PlayerEndLevel:
00ACE8  1  A9 01                  lda #$01                  ;force player to walk to the right
00ACEA  1  20 EC AA               jsr AutoControlPlayer
00ACED  1  A5 CE                  lda Player_Y_Position     ;check player's vertical position
00ACEF  1  C9 AE                  cmp #$ae
00ACF1  1  90 0E                  bcc ChkStop               ;if player is not yet off the flagpole, skip this part
00ACF3  1  AD 23 07               lda ScrollLock            ;if scroll lock not set, branch ahead to next part
00ACF6  1  F0 09                  beq ChkStop               ;because we only need to do this part once
00ACF8  1  A9 20                  lda #EndOfLevelMusic
00ACFA  1  85 FC                  sta EventMusicQueue       ;load win level music in event music queue
00ACFC  1  A9 00                  lda #$00
00ACFE  1  8D 23 07               sta ScrollLock            ;turn off scroll lock to skip this part later
00AD01  1  AD 90 04     ChkStop:  lda Player_CollisionBits  ;get player collision bits
00AD04  1  4A                     lsr                       ;check for d0 set
00AD05  1  B0 0D                  bcs RdyNextA              ;if d0 set, skip to next part
00AD07  1  AD 46 07               lda StarFlagTaskControl   ;if star flag task control already set,
00AD0A  1  D0 03                  bne InCastle              ;go ahead with the rest of the code
00AD0C  1  EE 46 07               inc StarFlagTaskControl   ;otherwise set task control now (this gets ball rolling!)
00AD0F  1  A9 20        InCastle: lda #%00100000            ;set player's background priority bit to
00AD11  1  8D C4 03               sta Player_SprAttrib      ;give illusion of being inside the castle
00AD14  1  AD 46 07     RdyNextA: lda StarFlagTaskControl
00AD17  1  C9 05                  cmp #$05                  ;if star flag task control not yet set
00AD19  1  D0 2B                  bne ExitNA                ;beyond last valid task number, branch to leave
00AD1B  1  EE 5C 07               inc LevelNumber           ;increment level number used for game logic
00AD1E  1  AD 5C 07               lda LevelNumber
00AD21  1  C9 03                  cmp #$03                  ;check to see if we have yet reached level -4
00AD23  1  D0 0E                  bne NextArea              ;and skip this last part here if not
00AD25  1  AC 5F 07               ldy WorldNumber           ;get world number as offset
00AD28  1  AD 48 07               lda CoinTallyFor1Ups      ;check third area coin tally for bonus 1-ups
00AD2B  1  D9 E0 AC               cmp Hidden1UpCoinAmts,y   ;against minimum value, if player has not collected
00AD2E  1  90 03                  bcc NextArea              ;at least this number of coins, leave flag clear
00AD30  1  EE 5D 07               inc Hidden1UpFlag         ;otherwise set hidden 1-up box control flag
00AD33  1  EE 60 07     NextArea: inc AreaNumber            ;increment area number used for address loader
00AD36  1  20 CE BB               jsr LoadAreaPointer       ;get new level pointer
00AD39  1  EE 57 07               inc FetchNewGameTimerFlag ;set flag to load new game timer
00AD3C  1  20 31 AC               jsr ChgAreaMode           ;do sub to set secondary mode, disable screen and sprite 0
00AD3F  1  8D 5B 07               sta HalfwayPage           ;reset halfway page to 0 (beginning)
00AD42  1  A9 80                  lda #Silence
00AD44  1  85 FC                  sta EventMusicQueue       ;silence music and leave
00AD46  1  60           ExitNA:   rts
00AD47  1               
00AD47  1               ;-------------------------------------------------------------------------------------
00AD47  1               
00AD47  1               PlayerMovementSubs:
00AD47  1  A9 00                   lda #$00                  ;set A to init crouch flag by default
00AD49  1  AC 54 07                ldy PlayerSize            ;is player small?
00AD4C  1  D0 08                   bne SetCrouch             ;if so, branch
00AD4E  1  A5 1D                   lda Player_State          ;check state of player
00AD50  1  D0 07                   bne ProcMove              ;if not on the ground, branch
00AD52  1  A5 0B                   lda Up_Down_Buttons       ;load controller bits for up and down
00AD54  1  29 04                   and #%00000100            ;single out bit for down button
00AD56  1  8D 14 07     SetCrouch: sta CrouchingFlag         ;store value in crouch flag
00AD59  1  20 6E AE     ProcMove:  jsr PlayerPhysicsSub      ;run sub related to jumping and swimming
00AD5C  1  AD 0B 07                lda PlayerChangeSizeFlag  ;if growing/shrinking flag set,
00AD5F  1  D0 16                   bne NoMoveSub             ;branch to leave
00AD61  1  A5 1D                   lda Player_State
00AD63  1  C9 03                   cmp #$03                  ;get player state
00AD65  1  F0 05                   beq MoveSubs              ;if climbing, branch ahead, leave timer unset
00AD67  1  A0 18                   ldy #$18
00AD69  1  8C 89 07                sty ClimbSideTimer        ;otherwise reset timer now
00AD6C  1  20 A8 BA     MoveSubs:  jsr JumpEngine
00AD6F  1               
00AD6F  1  78 AD              .word OnGroundStateSub
00AD71  1  94 AD              .word JumpSwimSub
00AD73  1  8B AD              .word FallingSub
00AD75  1  ED AD              .word ClimbingSub
00AD77  1               
00AD77  1  60           NoMoveSub: rts
00AD78  1               
00AD78  1               ;-------------------------------------------------------------------------------------
00AD78  1               ;$00 - used by ClimbingSub to store high vertical adder
00AD78  1               
00AD78  1               OnGroundStateSub:
00AD78  1  20 AD AF              jsr GetPlayerAnimSpeed     ;do a sub to set animation frame timing
00AD7B  1  A5 0C                 lda Left_Right_Buttons
00AD7D  1  F0 02                 beq GndMove                ;if left/right controller bits not set, skip instruction
00AD7F  1  85 33                 sta PlayerFacingDir        ;otherwise set new facing direction
00AD81  1  20 EA AF     GndMove: jsr ImposeFriction         ;do a sub to impose friction on player's walk/run
00AD84  1  20 EB BE              jsr MovePlayerHorizontally ;do another sub to move player horizontally
00AD87  1  8D FF 06              sta Player_X_Scroll        ;set returned value as player's movement speed for scroll
00AD8A  1  60                    rts
00AD8B  1               
00AD8B  1               ;--------------------------------
00AD8B  1               
00AD8B  1               FallingSub:
00AD8B  1  AD 0A 07           lda VerticalForceDown
00AD8E  1  8D 09 07           sta VerticalForce      ;dump vertical movement force for falling into main one
00AD91  1  4C CA AD           jmp LRAir              ;movement force, then skip ahead to process left/right movement
00AD94  1               
00AD94  1               ;--------------------------------
00AD94  1               
00AD94  1               JumpSwimSub:
00AD94  1  A4 9F                  ldy Player_Y_Speed         ;if player's vertical speed zero
00AD96  1  10 13                  bpl DumpFall               ;or moving downwards, branch to falling
00AD98  1  A5 0A                  lda A_B_Buttons
00AD9A  1  29 80                  and #A_Button              ;check to see if A button is being pressed
00AD9C  1  25 0D                  and PreviousA_B_Buttons    ;and was pressed in previous frame
00AD9E  1  D0 11                  bne ProcSwim               ;if so, branch elsewhere
00ADA0  1  AD 08 07               lda JumpOrigin_Y_Position  ;get vertical position player jumped from
00ADA3  1  38                     sec
00ADA4  1  E5 CE                  sbc Player_Y_Position      ;subtract current from original vertical coordinate
00ADA6  1  CD 06 07               cmp DiffToHaltJump         ;compare to value set here to see if player is in mid-jump
00ADA9  1  90 06                  bcc ProcSwim               ;or just starting to jump, if just starting, skip ahead
00ADAB  1  AD 0A 07     DumpFall: lda VerticalForceDown      ;otherwise dump falling into main fractional
00ADAE  1  8D 09 07               sta VerticalForce
00ADB1  1  AD 04 07     ProcSwim: lda SwimmingFlag           ;if swimming flag not set,
00ADB4  1  F0 14                  beq LRAir                  ;branch ahead to last part
00ADB6  1  20 AD AF               jsr GetPlayerAnimSpeed     ;do a sub to get animation frame timing
00ADB9  1  A5 CE                  lda Player_Y_Position
00ADBB  1  C9 14                  cmp #$14                   ;check vertical position against preset value
00ADBD  1  B0 05                  bcs LRWater                ;if not yet reached a certain position, branch ahead
00ADBF  1  A9 18                  lda #$18
00ADC1  1  8D 09 07               sta VerticalForce          ;otherwise set fractional
00ADC4  1  A5 0C        LRWater:  lda Left_Right_Buttons     ;check left/right controller bits (check for swimming)
00ADC6  1  F0 02                  beq LRAir                  ;if not pressing any, skip
00ADC8  1  85 33                  sta PlayerFacingDir        ;otherwise set facing direction accordingly
00ADCA  1  A5 0C        LRAir:    lda Left_Right_Buttons     ;check left/right controller bits (check for jumping/falling)
00ADCC  1  F0 03                  beq JSMove                 ;if not pressing any, skip
00ADCE  1  20 EA AF               jsr ImposeFriction         ;otherwise process horizontal movement
00ADD1  1  20 EB BE     JSMove:   jsr MovePlayerHorizontally ;do a sub to move player horizontally
00ADD4  1  8D FF 06               sta Player_X_Scroll        ;set player's speed here, to be used for scroll later
00ADD7  1  A5 0E                  lda GameEngineSubroutine
00ADD9  1  C9 0B                  cmp #$0b                   ;check for specific routine selected
00ADDB  1  D0 05                  bne ExitMov1               ;branch if not set to run
00ADDD  1  A9 28                  lda #$28
00ADDF  1  8D 09 07               sta VerticalForce          ;otherwise set fractional
00ADE2  1  4C 2F BF     ExitMov1: jmp MovePlayerVertically   ;jump to move player vertically, then leave
00ADE5  1               
00ADE5  1               ;--------------------------------
00ADE5  1               
00ADE5  1               ClimbAdderLow:
00ADE5  1  0E 04 FC F2        .byte $0e, $04, $fc, $f2
00ADE9  1               ClimbAdderHigh:
00ADE9  1  00 00 FF FF        .byte $00, $00, $ff, $ff
00ADED  1               
00ADED  1               ClimbingSub:
00ADED  1  AD 16 04                  lda Player_YMF_Dummy
00ADF0  1  18                        clc                      ;add movement force to dummy variable
00ADF1  1  6D 33 04                  adc Player_Y_MoveForce   ;save with carry
00ADF4  1  8D 16 04                  sta Player_YMF_Dummy
00ADF7  1  A0 00                     ldy #$00                 ;set default adder here
00ADF9  1  A5 9F                     lda Player_Y_Speed       ;get player's vertical speed
00ADFB  1  10 01                     bpl MoveOnVine           ;if not moving upwards, branch
00ADFD  1  88                        dey                      ;otherwise set adder to $ff
00ADFE  1  84 00        MoveOnVine:  sty $00                  ;store adder here
00AE00  1  65 CE                     adc Player_Y_Position    ;add carry to player's vertical position
00AE02  1  85 CE                     sta Player_Y_Position    ;and store to move player up or down
00AE04  1  A5 B5                     lda Player_Y_HighPos
00AE06  1  65 00                     adc $00                  ;add carry to player's page location
00AE08  1  85 B5                     sta Player_Y_HighPos     ;and store
00AE0A  1  A5 0C                     lda Left_Right_Buttons   ;compare left/right controller bits
00AE0C  1  2D 90 04                  and Player_CollisionBits ;to collision flag
00AE0F  1  F0 2D                     beq InitCSTimer          ;if not set, skip to end
00AE11  1  AC 89 07                  ldy ClimbSideTimer       ;otherwise check timer
00AE14  1  D0 27                     bne ExitCSub             ;if timer not expired, branch to leave
00AE16  1  A0 18                     ldy #$18
00AE18  1  8C 89 07                  sty ClimbSideTimer       ;otherwise set timer now
00AE1B  1  A2 00                     ldx #$00                 ;set default offset here
00AE1D  1  A4 33                     ldy PlayerFacingDir      ;get facing direction
00AE1F  1  4A                        lsr                      ;move right button controller bit to carry
00AE20  1  B0 02                     bcs ClimbFD              ;if controller right pressed, branch ahead
00AE22  1  E8                        inx
00AE23  1  E8                        inx                      ;otherwise increment offset by 2 bytes
00AE24  1  88           ClimbFD:     dey                      ;check to see if facing right
00AE25  1  F0 01                     beq CSetFDir             ;if so, branch, do not increment
00AE27  1  E8                        inx                      ;otherwise increment by 1 byte
00AE28  1  A5 86        CSetFDir:    lda Player_X_Position
00AE2A  1  18                        clc                      ;add or subtract from player's horizontal position
00AE2B  1  7D E5 AD                  adc ClimbAdderLow,x      ;using value here as adder and X as offset
00AE2E  1  85 86                     sta Player_X_Position
00AE30  1  A5 6D                     lda Player_PageLoc       ;add or subtract carry or borrow using value here
00AE32  1  7D E9 AD                  adc ClimbAdderHigh,x     ;from the player's page location
00AE35  1  85 6D                     sta Player_PageLoc
00AE37  1  A5 0C                     lda Left_Right_Buttons   ;get left/right controller bits again
00AE39  1  49 03                     eor #%00000011           ;invert them and store them while player
00AE3B  1  85 33                     sta PlayerFacingDir      ;is on vine to face player in opposite direction
00AE3D  1  60           ExitCSub:    rts                      ;then leave
00AE3E  1  8D 89 07     InitCSTimer: sta ClimbSideTimer       ;initialize timer here
00AE41  1  60                        rts
00AE42  1               
00AE42  1               ;-------------------------------------------------------------------------------------
00AE42  1               ;$00 - used to store offset to friction data
00AE42  1               
00AE42  1               JumpMForceData:
00AE42  1  20 20 1E 28        .byte $20, $20, $1e, $28, $28, $0d, $04
00AE46  1  28 0D 04     
00AE49  1               
00AE49  1               FallMForceData:
00AE49  1  70 70 60 90        .byte $70, $70, $60, $90, $90, $0a, $09
00AE4D  1  90 0A 09     
00AE50  1               
00AE50  1               PlayerYSpdData:
00AE50  1  FC FC FC FB        .byte $fc, $fc, $fc, $fb, $fb, $fe, $ff
00AE54  1  FB FE FF     
00AE57  1               
00AE57  1               InitMForceData:
00AE57  1  00 00 00 00        .byte $00, $00, $00, $00, $00, $80, $00
00AE5B  1  00 80 00     
00AE5E  1               
00AE5E  1               MaxLeftXSpdData:
00AE5E  1  D8 E8 F0           .byte $d8, $e8, $f0
00AE61  1               
00AE61  1               MaxRightXSpdData:
00AE61  1  28 18 10           .byte $28, $18, $10
00AE64  1  0C                 .byte $0c ;used for pipe intros
00AE65  1               
00AE65  1               FrictionData:
00AE65  1  E4 98 D0           .byte $e4, $98, $d0
00AE68  1               
00AE68  1               Climb_Y_SpeedData:
00AE68  1  00 FF 01           .byte $00, $ff, $01
00AE6B  1               
00AE6B  1               Climb_Y_MForceData:
00AE6B  1  00 20 FF           .byte $00, $20, $ff
00AE6E  1               
00AE6E  1               PlayerPhysicsSub:
00AE6E  1  A5 1D                   lda Player_State          ;check player state
00AE70  1  C9 03                   cmp #$03
00AE72  1  D0 23                   bne CheckForJumping       ;if not climbing, branch
00AE74  1  A0 00                   ldy #$00
00AE76  1  A5 0B                   lda Up_Down_Buttons       ;get controller bits for up/down
00AE78  1  2D 90 04                and Player_CollisionBits  ;check against player's collision detection bits
00AE7B  1  F0 06                   beq ProcClimb             ;if not pressing up or down, branch
00AE7D  1  C8                      iny
00AE7E  1  29 08                   and #%00001000            ;check for pressing up
00AE80  1  D0 01                   bne ProcClimb
00AE82  1  C8                      iny
00AE83  1  BE 6B AE     ProcClimb: ldx Climb_Y_MForceData,y  ;load value here
00AE86  1  8E 33 04                stx Player_Y_MoveForce    ;store as vertical movement force
00AE89  1  A9 08                   lda #$08                  ;load default animation timing
00AE8B  1  BE 68 AE                ldx Climb_Y_SpeedData,y   ;load some other value here
00AE8E  1  86 9F                   stx Player_Y_Speed        ;store as vertical speed
00AE90  1  30 01                   bmi SetCAnim              ;if climbing down, use default animation timing value
00AE92  1  4A                      lsr                       ;otherwise divide timer setting by 2
00AE93  1  8D 0C 07     SetCAnim:  sta PlayerAnimTimerSet    ;store animation timer setting and leave
00AE96  1  60                      rts
00AE97  1               
00AE97  1               CheckForJumping:
00AE97  1  AD 0E 07             lda JumpspringAnimCtrl    ;if jumpspring animating,
00AE9A  1  D0 0A                bne NoJump                ;skip ahead to something else
00AE9C  1  A5 0A                lda A_B_Buttons           ;check for A button press
00AE9E  1  29 80                and #A_Button
00AEA0  1  F0 04                beq NoJump                ;if not, branch to something else
00AEA2  1  25 0D                and PreviousA_B_Buttons   ;if button not pressed in previous frame, branch
00AEA4  1  F0 03                beq ProcJumping
00AEA6  1  4C 3A AF     NoJump: jmp X_Physics             ;otherwise, jump to something else
00AEA9  1               
00AEA9  1               ProcJumping:
00AEA9  1  A5 1D                   lda Player_State           ;check player state
00AEAB  1  F0 11                   beq InitJS                 ;if on the ground, branch
00AEAD  1  AD 04 07                lda SwimmingFlag           ;if swimming flag not set, jump to do something else
00AEB0  1  F0 F4                   beq NoJump                 ;to prevent midair jumping, otherwise continue
00AEB2  1  AD 82 07                lda JumpSwimTimer          ;if jump/swim timer nonzero, branch
00AEB5  1  D0 07                   bne InitJS
00AEB7  1  A5 9F                   lda Player_Y_Speed         ;check player's vertical speed
00AEB9  1  10 03                   bpl InitJS                 ;if player's vertical speed motionless or down, branch
00AEBB  1  4C 3A AF                jmp X_Physics              ;if timer at zero and player still rising, do not swim
00AEBE  1  A9 20        InitJS:    lda #$20                   ;set jump/swim timer
00AEC0  1  8D 82 07                sta JumpSwimTimer
00AEC3  1  A0 00                   ldy #$00                   ;initialize vertical force and dummy variable
00AEC5  1  8C 16 04                sty Player_YMF_Dummy
00AEC8  1  8C 33 04                sty Player_Y_MoveForce
00AECB  1  A5 B5                   lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
00AECD  1  8D 07 07                sta JumpOrigin_Y_HighPos   ;and store them next to each other here
00AED0  1  A5 CE                   lda Player_Y_Position
00AED2  1  8D 08 07                sta JumpOrigin_Y_Position
00AED5  1  A9 01                   lda #$01                   ;set player state to jumping/swimming
00AED7  1  85 1D                   sta Player_State
00AED9  1  AD 00 07                lda Player_XSpeedAbsolute  ;check value related to walking/running speed
00AEDC  1  C9 09                   cmp #$09
00AEDE  1  90 10                   bcc ChkWtr                 ;branch if below certain values, increment Y
00AEE0  1  C8                      iny                        ;for each amount equal or exceeded
00AEE1  1  C9 10                   cmp #$10
00AEE3  1  90 0B                   bcc ChkWtr
00AEE5  1  C8                      iny
00AEE6  1  C9 19                   cmp #$19
00AEE8  1  90 06                   bcc ChkWtr
00AEEA  1  C8                      iny
00AEEB  1  C9 1C                   cmp #$1c
00AEED  1  90 01                   bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
00AEEF  1  C8                      iny
00AEF0  1  A9 01        ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
00AEF2  1  8D 06 07                sta DiffToHaltJump
00AEF5  1  AD 04 07                lda SwimmingFlag           ;if swimming flag disabled, branch
00AEF8  1  F0 08                   beq GetYPhy
00AEFA  1  A0 05                   ldy #$05                   ;otherwise set Y to 5, range is 5-6
00AEFC  1  AD 7D 04                lda Whirlpool_Flag         ;if whirlpool flag not set, branch
00AEFF  1  F0 01                   beq GetYPhy
00AF01  1  C8                      iny                        ;otherwise increment to 6
00AF02  1  B9 42 AE     GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
00AF05  1  8D 09 07                sta VerticalForce          ;data here
00AF08  1  B9 49 AE                lda FallMForceData,y
00AF0B  1  8D 0A 07                sta VerticalForceDown
00AF0E  1  B9 57 AE                lda InitMForceData,y
00AF11  1  8D 33 04                sta Player_Y_MoveForce
00AF14  1  B9 50 AE                lda PlayerYSpdData,y
00AF17  1  85 9F                   sta Player_Y_Speed
00AF19  1  AD 04 07                lda SwimmingFlag           ;if swimming flag disabled, branch
00AF1C  1  F0 11                   beq PJumpSnd
00AF1E  1  A9 04                   lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
00AF20  1  85 FF                   sta Square1SoundQueue      ;square 1's sfx queue
00AF22  1  A5 CE                   lda Player_Y_Position
00AF24  1  C9 14                   cmp #$14                   ;check vertical low byte of player position
00AF26  1  B0 12                   bcs X_Physics              ;if below a certain point, branch
00AF28  1  A9 00                   lda #$00                   ;otherwise reset player's vertical speed
00AF2A  1  85 9F                   sta Player_Y_Speed         ;and jump to something else to keep player
00AF2C  1  4C 3A AF                jmp X_Physics              ;from swimming above water level
00AF2F  1  A9 01        PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
00AF31  1  AC 54 07                ldy PlayerSize             ;is mario big?
00AF34  1  F0 02                   beq SJumpSnd
00AF36  1  A9 80                   lda #Sfx_SmallJump         ;if not, load small mario's jump sound
00AF38  1  85 FF        SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
00AF3A  1  A0 00        X_Physics: ldy #$00
00AF3C  1  84 00                   sty $00                    ;init value here
00AF3E  1  A5 1D                   lda Player_State           ;if mario is on the ground, branch
00AF40  1  F0 09                   beq ProcPRun
00AF42  1  AD 00 07                lda Player_XSpeedAbsolute  ;check something that seems to be related
00AF45  1  C9 19                   cmp #$19                   ;to mario's speed
00AF47  1  B0 33                   bcs GetXPhy                ;if =>$19 branch here
00AF49  1  90 18                   bcc ChkRFast               ;if not branch elsewhere
00AF4B  1  C8           ProcPRun:  iny                        ;if mario on the ground, increment Y
00AF4C  1  AD 4E 07                lda AreaType               ;check area type
00AF4F  1  F0 12                   beq ChkRFast               ;if water type, branch
00AF51  1  88                      dey                        ;decrement Y by default for non-water type area
00AF52  1  A5 0C                   lda Left_Right_Buttons     ;get left/right controller bits
00AF54  1  C5 45                   cmp Player_MovingDir       ;check against moving direction
00AF56  1  D0 0B                   bne ChkRFast               ;if controller bits <> moving direction, skip this part
00AF58  1  A5 0A                   lda A_B_Buttons            ;check for b button pressed
00AF5A  1  29 40                   and #B_Button
00AF5C  1  D0 19                   bne SetRTmr                ;if pressed, skip ahead to set timer
00AF5E  1  AD 83 07                lda RunningTimer           ;check for running timer set
00AF61  1  D0 19                   bne GetXPhy                ;if set, branch
00AF63  1  C8           ChkRFast:  iny                        ;if running timer not set or level type is water,
00AF64  1  E6 00                   inc $00                    ;increment Y again and temp variable in memory
00AF66  1  AD 03 07                lda RunningSpeed
00AF69  1  D0 07                   bne FastXSp                ;if running speed set here, branch
00AF6B  1  AD 00 07                lda Player_XSpeedAbsolute
00AF6E  1  C9 21                   cmp #$21                   ;otherwise check player's walking/running speed
00AF70  1  90 0A                   bcc GetXPhy                ;if less than a certain amount, branch ahead
00AF72  1  E6 00        FastXSp:   inc $00                    ;if running speed set or speed => $21 increment $00
00AF74  1  4C 7C AF                jmp GetXPhy                ;and jump ahead
00AF77  1  A9 0A        SetRTmr:   lda #$0a                   ;if b button pressed, set running timer
00AF79  1  8D 83 07                sta RunningTimer
00AF7C  1  B9 5E AE     GetXPhy:   lda MaxLeftXSpdData,y      ;get maximum speed to the left
00AF7F  1  8D 50 04                sta MaximumLeftSpeed
00AF82  1  A5 0E                   lda GameEngineSubroutine   ;check for specific routine running
00AF84  1  C9 07                   cmp #$07                   ;(player entrance)
00AF86  1  D0 02                   bne GetXPhy2               ;if not running, skip and use old value of Y
00AF88  1  A0 03                   ldy #$03                   ;otherwise set Y to 3
00AF8A  1  B9 61 AE     GetXPhy2:  lda MaxRightXSpdData,y     ;get maximum speed to the right
00AF8D  1  8D 56 04                sta MaximumRightSpeed
00AF90  1  A4 00                   ldy $00                    ;get other value in memory
00AF92  1  B9 65 AE                lda FrictionData,y         ;get value using value in memory as offset
00AF95  1  8D 02 07                sta FrictionAdderLow
00AF98  1  A9 00                   lda #$00
00AF9A  1  8D 01 07                sta FrictionAdderHigh      ;init something here
00AF9D  1  A5 33                   lda PlayerFacingDir
00AF9F  1  C5 45                   cmp Player_MovingDir       ;check facing direction against moving direction
00AFA1  1  F0 06                   beq ExitPhy                ;if the same, branch to leave
00AFA3  1  0E 02 07                asl FrictionAdderLow       ;otherwise shift d7 of friction adder low into carry
00AFA6  1  2E 01 07                rol FrictionAdderHigh      ;then rotate carry onto d0 of friction adder high
00AFA9  1  60           ExitPhy:   rts                        ;and then leave
00AFAA  1               
00AFAA  1               ;-------------------------------------------------------------------------------------
00AFAA  1               
00AFAA  1               PlayerAnimTmrData:
00AFAA  1  02 04 07           .byte $02, $04, $07
00AFAD  1               
00AFAD  1               GetPlayerAnimSpeed:
00AFAD  1  A0 00                    ldy #$00                   ;initialize offset in Y
00AFAF  1  AD 00 07                 lda Player_XSpeedAbsolute  ;check player's walking/running speed
00AFB2  1  C9 1C                    cmp #$1c                   ;against preset amount
00AFB4  1  B0 15                    bcs SetRunSpd              ;if greater than a certain amount, branch ahead
00AFB6  1  C8                       iny                        ;otherwise increment Y
00AFB7  1  C9 0E                    cmp #$0e                   ;compare against lower amount
00AFB9  1  B0 01                    bcs ChkSkid                ;if greater than this but not greater than first, skip increment
00AFBB  1  C8                       iny                        ;otherwise increment Y again
00AFBC  1  AD FC 06     ChkSkid:    lda SavedJoypadBits        ;get controller bits
00AFBF  1  29 7F                    and #%01111111             ;mask out A button
00AFC1  1  F0 20                    beq SetAnimSpd             ;if no other buttons pressed, branch ahead of all this
00AFC3  1  29 03                    and #$03                   ;mask out all others except left and right
00AFC5  1  C5 45                    cmp Player_MovingDir       ;check against moving direction
00AFC7  1  D0 08                    bne ProcSkid               ;if left/right controller bits <> moving direction, branch
00AFC9  1  A9 00                    lda #$00                   ;otherwise set zero value here
00AFCB  1  8D 03 07     SetRunSpd:  sta RunningSpeed           ;store zero or running speed here
00AFCE  1  4C E3 AF                 jmp SetAnimSpd
00AFD1  1  AD 00 07     ProcSkid:   lda Player_XSpeedAbsolute  ;check player's walking/running speed
00AFD4  1  C9 0B                    cmp #$0b                   ;against one last amount
00AFD6  1  B0 0B                    bcs SetAnimSpd             ;if greater than this amount, branch
00AFD8  1  A5 33                    lda PlayerFacingDir
00AFDA  1  85 45                    sta Player_MovingDir       ;otherwise use facing direction to set moving direction
00AFDC  1  A9 00                    lda #$00
00AFDE  1  85 57                    sta Player_X_Speed         ;nullify player's horizontal speed
00AFE0  1  8D 05 07                 sta Player_X_MoveForce     ;and dummy variable for player
00AFE3  1  B9 AA AF     SetAnimSpd: lda PlayerAnimTmrData,y    ;get animation timer setting using Y as offset
00AFE6  1  8D 0C 07                 sta PlayerAnimTimerSet
00AFE9  1  60                       rts
00AFEA  1               
00AFEA  1               ;-------------------------------------------------------------------------------------
00AFEA  1               
00AFEA  1               ImposeFriction:
00AFEA  1  2D 90 04                and Player_CollisionBits  ;perform AND between left/right controller bits and collision flag
00AFED  1  C9 00                   cmp #$00                  ;then compare to zero (this instruction is redundant)
00AFEF  1  D0 08                   bne JoypFrict             ;if any bits set, branch to next part
00AFF1  1  A5 57                   lda Player_X_Speed
00AFF3  1  F0 49                   beq SetAbsSpd             ;if player has no horizontal speed, branch ahead to last part
00AFF5  1  10 23                   bpl RghtFrict             ;if player moving to the right, branch to slow
00AFF7  1  30 03                   bmi LeftFrict             ;otherwise logic dictates player moving left, branch to slow
00AFF9  1  4A           JoypFrict: lsr                       ;put right controller bit into carry
00AFFA  1  90 1E                   bcc RghtFrict             ;if left button pressed, carry = 0, thus branch
00AFFC  1  AD 05 07     LeftFrict: lda Player_X_MoveForce    ;load value set here
00AFFF  1  18                      clc
00B000  1  6D 02 07                adc FrictionAdderLow      ;add to it another value set here
00B003  1  8D 05 07                sta Player_X_MoveForce    ;store here
00B006  1  A5 57                   lda Player_X_Speed
00B008  1  6D 01 07                adc FrictionAdderHigh     ;add value plus carry to horizontal speed
00B00B  1  85 57                   sta Player_X_Speed        ;set as new horizontal speed
00B00D  1  CD 56 04                cmp MaximumRightSpeed     ;compare against maximum value for right movement
00B010  1  30 23                   bmi XSpdSign              ;if horizontal speed greater negatively, branch
00B012  1  AD 56 04                lda MaximumRightSpeed     ;otherwise set preset value as horizontal speed
00B015  1  85 57                   sta Player_X_Speed        ;thus slowing the player's left movement down
00B017  1  4C 3E B0                jmp SetAbsSpd             ;skip to the end
00B01A  1  AD 05 07     RghtFrict: lda Player_X_MoveForce    ;load value set here
00B01D  1  38                      sec
00B01E  1  ED 02 07                sbc FrictionAdderLow      ;subtract from it another value set here
00B021  1  8D 05 07                sta Player_X_MoveForce    ;store here
00B024  1  A5 57                   lda Player_X_Speed
00B026  1  ED 01 07                sbc FrictionAdderHigh     ;subtract value plus borrow from horizontal speed
00B029  1  85 57                   sta Player_X_Speed        ;set as new horizontal speed
00B02B  1  CD 50 04                cmp MaximumLeftSpeed      ;compare against maximum value for left movement
00B02E  1  10 05                   bpl XSpdSign              ;if horizontal speed greater positively, branch
00B030  1  AD 50 04                lda MaximumLeftSpeed      ;otherwise set preset value as horizontal speed
00B033  1  85 57                   sta Player_X_Speed        ;thus slowing the player's right movement down
00B035  1  C9 00        XSpdSign:  cmp #$00                  ;if player not moving or moving to the right,
00B037  1  10 05                   bpl SetAbsSpd             ;branch and leave horizontal speed value unmodified
00B039  1  49 FF                   eor #$ff
00B03B  1  18                      clc                       ;otherwise get two's compliment to get absolute
00B03C  1  69 01                   adc #$01                  ;unsigned walking/running speed
00B03E  1  8D 00 07     SetAbsSpd: sta Player_XSpeedAbsolute ;store walking/running speed here and leave
00B041  1  60                      rts
00B042  1               
00B042  1               ;-------------------------------------------------------------------------------------
00B042  1               ;$00 - used to store downward movement force in FireballObjCore
00B042  1               ;$02 - used to store maximum vertical speed in FireballObjCore
00B042  1               ;$07 - used to store pseudorandom bit in BubbleCheck
00B042  1               
00B042  1               ProcFireball_Bubble:
00B042  1  AD 56 07           lda PlayerStatus           ;check player's status
00B045  1  C9 02              cmp #$02
00B047  1  90 43              bcc ProcAirBubbles         ;if not fiery, branch
00B049  1  A5 0A              lda A_B_Buttons
00B04B  1  29 40              and #B_Button              ;check for b button pressed
00B04D  1  F0 33              beq ProcFireballs          ;branch if not pressed
00B04F  1  25 0D              and PreviousA_B_Buttons
00B051  1  D0 2F              bne ProcFireballs          ;if button pressed in previous frame, branch
00B053  1  AD CE 06           lda FireballCounter        ;load fireball counter
00B056  1  29 01              and #%00000001             ;get LSB and use as offset for buffer
00B058  1  AA                 tax
00B059  1  B5 24              lda Fireball_State,x       ;load fireball state
00B05B  1  D0 25              bne ProcFireballs          ;if not inactive, branch
00B05D  1  A4 B5              ldy Player_Y_HighPos       ;if player too high or too low, branch
00B05F  1  88                 dey
00B060  1  D0 20              bne ProcFireballs
00B062  1  AD 14 07           lda CrouchingFlag          ;if player crouching, branch
00B065  1  D0 1B              bne ProcFireballs
00B067  1  A5 1D              lda Player_State           ;if player's state = climbing, branch
00B069  1  C9 03              cmp #$03
00B06B  1  F0 15              beq ProcFireballs
00B06D  1  A9 20              lda #Sfx_Fireball          ;play fireball sound effect
00B06F  1  85 FF              sta Square1SoundQueue
00B071  1  A9 02              lda #$02                   ;load state
00B073  1  95 24              sta Fireball_State,x
00B075  1  AC 0C 07           ldy PlayerAnimTimerSet     ;copy animation frame timer setting
00B078  1  8C 11 07           sty FireballThrowingTimer  ;into fireball throwing timer
00B07B  1  88                 dey
00B07C  1  8C 81 07           sty PlayerAnimTimer        ;decrement and store in player's animation timer
00B07F  1  EE CE 06           inc FireballCounter        ;increment fireball counter
00B082  1               
00B082  1               ProcFireballs:
00B082  1  A2 00              ldx #$00
00B084  1  20 A7 B0           jsr FireballObjCore  ;process first fireball object
00B087  1  A2 01              ldx #$01
00B089  1  20 A7 B0           jsr FireballObjCore  ;process second fireball object, then do air bubbles
00B08C  1               
00B08C  1               ProcAirBubbles:
00B08C  1  AD 4E 07               lda AreaType                ;if not water type level, skip the rest of this
00B08F  1  D0 13                  bne BublExit
00B091  1  A2 02                  ldx #$02                    ;otherwise load counter and use as offset
00B093  1  86 08        BublLoop: stx ObjectOffset            ;store offset
00B095  1  20 17 B1               jsr BubbleCheck             ;check timers and coordinates, create air bubble
00B098  1  20 C9 EB               jsr RelativeBubblePosition  ;get relative coordinates
00B09B  1  20 29 EC               jsr GetBubbleOffscreenBits  ;get offscreen information
00B09E  1  20 99 E8               jsr DrawBubble              ;draw the air bubble
00B0A1  1  CA                     dex
00B0A2  1  10 EF                  bpl BublLoop                ;do this until all three are handled
00B0A4  1  60           BublExit: rts                         ;then leave
00B0A5  1               
00B0A5  1               FireballXSpdData:
00B0A5  1  40 C0              .byte $40, $c0
00B0A7  1               
00B0A7  1               FireballObjCore:
00B0A7  1  86 08                 stx ObjectOffset             ;store offset as current object
00B0A9  1  B5 24                 lda Fireball_State,x         ;check for d7 = 1
00B0AB  1  0A                    asl
00B0AC  1  B0 63                 bcs FireballExplosion        ;if so, branch to get relative coordinates and draw explosion
00B0AE  1  B4 24                 ldy Fireball_State,x         ;if fireball inactive, branch to leave
00B0B0  1  F0 5E                 beq NoFBall
00B0B2  1  88                    dey                          ;if fireball state set to 1, skip this part and just run it
00B0B3  1  F0 27                 beq RunFB
00B0B5  1  A5 86                 lda Player_X_Position        ;get player's horizontal position
00B0B7  1  69 04                 adc #$04                     ;add four pixels and store as fireball's horizontal position
00B0B9  1  95 8D                 sta Fireball_X_Position,x
00B0BB  1  A5 6D                 lda Player_PageLoc           ;get player's page location
00B0BD  1  69 00                 adc #$00                     ;add carry and store as fireball's page location
00B0BF  1  95 74                 sta Fireball_PageLoc,x
00B0C1  1  A5 CE                 lda Player_Y_Position        ;get player's vertical position and store
00B0C3  1  95 D5                 sta Fireball_Y_Position,x
00B0C5  1  A9 01                 lda #$01                     ;set high byte of vertical position
00B0C7  1  95 BC                 sta Fireball_Y_HighPos,x
00B0C9  1  A4 33                 ldy PlayerFacingDir          ;get player's facing direction
00B0CB  1  88                    dey                          ;decrement to use as offset here
00B0CC  1  B9 A5 B0              lda FireballXSpdData,y       ;set horizontal speed of fireball accordingly
00B0CF  1  95 5E                 sta Fireball_X_Speed,x
00B0D1  1  A9 04                 lda #$04                     ;set vertical speed of fireball
00B0D3  1  95 A6                 sta Fireball_Y_Speed,x
00B0D5  1  A9 07                 lda #$07
00B0D7  1  9D A0 04              sta Fireball_BoundBoxCtrl,x  ;set bounding box size control for fireball
00B0DA  1  D6 24                 dec Fireball_State,x         ;decrement state to 1 to skip this part from now on
00B0DC  1  8A           RunFB:   txa                          ;add 7 to offset to use
00B0DD  1  18                    clc                          ;as fireball offset for next routines
00B0DE  1  69 07                 adc #$07
00B0E0  1  AA                    tax
00B0E1  1  A9 50                 lda #$50                     ;set downward movement force here
00B0E3  1  85 00                 sta $00
00B0E5  1  A9 03                 lda #$03                     ;set maximum speed here
00B0E7  1  85 02                 sta $02
00B0E9  1  A9 00                 lda #$00
00B0EB  1  20 B9 BF              jsr ImposeGravity            ;do sub here to impose gravity on fireball and move vertically
00B0EE  1  20 F1 BE              jsr MoveObjectHorizontally   ;do another sub to move it horizontally
00B0F1  1  A6 08                 ldx ObjectOffset             ;return fireball offset to X
00B0F3  1  20 D3 EB              jsr RelativeFireballPosition ;get relative coordinates
00B0F6  1  20 1F EC              jsr GetFireballOffscreenBits ;get offscreen information
00B0F9  1  20 E5 DC              jsr GetFireballBoundBox      ;get bounding box coordinates
00B0FC  1  20 80 DC              jsr FireballBGCollision      ;do fireball to background collision detection
00B0FF  1  AD D2 03              lda FBall_OffscreenBits      ;get fireball offscreen bits
00B102  1  29 CC                 and #%11001100               ;mask out certain bits
00B104  1  D0 06                 bne EraseFB                  ;if any bits still set, branch to kill fireball
00B106  1  20 F4 D1              jsr FireballEnemyCollision   ;do fireball to enemy collision detection and deal with collisions
00B109  1  4C 96 E7              jmp DrawFireball             ;draw fireball appropriately and leave
00B10C  1  A9 00        EraseFB: lda #$00                     ;erase fireball state
00B10E  1  95 24                 sta Fireball_State,x
00B110  1  60           NoFBall: rts                          ;leave
00B111  1               
00B111  1               FireballExplosion:
00B111  1  20 D3 EB           jsr RelativeFireballPosition
00B114  1  4C C1 E7           jmp DrawExplosion_Fireball
00B117  1               
00B117  1               BubbleCheck:
00B117  1  BD A8 07           lda PseudoRandomBitReg+1,x  ;get part of LSFR
00B11A  1  29 01              and #$01
00B11C  1  85 07              sta $07                     ;store pseudorandom bit here
00B11E  1  B5 E4              lda Bubble_Y_Position,x     ;get vertical coordinate for air bubble
00B120  1  C9 F8              cmp #$f8                    ;if offscreen coordinate not set,
00B122  1  D0 2C              bne MoveBubl                ;branch to move air bubble
00B124  1  AD 92 07           lda AirBubbleTimer          ;if air bubble timer not expired,
00B127  1  D0 3F              bne ExitBubl                ;branch to leave, otherwise create new air bubble
00B129  1               
00B129  1               SetupBubble:
00B129  1  A0 00                  ldy #$00                 ;load default value here
00B12B  1  A5 33                  lda PlayerFacingDir      ;get player's facing direction
00B12D  1  4A                     lsr                      ;move d0 to carry
00B12E  1  90 02                  bcc PosBubl              ;branch to use default value if facing left
00B130  1  A0 08                  ldy #$08                 ;otherwise load alternate value here
00B132  1  98           PosBubl:  tya                      ;use value loaded as adder
00B133  1  65 86                  adc Player_X_Position    ;add to player's horizontal position
00B135  1  95 9C                  sta Bubble_X_Position,x  ;save as horizontal position for airbubble
00B137  1  A5 6D                  lda Player_PageLoc
00B139  1  69 00                  adc #$00                 ;add carry to player's page location
00B13B  1  95 83                  sta Bubble_PageLoc,x     ;save as page location for airbubble
00B13D  1  A5 CE                  lda Player_Y_Position
00B13F  1  18                     clc                      ;add eight pixels to player's vertical position
00B140  1  69 08                  adc #$08
00B142  1  95 E4                  sta Bubble_Y_Position,x  ;save as vertical position for air bubble
00B144  1  A9 01                  lda #$01
00B146  1  95 CB                  sta Bubble_Y_HighPos,x   ;set vertical high byte for air bubble
00B148  1  A4 07                  ldy $07                  ;get pseudorandom bit, use as offset
00B14A  1  B9 6B B1               lda BubbleTimerData,y    ;get data for air bubble timer
00B14D  1  8D 92 07               sta AirBubbleTimer       ;set air bubble timer
00B150  1  A4 07        MoveBubl: ldy $07                  ;get pseudorandom bit again, use as offset
00B152  1  BD 2C 04               lda Bubble_YMF_Dummy,x
00B155  1  38                     sec                      ;subtract pseudorandom amount from dummy variable
00B156  1  F9 69 B1               sbc Bubble_MForceData,y
00B159  1  9D 2C 04               sta Bubble_YMF_Dummy,x   ;save dummy variable
00B15C  1  B5 E4                  lda Bubble_Y_Position,x
00B15E  1  E9 00                  sbc #$00                 ;subtract borrow from airbubble's vertical coordinate
00B160  1  C9 20                  cmp #$20                 ;if below the status bar,
00B162  1  B0 02                  bcs Y_Bubl               ;branch to go ahead and use to move air bubble upwards
00B164  1  A9 F8                  lda #$f8                 ;otherwise set offscreen coordinate
00B166  1  95 E4        Y_Bubl:   sta Bubble_Y_Position,x  ;store as new vertical coordinate for air bubble
00B168  1  60           ExitBubl: rts                      ;leave
00B169  1               
00B169  1               Bubble_MForceData:
00B169  1  FF 50              .byte $ff, $50
00B16B  1               
00B16B  1               BubbleTimerData:
00B16B  1  40 20              .byte $40, $20
00B16D  1               
00B16D  1               ;-------------------------------------------------------------------------------------
00B16D  1               ;$00 - used in WhirlpoolActivate to store whirlpool length / 2, page location of center of whirlpool
00B16D  1               ;and also to store movement force exerted on player
00B16D  1               ;$01 - used in ProcessWhirlpools to store page location of right extent of whirlpool
00B16D  1               ;and in WhirlpoolActivate to store center of whirlpool
00B16D  1               ;$02 - used in ProcessWhirlpools to store right extent of whirlpool and in
00B16D  1               ;WhirlpoolActivate to store maximum vertical speed
00B16D  1               
00B16D  1               ProcessWhirlpools:
00B16D  1  AD 4E 07             lda AreaType                ;check for water type level
00B170  1  D0 37                bne ExitWh                  ;branch to leave if not found
00B172  1  8D 7D 04             sta Whirlpool_Flag          ;otherwise initialize whirlpool flag
00B175  1  AD 47 07             lda TimerControl            ;if master timer control set,
00B178  1  D0 2F                bne ExitWh                  ;branch to leave
00B17A  1  A0 04                ldy #$04                    ;otherwise start with last whirlpool data
00B17C  1  B9 71 04     WhLoop: lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
00B17F  1  18                   clc
00B180  1  79 77 04             adc Whirlpool_Length,y      ;add length of whirlpool
00B183  1  85 02                sta $02                     ;store result as right extent here
00B185  1  B9 6B 04             lda Whirlpool_PageLoc,y     ;get page location
00B188  1  F0 1C                beq NextWh                  ;if none or page 0, branch to get next data
00B18A  1  69 00                adc #$00                    ;add carry
00B18C  1  85 01                sta $01                     ;store result as page location of right extent here
00B18E  1  A5 86                lda Player_X_Position       ;get player's horizontal position
00B190  1  38                   sec
00B191  1  F9 71 04             sbc Whirlpool_LeftExtent,y  ;subtract left extent
00B194  1  A5 6D                lda Player_PageLoc          ;get player's page location
00B196  1  F9 6B 04             sbc Whirlpool_PageLoc,y     ;subtract borrow
00B199  1  30 0B                bmi NextWh                  ;if player too far left, branch to get next data
00B19B  1  A5 02                lda $02                     ;otherwise get right extent
00B19D  1  38                   sec
00B19E  1  E5 86                sbc Player_X_Position       ;subtract player's horizontal coordinate
00B1A0  1  A5 01                lda $01                     ;get right extent's page location
00B1A2  1  E5 6D                sbc Player_PageLoc          ;subtract borrow
00B1A4  1  10 04                bpl WhirlpoolActivate       ;if player within right extent, branch to whirlpool code
00B1A6  1  88           NextWh: dey                         ;move onto next whirlpool data
00B1A7  1  10 D3                bpl WhLoop                  ;do this until all whirlpools are checked
00B1A9  1  60           ExitWh: rts                         ;leave
00B1AA  1               
00B1AA  1               WhirlpoolActivate:
00B1AA  1  B9 77 04             lda Whirlpool_Length,y      ;get length of whirlpool
00B1AD  1  4A                   lsr                         ;divide by 2
00B1AE  1  85 00                sta $00                     ;save here
00B1B0  1  B9 71 04             lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
00B1B3  1  18                   clc
00B1B4  1  65 00                adc $00                     ;add length divided by 2
00B1B6  1  85 01                sta $01                     ;save as center of whirlpool
00B1B8  1  B9 6B 04             lda Whirlpool_PageLoc,y     ;get page location
00B1BB  1  69 00                adc #$00                    ;add carry
00B1BD  1  85 00                sta $00                     ;save as page location of whirlpool center
00B1BF  1  A5 09                lda FrameCounter            ;get frame counter
00B1C1  1  4A                   lsr                         ;shift d0 into carry (to run on every other frame)
00B1C2  1  90 2C                bcc WhPull                  ;if d0 not set, branch to last part of code
00B1C4  1  A5 01                lda $01                     ;get center
00B1C6  1  38                   sec
00B1C7  1  E5 86                sbc Player_X_Position       ;subtract player's horizontal coordinate
00B1C9  1  A5 00                lda $00                     ;get page location of center
00B1CB  1  E5 6D                sbc Player_PageLoc          ;subtract borrow
00B1CD  1  10 0E                bpl LeftWh                  ;if player to the left of center, branch
00B1CF  1  A5 86                lda Player_X_Position       ;otherwise slowly pull player left, towards the center
00B1D1  1  38                   sec
00B1D2  1  E9 01                sbc #$01                    ;subtract one pixel
00B1D4  1  85 86                sta Player_X_Position       ;set player's new horizontal coordinate
00B1D6  1  A5 6D                lda Player_PageLoc
00B1D8  1  E9 00                sbc #$00                    ;subtract borrow
00B1DA  1  4C EE B1             jmp SetPWh                  ;jump to set player's new page location
00B1DD  1  AD 90 04     LeftWh: lda Player_CollisionBits    ;get player's collision bits
00B1E0  1  4A                   lsr                         ;shift d0 into carry
00B1E1  1  90 0D                bcc WhPull                  ;if d0 not set, branch
00B1E3  1  A5 86                lda Player_X_Position       ;otherwise slowly pull player right, towards the center
00B1E5  1  18                   clc
00B1E6  1  69 01                adc #$01                    ;add one pixel
00B1E8  1  85 86                sta Player_X_Position       ;set player's new horizontal coordinate
00B1EA  1  A5 6D                lda Player_PageLoc
00B1EC  1  69 00                adc #$00                    ;add carry
00B1EE  1  85 6D        SetPWh: sta Player_PageLoc          ;set player's new page location
00B1F0  1  A9 10        WhPull: lda #$10
00B1F2  1  85 00                sta $00                     ;set vertical movement force
00B1F4  1  A9 01                lda #$01
00B1F6  1  8D 7D 04             sta Whirlpool_Flag          ;set whirlpool flag to be used later
00B1F9  1  85 02                sta $02                     ;also set maximum vertical speed
00B1FB  1  4A                   lsr
00B1FC  1  AA                   tax                         ;set X for player offset
00B1FD  1  4C B9 BF             jmp ImposeGravity           ;jump to put whirlpool effect on player vertically, do not return
00B200  1               
00B200  1               ;-------------------------------------------------------------------------------------
00B200  1               
00B200  1               FlagpoleScoreMods:
00B200  1  05 02 08 04        .byte $05, $02, $08, $04, $01
00B204  1  01           
00B205  1               
00B205  1               FlagpoleScoreDigits:
00B205  1  03 03 04 04        .byte $03, $03, $04, $04, $04
00B209  1  04           
00B20A  1               
00B20A  1               FlagpoleRoutine:
00B20A  1  A2 05                   ldx #$05                  ;set enemy object offset
00B20C  1  86 08                   stx ObjectOffset          ;to special use slot
00B20E  1  B5 16                   lda Enemy_ID,x
00B210  1  C9 30                   cmp #FlagpoleFlagObject   ;if flagpole flag not found,
00B212  1  D0 56                   bne ExitFlagP             ;branch to leave
00B214  1  A5 0E                   lda GameEngineSubroutine
00B216  1  C9 04                   cmp #$04                  ;if flagpole slide routine not running,
00B218  1  D0 31                   bne SkipScore             ;branch to near the end of code
00B21A  1  A5 1D                   lda Player_State
00B21C  1  C9 03                   cmp #$03                  ;if player state not climbing,
00B21E  1  D0 2B                   bne SkipScore             ;branch to near the end of code
00B220  1  B5 CF                   lda Enemy_Y_Position,x    ;check flagpole flag's vertical coordinate
00B222  1  C9 AA                   cmp #$aa                  ;if flagpole flag down to a certain point,
00B224  1  B0 28                   bcs GiveFPScr             ;branch to end the level
00B226  1  A5 CE                   lda Player_Y_Position     ;check player's vertical coordinate
00B228  1  C9 A2                   cmp #$a2                  ;if player down to a certain point,
00B22A  1  B0 22                   bcs GiveFPScr             ;branch to end the level
00B22C  1  BD 17 04                lda Enemy_YMF_Dummy,x
00B22F  1  69 FF                   adc #$ff                  ;add movement amount to dummy variable
00B231  1  9D 17 04                sta Enemy_YMF_Dummy,x     ;save dummy variable
00B234  1  B5 CF                   lda Enemy_Y_Position,x    ;get flag's vertical coordinate
00B236  1  69 01                   adc #$01                  ;add 1 plus carry to move flag, and
00B238  1  95 CF                   sta Enemy_Y_Position,x    ;store vertical coordinate
00B23A  1  AD 0E 01                lda FlagpoleFNum_YMFDummy
00B23D  1  38                      sec                       ;subtract movement amount from dummy variable
00B23E  1  E9 FF                   sbc #$ff
00B240  1  8D 0E 01                sta FlagpoleFNum_YMFDummy ;save dummy variable
00B243  1  AD 0D 01                lda FlagpoleFNum_Y_Pos
00B246  1  E9 01                   sbc #$01                  ;subtract one plus borrow to move floatey number,
00B248  1  8D 0D 01                sta FlagpoleFNum_Y_Pos    ;and store vertical coordinate here
00B24B  1  4C 61 B2     SkipScore: jmp FPGfx                 ;jump to skip ahead and draw flag and floatey number
00B24E  1  AC 0F 01     GiveFPScr: ldy FlagpoleScore         ;get score offset from earlier (when player touched flagpole)
00B251  1  B9 00 B2                lda FlagpoleScoreMods,y   ;get amount to award player points
00B254  1  BE 05 B2                ldx FlagpoleScoreDigits,y ;get digit with which to award points
00B257  1  9D 34 01                sta DigitModifier,x       ;store in digit modifier
00B25A  1  20 11 B4                jsr AddToScore        ;do sub to award player points depending on height of collision
00B25D  1  A9 05                   lda #$05
00B25F  1  85 0E                   sta GameEngineSubroutine  ;set to run end-of-level subroutine on next frame
00B261  1  20 47 EC     FPGfx:     jsr GetEnemyOffscreenBits ;get offscreen information
00B264  1  20 EA EB                jsr RelativeEnemyPosition ;get relative coordinates
00B267  1  20 03 E0                jsr FlagpoleGfxHandler    ;draw flagpole flag and floatey number
00B26A  1  60           ExitFlagP: rts
00B26B  1               
00B26B  1               ;-------------------------------------------------------------------------------------
00B26B  1               
00B26B  1               CannonBitmasks:
00B26B  1  0F 07              .byte %00001111, %00000111
00B26D  1               
00B26D  1               ProcessCannons:
00B26D  1  AD 4E 07                lda AreaType                ;get area type
00B270  1  F0 6F                   beq ExCannon                ;if water type area, branch to leave
00B272  1  A2 02                   ldx #$02
00B274  1  86 08        ThreeSChk: stx ObjectOffset            ;start at third enemy slot
00B276  1  B5 0F                   lda Enemy_Flag,x            ;check enemy buffer flag
00B278  1  D0 51                   bne Chk_BB                  ;if set, branch to check enemy
00B27A  1  BD A8 07                lda PseudoRandomBitReg+1,x  ;otherwise get part of LSFR
00B27D  1  AC CC 06                ldy SecondaryHardMode       ;get secondary hard mode flag, use as offset
00B280  1  39 6B B2                and CannonBitmasks,y        ;mask out bits of LSFR as decided by flag
00B283  1  C9 06                   cmp #$06                    ;check to see if lower nybble is above certain value
00B285  1  B0 44                   bcs Chk_BB                  ;if so, branch to check enemy
00B287  1  A8                      tay                         ;transfer masked contents of LSFR to Y as pseudorandom offset
00B288  1  B9 6B 04                lda Cannon_PageLoc,y        ;get page location
00B28B  1  F0 3E                   beq Chk_BB                  ;if not set or on page 0, branch to check enemy
00B28D  1  B9 7D 04                lda Cannon_Timer,y          ;get cannon timer
00B290  1  F0 08                   beq FireCannon              ;if expired, branch to fire cannon
00B292  1  E9 00                   sbc #$00                    ;otherwise subtract borrow (note carry will always be clear here)
00B294  1  99 7D 04                sta Cannon_Timer,y          ;to count timer down
00B297  1  4C CB B2                jmp Chk_BB                  ;then jump ahead to check enemy
00B29A  1               
00B29A  1               FireCannon:
00B29A  1  AD 47 07               lda TimerControl           ;if master timer control set,
00B29D  1  D0 2C                  bne Chk_BB                 ;branch to check enemy
00B29F  1  A9 0E                  lda #$0e                   ;otherwise we start creating one
00B2A1  1  99 7D 04               sta Cannon_Timer,y         ;first, reset cannon timer
00B2A4  1  B9 6B 04               lda Cannon_PageLoc,y       ;get page location of cannon
00B2A7  1  95 6E                  sta Enemy_PageLoc,x        ;save as page location of bullet bill
00B2A9  1  B9 71 04               lda Cannon_X_Position,y    ;get horizontal coordinate of cannon
00B2AC  1  95 87                  sta Enemy_X_Position,x     ;save as horizontal coordinate of bullet bill
00B2AE  1  B9 77 04               lda Cannon_Y_Position,y    ;get vertical coordinate of cannon
00B2B1  1  38                     sec
00B2B2  1  E9 08                  sbc #$08                   ;subtract eight pixels (because enemies are 24 pixels tall)
00B2B4  1  95 CF                  sta Enemy_Y_Position,x     ;save as vertical coordinate of bullet bill
00B2B6  1  A9 01                  lda #$01
00B2B8  1  95 B6                  sta Enemy_Y_HighPos,x      ;set vertical high byte of bullet bill
00B2BA  1  95 0F                  sta Enemy_Flag,x           ;set buffer flag
00B2BC  1  4A                     lsr                        ;shift right once to init A
00B2BD  1  95 1E                  sta Enemy_State,x          ;then initialize enemy's state
00B2BF  1  A9 09                  lda #$09
00B2C1  1  9D 9A 04               sta Enemy_BoundBoxCtrl,x   ;set bounding box size control for bullet bill
00B2C4  1  A9 33                  lda #BulletBill_CannonVar
00B2C6  1  95 16                  sta Enemy_ID,x             ;load identifier for bullet bill (cannon variant)
00B2C8  1  4C DE B2               jmp Next3Slt               ;move onto next slot
00B2CB  1  B5 16        Chk_BB:   lda Enemy_ID,x             ;check enemy identifier for bullet bill (cannon variant)
00B2CD  1  C9 33                  cmp #BulletBill_CannonVar
00B2CF  1  D0 0D                  bne Next3Slt               ;if not found, branch to get next slot
00B2D1  1  20 95 D1               jsr OffscreenBoundsCheck   ;otherwise, check to see if it went offscreen
00B2D4  1  B5 0F                  lda Enemy_Flag,x           ;check enemy buffer flag
00B2D6  1  F0 06                  beq Next3Slt               ;if not set, branch to get next slot
00B2D8  1  20 47 EC               jsr GetEnemyOffscreenBits  ;otherwise, get offscreen information
00B2DB  1  20 E4 B2               jsr BulletBillHandler      ;then do sub to handle bullet bill
00B2DE  1  CA           Next3Slt: dex                        ;move onto next slot
00B2DF  1  10 93                  bpl ThreeSChk              ;do this until first three slots are checked
00B2E1  1  60           ExCannon: rts                        ;then leave
00B2E2  1               
00B2E2  1               ;--------------------------------
00B2E2  1               
00B2E2  1               BulletBillXSpdData:
00B2E2  1  18 E8              .byte $18, $e8
00B2E4  1               
00B2E4  1               BulletBillHandler:
00B2E4  1  AD 47 07                lda TimerControl          ;if master timer control set,
00B2E7  1  D0 3E                   bne RunBBSubs             ;branch to run subroutines except movement sub
00B2E9  1  B5 1E                   lda Enemy_State,x
00B2EB  1  D0 2E                   bne ChkDSte               ;if bullet bill's state set, branch to check defeated state
00B2ED  1  AD D1 03                lda Enemy_OffscreenBits   ;otherwise load offscreen bits
00B2F0  1  29 0C                   and #%00001100            ;mask out bits
00B2F2  1  C9 0C                   cmp #%00001100            ;check to see if all bits are set
00B2F4  1  F0 40                   beq KillBB                ;if so, branch to kill this object
00B2F6  1  A0 01                   ldy #$01                  ;set to move right by default
00B2F8  1  20 FB DB                jsr PlayerEnemyDiff       ;get horizontal difference between player and bullet bill
00B2FB  1  30 01                   bmi SetupBB               ;if enemy to the left of player, branch
00B2FD  1  C8                      iny                       ;otherwise increment to move left
00B2FE  1  94 46        SetupBB:   sty Enemy_MovingDir,x     ;set bullet bill's moving direction
00B300  1  88                      dey                       ;decrement to use as offset
00B301  1  B9 E2 B2                lda BulletBillXSpdData,y  ;get horizontal speed based on moving direction
00B304  1  95 58                   sta Enemy_X_Speed,x       ;and store it
00B306  1  A5 00                   lda $00                   ;get horizontal difference
00B308  1  69 28                   adc #$28                  ;add 40 pixels
00B30A  1  C9 50                   cmp #$50                  ;if less than a certain amount, player is too close
00B30C  1  90 28                   bcc KillBB                ;to cannon either on left or right side, thus branch
00B30E  1  A9 01                   lda #$01
00B310  1  95 1E                   sta Enemy_State,x         ;otherwise set bullet bill's state
00B312  1  A9 0A                   lda #$0a
00B314  1  9D 8A 07                sta EnemyFrameTimer,x     ;set enemy frame timer
00B317  1  A9 08                   lda #Sfx_Blast
00B319  1  85 FE                   sta Square2SoundQueue     ;play fireworks/gunfire sound
00B31B  1  B5 1E        ChkDSte:   lda Enemy_State,x         ;check enemy state for d5 set
00B31D  1  29 20                   and #%00100000
00B31F  1  F0 03                   beq BBFly                 ;if not set, skip to move horizontally
00B321  1  20 45 BF                jsr MoveD_EnemyVertically ;otherwise do sub to move bullet bill vertically
00B324  1  20 E4 BE     BBFly:     jsr MoveEnemyHorizontally ;do sub to move bullet bill horizontally
00B327  1  20 47 EC     RunBBSubs: jsr GetEnemyOffscreenBits ;get offscreen information
00B32A  1  20 EA EB                jsr RelativeEnemyPosition ;get relative coordinates
00B32D  1  20 FB DC                jsr GetEnemyBoundBox      ;get bounding box coordinates
00B330  1  20 6E D3                jsr PlayerEnemyCollision  ;handle player to enemy collisions
00B333  1  4C 35 E3                jmp EnemyGfxHandler       ;draw the bullet bill and leave
00B336  1  20 CE C5     KillBB:    jsr EraseEnemyObject      ;kill bullet bill and leave
00B339  1  60                      rts
00B33A  1               
00B33A  1               ;--------------------------------
00B33A  1               ;$00 - used to set downward force
00B33A  1               ;$01 - used to set upward force (residual)
00B33A  1               ;$02 - used to set maximum speed
00B33A  1               
00B33A  1               ProcHammerObj:
00B33A  1  AD 47 07               lda TimerControl           ;if master timer control set
00B33D  1  D0 63                  bne RunHSubs               ;skip all of this code and go to last subs at the end
00B33F  1  B5 2A                  lda Misc_State,x           ;otherwise get hammer's state
00B341  1  29 7F                  and #%01111111             ;mask out d7
00B343  1  BC AE 06               ldy HammerEnemyOffset,x    ;get enemy object offset that spawned this hammer
00B346  1  C9 02                  cmp #$02                   ;check hammer's state
00B348  1  F0 20                  beq SetHSpd                ;if currently at 2, branch
00B34A  1  B0 34                  bcs SetHPos                ;if greater than 2, branch elsewhere
00B34C  1  8A                     txa
00B34D  1  18                     clc                        ;add 13 bytes to use
00B34E  1  69 0D                  adc #$0d                   ;proper misc object
00B350  1  AA                     tax                        ;return offset to X
00B351  1  A9 10                  lda #$10
00B353  1  85 00                  sta $00                    ;set downward movement force
00B355  1  A9 0F                  lda #$0f
00B357  1  85 01                  sta $01                    ;set upward movement force (not used)
00B359  1  A9 04                  lda #$04
00B35B  1  85 02                  sta $02                    ;set maximum vertical speed
00B35D  1  A9 00                  lda #$00                   ;set A to impose gravity on hammer
00B35F  1  20 B9 BF               jsr ImposeGravity          ;do sub to impose gravity on hammer and move vertically
00B362  1  20 F1 BE               jsr MoveObjectHorizontally ;do sub to move it horizontally
00B365  1  A6 08                  ldx ObjectOffset           ;get original misc object offset
00B367  1  4C 9F B3               jmp RunAllH                ;branch to essential subroutines
00B36A  1  A9 FE        SetHSpd:  lda #$fe
00B36C  1  95 AC                  sta Misc_Y_Speed,x         ;set hammer's vertical speed
00B36E  1  B9 1E 00               lda Enemy_State,y          ;get enemy object state
00B371  1  29 F7                  and #%11110111             ;mask out d3
00B373  1  99 1E 00               sta Enemy_State,y          ;store new state
00B376  1  B6 46                  ldx Enemy_MovingDir,y      ;get enemy's moving direction
00B378  1  CA                     dex                        ;decrement to use as offset
00B379  1  BD 5F F0               lda HammerXSpdData,x       ;get proper speed to use based on moving direction
00B37C  1  A6 08                  ldx ObjectOffset           ;reobtain hammer's buffer offset
00B37E  1  95 64                  sta Misc_X_Speed,x         ;set hammer's horizontal speed
00B380  1  D6 2A        SetHPos:  dec Misc_State,x           ;decrement hammer's state
00B382  1  B9 87 00               lda Enemy_X_Position,y     ;get enemy's horizontal position
00B385  1  18                     clc
00B386  1  69 02                  adc #$02                   ;set position 2 pixels to the right
00B388  1  95 93                  sta Misc_X_Position,x      ;store as hammer's horizontal position
00B38A  1  B9 6E 00               lda Enemy_PageLoc,y        ;get enemy's page location
00B38D  1  69 00                  adc #$00                   ;add carry
00B38F  1  95 7A                  sta Misc_PageLoc,x         ;store as hammer's page location
00B391  1  B9 CF 00               lda Enemy_Y_Position,y     ;get enemy's vertical position
00B394  1  38                     sec
00B395  1  E9 0A                  sbc #$0a                   ;move position 10 pixels upward
00B397  1  95 DB                  sta Misc_Y_Position,x      ;store as hammer's vertical position
00B399  1  A9 01                  lda #$01
00B39B  1  95 C2                  sta Misc_Y_HighPos,x       ;set hammer's vertical high byte
00B39D  1  D0 03                  bne RunHSubs               ;unconditional branch to skip first routine
00B39F  1  20 DF D2     RunAllH:  jsr PlayerHammerCollision  ;handle collisions
00B3A2  1  20 33 EC     RunHSubs: jsr GetMiscOffscreenBits   ;get offscreen information
00B3A5  1  20 E0 EB               jsr RelativeMiscPosition   ;get relative coordinates
00B3A8  1  20 EE DC               jsr GetMiscBoundBox        ;get bounding box coordinates
00B3AB  1  20 94 DF               jsr DrawHammer             ;draw the hammer
00B3AE  1  60                     rts                        ;and we are done here
00B3AF  1               
00B3AF  1               ;-------------------------------------------------------------------------------------
00B3AF  1               
00B3AF  1               MiscObjectsCore:
00B3AF  1  A2 08                  ldx #$08          ;set at end of misc object buffer
00B3B1  1  86 08        MiscLoop: stx ObjectOffset  ;store misc object offset here
00B3B3  1  B5 2A                  lda Misc_State,x  ;check misc object state
00B3B5  1  F0 56                  beq MiscLoopBack  ;branch to check next slot
00B3B7  1  0A                     asl               ;otherwise shift d7 into carry
00B3B8  1  90 06                  bcc ProcJumpCoin  ;if d7 not set, jumping coin, thus skip to rest of code here
00B3BA  1  20 3A B3               jsr ProcHammerObj ;otherwise go to process hammer,
00B3BD  1  4C 0D B4               jmp MiscLoopBack  ;then check next slot
00B3C0  1               
00B3C0  1               ;--------------------------------
00B3C0  1               ;$00 - used to set downward force
00B3C0  1               ;$01 - used to set upward force (residual)
00B3C0  1               ;$02 - used to set maximum speed
00B3C0  1               
00B3C0  1               ProcJumpCoin:
00B3C0  1  B4 2A                   ldy Misc_State,x          ;check misc object state
00B3C2  1  88                      dey                       ;decrement to see if it's set to 1
00B3C3  1  F0 1D                   beq JCoinRun              ;if so, branch to handle jumping coin
00B3C5  1  F6 2A                   inc Misc_State,x          ;otherwise increment state to either start off or as timer
00B3C7  1  B5 93                   lda Misc_X_Position,x     ;get horizontal coordinate for misc object
00B3C9  1  18                      clc                       ;whether its jumping coin (state 0 only) or floatey number
00B3CA  1  6D 75 07                adc ScrollAmount          ;add current scroll speed
00B3CD  1  95 93                   sta Misc_X_Position,x     ;store as new horizontal coordinate
00B3CF  1  B5 7A                   lda Misc_PageLoc,x        ;get page location
00B3D1  1  69 00                   adc #$00                  ;add carry
00B3D3  1  95 7A                   sta Misc_PageLoc,x        ;store as new page location
00B3D5  1  B5 2A                   lda Misc_State,x
00B3D7  1  C9 30                   cmp #$30                  ;check state of object for preset value
00B3D9  1  D0 26                   bne RunJCSubs             ;if not yet reached, branch to subroutines
00B3DB  1  A9 00                   lda #$00
00B3DD  1  95 2A                   sta Misc_State,x          ;otherwise nullify object state
00B3DF  1  4C 0D B4                jmp MiscLoopBack          ;and move onto next slot
00B3E2  1  8A           JCoinRun:  txa
00B3E3  1  18                      clc                       ;add 13 bytes to offset for next subroutine
00B3E4  1  69 0D                   adc #$0d
00B3E6  1  AA                      tax
00B3E7  1  A9 50                   lda #$50                  ;set downward movement amount
00B3E9  1  85 00                   sta $00
00B3EB  1  A9 06                   lda #$06                  ;set maximum vertical speed
00B3ED  1  85 02                   sta $02
00B3EF  1  4A                      lsr                       ;divide by 2 and set
00B3F0  1  85 01                   sta $01                   ;as upward movement amount (apparently residual)
00B3F2  1  A9 00                   lda #$00                  ;set A to impose gravity on jumping coin
00B3F4  1  20 B9 BF                jsr ImposeGravity         ;do sub to move coin vertically and impose gravity on it
00B3F7  1  A6 08                   ldx ObjectOffset          ;get original misc object offset
00B3F9  1  B5 AC                   lda Misc_Y_Speed,x        ;check vertical speed
00B3FB  1  C9 05                   cmp #$05
00B3FD  1  D0 02                   bne RunJCSubs             ;if not moving downward fast enough, keep state as-is
00B3FF  1  F6 2A                   inc Misc_State,x          ;otherwise increment state to change to floatey number
00B401  1  20 E0 EB     RunJCSubs: jsr RelativeMiscPosition  ;get relative coordinates
00B404  1  20 33 EC                jsr GetMiscOffscreenBits  ;get offscreen information
00B407  1  20 EE DC                jsr GetMiscBoundBox       ;get bounding box coordinates (why?)
00B40A  1  20 3E E1                jsr JCoinGfxHandler       ;draw the coin or floatey number
00B40D  1               
00B40D  1               MiscLoopBack:
00B40D  1  CA                      dex                       ;decrement misc object offset
00B40E  1  10 A1                   bpl MiscLoop              ;loop back until all misc objects handled
00B410  1  60                      rts                       ;then leave
00B411  1               
00B411  1               ;-------------------------------------------------------------------------------------
00B411  1               
00B411  1               GiveOneCoin:
00B411  1               CoinPoints:
00B411  1               AddToScore:
00B411  1               GetSBNybbles:
00B411  1               UpdateNumber:
00B411  1  A6 08        NoZSup: ldx ObjectOffset          ;get enemy object buffer offset
00B413  1  60                   rts
00B414  1               
00B414  1               EnemyAddrHOffsets:
00B414  1  1F 06 1C 00        .byte $1f, $06, $1c, $00
00B418  1               
00B418  1               GetAreaDataAddrs:
00B418  1  AD 50 07                 lda AreaPointer          ;use 2 MSB for Y
00B41B  1  20 D4 BB                 jsr GetAreaType
00B41E  1  A8                       tay
00B41F  1  AD 50 07                 lda AreaPointer          ;mask out all but 5 LSB
00B422  1  29 1F                    and #%00011111
00B424  1  8D 4F 07                 sta AreaAddrsLOffset     ;save as low offset
00B427  1  B9 14 B4                 lda EnemyAddrHOffsets,y  ;load base value with 2 altered MSB,
00B42A  1  18                       clc                      ;then add base value to 5 LSB, result
00B42B  1  6D 4F 07                 adc AreaAddrsLOffset     ;becomes offset for level data
00B42E  1  A8                       tay
00B42F  1  B9 80 96                 lda EnemyDataAddrLow,y   ;use offset to load pointer
00B432  1  85 E9                    sta EnemyDataLow
00B434  1  B9 A2 96                 lda EnemyDataAddrHigh,y
00B437  1  85 EA                    sta EnemyDataHigh
00B439  1  AC 4E 07                 ldy AreaType             ;use area type as offset
00B43C  1  B9 C4 96                 lda AreaDataHOffsets,y   ;do the same thing but with different base value
00B43F  1  18                       clc
00B440  1  6D 4F 07                 adc AreaAddrsLOffset
00B443  1  A8                       tay
00B444  1  B9 C8 96                 lda AreaDataAddrLow,y    ;use this offset to load another pointer
00B447  1  85 E7                    sta AreaDataLow
00B449  1  B9 EA 96                 lda AreaDataAddrHigh,y
00B44C  1  85 E8                    sta AreaDataHigh
00B44E  1  A0 00                    ldy #$00                 ;load first byte of header
00B450  1  B1 E7                    lda (AreaData),y
00B452  1  48                       pha                      ;save it to the stack for now
00B453  1  29 07                    and #%00000111           ;save 3 LSB for foreground scenery or bg color control
00B455  1  C9 04                    cmp #$04
00B457  1  90 05                    bcc StoreFore
00B459  1  8D 44 07                 sta BackgroundColorCtrl  ;if 4 or greater, save value here as bg color control
00B45C  1  A9 00                    lda #$00
00B45E  1  8D 41 07     StoreFore:  sta ForegroundScenery    ;if less, save value here as foreground scenery
00B461  1  68                       pla                      ;pull byte from stack and push it back
00B462  1  48                       pha
00B463  1  29 38                    and #%00111000           ;save player entrance control bits
00B465  1  4A                       lsr                      ;shift bits over to LSBs
00B466  1  4A                       lsr
00B467  1  4A                       lsr
00B468  1  8D 10 07                 sta PlayerEntranceCtrl       ;save value here as player entrance control
00B46B  1  68                       pla                      ;pull byte again but do not push it back
00B46C  1  29 C0                    and #%11000000           ;save 2 MSB for game timer setting
00B46E  1  18                       clc
00B46F  1  2A                       rol                      ;rotate bits over to LSBs
00B470  1  2A                       rol
00B471  1  2A                       rol
00B472  1  8D 15 07                 sta GameTimerSetting     ;save value here as game timer setting
00B475  1  C8                       iny
00B476  1  B1 E7                    lda (AreaData),y         ;load second byte of header
00B478  1  48                       pha                      ;save to stack
00B479  1  29 0F                    and #%00001111           ;mask out all but lower nybble
00B47B  1  8D 27 07                 sta TerrainControl
00B47E  1  68                       pla                      ;pull and push byte to copy it to A
00B47F  1  48                       pha
00B480  1  29 30                    and #%00110000           ;save 2 MSB for background scenery type
00B482  1  4A                       lsr
00B483  1  4A                       lsr                      ;shift bits to LSBs
00B484  1  4A                       lsr
00B485  1  4A                       lsr
00B486  1  8D 42 07                 sta BackgroundScenery    ;save as background scenery
00B489  1  68                       pla
00B48A  1  29 C0                    and #%11000000
00B48C  1  18                       clc
00B48D  1  2A                       rol                      ;rotate bits over to LSBs
00B48E  1  2A                       rol
00B48F  1  2A                       rol
00B490  1  C9 03                    cmp #%00000011           ;if set to 3, store here
00B492  1  D0 05                    bne StoreStyle           ;and nullify other value
00B494  1  8D 43 07                 sta CloudTypeOverride    ;otherwise store value in other place
00B497  1  A9 00                    lda #$00
00B499  1  8D 33 07     StoreStyle: sta AreaStyle
00B49C  1  A5 E7                    lda AreaDataLow          ;increment area data address by 2 bytes
00B49E  1  18                       clc
00B49F  1  69 02                    adc #$02
00B4A1  1  85 E7                    sta AreaDataLow
00B4A3  1  A5 E8                    lda AreaDataHigh
00B4A5  1  69 00                    adc #$00
00B4A7  1  85 E8                    sta AreaDataHigh
00B4A9  1  60                       rts
00B4AA  1               
00B4AA  1               WarpZoneNumbers:
00B4AA  1  04 03 02 00    .byte $04, $03, $02, $00         ; warp zone numbers, note spaces on middle
00B4AE  1  24 05 24 00    .byte $24, $05, $24, $00         ; zone, partly responsible for
00B4B2  1  08 07 06 00    .byte $08, $07, $06, $00         ; the minus world
00B4B6  1               
00B4B6  1               HandlePipeEntry:
00B4B6  1  A5 0B                 lda Up_Down_Buttons       ;check saved controller bits from earlier
00B4B8  1  29 04                 and #%00000100            ;for pressing down
00B4BA  1  F0 5C                 beq ExPipeE               ;if not pressing down, branch to leave
00B4BC  1  A5 00                 lda $00
00B4BE  1  C9 11                 cmp #$11                  ;check right foot metatile for warp pipe right metatile
00B4C0  1  D0 56                 bne ExPipeE               ;branch to leave if not found
00B4C2  1  A5 01                 lda $01
00B4C4  1  C9 10                 cmp #$10                  ;check left foot metatile for warp pipe left metatile
00B4C6  1  D0 50                 bne ExPipeE               ;branch to leave if not found
00B4C8  1  A9 30                 lda #$30
00B4CA  1  8D DE 06              sta ChangeAreaTimer       ;set timer for change of area
00B4CD  1  A9 03                 lda #$03
00B4CF  1  85 0E                 sta GameEngineSubroutine  ;set to run vertical pipe entry routine on next frame
00B4D1  1  A9 10                 lda #Sfx_PipeDown_Injury
00B4D3  1  85 FF                 sta Square1SoundQueue     ;load pipedown/injury sound
00B4D5  1  A9 20                 lda #%00100000
00B4D7  1  8D C4 03              sta Player_SprAttrib      ;set background priority bit in player's attributes
00B4DA  1  AD D6 06              lda WarpZoneControl       ;check warp zone control
00B4DD  1  F0 39                 beq ExPipeE               ;branch to leave if none found
00B4DF  1  29 03                 and #%00000011            ;mask out all but 2 LSB
00B4E1  1  0A                    asl
00B4E2  1  0A                    asl                       ;multiply by four
00B4E3  1  AA                    tax                       ;save as offset to warp zone numbers (starts at left pipe)
00B4E4  1  A5 86                 lda Player_X_Position     ;get player's horizontal position
00B4E6  1  C9 60                 cmp #$60
00B4E8  1  90 06                 bcc GetWNum               ;if player at left, not near middle, use offset and skip ahead
00B4EA  1  E8                    inx                       ;otherwise increment for middle pipe
00B4EB  1  C9 A0                 cmp #$a0
00B4ED  1  90 01                 bcc GetWNum               ;if player at middle, but not too far right, use offset and skip
00B4EF  1  E8                    inx                       ;otherwise increment for last pipe
00B4F0  1  BC AA B4     GetWNum: ldy WarpZoneNumbers,x     ;get warp zone numbers
00B4F3  1  88                    dey                       ;decrement for use as world number
00B4F4  1  8C 5F 07              sty WorldNumber           ;store as world number and offset
00B4F7  1  BE ED BB              ldx WorldAddrOffsets,y    ;get offset to where this world's area offsets are
00B4FA  1  BD F5 BB              lda AreaAddrOffsets,x     ;get area offset based on world offset
00B4FD  1  8D 50 07              sta AreaPointer           ;store area offset here to be used to change areas
00B500  1  A9 80                 lda #Silence
00B502  1  85 FC                 sta EventMusicQueue       ;silence music
00B504  1  A9 00                 lda #$00
00B506  1  8D 51 07              sta EntrancePage          ;initialize starting page number
00B509  1  8D 60 07              sta AreaNumber            ;initialize area number used for area address offset
00B50C  1  8D 5C 07              sta LevelNumber           ;initialize level number used for world display
00B50F  1  8D 52 07              sta AltEntranceControl    ;initialize mode of entry
00B512  1  EE 5D 07              inc Hidden1UpFlag         ;set flag for hidden 1-up blocks
00B515  1  EE 57 07              inc FetchNewGameTimerFlag ;set flag to load new game timer
00B518  1  60           ExPipeE: rts                       ;leave!!!
00B519  1               
00B519  1               ;-------------------------------------------------------------------------------------
00B519  1               
00B519  1               EnemiesAndLoopsCore:
00B519  1  B5 0F                    lda Enemy_Flag,x         ;check data here for MSB set
00B51B  1  48                       pha                      ;save in stack
00B51C  1  0A                       asl
00B51D  1  B0 12                    bcs ChkBowserF           ;if MSB set in enemy flag, branch ahead of jumps
00B51F  1  68                       pla                      ;get from stack
00B520  1  F0 03                    beq ChkAreaTsk           ;if data zero, branch
00B522  1  4C A7 C4                 jmp RunEnemyObjectsCore  ;otherwise, jump to run enemy subroutines
00B525  1  AD 1F 07     ChkAreaTsk: lda AreaParserTaskNum    ;check number of tasks to perform
00B528  1  29 07                    and #$07
00B52A  1  C9 07                    cmp #$07                 ;if at a specific task, jump and leave
00B52C  1  F0 0E                    beq ExitELCore
00B52E  1  4C 9E B5                 jmp ProcLoopCommand      ;otherwise, jump to process loop command/load enemies
00B531  1  68           ChkBowserF: pla                      ;get data from stack
00B532  1  29 0F                    and #%00001111           ;mask out high nybble
00B534  1  A8                       tay
00B535  1  B9 0F 00                 lda Enemy_Flag,y         ;use as pointer and load same place with different offset
00B538  1  D0 02                    bne ExitELCore
00B53A  1  95 0F                    sta Enemy_Flag,x         ;if second enemy flag not set, also clear first one
00B53C  1  60           ExitELCore: rts
00B53D  1               
00B53D  1               ;--------------------------------
00B53D  1               
00B53D  1               ;loop command data
00B53D  1               LoopCmdWorldNumber:
00B53D  1  03 03 06 06        .byte $03, $03, $06, $06, $06, $06, $06, $06, $07, $07, $07
00B541  1  06 06 06 06  
00B545  1  07 07 07     
00B548  1               
00B548  1               LoopCmdPageNumber:
00B548  1  05 09 04 05        .byte $05, $09, $04, $05, $06, $08, $09, $0a, $06, $0b, $10
00B54C  1  06 08 09 0A  
00B550  1  06 0B 10     
00B553  1               
00B553  1               LoopCmdYPosition:
00B553  1  40 B0 B0 80        .byte $40, $b0, $b0, $80, $40, $40, $80, $40, $f0, $f0, $f0
00B557  1  40 40 80 40  
00B55B  1  F0 F0 F0     
00B55E  1               
00B55E  1               ExecGameLoopback:
00B55E  1  A5 6D              lda Player_PageLoc        ;send player back four pages
00B560  1  38                 sec
00B561  1  E9 04              sbc #$04
00B563  1  85 6D              sta Player_PageLoc
00B565  1  AD 25 07           lda CurrentPageLoc        ;send current page back four pages
00B568  1  38                 sec
00B569  1  E9 04              sbc #$04
00B56B  1  8D 25 07           sta CurrentPageLoc
00B56E  1  AD 1A 07           lda ScreenLeft_PageLoc    ;subtract four from page location
00B571  1  38                 sec                       ;of screen's left border
00B572  1  E9 04              sbc #$04
00B574  1  8D 1A 07           sta ScreenLeft_PageLoc
00B577  1  AD 1B 07           lda ScreenRight_PageLoc   ;do the same for the page location
00B57A  1  38                 sec                       ;of screen's right border
00B57B  1  E9 04              sbc #$04
00B57D  1  8D 1B 07           sta ScreenRight_PageLoc
00B580  1  AD 2A 07           lda AreaObjectPageLoc     ;subtract four from page control
00B583  1  38                 sec                       ;for area objects
00B584  1  E9 04              sbc #$04
00B586  1  8D 2A 07           sta AreaObjectPageLoc
00B589  1  A9 00              lda #$00                  ;initialize page select for both
00B58B  1  8D 3B 07           sta EnemyObjectPageSel    ;area and enemy objects
00B58E  1  8D 2B 07           sta AreaObjectPageSel
00B591  1  8D 39 07           sta EnemyDataOffset       ;initialize enemy object data offset
00B594  1  8D 3A 07           sta EnemyObjectPageLoc    ;and enemy object page control
00B597  1  B9 75 96           lda AreaDataOfsLoopback,y ;adjust area object offset based on
00B59A  1  8D 2C 07           sta AreaDataOffset        ;which loop command we encountered
00B59D  1  60                 rts
00B59E  1               
00B59E  1               ProcLoopCommand:
00B59E  1  AD 45 07               lda LoopCommand           ;check if loop command was found
00B5A1  1  F0 5E                  beq ChkEnemyFrenzy
00B5A3  1  AD 26 07               lda CurrentColumnPos      ;check to see if we're still on the first page
00B5A6  1  D0 59                  bne ChkEnemyFrenzy        ;if not, do not loop yet
00B5A8  1  A0 0B                  ldy #$0b                  ;start at the end of each set of loop data
00B5AA  1  88           FindLoop: dey
00B5AB  1  30 54                  bmi ChkEnemyFrenzy        ;if all data is checked and not match, do not loop
00B5AD  1  AD 5F 07               lda WorldNumber           ;check to see if one of the world numbers
00B5B0  1  D9 3D B5               cmp LoopCmdWorldNumber,y  ;matches our current world number
00B5B3  1  D0 F5                  bne FindLoop
00B5B5  1  AD 25 07               lda CurrentPageLoc        ;check to see if one of the page numbers
00B5B8  1  D9 48 B5               cmp LoopCmdPageNumber,y   ;matches the page we're currently on
00B5BB  1  D0 ED                  bne FindLoop
00B5BD  1  A5 CE                  lda Player_Y_Position     ;check to see if the player is at the correct position
00B5BF  1  D9 53 B5               cmp LoopCmdYPosition,y    ;if not, branch to check for world 7
00B5C2  1  D0 23                  bne WrongChk
00B5C4  1  A5 1D                  lda Player_State          ;check to see if the player is
00B5C6  1  C9 00                  cmp #$00                  ;on solid ground (i.e. not jumping or falling)
00B5C8  1  D0 1D                  bne WrongChk              ;if not, player fails to pass loop, and loopback
00B5CA  1  AD 5F 07               lda WorldNumber           ;are we in world 7? (check performed on correct
00B5CD  1  C9 06                  cmp #World7               ;vertical position and on solid ground)
00B5CF  1  D0 23                  bne InitMLp               ;if not, initialize flags used there, otherwise
00B5D1  1  EE D9 06               inc MultiLoopCorrectCntr  ;increment counter for correct progression
00B5D4  1  EE DA 06     IncMLoop: inc MultiLoopPassCntr     ;increment master multi-part counter
00B5D7  1  AD DA 06               lda MultiLoopPassCntr     ;have we done all three parts?
00B5DA  1  C9 03                  cmp #$03
00B5DC  1  D0 1E                  bne InitLCmd              ;if not, skip this part
00B5DE  1  AD D9 06               lda MultiLoopCorrectCntr  ;if so, have we done them all correctly?
00B5E1  1  C9 03                  cmp #$03
00B5E3  1  F0 0F                  beq InitMLp               ;if so, branch past unnecessary check here
00B5E5  1  D0 07                  bne DoLpBack              ;unconditional branch if previous branch fails
00B5E7  1  AD 5F 07     WrongChk: lda WorldNumber           ;are we in world 7? (check performed on
00B5EA  1  C9 06                  cmp #World7               ;incorrect vertical position or not on solid ground)
00B5EC  1  F0 E6                  beq IncMLoop
00B5EE  1  20 5E B5     DoLpBack: jsr ExecGameLoopback      ;if player is not in right place, loop back
00B5F1  1  20 A7 CC               jsr KillAllEnemies
00B5F4  1  A9 00        InitMLp:  lda #$00                  ;initialize counters used for multi-part loop commands
00B5F6  1  8D DA 06               sta MultiLoopPassCntr
00B5F9  1  8D D9 06               sta MultiLoopCorrectCntr
00B5FC  1  A9 00        InitLCmd: lda #$00                  ;initialize loop command flag
00B5FE  1  8D 45 07               sta LoopCommand
00B601  1               
00B601  1               ;--------------------------------
00B601  1               
00B601  1               ChkEnemyFrenzy:
00B601  1  AD CD 06           lda EnemyFrenzyQueue  ;check for enemy object in frenzy queue
00B604  1  F0 10              beq ProcessEnemyData  ;if not, skip this part
00B606  1  95 16              sta Enemy_ID,x        ;store as enemy object identifier here
00B608  1  A9 01              lda #$01
00B60A  1  95 0F              sta Enemy_Flag,x      ;activate enemy object flag
00B60C  1  A9 00              lda #$00
00B60E  1  95 1E              sta Enemy_State,x     ;initialize state and frenzy queue
00B610  1  8D CD 06           sta EnemyFrenzyQueue
00B613  1  4C F8 B6           jmp InitEnemyObject   ;and then jump to deal with this enemy
00B616  1               
00B616  1               ;--------------------------------
00B616  1               ;$06 - used to hold page location of extended right boundary
00B616  1               ;$07 - used to hold high nybble of position of extended right boundary
00B616  1               
00B616  1               ProcessEnemyData:
00B616  1  AC 39 07             ldy EnemyDataOffset      ;get offset of enemy object data
00B619  1  B1 E9                lda (EnemyData),y        ;load first byte
00B61B  1  C9 FF                cmp #$ff                 ;check for EOD terminator
00B61D  1  D0 03                bne CheckEndofBuffer
00B61F  1  4C E8 B6             jmp CheckFrenzyBuffer    ;if found, jump to check frenzy buffer, otherwise
00B622  1               
00B622  1               CheckEndofBuffer:
00B622  1  29 0F                and #%00001111           ;check for special row $0e
00B624  1  C9 0E                cmp #$0e
00B626  1  F0 0E                beq CheckRightBounds     ;if found, branch, otherwise
00B628  1  E0 05                cpx #$05                 ;check for end of buffer
00B62A  1  90 0A                bcc CheckRightBounds     ;if not at end of buffer, branch
00B62C  1  C8                   iny
00B62D  1  B1 E9                lda (EnemyData),y        ;check for specific value here
00B62F  1  29 3F                and #%00111111           ;not sure what this was intended for, exactly
00B631  1  C9 2E                cmp #$2e                 ;this part is quite possibly residual code
00B633  1  F0 01                beq CheckRightBounds     ;but it has the effect of keeping enemies out of
00B635  1  60                   rts                      ;the sixth slot
00B636  1               
00B636  1               CheckRightBounds:
00B636  1  AD 1D 07             lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
00B639  1  18                   clc
00B63A  1  69 30                adc #$30
00B63C  1  29 F0                and #%11110000           ;store high nybble
00B63E  1  85 07                sta $07
00B640  1  AD 1B 07             lda ScreenRight_PageLoc  ;add carry to page location of right boundary
00B643  1  69 00                adc #$00
00B645  1  85 06                sta $06                  ;store page location + carry
00B647  1  AC 39 07             ldy EnemyDataOffset
00B64A  1  C8                   iny
00B64B  1  B1 E9                lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
00B64D  1  0A                   asl
00B64E  1  90 0B                bcc CheckPageCtrlRow
00B650  1  AD 3B 07             lda EnemyObjectPageSel   ;if page select already set, do not set again
00B653  1  D0 06                bne CheckPageCtrlRow
00B655  1  EE 3B 07             inc EnemyObjectPageSel   ;otherwise, if MSB is set, set page select
00B658  1  EE 3A 07             inc EnemyObjectPageLoc   ;and increment page control
00B65B  1               
00B65B  1               CheckPageCtrlRow:
00B65B  1  88                   dey
00B65C  1  B1 E9                lda (EnemyData),y        ;reread first byte
00B65E  1  29 0F                and #$0f
00B660  1  C9 0F                cmp #$0f                 ;check for special row $0f
00B662  1  D0 19                bne PositionEnemyObj     ;if not found, branch to position enemy object
00B664  1  AD 3B 07             lda EnemyObjectPageSel   ;if page select set,
00B667  1  D0 14                bne PositionEnemyObj     ;branch without reading second byte
00B669  1  C8                   iny
00B66A  1  B1 E9                lda (EnemyData),y        ;otherwise, get second byte, mask out 2 MSB
00B66C  1  29 3F                and #%00111111
00B66E  1  8D 3A 07             sta EnemyObjectPageLoc   ;store as page control for enemy object data
00B671  1  EE 39 07             inc EnemyDataOffset      ;increment enemy object data offset 2 bytes
00B674  1  EE 39 07             inc EnemyDataOffset
00B677  1  EE 3B 07             inc EnemyObjectPageSel   ;set page select for enemy object data and
00B67A  1  4C 9E B5             jmp ProcLoopCommand      ;jump back to process loop commands again
00B67D  1               
00B67D  1               PositionEnemyObj:
00B67D  1  AD 3A 07             lda EnemyObjectPageLoc   ;store page control as page location
00B680  1  95 6E                sta Enemy_PageLoc,x      ;for enemy object
00B682  1  B1 E9                lda (EnemyData),y        ;get first byte of enemy object
00B684  1  29 F0                and #%11110000
00B686  1  95 87                sta Enemy_X_Position,x   ;store column position
00B688  1  CD 1D 07             cmp ScreenRight_X_Pos    ;check column position against right boundary
00B68B  1  B5 6E                lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
00B68D  1  ED 1B 07             sbc ScreenRight_PageLoc  ;from page location
00B690  1  B0 0B                bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
00B692  1  B1 E9                lda (EnemyData),y
00B694  1  29 0F                and #%00001111           ;check for special row $0e
00B696  1  C9 0E                cmp #$0e                 ;if found, jump elsewhere
00B698  1  F0 69                beq ParseRow0e
00B69A  1  4C 22 B7             jmp CheckThreeBytes      ;if not found, unconditional jump
00B69D  1               
00B69D  1               CheckRightExtBounds:
00B69D  1  A5 07                lda $07                  ;check right boundary + 48 against
00B69F  1  D5 87                cmp Enemy_X_Position,x   ;column position without subtracting,
00B6A1  1  A5 06                lda $06                  ;then subtract borrow from page control temp
00B6A3  1  F5 6E                sbc Enemy_PageLoc,x      ;plus carry
00B6A5  1  90 41                bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
00B6A7  1  A9 01                lda #$01                 ;store value in vertical high byte
00B6A9  1  95 B6                sta Enemy_Y_HighPos,x
00B6AB  1  B1 E9                lda (EnemyData),y        ;get first byte again
00B6AD  1  0A                   asl                      ;multiply by four to get the vertical
00B6AE  1  0A                   asl                      ;coordinate
00B6AF  1  0A                   asl
00B6B0  1  0A                   asl
00B6B1  1  95 CF                sta Enemy_Y_Position,x
00B6B3  1  C9 E0                cmp #$e0                 ;do one last check for special row $0e
00B6B5  1  F0 4C                beq ParseRow0e           ;(necessary if branched to $c1cb)
00B6B7  1  C8                   iny
00B6B8  1  B1 E9                lda (EnemyData),y        ;get second byte of object
00B6BA  1  29 40                and #%01000000           ;check to see if hard mode bit is set
00B6BC  1  F0 05                beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
00B6BE  1  AD CC 06             lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
00B6C1  1  F0 6D                beq Inc2B                ;is on, and if not, branch to skip this object completely
00B6C3  1               
00B6C3  1               CheckForEnemyGroup:
00B6C3  1  B1 E9                lda (EnemyData),y      ;get second byte and mask out 2 MSB
00B6C5  1  29 3F                and #%00111111
00B6C7  1  C9 37                cmp #$37               ;check for value below $37
00B6C9  1  90 04                bcc BuzzyBeetleMutate
00B6CB  1  C9 3F                cmp #$3f               ;if $37 or greater, check for value
00B6CD  1  90 31                bcc DoGroup            ;below $3f, branch if below $3f
00B6CF  1               
00B6CF  1               BuzzyBeetleMutate:
00B6CF  1  C9 06                cmp #Goomba          ;if below $37, check for goomba
00B6D1  1  D0 07                bne StrID            ;value ($3f or more always fails)
00B6D3  1  AC 6A 07             ldy PrimaryHardMode  ;check if primary hard mode flag is set
00B6D6  1  F0 02                beq StrID            ;and if so, change goomba to buzzy beetle
00B6D8  1  A9 02                lda #BuzzyBeetle
00B6DA  1  95 16        StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
00B6DC  1  A9 01                lda #$01
00B6DE  1  95 0F                sta Enemy_Flag,x     ;set flag for enemy in buffer
00B6E0  1  20 F8 B6             jsr InitEnemyObject
00B6E3  1  B5 0F                lda Enemy_Flag,x     ;check to see if flag is set
00B6E5  1  D0 49                bne Inc2B            ;if not, leave, otherwise branch
00B6E7  1  60                   rts
00B6E8  1               
00B6E8  1               CheckFrenzyBuffer:
00B6E8  1  AD CB 06             lda EnemyFrenzyBuffer    ;if enemy object stored in frenzy buffer
00B6EB  1  D0 09                bne StrFre               ;then branch ahead to store in enemy object buffer
00B6ED  1  AD 98 03             lda VineFlagOffset       ;otherwise check vine flag offset
00B6F0  1  C9 01                cmp #$01
00B6F2  1  D0 0B                bne ExEPar               ;if other value <> 1, leave
00B6F4  1  A9 2F                lda #VineObject          ;otherwise put vine in enemy identifier
00B6F6  1  95 16        StrFre: sta Enemy_ID,x           ;store contents of frenzy buffer into enemy identifier value
00B6F8  1               
00B6F8  1               InitEnemyObject:
00B6F8  1  A9 00                lda #$00                 ;initialize enemy state
00B6FA  1  95 1E                sta Enemy_State,x
00B6FC  1  20 3B B8             jsr CheckpointEnemyID    ;jump ahead to run jump engine and subroutines
00B6FF  1  60           ExEPar: rts                      ;then leave
00B700  1               
00B700  1               DoGroup:
00B700  1  4C CF B7             jmp HandleGroupEnemies   ;handle enemy group objects
00B703  1               
00B703  1               ParseRow0e:
00B703  1  C8                   iny                      ;increment Y to load third byte of object
00B704  1  C8                   iny
00B705  1  B1 E9                lda (EnemyData),y
00B707  1  4A                   lsr                      ;move 3 MSB to the bottom, effectively
00B708  1  4A                   lsr                      ;making %xxx00000 into %00000xxx
00B709  1  4A                   lsr
00B70A  1  4A                   lsr
00B70B  1  4A                   lsr
00B70C  1  CD 5F 07             cmp WorldNumber          ;is it the same world number as we're on?
00B70F  1  D0 0E                bne NotUse               ;if not, do not use (this allows multiple uses
00B711  1  88                   dey                      ;of the same area, like the underground bonus areas)
00B712  1  B1 E9                lda (EnemyData),y        ;otherwise, get second byte and use as offset
00B714  1  8D 50 07             sta AreaPointer          ;to addresses for level and enemy object data
00B717  1  C8                   iny
00B718  1  B1 E9                lda (EnemyData),y        ;get third byte again, and this time mask out
00B71A  1  29 1F                and #%00011111           ;the 3 MSB from before, save as page number to be
00B71C  1  8D 51 07             sta EntrancePage         ;used upon entry to area, if area is entered
00B71F  1  4C 2D B7     NotUse: jmp Inc3B
00B722  1               
00B722  1               CheckThreeBytes:
00B722  1  AC 39 07             ldy EnemyDataOffset      ;load current offset for enemy object data
00B725  1  B1 E9                lda (EnemyData),y        ;get first byte
00B727  1  29 0F                and #%00001111           ;check for special row $0e
00B729  1  C9 0E                cmp #$0e
00B72B  1  D0 03                bne Inc2B
00B72D  1  EE 39 07     Inc3B:  inc EnemyDataOffset      ;if row = $0e, increment three bytes
00B730  1  EE 39 07     Inc2B:  inc EnemyDataOffset      ;otherwise increment two bytes
00B733  1  EE 39 07             inc EnemyDataOffset
00B736  1  A9 00                lda #$00                 ;init page select for enemy objects
00B738  1  8D 3B 07             sta EnemyObjectPageSel
00B73B  1  A6 08                ldx ObjectOffset         ;reload current offset in enemy buffers
00B73D  1  60                   rts                      ;and leave
00B73E  1               ;--------------------------------
00B73E  1               
00B73E  1               Bitmasks:
00B73E  1  01 02 04 08        .byte %00000001, %00000010, %00000100, %00001000, %00010000, %00100000, %01000000, %10000000
00B742  1  10 20 40 80  
00B746  1               
00B746  1               Enemy17YPosData:
00B746  1  40 30 90 50        .byte $40, $30, $90, $50, $20, $60, $a0, $70
00B74A  1  20 60 A0 70  
00B74E  1               
00B74E  1               SwimCC_IDData:
00B74E  1  0A 0B              .byte $0a, $0b
00B750  1               
00B750  1               BulletBillCheepCheep:
00B750  1  AD 8F 07              lda FrenzyEnemyTimer      ;if timer not expired yet, branch to leave
00B753  1  D0 6F                 bne ExF17
00B755  1  AD 4E 07              lda AreaType              ;are we in a water-type level?
00B758  1  D0 57                 bne DoBulletBills         ;if not, branch elsewhere
00B75A  1  E0 03                 cpx #$03                  ;are we past third enemy slot?
00B75C  1  B0 66                 bcs ExF17                 ;if so, branch to leave
00B75E  1  A0 00                 ldy #$00                  ;load default offset
00B760  1  BD A7 07              lda PseudoRandomBitReg,x
00B763  1  C9 AA                 cmp #$aa                  ;check first part of LSFR against preset value
00B765  1  90 01                 bcc ChkW2                 ;if less than preset, do not increment offset
00B767  1  C8                    iny                       ;otherwise increment
00B768  1  AD 5F 07     ChkW2:   lda WorldNumber           ;check world number
00B76B  1  C9 01                 cmp #World2
00B76D  1  F0 01                 beq Get17ID               ;if we're on world 2, do not increment offset
00B76F  1  C8                    iny                       ;otherwise increment
00B770  1  98           Get17ID: tya
00B771  1  29 01                 and #%00000001            ;mask out all but last bit of offset
00B773  1  A8                    tay
00B774  1  B9 4E B7              lda SwimCC_IDData,y       ;load identifier for cheep-cheeps
00B777  1  95 16        Set17ID: sta Enemy_ID,x            ;store whatever's in A as enemy identifier
00B779  1  AD DD 06              lda BitMFilter
00B77C  1  C9 FF                 cmp #$ff                  ;if not all bits set, skip init part and compare bits
00B77E  1  D0 05                 bne GetRBit
00B780  1  A9 00                 lda #$00                  ;initialize vertical position filter
00B782  1  8D DD 06              sta BitMFilter
00B785  1  BD A7 07     GetRBit: lda PseudoRandomBitReg,x  ;get first part of LSFR
00B788  1  29 07                 and #%00000111            ;mask out all but 3 LSB
00B78A  1  A8           ChkRBit: tay                       ;use as offset
00B78B  1  B9 3E B7              lda Bitmasks,y            ;load bitmask
00B78E  1  2C DD 06              bit BitMFilter            ;perform AND on filter without changing it
00B791  1  F0 07                 beq AddFBit
00B793  1  C8                    iny                       ;increment offset
00B794  1  98                    tya
00B795  1  29 07                 and #%00000111            ;mask out all but 3 LSB thus keeping it 0-7
00B797  1  4C 8A B7              jmp ChkRBit               ;do another check
00B79A  1  0D DD 06     AddFBit: ora BitMFilter            ;add bit to already set bits in filter
00B79D  1  8D DD 06              sta BitMFilter            ;and store
00B7A0  1  B9 46 B7              lda Enemy17YPosData,y     ;load vertical position using offset
00B7A3  1  20 11 C3              jsr PutAtRightExtent      ;set vertical position and other values
00B7A6  1  9D 17 04              sta Enemy_YMF_Dummy,x     ;initialize dummy variable
00B7A9  1  A9 20                 lda #$20                  ;set timer
00B7AB  1  8D 8F 07              sta FrenzyEnemyTimer
00B7AE  1  4C 3B B8              jmp CheckpointEnemyID     ;process our new enemy object
00B7B1  1               
00B7B1  1               
00B7B1  1               DoBulletBills:
00B7B1  1  A0 FF                  ldy #$ff                   ;start at beginning of enemy slots
00B7B3  1  C8           BB_SLoop: iny                        ;move onto the next slot
00B7B4  1  C0 05                  cpy #$05                   ;branch to play sound if we've done all slots
00B7B6  1  B0 0D                  bcs FireBulletBill
00B7B8  1  B9 0F 00               lda Enemy_Flag,y           ;if enemy buffer flag not set,
00B7BB  1  F0 F6                  beq BB_SLoop               ;loop back and check another slot
00B7BD  1  B9 16 00               lda Enemy_ID,y
00B7C0  1  C9 08                  cmp #BulletBill_FrenzyVar  ;check enemy identifier for
00B7C2  1  D0 EF                  bne BB_SLoop               ;bullet bill object (frenzy variant)
00B7C4  1  60           ExF17:    rts                        ;if found, leave
00B7C5  1               
00B7C5  1               FireBulletBill:
00B7C5  1  A5 FE              lda Square2SoundQueue
00B7C7  1  09 08              ora #Sfx_Blast            ;play fireworks/gunfire sound
00B7C9  1  85 FE              sta Square2SoundQueue
00B7CB  1  A9 08              lda #BulletBill_FrenzyVar ;load identifier for bullet bill object
00B7CD  1  D0 A8              bne Set17ID               ;unconditional branch
00B7CF  1               
00B7CF  1               ;--------------------------------
00B7CF  1               ;$00 - used to store Y position of group enemies
00B7CF  1               ;$01 - used to store enemy ID
00B7CF  1               ;$02 - used to store page location of right side of screen
00B7CF  1               ;$03 - used to store X position of right side of screen
00B7CF  1               
00B7CF  1               HandleGroupEnemies:
00B7CF  1  A0 00                ldy #$00                  ;load value for green koopa troopa
00B7D1  1  38                   sec
00B7D2  1  E9 37                sbc #$37                  ;subtract $37 from second byte read
00B7D4  1  48                   pha                       ;save result in stack for now
00B7D5  1  C9 04                cmp #$04                  ;was byte in $3b-$3e range?
00B7D7  1  B0 0B                bcs SnglID                ;if so, branch
00B7D9  1  48                   pha                       ;save another copy to stack
00B7DA  1  A0 06                ldy #Goomba               ;load value for goomba enemy
00B7DC  1  AD 6A 07             lda PrimaryHardMode       ;if primary hard mode flag not set,
00B7DF  1  F0 02                beq PullID                ;branch, otherwise change to value
00B7E1  1  A0 02                ldy #BuzzyBeetle          ;for buzzy beetle
00B7E3  1  68           PullID: pla                       ;get second copy from stack
00B7E4  1  84 01        SnglID: sty $01                   ;save enemy id here
00B7E6  1  A0 B0                ldy #$b0                  ;load default y coordinate
00B7E8  1  29 02                and #$02                  ;check to see if d1 was set
00B7EA  1  F0 02                beq SetYGp                ;if so, move y coordinate up,
00B7EC  1  A0 70                ldy #$70                  ;otherwise branch and use default
00B7EE  1  84 00        SetYGp: sty $00                   ;save y coordinate here
00B7F0  1  AD 1B 07             lda ScreenRight_PageLoc   ;get page number of right edge of screen
00B7F3  1  85 02                sta $02                   ;save here
00B7F5  1  AD 1D 07             lda ScreenRight_X_Pos     ;get pixel coordinate of right edge
00B7F8  1  85 03                sta $03                   ;save here
00B7FA  1  A0 02                ldy #$02                  ;load two enemies by default
00B7FC  1  68                   pla                       ;get first copy from stack
00B7FD  1  4A                   lsr                       ;check to see if d0 was set
00B7FE  1  90 01                bcc CntGrp                ;if not, use default value
00B800  1  C8                   iny                       ;otherwise increment to three enemies
00B801  1  8C D3 06     CntGrp: sty NumberofGroupEnemies  ;save number of enemies here
00B804  1  A2 FF        GrLoop: ldx #$ff                  ;start at beginning of enemy buffers
00B806  1  E8           GSltLp: inx                       ;increment and branch if past
00B807  1  E0 05                cpx #$05                  ;end of buffers
00B809  1  B0 2D                bcs NextED
00B80B  1  B5 0F                lda Enemy_Flag,x          ;check to see if enemy is already
00B80D  1  D0 F7                bne GSltLp                ;stored in buffer, and branch if so
00B80F  1  A5 01                lda $01
00B811  1  95 16                sta Enemy_ID,x            ;store enemy object identifier
00B813  1  A5 02                lda $02
00B815  1  95 6E                sta Enemy_PageLoc,x       ;store page location for enemy object
00B817  1  A5 03                lda $03
00B819  1  95 87                sta Enemy_X_Position,x    ;store x coordinate for enemy object
00B81B  1  18                   clc
00B81C  1  69 18                adc #$18                  ;add 24 pixels for next enemy
00B81E  1  85 03                sta $03
00B820  1  A5 02                lda $02                   ;add carry to page location for
00B822  1  69 00                adc #$00                  ;next enemy
00B824  1  85 02                sta $02
00B826  1  A5 00                lda $00                   ;store y coordinate for enemy object
00B828  1  95 CF                sta Enemy_Y_Position,x
00B82A  1  A9 01                lda #$01                  ;activate flag for buffer, and
00B82C  1  95 B6                sta Enemy_Y_HighPos,x     ;put enemy within the screen vertically
00B82E  1  95 0F                sta Enemy_Flag,x
00B830  1  20 3B B8             jsr CheckpointEnemyID     ;process each enemy object separately
00B833  1  CE D3 06             dec NumberofGroupEnemies  ;do this until we run out of enemy objects
00B836  1  D0 CC                bne GrLoop
00B838  1  4C 30 B7     NextED: jmp Inc2B                 ;jump to increment data offset and leave
00B83B  1               
00B83B  1               ; ------------------
00B83B  1               
00B83B  1               CheckpointEnemyID:
00B83B  1  B5 16                lda Enemy_ID,x
00B83D  1  C9 15                cmp #$15                     ;check enemy object identifier for $15 or greater
00B83F  1  B0 0D                bcs InitEnemyRoutines        ;and branch straight to the jump engine if found
00B841  1  A8                   tay                          ;save identifier in Y register for now
00B842  1  B5 CF                lda Enemy_Y_Position,x
00B844  1  69 08                adc #$08                     ;add eight pixels to what will eventually be the
00B846  1  95 CF                sta Enemy_Y_Position,x       ;enemy object's vertical coordinate ($00-$14 only)
00B848  1  A9 01                lda #$01
00B84A  1  9D D8 03             sta EnemyOffscrBitsMasked,x  ;set offscreen masked bit
00B84D  1  98                   tya                          ;get identifier back and use as offset for jump engine
00B84E  1               
00B84E  1               InitEnemyRoutines:
00B84E  1  20 A8 BA             jsr JumpEngine
00B851  1               
00B851  1               ;jump engine table for newly loaded enemy objects
00B851  1               
00B851  1  47 C0              .word InitNormalEnemy  ;for objects $00-$0f
00B853  1  47 C0              .word InitNormalEnemy
00B855  1  47 C0              .word InitNormalEnemy
00B857  1  57 C0              .word InitRedKoopa
00B859  1  29 C0              .word NoInitCode
00B85B  1  61 C0              .word InitHammerBro
00B85D  1  2A C0              .word InitGoomba
00B85F  1  7B C0              .word InitBloober
00B861  1  A4 C0              .word InitBulletBill
00B863  1  29 C0              .word NoInitCode
00B865  1  AE C0              .word InitCheepCheep
00B867  1  AE C0              .word InitCheepCheep
00B869  1  30 C0              .word InitPodoboo
00B86B  1  C3 C3              .word InitPiranhaPlant
00B86D  1  F6 C3              .word InitJumpGPTroopa
00B86F  1  83 C0              .word InitRedPTroopa
00B871  1               
00B871  1  76 C0              .word InitHorizFlySwimEnemy  ;for objects $10-$1f
00B873  1  BE C0              .word InitLakitu
00B875  1  BF B8              .word InitEnemyFrenzy
00B877  1  29 C0              .word NoInitCode
00B879  1  BF B8              .word InitEnemyFrenzy
00B87B  1  BF B8              .word InitEnemyFrenzy
00B87D  1  BF B8              .word InitEnemyFrenzy
00B87F  1  BF B8              .word InitEnemyFrenzy
00B881  1  DD C3              .word EndFrenzy
00B883  1  29 C0              .word NoInitCode
00B885  1  29 C0              .word NoInitCode
00B887  1  95 C1              .word InitShortFirebar
00B889  1  95 C1              .word InitShortFirebar
00B88B  1  95 C1              .word InitShortFirebar
00B88D  1  95 C1              .word InitShortFirebar
00B88F  1  92 C1              .word InitLongFirebar
00B891  1               
00B891  1  29 C0              .word NoInitCode ;for objects $20-$2f
00B893  1  29 C0              .word NoInitCode
00B895  1  29 C0              .word NoInitCode
00B897  1  29 C0              .word NoInitCode
00B899  1  04 C4              .word InitBalPlatform
00B89B  1  37 C4              .word InitVertPlatform
00B89D  1  64 C4              .word LargeLiftUp
00B89F  1  6A C4              .word LargeLiftDown
00B8A1  1  30 C4              .word InitHoriPlatform
00B8A3  1  28 C4              .word InitDropPlatform
00B8A5  1  30 C4              .word InitHoriPlatform
00B8A7  1  70 C4              .word PlatLiftUp
00B8A9  1  7C C4              .word PlatLiftDown
00B8AB  1  82 C2              .word InitBowser
00B8AD  1  42 BC              .word PwrUpJmp   ;possibly dummy value
00B8AF  1  7B ED              .word Setup_Vine
00B8B1  1               
00B8B1  1  29 C0              .word NoInitCode ;for objects $30-$36
00B8B3  1  29 C0              .word NoInitCode
00B8B5  1  29 C0              .word NoInitCode
00B8B7  1  29 C0              .word NoInitCode
00B8B9  1  29 C0              .word NoInitCode
00B8BB  1  40 C0              .word InitRetainerObj
00B8BD  1  A6 C4              .word EndOfEnemyInitCode
00B8BF  1               
00B8BF  1               ;--------------------------------
00B8BF  1               
00B8BF  1               InitEnemyFrenzy:
00B8BF  1  B5 16              lda Enemy_ID,x        ;load enemy identifier
00B8C1  1  8D CB 06           sta EnemyFrenzyBuffer ;save in enemy frenzy buffer
00B8C4  1  38                 sec
00B8C5  1  E9 12              sbc #$12              ;subtract 12 and use as offset for jump engine
00B8C7  1  20 A8 BA           jsr JumpEngine
00B8CA  1               
00B8CA  1               ;frenzy object jump table
00B8CA  1  DD C0              .word LakituAndSpinyHandler
00B8CC  1  DC C3              .word NoFrenzyCode
00B8CE  1  E1 C1              .word InitFlyingCheepCheep
00B8D0  1  DC C2              .word InitBowserFlame
00B8D2  1  76 C3              .word InitFireworks
00B8D4  1  50 B7              .word BulletBillCheepCheep
00B8D6  1               
00B8D6  1               ;--------------------------------
00B8D6  1               
00B8D6  1               IntermediatePlayerData:
00B8D6  1  58 01 00 60          .byte $58, $01, $00, $60, $ff, $04
00B8DA  1  FF 04        
00B8DC  1               
00B8DC  1               DrawPlayer_Intermediate:
00B8DC  1  A2 05                  ldx #$05                       ;store data into zero page memory
00B8DE  1  BD D6 B8     PIntLoop: lda IntermediatePlayerData,x   ;load data to display player as he always
00B8E1  1  95 02                  sta $02,x                      ;appears on world/lives display
00B8E3  1  CA                     dex
00B8E4  1  10 F8                  bpl PIntLoop                   ;do this until all data is loaded
00B8E6  1  A2 B8                  ldx #$b8                       ;load offset for small standing
00B8E8  1  A0 04                  ldy #$04                       ;load sprite data offset
00B8EA  1  20 74 EA               jsr DrawPlayerLoop             ;draw player accordingly
00B8ED  1  AD 26 02               lda Sprite_Attributes+36       ;get empty sprite attributes
00B8F0  1  09 40                  ora #%01000000                 ;set horizontal flip bit for bottom-right sprite
00B8F2  1  8D 22 02               sta Sprite_Attributes+32       ;store and leave
00B8F5  1  60                     rts
00B8F6  1               
00B8F6  1               ;-------------------------------------------------------------------------------------
00B8F6  1               
00B8F6  1               InitializeGame:
00B8F6  1  A0 6F                     ldy #$6f              ;clear all memory as in initialization procedure,
00B8F8  1  20 BD BA                  jsr InitializeMemory  ;but this time, clear only as far as $076f
00B8FB  1  A0 1F                     ldy #$1f
00B8FD  1  99 B0 07     ClrSndLoop:  sta SoundMemory,y     ;clear out memory used
00B900  1  88                        dey                   ;by the sound engines
00B901  1  10 FA                     bpl ClrSndLoop
00B903  1               
00B903  1               InitializeArea:
00B903  1  A0 4B                       ldy #$4b                 ;clear all memory again, only as far as $074b
00B905  1  20 BD BA                    jsr InitializeMemory     ;this is only necessary if branching from
00B908  1  A2 21                       ldx #$21
00B90A  1  A9 00                       lda #$00
00B90C  1  9D 80 07     ClrTimersLoop: sta Timers,x             ;clear out memory between
00B90F  1  CA                          dex                      ;$0780 and $07a1
00B910  1  10 FA                       bpl ClrTimersLoop
00B912  1                              ;
00B912  1                              ; FPG load level
00B912  1                              ;
00B912  1  AD 61 07                    lda FpgFlags
00B915  1  29 40                       and #$40
00B917  1  D0 05                       bne LoadFpgStuff
00B919  1                              ; title
00B919  1  A9 00                       lda #0
00B91B  1  4C 2F B9                    jmp LoadWorldStuff
00B91E  1               LoadFpgStuff:
00B91E  1  20 00 FE                    jsr Enter_ScenLoadArea
00B921  1  A9 00                       lda #$00
00B923  1  8D 61 07                    sta FpgFlags
00B926  1  8D D8 07                    sta FpgError
00B929  1  8D 17 07                    sta FpgRuleset
00B92C  1  AD 1A 07                    lda ScreenEdge_PageLoc
00B92F  1               LoadWorldStuff:
00B92F  1  8D 25 07                    sta CurrentPageLoc       ;also set as current page
00B932  1  8D 28 07                    sta BackloadingFlag      ;set flag here if halfway page or saved entry page number found
00B935  1  20 CE BB                    jsr LoadAreaPointer
00B938  1               
00B938  1  20 19 BC                    jsr GetScreenPosition    ;get pixel coordinates for screen borders
00B93B  1  A0 20                       ldy #$20                 ;if on odd numbered page, use $2480 as start of rendering
00B93D  1  29 01                       and #%00000001           ;otherwise use $2080, this address used later as name table
00B93F  1  F0 02                       beq SetInitNTHigh        ;address for rendering of game area
00B941  1  A0 24                       ldy #$24
00B943  1  8C 20 07     SetInitNTHigh: sty CurrentNTAddr_High   ;store name table address
00B946  1  A0 80                       ldy #$80
00B948  1  8C 21 07                    sty CurrentNTAddr_Low
00B94B  1  0A                          asl                      ;store LSB of page number in high nybble
00B94C  1  0A                          asl                      ;of block buffer column position
00B94D  1  0A                          asl
00B94E  1  0A                          asl
00B94F  1  8D A0 06                    sta BlockBufferColumnPos
00B952  1  CE 30 07                    dec AreaObjectLength     ;set area object lengths for all empty
00B955  1  CE 31 07                    dec AreaObjectLength+1
00B958  1  CE 32 07                    dec AreaObjectLength+2
00B95B  1  A9 0F                       lda #$0f                 ;set value for renderer to update 12 column sets
00B95D  1  8D 1E 07                    sta ColumnSets           ;12 column sets = 24 metatile columns = 1 1/2 screens
00B960  1  20 18 B4                    jsr GetAreaDataAddrs     ;get enemy and level addresses and load header
00B963  1  AD 6A 07                    lda PrimaryHardMode      ;check to see if primary hard mode has been activated
00B966  1  D0 10                       bne SetSecHard           ;if so, activate the secondary no matter where we're at
00B968  1  AD 5F 07                    lda WorldNumber          ;otherwise check world number
00B96B  1  C9 04                       cmp #World5              ;if less than 5, do not activate secondary
00B96D  1  90 0C                       bcc CheckHalfway
00B96F  1  D0 07                       bne SetSecHard           ;if not equal to, then world > 5, thus activate
00B971  1  AD 5C 07                    lda LevelNumber          ;otherwise, world 5, so check level number
00B974  1  C9 02                       cmp #Level3              ;if 1 or 2, do not set secondary hard mode flag
00B976  1  90 03                       bcc CheckHalfway
00B978  1  EE CC 06     SetSecHard:    inc SecondaryHardMode    ;set secondary hard mode flag for areas 5-3 and beyond
00B97B  1  AD 5B 07     CheckHalfway:  lda HalfwayPage
00B97E  1  F0 05                       beq DoneInitArea
00B980  1  A9 02                       lda #$02                 ;if halfway page set, overwrite start position from header
00B982  1  8D 10 07                    sta PlayerEntranceCtrl
00B985  1  A9 80        DoneInitArea:  lda #Silence             ;silence music
00B987  1  85 FB                       sta AreaMusicQueue
00B989  1  EE 72 07                    inc OperMode_Task        ;increment one of the modes
00B98C  1  60                          rts
00B98D  1               
00B98D  1               ;--------------------------------
00B98D  1               
00B98D  1               RunFireworks:
00B98D  1  D6 A0                   dec ExplosionTimerCounter,x ;decrement explosion timing counter here
00B98F  1  D0 0C                   bne SetupExpl               ;if not expired, skip this part
00B991  1  A9 08                   lda #$08
00B993  1  95 A0                   sta ExplosionTimerCounter,x ;reset counter
00B995  1  F6 58                   inc ExplosionGfxCounter,x   ;increment explosion graphics counter
00B997  1  B5 58                   lda ExplosionGfxCounter,x
00B999  1  C9 03                   cmp #$03                    ;check explosion graphics counter
00B99B  1  B0 18                   bcs FireworksSoundScore     ;if at a certain point, branch to kill this object
00B99D  1  20 EA EB     SetupExpl: jsr RelativeEnemyPosition   ;get relative coordinates of explosion
00B9A0  1  AD B9 03                lda Enemy_Rel_YPos          ;copy relative coordinates
00B9A3  1  8D BA 03                sta Fireball_Rel_YPos       ;from the enemy object to the fireball object
00B9A6  1  AD AE 03                lda Enemy_Rel_XPos          ;first vertical, then horizontal
00B9A9  1  8D AF 03                sta Fireball_Rel_XPos
00B9AC  1  BC E5 06                ldy Enemy_SprDataOffset,x   ;get OAM data offset
00B9AF  1  B5 58                   lda ExplosionGfxCounter,x   ;get explosion graphics counter
00B9B1  1  20 CF E7                jsr DrawExplosion_Fireworks ;do a sub to draw the explosion then leave
00B9B4  1  60                      rts
00B9B5  1               
00B9B5  1               FireworksSoundScore:
00B9B5  1  A9 00              lda #$00               ;disable enemy buffer flag
00B9B7  1  95 0F              sta Enemy_Flag,x
00B9B9  1  A9 08              lda #Sfx_Blast         ;play fireworks/gunfire sound
00B9BB  1  85 FE              sta Square2SoundQueue
00B9BD  1  A9 05              lda #$05               ;set part of score modifier for 500 points
00B9BF  1  8D 38 01           sta DigitModifier+4
00B9C2  1  4C 2E BA           jmp EndAreaPoints     ;jump to award points accordingly then leave
00B9C5  1               
00B9C5  1               ;--------------------------------
00B9C5  1               
00B9C5  1               StarFlagYPosAdder:
00B9C5  1  00 00 08 08        .byte $00, $00, $08, $08
00B9C9  1               
00B9C9  1               StarFlagXPosAdder:
00B9C9  1  00 08 00 08        .byte $00, $08, $00, $08
00B9CD  1               
00B9CD  1               StarFlagTileData:
00B9CD  1  54 55 56 57        .byte $54, $55, $56, $57
00B9D1  1               
00B9D1  1               RunStarFlagObj:
00B9D1  1  A9 00              lda #$00                 ;initialize enemy frenzy buffer
00B9D3  1  8D CB 06           sta EnemyFrenzyBuffer
00B9D6  1  AD 46 07           lda StarFlagTaskControl  ;check star flag object task number here
00B9D9  1  C9 05              cmp #$05                 ;if greater than 5, branch to exit
00B9DB  1  B0 2C              bcs StarFlagExit
00B9DD  1  20 A8 BA           jsr JumpEngine           ;otherwise jump to appropriate sub
00B9E0  1               
00B9E0  1  09 BA              .word StarFlagExit
00B9E2  1  EA B9              .word GameTimerFireworks
00B9E4  1  0A BA              .word AwardGameTimerPoints
00B9E6  1  46 BA              .word RaiseFlagSetoffFWorks
00B9E8  1  9A BA              .word DelayToAreaEnd
00B9EA  1               
00B9EA  1               GameTimerFireworks:
00B9EA  1  A0 05                ldy #$05               ;set default state for star flag object
00B9EC  1  AD FA 07             lda GameTimerDisplay+2 ;get game timer's last digit
00B9EF  1  C9 01                cmp #$01
00B9F1  1  F0 0E                beq SetFWC             ;if last digit of game timer set to 1, skip ahead
00B9F3  1  A0 03                ldy #$03               ;otherwise load new value for state
00B9F5  1  C9 03                cmp #$03
00B9F7  1  F0 08                beq SetFWC             ;if last digit of game timer set to 3, skip ahead
00B9F9  1  A0 00                ldy #$00               ;otherwise load one more potential value for state
00B9FB  1  C9 06                cmp #$06
00B9FD  1  F0 02                beq SetFWC             ;if last digit of game timer set to 6, skip ahead
00B9FF  1  A9 FF                lda #$ff               ;otherwise set value for no fireworks
00BA01  1  8D D7 06     SetFWC: sta FireworksCounter   ;set fireworks counter here
00BA04  1  94 1E                sty Enemy_State,x      ;set whatever state we have in star flag object
00BA06  1               
00BA06  1               IncrementSFTask1:
00BA06  1  EE 46 07           inc StarFlagTaskControl  ;increment star flag object task number
00BA09  1               
00BA09  1               StarFlagExit:
00BA09  1  60                 rts                      ;leave
00BA0A  1               
00BA0A  1               AwardGameTimerPoints:
00BA0A  1  AD F8 07              lda GameTimerDisplay   ;check all game timer digits for any intervals left
00BA0D  1  0D F9 07              ora GameTimerDisplay+1
00BA10  1  0D FA 07              ora GameTimerDisplay+2
00BA13  1  F0 F1                 beq IncrementSFTask1   ;if no time left on game timer at all, branch to next task
00BA15  1  A5 09                 lda FrameCounter
00BA17  1  29 04                 and #%00000100         ;check frame counter for d2 set (skip ahead
00BA19  1  F0 04                 beq NoTTick            ;for four frames every four frames) branch if not set
00BA1B  1  A9 10                 lda #Sfx_TimerTick
00BA1D  1  85 FE                 sta Square2SoundQueue  ;load timer tick sound
00BA1F  1  A0 23        NoTTick: ldy #$23               ;set offset here to subtract from game timer's last digit
00BA21  1  A9 FF                 lda #$ff               ;set adder here to $ff, or -1, to subtract one
00BA23  1  8D 39 01              sta DigitModifier+5    ;from the last digit of the game timer
00BA26  1  20 68 8B              jsr DigitsMathRoutine  ;subtract digit
00BA29  1  A9 05                 lda #$05               ;set now to add 50 points
00BA2B  1  8D 39 01              sta DigitModifier+5    ;per game timer interval subtracted
00BA2E  1               
00BA2E  1               EndAreaPoints:
00BA2E  1  A0 0B                 ldy #$0b               ;load offset for mario's score by default
00BA30  1  AD 53 07              lda CurrentPlayer      ;check player on the screen
00BA33  1  F0 02                 beq ELPGive            ;if mario, do not change
00BA35  1  A0 11                 ldy #$11               ;otherwise load offset for luigi's score
00BA37  1  20 68 8B     ELPGive: jsr DigitsMathRoutine  ;award 50 points per game timer interval
00BA3A  1  AD 53 07              lda CurrentPlayer      ;get player on the screen (or 500 points per
00BA3D  1  0A                    asl                    ;fireworks explosion if branched here from there)
00BA3E  1  0A                    asl                    ;shift to high nybble
00BA3F  1  0A                    asl
00BA40  1  0A                    asl
00BA41  1  09 04                 ora #%00000100         ;add four to set nybble for game timer
00BA43  1  4C 11 B4              jmp UpdateNumber       ;jump to print the new score and game timer
00BA46  1               
00BA46  1               RaiseFlagSetoffFWorks:
00BA46  1  B5 CF                 lda Enemy_Y_Position,x  ;check star flag's vertical position
00BA48  1  C9 72                 cmp #$72                ;against preset value
00BA4A  1  90 05                 bcc SetoffF             ;if star flag higher vertically, branch to other code
00BA4C  1  D6 CF                 dec Enemy_Y_Position,x  ;otherwise, raise star flag by one pixel
00BA4E  1  4C 5D BA              jmp DrawStarFlag        ;and skip this part here
00BA51  1  AD D7 06     SetoffF: lda FireworksCounter    ;check fireworks counter
00BA54  1  F0 38                 beq DrawFlagSetTimer    ;if no fireworks left to go off, skip this part
00BA56  1  30 36                 bmi DrawFlagSetTimer    ;if no fireworks set to go off, skip this part
00BA58  1  A9 16                 lda #Fireworks
00BA5A  1  8D CB 06              sta EnemyFrenzyBuffer   ;otherwise set fireworks object in frenzy queue
00BA5D  1               
00BA5D  1               DrawStarFlag:
00BA5D  1  20 EA EB              jsr RelativeEnemyPosition  ;get relative coordinates of star flag
00BA60  1  BC E5 06              ldy Enemy_SprDataOffset,x  ;get OAM data offset
00BA63  1  A2 03                 ldx #$03                   ;do four sprites
00BA65  1  AD B9 03     DSFLoop: lda Enemy_Rel_YPos         ;get relative vertical coordinate
00BA68  1  18                    clc
00BA69  1  7D C5 B9              adc StarFlagYPosAdder,x    ;add Y coordinate adder data
00BA6C  1  99 00 02              sta Sprite_Y_Position,y    ;store as Y coordinate
00BA6F  1  BD CD B9              lda StarFlagTileData,x     ;get tile number
00BA72  1  99 01 02              sta Sprite_Tilenumber,y    ;store as tile number
00BA75  1  A9 22                 lda #$22                   ;set palette and background priority bits
00BA77  1  99 02 02              sta Sprite_Attributes,y    ;store as attributes
00BA7A  1  AD AE 03              lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00BA7D  1  18                    clc
00BA7E  1  7D C9 B9              adc StarFlagXPosAdder,x    ;add X coordinate adder data
00BA81  1  99 03 02              sta Sprite_X_Position,y    ;store as X coordinate
00BA84  1  C8                    iny
00BA85  1  C8                    iny                        ;increment OAM data offset four bytes
00BA86  1  C8                    iny                        ;for next sprite
00BA87  1  C8                    iny
00BA88  1  CA                    dex                        ;move onto next sprite
00BA89  1  10 DA                 bpl DSFLoop                ;do this until all sprites are done
00BA8B  1  A6 08                 ldx ObjectOffset           ;get enemy object offset and leave
00BA8D  1  60                    rts
00BA8E  1               
00BA8E  1               DrawFlagSetTimer:
00BA8E  1  20 5D BA           jsr DrawStarFlag          ;do sub to draw star flag
00BA91  1  A9 06              lda #$06
00BA93  1  9D 96 07           sta EnemyIntervalTimer,x  ;set interval timer here
00BA96  1               
00BA96  1               IncrementSFTask2:
00BA96  1  EE 46 07           inc StarFlagTaskControl   ;move onto next task
00BA99  1  60                 rts
00BA9A  1               
00BA9A  1               DelayToAreaEnd:
00BA9A  1  20 5D BA           jsr DrawStarFlag          ;do sub to draw star flag
00BA9D  1  BD 96 07           lda EnemyIntervalTimer,x  ;if interval timer set in previous task
00BAA0  1  D0 05              bne StarFlagExit2         ;not yet expired, branch to leave
00BAA2  1  AD B1 07           lda EventMusicBuffer      ;if event music buffer empty,
00BAA5  1  F0 EF              beq IncrementSFTask2      ;branch to increment task
00BAA7  1               
00BAA7  1               StarFlagExit2:
00BAA7  1  60                 rts                       ;otherwise leave
00BAA8  1               
00BAA8  1               ;-------------------------------------------------------------------------------------
00BAA8  1               ;$04 - address low to jump address
00BAA8  1               ;$05 - address high to jump address
00BAA8  1               ;$06 - jump address low
00BAA8  1               ;$07 - jump address high
00BAA8  1               
00BAA8  1               JumpEngine:
00BAA8  1  0A                  asl          ;shift bit from contents of A
00BAA9  1  A8                  tay
00BAAA  1  68                  pla          ;pull saved return address from stack
00BAAB  1  85 04               sta $04      ;save to indirect
00BAAD  1  68                  pla
00BAAE  1  85 05               sta $05
00BAB0  1  C8                  iny
00BAB1  1  B1 04               lda ($04),y  ;load pointer from indirect
00BAB3  1  85 06               sta $06      ;note that if an RTS is performed in next routine
00BAB5  1  C8                  iny          ;it will return to the execution before the sub
00BAB6  1  B1 04               lda ($04),y  ;that called this routine
00BAB8  1  85 07               sta $07
00BABA  1  6C 06 00            jmp ($06)    ;jump to the address we loaded
00BABD  1               
00BABD  1               ;-------------------------------------------------------------------------------------
00BABD  1               
00BABD  1               ;$06 - RAM address low
00BABD  1               ;$07 - RAM address high
00BABD  1               
00BABD  1               InitializeMemory:
00BABD  1  AD FF 07                   lda BANK_SELECTED
00BAC0  1  48                         pha
00BAC1  1  A2 07                      ldx #$07          ;set initial high byte to $0700-$07ff
00BAC3  1  A9 00                      lda #$00          ;set initial low byte to start of page (at $00 of page)
00BAC5  1  85 06                      sta $06
00BAC7  1  86 07        InitPageLoop: stx $07
00BAC9  1  E0 01        InitByteLoop: cpx #$01          ;check to see if we're on the stack ($0100-$01ff)
00BACB  1  D0 04                      bne InitByte      ;if not, go ahead anyway
00BACD  1  C0 60                      cpy #$60          ;otherwise, check to see if we're at $0160-$01ff
00BACF  1  B0 02                      bcs SkipByte      ;if so, skip write
00BAD1  1  91 06        InitByte:     sta ($06),y       ;otherwise, initialize byte with current low byte in Y
00BAD3  1  88           SkipByte:     dey
00BAD4  1  C0 FF                      cpy #$ff          ;do this until all bytes in page have been erased
00BAD6  1  D0 F1                      bne InitByteLoop
00BAD8  1  CA                         dex               ;go onto the next page
00BAD9  1  10 EC                      bpl InitPageLoop  ;do this until all pages of memory have been erased
00BADB  1  68                         pla
00BADC  1  8D FF 07                   sta BANK_SELECTED
00BADF  1  A9 00                      lda #00
00BAE1  1  60                         rts
00BAE2  1               
00BAE2  1               ;-------------------------------------------------------------------------------------
00BAE2  1               ;$00 - vram buffer address table low
00BAE2  1               ;$01 - vram buffer address table high
00BAE2  1               
00BAE2  1               WriteBufferToScreen:
00BAE2  1  8D 06 20                    sta PPU_ADDRESS           ;store high byte of vram address
00BAE5  1  C8                          iny
00BAE6  1  B1 00                       lda ($00),y               ;load next byte (second)
00BAE8  1  8D 06 20                    sta PPU_ADDRESS           ;store low byte of vram address
00BAEB  1  C8                          iny
00BAEC  1  B1 00                       lda ($00),y               ;load next byte (third)
00BAEE  1  0A                          asl                       ;shift to left and save in stack
00BAEF  1  48                          pha
00BAF0  1  AD 78 07                    lda Mirror_PPU_CTRL_REG1  ;load mirror of $2000,
00BAF3  1  09 04                       ora #%00000100            ;set ppu to increment by 32 by default
00BAF5  1  B0 02                       bcs SetupWrites           ;if d7 of third byte was clear, ppu will
00BAF7  1  29 FB                       and #%11111011            ;only increment by 1
00BAF9  1  20 3D BB     SetupWrites:   jsr WritePPUReg1          ;write to register
00BAFC  1  68                          pla                       ;pull from stack and shift to left again
00BAFD  1  0A                          asl
00BAFE  1  90 03                       bcc GetLength             ;if d6 of third byte was clear, do not repeat byte
00BB00  1  09 02                       ora #%00000010            ;otherwise set d1 and increment Y
00BB02  1  C8                          iny
00BB03  1  4A           GetLength:     lsr                       ;shift back to the right to get proper length
00BB04  1  4A                          lsr                       ;note that d1 will now be in carry
00BB05  1  AA                          tax
00BB06  1  B0 01        OutputToVRAM:  bcs RepeatByte            ;if carry set, repeat loading the same byte
00BB08  1  C8                          iny                       ;otherwise increment Y to load next byte
00BB09  1  B1 00        RepeatByte:    lda ($00),y               ;load more data from buffer and write to vram
00BB0B  1  8D 07 20                    sta PPU_DATA
00BB0E  1  CA                          dex                       ;done writing?
00BB0F  1  D0 F5                       bne OutputToVRAM
00BB11  1  38                          sec
00BB12  1  98                          tya
00BB13  1  65 00                       adc $00                   ;add end length plus one to the indirect at $00
00BB15  1  85 00                       sta $00                   ;to allow this routine to read another set of updates
00BB17  1  A9 00                       lda #$00
00BB19  1  65 01                       adc $01
00BB1B  1  85 01                       sta $01
00BB1D  1  A9 3F                       lda #$3f                  ;sets vram address to $3f00
00BB1F  1  8D 06 20                    sta PPU_ADDRESS
00BB22  1  A9 00                       lda #$00
00BB24  1  8D 06 20                    sta PPU_ADDRESS
00BB27  1  8D 06 20                    sta PPU_ADDRESS           ;then reinitializes it for some reason
00BB2A  1  8D 06 20                    sta PPU_ADDRESS
00BB2D  1  AE 02 20     UpdateScreen:  ldx PPU_STATUS            ;reset flip-flop
00BB30  1  A0 00                       ldy #$00                  ;load first byte from indirect as a pointer
00BB32  1  B1 00                       lda ($00),y
00BB34  1  D0 AC                       bne WriteBufferToScreen   ;if byte is zero we have no further updates to make here
00BB36  1  8D 05 20     InitScroll:    sta PPU_SCROLL_REG        ;store contents of A into scroll registers
00BB39  1  8D 05 20                    sta PPU_SCROLL_REG        ;and end whatever subroutine led us here
00BB3C  1  60                          rts
00BB3D  1               
00BB3D  1               ;-------------------------------------------------------------------------------------
00BB3D  1               
00BB3D  1               WritePPUReg1:
00BB3D  1  8D 00 20                    sta PPU_CTRL_REG1         ;write contents of A to PPU register 1
00BB40  1  8D 78 07                    sta Mirror_PPU_CTRL_REG1  ;and its mirror
00BB43  1  60                          rts
00BB44  1               
00BB44  1               ;-------------------------------------------------------------------------------------
00BB44  1               
00BB44  1               InitializeNameTables:
00BB44  1  AD 02 20                   lda PPU_STATUS            ;reset flip-flop
00BB47  1  AD 78 07                   lda Mirror_PPU_CTRL_REG1  ;load mirror of ppu reg $2000
00BB4A  1  09 10                      ora #%00010000            ;set sprites for first 4k and background for second 4k
00BB4C  1  29 F0                      and #%11110000            ;clear rest of lower nybble, leave higher alone
00BB4E  1  20 3D BB                   jsr WritePPUReg1
00BB51  1  A9 24                      lda #$24                  ;set vram address to start of name table 1
00BB53  1  20 58 BB                   jsr WriteNTAddr
00BB56  1  A9 20                      lda #$20                  ;and then set it to name table 0
00BB58  1  8D 06 20     WriteNTAddr:  sta PPU_ADDRESS
00BB5B  1  A9 00                      lda #$00
00BB5D  1  8D 06 20                   sta PPU_ADDRESS
00BB60  1  A2 04                      ldx #$04                  ;clear name table with blank tile #24
00BB62  1  A0 C0                      ldy #$c0
00BB64  1  A9 24                      lda #$24
00BB66  1  8D 07 20     InitNTLoop:   sta PPU_DATA              ;count out exactly 768 tiles
00BB69  1  88                         dey
00BB6A  1  D0 FA                      bne InitNTLoop
00BB6C  1  CA                         dex
00BB6D  1  D0 F7                      bne InitNTLoop
00BB6F  1  A0 40                      ldy #64                   ;now to clear the attribute table (with zero this time)
00BB71  1  8A                         txa
00BB72  1  8D 00 03                   sta VRAM_Buffer1_Offset   ;init vram buffer 1 offset
00BB75  1  8D 01 03                   sta VRAM_Buffer1          ;init vram buffer 1
00BB78  1  8D 07 20     InitATLoop:   sta PPU_DATA
00BB7B  1  88                         dey
00BB7C  1  D0 FA                      bne InitATLoop
00BB7E  1  8D 3F 07                   sta HorizontalScroll      ;reset scroll variables
00BB81  1  8D 40 07                   sta VerticalScroll
00BB84  1  4C 36 BB                   jmp InitScroll            ;initialize scroll registers to zero
00BB87  1               
00BB87  1               ;-------------------------------------------------------------------------------------
00BB87  1               ;$00 - temp joypad bit
00BB87  1               
00BB87  1               ReadJoypads:
00BB87  1  A9 01                      lda #$01               ;reset and clear strobe of joypad ports
00BB89  1  8D 16 40                   sta JOYPAD_PORT
00BB8C  1  4A                         lsr
00BB8D  1  AA                         tax                    ;start with joypad 1's port
00BB8E  1  8D 16 40                   sta JOYPAD_PORT
00BB91  1  20 95 BB                   jsr ReadPortBits
00BB94  1  E8                         inx                    ;increment for joypad 2's port
00BB95  1  A0 08        ReadPortBits: ldy #$08
00BB97  1  48           PortLoop:     pha                    ;push previous bit onto stack
00BB98  1  BD 16 40                   lda JOYPAD_PORT,x      ;read current bit on joypad port
00BB9B  1  85 00                      sta $00                ;check d1 and d0 of port output
00BB9D  1  4A                         lsr                    ;this is necessary on the old
00BB9E  1  05 00                      ora $00                ;famicom systems in japan
00BBA0  1  4A                         lsr
00BBA1  1  68                         pla                    ;read bits from stack
00BBA2  1  2A                         rol                    ;rotate bit from carry flag
00BBA3  1  88                         dey
00BBA4  1  D0 F1                      bne PortLoop           ;count down bits left
00BBA6  1  9D FC 06                   sta SavedJoypadBits,x  ;save controller status here always
00BBA9  1  48                         pha
00BBAA  1  29 30                      and #%00110000         ;check for select or start
00BBAC  1  3D 4A 07                   and JoypadBitMask,x    ;if neither saved state nor current state
00BBAF  1  F0 07                      beq Save8Bits          ;have any of these two set, branch
00BBB1  1  68                         pla
00BBB2  1  29 CF                      and #%11001111         ;otherwise store without select
00BBB4  1  9D FC 06                   sta SavedJoypadBits,x  ;or start bits and leave
00BBB7  1  60                         rts
00BBB8  1  68           Save8Bits:    pla
00BBB9  1  9D 4A 07                   sta JoypadBitMask,x    ;save with all bits in another place and leave
00BBBC  1  60                         rts
00BBBD  1               
00BBBD  1               ;-------------------------------------------------------------------------------------
00BBBD  1               
00BBBD  1               MoveAllSpritesOffscreen:
00BBBD  1  A0 00                      ldy #$00                ;this routine moves all sprites off the screen
00BBBF  1  2C                         .byte $2c                 ;BIT instruction opcode
00BBC0  1               
00BBC0  1               MoveSpritesOffscreen:
00BBC0  1  A0 04                      ldy #$04                ;this routine moves all but sprite 0
00BBC2  1  A9 F8                      lda #$f8                ;off the screen
00BBC4  1  99 00 02     SprInitLoop:  sta Sprite_Y_Position,y ;write 248 into OAM data's Y coordinate
00BBC7  1  C8                         iny                     ;which will move it off the screen
00BBC8  1  C8                         iny
00BBC9  1  C8                         iny
00BBCA  1  C8                         iny
00BBCB  1  D0 F7                      bne SprInitLoop
00BBCD  1  60                         rts
00BBCE  1               
00BBCE  1               ;-------------------------------------------------------------------------------------
00BBCE  1               
00BBCE  1               LoadAreaPointer:
00BBCE  1  20 DE BB                  jsr FindAreaPointer  ;find it and store it here
00BBD1  1  8D 50 07                  sta AreaPointer
00BBD4  1  29 60        GetAreaType: and #%01100000       ;mask out all but d6 and d5
00BBD6  1  0A                        asl
00BBD7  1  2A                        rol
00BBD8  1  2A                        rol
00BBD9  1  2A                        rol                  ;make %0xx00000 into %000000xx
00BBDA  1  8D 4E 07                  sta AreaType         ;save 2 MSB as area type
00BBDD  1  60                        rts
00BBDE  1               
00BBDE  1               FindAreaPointer:
00BBDE  1  AC 5F 07           ldy WorldNumber        ;load offset from world variable
00BBE1  1  B9 ED BB           lda WorldAddrOffsets,y
00BBE4  1  18                 clc                    ;add area number used to find data
00BBE5  1  6D 60 07           adc AreaNumber
00BBE8  1  A8                 tay
00BBE9  1  B9 F5 BB           lda AreaAddrOffsets,y  ;from there we have our area pointer
00BBEC  1  60                 rts
00BBED  1               
00BBED  1               ;-------------------------------------------------------------------------------------
00BBED  1               ;GAME LEVELS DATA
00BBED  1               
00BBED  1               WorldAddrOffsets:
00BBED  1  00 05              .byte World1Areas-AreaAddrOffsets, World2Areas-AreaAddrOffsets
00BBEF  1  0A 0E              .byte World3Areas-AreaAddrOffsets, World4Areas-AreaAddrOffsets
00BBF1  1  13 17              .byte World5Areas-AreaAddrOffsets, World6Areas-AreaAddrOffsets
00BBF3  1  1B 20              .byte World7Areas-AreaAddrOffsets, World8Areas-AreaAddrOffsets
00BBF5  1               
00BBF5  1               AreaAddrOffsets:
00BBF5  1  25 29 C0 26  World1Areas: .byte $25, $29, $c0, $26, $60
00BBF9  1  60           
00BBFA  1  28 29 01 27  World2Areas: .byte $28, $29, $01, $27, $62
00BBFE  1  62           
00BBFF  1  24 35 20 63  World3Areas: .byte $24, $35, $20, $63
00BC03  1  22 29 41 2C  World4Areas: .byte $22, $29, $41, $2c, $61
00BC07  1  61           
00BC08  1  2A 31 26 62  World5Areas: .byte $2a, $31, $26, $62
00BC0C  1  2E 23 2D 60  World6Areas: .byte $2e, $23, $2d, $60
00BC10  1  33 29 01 27  World7Areas: .byte $33, $29, $01, $27, $64
00BC14  1  64           
00BC15  1  30 32 21 65  World8Areas: .byte $30, $32, $21, $65
00BC19  1               
00BC19  1               ;-------------------------------------------------------------------------------------
00BC19  1               
00BC19  1               GetScreenPosition:
00BC19  1  AD 1C 07           lda ScreenLeft_X_Pos    ;get coordinate of screen's left boundary
00BC1C  1  18                 clc
00BC1D  1  69 FF              adc #$ff                ;add 255 pixels
00BC1F  1  8D 1D 07           sta ScreenRight_X_Pos   ;store as coordinate of screen's right boundary
00BC22  1  AD 1A 07           lda ScreenLeft_PageLoc  ;get page number where left boundary is
00BC25  1  69 00              adc #$00                ;add carry from before
00BC27  1  8D 1B 07           sta ScreenRight_PageLoc ;store as page number where right boundary is
00BC2A  1  60                 rts
00BC2B  1               
00BC2B  1               ;-------------------------------------------------------------------------------------
00BC2B  1               
00BC2B  1               SetupPowerUp:
00BC2B  1  A9 2E                   lda #PowerUpObject        ;load power-up identifier into
00BC2D  1  85 1B                   sta Enemy_ID+5            ;special use slot of enemy object buffer
00BC2F  1  B5 76                   lda Block_PageLoc,x       ;store page location of block object
00BC31  1  85 73                   sta Enemy_PageLoc+5       ;as page location of power-up object
00BC33  1  B5 8F                   lda Block_X_Position,x    ;store horizontal coordinate of block object
00BC35  1  85 8C                   sta Enemy_X_Position+5    ;as horizontal coordinate of power-up object
00BC37  1  A9 01                   lda #$01
00BC39  1  85 BB                   sta Enemy_Y_HighPos+5     ;set vertical high byte of power-up object
00BC3B  1  B5 D7                   lda Block_Y_Position,x    ;get vertical coordinate of block object
00BC3D  1  38                      sec
00BC3E  1  E9 08                   sbc #$08                  ;subtract 8 pixels
00BC40  1  85 D4                   sta Enemy_Y_Position+5    ;and use as vertical coordinate of power-up object
00BC42  1  A9 01        PwrUpJmp:  lda #$01                  ;this is a residual jump point in enemy object jump table
00BC44  1  85 23                   sta Enemy_State+5         ;set power-up object's state
00BC46  1  85 14                   sta Enemy_Flag+5          ;set buffer flag
00BC48  1  A9 03                   lda #$03
00BC4A  1  8D 9F 04                sta Enemy_BoundBoxCtrl+5  ;set bounding box size control for power-up object
00BC4D  1  A5 39                   lda PowerUpType
00BC4F  1  C9 02                   cmp #$02                  ;check currently loaded power-up type
00BC51  1  B0 0A                   bcs PutBehind             ;if star or 1-up, branch ahead
00BC53  1  AD 56 07                lda PlayerStatus          ;otherwise check player's current status
00BC56  1  C9 02                   cmp #$02
00BC58  1  90 01                   bcc StrType               ;if player not fiery, use status as power-up type
00BC5A  1  4A                      lsr                       ;otherwise shift right to force fire flower type
00BC5B  1  85 39        StrType:   sta PowerUpType           ;store type here
00BC5D  1  A9 20        PutBehind: lda #%00100000
00BC5F  1  8D CA 03                sta Enemy_SprAttrib+5     ;set background priority bit
00BC62  1  A9 02                   lda #Sfx_GrowPowerUp
00BC64  1  85 FE                   sta Square2SoundQueue     ;load power-up reveal sound and leave
00BC66  1  60                      rts
00BC67  1               
00BC67  1               ;-------------------------------------------------------------------------------------
00BC67  1               
00BC67  1               PowerUpObjHandler:
00BC67  1  A2 05                 ldx #$05                   ;set object offset for last slot in enemy object buffer
00BC69  1  86 08                 stx ObjectOffset
00BC6B  1  A5 23                 lda Enemy_State+5          ;check power-up object's state
00BC6D  1  F0 5D                 beq ExitPUp                ;if not set, branch to leave
00BC6F  1  0A                    asl                        ;shift to check if d7 was set in object state
00BC70  1  90 23                 bcc GrowThePowerUp         ;if not set, branch ahead to skip this part
00BC72  1  AD 47 07              lda TimerControl           ;if master timer control set,
00BC75  1  D0 43                 bne RunPUSubs              ;branch ahead to enemy object routines
00BC77  1  A5 39                 lda PowerUpType            ;check power-up type
00BC79  1  F0 11                 beq ShroomM                ;if normal mushroom, branch ahead to move it
00BC7B  1  C9 03                 cmp #$03
00BC7D  1  F0 0D                 beq ShroomM                ;if 1-up mushroom, branch ahead to move it
00BC7F  1  C9 02                 cmp #$02
00BC81  1  D0 37                 bne RunPUSubs              ;if not star, branch elsewhere to skip movement
00BC83  1  20 2F C7              jsr MoveJumpingEnemy       ;otherwise impose gravity on star power-up and make it jump
00BC86  1  20 1B DC              jsr EnemyJump              ;note that green paratroopa shares the same code here
00BC89  1  4C BA BC              jmp RunPUSubs              ;then jump to other power-up subroutines
00BC8C  1  20 AD C6     ShroomM: jsr MoveNormalEnemy        ;do sub to make mushrooms move
00BC8F  1  20 79 DA              jsr EnemyToBGCollisionDet  ;deal with collisions
00BC92  1  4C BA BC              jmp RunPUSubs              ;run the other subroutines
00BC95  1               
00BC95  1               GrowThePowerUp:
00BC95  1  A5 09                   lda FrameCounter           ;get frame counter
00BC97  1  29 03                   and #$03                   ;mask out all but 2 LSB
00BC99  1  D0 19                   bne ChkPUSte               ;if any bits set here, branch
00BC9B  1  C6 D4                   dec Enemy_Y_Position+5     ;otherwise decrement vertical coordinate slowly
00BC9D  1  A5 23                   lda Enemy_State+5          ;load power-up object state
00BC9F  1  E6 23                   inc Enemy_State+5          ;increment state for next frame (to make power-up rise)
00BCA1  1  C9 11                   cmp #$11                   ;if power-up object state not yet past 16th pixel,
00BCA3  1  90 0F                   bcc ChkPUSte               ;branch ahead to last part here
00BCA5  1  A9 10                   lda #$10
00BCA7  1  95 58                   sta Enemy_X_Speed,x        ;otherwise set horizontal speed
00BCA9  1  A9 80                   lda #%10000000
00BCAB  1  85 23                   sta Enemy_State+5          ;and then set d7 in power-up object's state
00BCAD  1  0A                      asl                        ;shift once to init A
00BCAE  1  8D CA 03                sta Enemy_SprAttrib+5      ;initialize background priority bit set here
00BCB1  1  2A                      rol                        ;rotate A to set right moving direction
00BCB2  1  95 46                   sta Enemy_MovingDir,x      ;set moving direction
00BCB4  1  A5 23        ChkPUSte:  lda Enemy_State+5          ;check power-up object's state
00BCB6  1  C9 06                   cmp #$06                   ;for if power-up has risen enough
00BCB8  1  90 12                   bcc ExitPUp                ;if not, don't even bother running these routines
00BCBA  1  20 EA EB     RunPUSubs: jsr RelativeEnemyPosition  ;get coordinates relative to screen
00BCBD  1  20 47 EC                jsr GetEnemyOffscreenBits  ;get offscreen bits
00BCC0  1  20 FB DC                jsr GetEnemyBoundBox       ;get bounding box coordinates
00BCC3  1  20 8A E1                jsr DrawPowerUp            ;draw the power-up object
00BCC6  1  20 6E D3                jsr PlayerEnemyCollision   ;check for collision with player
00BCC9  1  20 95 D1                jsr OffscreenBoundsCheck   ;check to see if it went offscreen
00BCCC  1  60           ExitPUp:   rts                        ;and we're done
00BCCD  1               
00BCCD  1               ;-------------------------------------------------------------------------------------
00BCCD  1               ;These apply to all routines in this section unless otherwise noted:
00BCCD  1               ;$00 - used to store metatile from block buffer routine
00BCCD  1               ;$02 - used to store vertical high nybble offset from block buffer routine
00BCCD  1               ;$05 - used to store metatile stored in A at beginning of PlayerHeadCollision
00BCCD  1               ;$06-$07 - used as block buffer address indirect
00BCCD  1               
00BCCD  1               BlockYPosAdderData:
00BCCD  1  04 12              .byte $04, $12
00BCCF  1               
00BCCF  1               PlayerHeadCollision:
00BCCF  1  48                      pha                      ;store metatile number to stack
00BCD0  1  A9 11                   lda #$11                 ;load unbreakable block object state by default
00BCD2  1  AE EE 03                ldx SprDataOffset_Ctrl   ;load offset control bit here
00BCD5  1  AC 54 07                ldy PlayerSize           ;check player's size
00BCD8  1  D0 02                   bne DBlockSte            ;if small, branch
00BCDA  1  A9 12                   lda #$12                 ;otherwise load breakable block object state
00BCDC  1  95 26        DBlockSte: sta Block_State,x        ;store into block object buffer
00BCDE  1  20 48 EF                jsr DestroyBlockMetatile ;store blank metatile in vram buffer to write to name table
00BCE1  1  AE EE 03                ldx SprDataOffset_Ctrl   ;load offset control bit
00BCE4  1  A5 02                   lda $02                  ;get vertical high nybble offset used in block buffer routine
00BCE6  1  9D E4 03                sta Block_Orig_YPos,x    ;set as vertical coordinate for block object
00BCE9  1  A8                      tay
00BCEA  1  A5 06                   lda $06                  ;get low byte of block buffer address used in same routine
00BCEC  1  9D E6 03                sta Block_BBuf_Low,x     ;save as offset here to be used later
00BCEF  1  B1 06                   lda ($06),y              ;get contents of block buffer at old address at $06, $07
00BCF1  1  20 D8 BD                jsr BlockBumpedChk       ;do a sub to check which block player bumped head on
00BCF4  1  85 00                   sta $00                  ;store metatile here
00BCF6  1  AC 54 07                ldy PlayerSize           ;check player's size
00BCF9  1  D0 01                   bne ChkBrick             ;if small, use metatile itself as contents of A
00BCFB  1  98                      tya                      ;otherwise init A (note: big = 0)
00BCFC  1  90 25        ChkBrick:  bcc PutMTileB            ;if no match was found in previous sub, skip ahead
00BCFE  1  A0 11                   ldy #$11                 ;otherwise load unbreakable state into block object buffer
00BD00  1  94 26                   sty Block_State,x        ;note this applies to both player sizes
00BD02  1  A9 C4                   lda #$c4                 ;load empty block metatile into A for now
00BD04  1  A4 00                   ldy $00                  ;get metatile from before
00BD06  1  C0 58                   cpy #$58                 ;is it brick with coins (with line)?
00BD08  1  F0 04                   beq StartBTmr            ;if so, branch
00BD0A  1  C0 5D                   cpy #$5d                 ;is it brick with coins (without line)?
00BD0C  1  D0 15                   bne PutMTileB            ;if not, branch ahead to store empty block metatile
00BD0E  1  AD BC 06     StartBTmr: lda BrickCoinTimerFlag   ;check brick coin timer flag
00BD11  1  D0 08                   bne ContBTmr             ;if set, timer expired or counting down, thus branch
00BD13  1  A9 0B                   lda #$0b
00BD15  1  8D 9D 07                sta BrickCoinTimer       ;if not set, set brick coin timer
00BD18  1  EE BC 06                inc BrickCoinTimerFlag   ;and set flag linked to it
00BD1B  1  AD 9D 07     ContBTmr:  lda BrickCoinTimer       ;check brick coin timer
00BD1E  1  D0 02                   bne PutOldMT             ;if not yet expired, branch to use current metatile
00BD20  1  A0 C4                   ldy #$c4                 ;otherwise use empty block metatile
00BD22  1  98           PutOldMT:  tya                      ;put metatile into A
00BD23  1  9D E8 03     PutMTileB: sta Block_Metatile,x     ;store whatever metatile be appropriate here
00BD26  1  20 66 BD                jsr InitBlock_XY_Pos     ;get block object horizontal coordinates saved
00BD29  1  A4 02                   ldy $02                  ;get vertical high nybble offset
00BD2B  1  A9 23                   lda #$23
00BD2D  1  91 06                   sta ($06),y              ;write blank metatile $23 to block buffer
00BD2F  1  A9 10                   lda #$10
00BD31  1  8D 84 07                sta BlockBounceTimer     ;set block bounce timer
00BD34  1  68                      pla                      ;pull original metatile from stack
00BD35  1  85 05                   sta $05                  ;and save here
00BD37  1  A0 00                   ldy #$00                 ;set default offset
00BD39  1  AD 14 07                lda CrouchingFlag        ;is player crouching?
00BD3C  1  D0 05                   bne SmallBP              ;if so, branch to increment offset
00BD3E  1  AD 54 07                lda PlayerSize           ;is player big?
00BD41  1  F0 01                   beq BigBP                ;if so, branch to use default offset
00BD43  1  C8           SmallBP:   iny                      ;increment for small or big and crouching
00BD44  1  A5 CE        BigBP:     lda Player_Y_Position    ;get player's vertical coordinate
00BD46  1  18                      clc
00BD47  1  79 CD BC                adc BlockYPosAdderData,y ;add value determined by size
00BD4A  1  29 F0                   and #$f0                 ;mask out low nybble to get 16-pixel correspondence
00BD4C  1  95 D7                   sta Block_Y_Position,x   ;save as vertical coordinate for block object
00BD4E  1  B4 26                   ldy Block_State,x        ;get block object state
00BD50  1  C0 11                   cpy #$11
00BD52  1  F0 06                   beq Unbreak              ;if set to value loaded for unbreakable, branch
00BD54  1  20 E4 BD                jsr BrickShatter         ;execute code for breakable brick
00BD57  1  4C 5D BD                jmp InvOBit              ;skip subroutine to do last part of code here
00BD5A  1  20 7D BD     Unbreak:   jsr BumpBlock            ;execute code for unbreakable brick or question block
00BD5D  1  AD EE 03     InvOBit:   lda SprDataOffset_Ctrl   ;invert control bit used by block objects
00BD60  1  49 01                   eor #$01                 ;and floatey numbers
00BD62  1  8D EE 03                sta SprDataOffset_Ctrl
00BD65  1  60                      rts                      ;leave!
00BD66  1               
00BD66  1               ;--------------------------------
00BD66  1               
00BD66  1               InitBlock_XY_Pos:
00BD66  1  A5 86              lda Player_X_Position   ;get player's horizontal coordinate
00BD68  1  18                 clc
00BD69  1  69 08              adc #$08                ;add eight pixels
00BD6B  1  29 F0              and #$f0                ;mask out low nybble to give 16-pixel correspondence
00BD6D  1  95 8F              sta Block_X_Position,x  ;save as horizontal coordinate for block object
00BD6F  1  A5 6D              lda Player_PageLoc
00BD71  1  69 00              adc #$00                ;add carry to page location of player
00BD73  1  95 76              sta Block_PageLoc,x     ;save as page location of block object
00BD75  1  9D EA 03           sta Block_PageLoc2,x    ;save elsewhere to be used later
00BD78  1  A5 B5              lda Player_Y_HighPos
00BD7A  1  95 BE              sta Block_Y_HighPos,x   ;save vertical high byte of player into
00BD7C  1  60                 rts                     ;vertical high byte of block object and leave
00BD7D  1               
00BD7D  1               ;--------------------------------
00BD7D  1               
00BD7D  1               BumpBlock:
00BD7D  1  20 01 BE                jsr CheckTopOfBlock     ;check to see if there's a coin directly above this block
00BD80  1  A9 02                   lda #Sfx_Bump
00BD82  1  85 FF                   sta Square1SoundQueue   ;play bump sound
00BD84  1  A9 00                   lda #$00
00BD86  1  95 60                   sta Block_X_Speed,x     ;initialize horizontal speed for block object
00BD88  1  9D 3C 04                sta Block_Y_MoveForce,x ;init fractional movement force
00BD8B  1  85 9F                   sta Player_Y_Speed      ;init player's vertical speed
00BD8D  1  A9 FE                   lda #$fe
00BD8F  1  95 A8                   sta Block_Y_Speed,x     ;set vertical speed for block object
00BD91  1  A5 05                   lda $05                 ;get original metatile from stack
00BD93  1  20 D8 BD                jsr BlockBumpedChk      ;do a sub to check which block player bumped head on
00BD96  1  90 31                   bcc ExitBlockChk        ;if no match was found, branch to leave
00BD98  1  98                      tya                     ;move block number to A
00BD99  1  C9 09                   cmp #$09                ;if block number was within 0-8 range,
00BD9B  1  90 02                   bcc BlockCode           ;branch to use current number
00BD9D  1  E9 05                   sbc #$05                ;otherwise subtract 5 for second set to get proper number
00BD9F  1  20 A8 BA     BlockCode: jsr JumpEngine          ;run appropriate subroutine depending on block number
00BDA2  1               
00BDA2  1  B4 BD              .word MushFlowerBlock
00BDA4  1  B8 EE              .word CoinBlock
00BDA6  1  B8 EE              .word CoinBlock
00BDA8  1  BA BD              .word ExtraLifeMushBlock
00BDAA  1  B4 BD              .word MushFlowerBlock
00BDAC  1  C1 BD              .word VineBlock
00BDAE  1  B7 BD              .word StarBlock
00BDB0  1  B8 EE              .word CoinBlock
00BDB2  1  BA BD              .word ExtraLifeMushBlock
00BDB4  1               
00BDB4  1               ;--------------------------------
00BDB4  1               
00BDB4  1               MushFlowerBlock:
00BDB4  1  A9 00              lda #$00       ;load mushroom/fire flower into power-up type
00BDB6  1  2C                 .byte $2c        ;BIT instruction opcode
00BDB7  1               
00BDB7  1               StarBlock:
00BDB7  1  A9 02              lda #$02       ;load star into power-up type
00BDB9  1  2C                 .byte $2c        ;BIT instruction opcode
00BDBA  1               
00BDBA  1               ExtraLifeMushBlock:
00BDBA  1  A9 03              lda #$03         ;load 1-up mushroom into power-up type
00BDBC  1  85 39              sta $39          ;store correct power-up type
00BDBE  1  4C 2B BC           jmp SetupPowerUp
00BDC1  1               
00BDC1  1               VineBlock:
00BDC1  1  A2 05              ldx #$05                ;load last slot for enemy object buffer
00BDC3  1  AC EE 03           ldy SprDataOffset_Ctrl  ;get control bit
00BDC6  1  20 7B ED           jsr Setup_Vine          ;set up vine object
00BDC9  1               
00BDC9  1               ExitBlockChk:
00BDC9  1  60                 rts                     ;leave
00BDCA  1               
00BDCA  1               ;--------------------------------
00BDCA  1               
00BDCA  1               BrickQBlockMetatiles:
00BDCA  1  C1 C0 5F 60        .byte $c1, $c0, $5f, $60 ;used by question blocks
00BDCE  1               
00BDCE  1                     ;these two sets are functionally identical, but look different
00BDCE  1  55 56 57 58        .byte $55, $56, $57, $58, $59 ;used by ground level types
00BDD2  1  59           
00BDD3  1  5A 5B 5C 5D        .byte $5a, $5b, $5c, $5d, $5e ;used by other level types
00BDD7  1  5E           
00BDD8  1               
00BDD8  1               BlockBumpedChk:
00BDD8  1  A0 0D                     ldy #$0d                    ;start at end of metatile data
00BDDA  1  D9 CA BD     BumpChkLoop: cmp BrickQBlockMetatiles,y  ;check to see if current metatile matches
00BDDD  1  F0 04                     beq MatchBump               ;metatile found in block buffer, branch if so
00BDDF  1  88                        dey                         ;otherwise move onto next metatile
00BDE0  1  10 F8                     bpl BumpChkLoop             ;do this until all metatiles are checked
00BDE2  1  18                        clc                         ;if none match, return with carry clear
00BDE3  1  60           MatchBump:   rts                         ;note carry is set if found match
00BDE4  1               
00BDE4  1               ;--------------------------------
00BDE4  1               
00BDE4  1               BrickShatter:
00BDE4  1  20 01 BE           jsr CheckTopOfBlock    ;check to see if there's a coin directly above this block
00BDE7  1  A9 01              lda #Sfx_BrickShatter
00BDE9  1  9D EC 03           sta Block_RepFlag,x    ;set flag for block object to immediately replace metatile
00BDEC  1  85 FD              sta NoiseSoundQueue    ;load brick shatter sound
00BDEE  1  20 23 BE           jsr SpawnBrickChunks   ;create brick chunk objects
00BDF1  1  A9 FE              lda #$fe
00BDF3  1  85 9F              sta Player_Y_Speed     ;set vertical speed for player
00BDF5  1  A9 05              lda #$05
00BDF7  1  8D 39 01           sta DigitModifier+5    ;set digit modifier to give player 50 points
00BDFA  1  20 11 B4           jsr AddToScore         ;do sub to update the score
00BDFD  1  AE EE 03           ldx SprDataOffset_Ctrl ;load control bit and leave
00BE00  1  60                 rts
00BE01  1               
00BE01  1               ;--------------------------------
00BE01  1               
00BE01  1               CheckTopOfBlock:
00BE01  1  AE EE 03            ldx SprDataOffset_Ctrl  ;load control bit
00BE04  1  A4 02               ldy $02                 ;get vertical high nybble offset used in block buffer
00BE06  1  F0 1A               beq TopEx               ;branch to leave if set to zero, because we're at the top
00BE08  1  98                  tya                     ;otherwise set to A
00BE09  1  38                  sec
00BE0A  1  E9 10               sbc #$10                ;subtract $10 to move up one row in the block buffer
00BE0C  1  85 02               sta $02                 ;store as new vertical high nybble offset
00BE0E  1  A8                  tay
00BE0F  1  B1 06               lda ($06),y             ;get contents of block buffer in same column, one row up
00BE11  1  C9 C2               cmp #$c2                ;is it a coin? (not underwater)
00BE13  1  D0 0D               bne TopEx               ;if not, branch to leave
00BE15  1  A9 00               lda #$00
00BE17  1  91 06               sta ($06),y             ;otherwise put blank metatile where coin was
00BE19  1  20 2A EF            jsr RemoveCoin_Axe      ;write blank metatile to vram buffer
00BE1C  1  AE EE 03            ldx SprDataOffset_Ctrl  ;get control bit
00BE1F  1  20 D1 EE            jsr SetupJumpCoin       ;create jumping coin object and update coin variables
00BE22  1  60           TopEx: rts                     ;leave!
00BE23  1               
00BE23  1               ;--------------------------------
00BE23  1               
00BE23  1               SpawnBrickChunks:
00BE23  1  B5 8F              lda Block_X_Position,x     ;set horizontal coordinate of block object
00BE25  1  9D F1 03           sta Block_Orig_XPos,x      ;as original horizontal coordinate here
00BE28  1  A9 F0              lda #$f0
00BE2A  1  95 60              sta Block_X_Speed,x        ;set horizontal speed for brick chunk objects
00BE2C  1  95 62              sta Block_X_Speed+2,x
00BE2E  1  A9 FA              lda #$fa
00BE30  1  95 A8              sta Block_Y_Speed,x        ;set vertical speed for one
00BE32  1  A9 FC              lda #$fc
00BE34  1  95 AA              sta Block_Y_Speed+2,x      ;set lower vertical speed for the other
00BE36  1  A9 00              lda #$00
00BE38  1  9D 3C 04           sta Block_Y_MoveForce,x    ;init fractional movement force for both
00BE3B  1  9D 3E 04           sta Block_Y_MoveForce+2,x
00BE3E  1  B5 76              lda Block_PageLoc,x
00BE40  1  95 78              sta Block_PageLoc+2,x      ;copy page location
00BE42  1  B5 8F              lda Block_X_Position,x
00BE44  1  95 91              sta Block_X_Position+2,x   ;copy horizontal coordinate
00BE46  1  B5 D7              lda Block_Y_Position,x
00BE48  1  18                 clc                        ;add 8 pixels to vertical coordinate
00BE49  1  69 08              adc #$08                   ;and save as vertical coordinate for one of them
00BE4B  1  95 D9              sta Block_Y_Position+2,x
00BE4D  1  A9 FA              lda #$fa
00BE4F  1  95 A8              sta Block_Y_Speed,x        ;set vertical speed...again??? (redundant)
00BE51  1  60                 rts
00BE52  1               
00BE52  1               ;-------------------------------------------------------------------------------------
00BE52  1               
00BE52  1               BlockObjectsCore:
00BE52  1  B5 26                lda Block_State,x           ;get state of block object
00BE54  1  F0 5D                beq UpdSte                  ;if not set, branch to leave
00BE56  1  29 0F                and #$0f                    ;mask out high nybble
00BE58  1  48                   pha                         ;push to stack
00BE59  1  A8                   tay                         ;put in Y for now
00BE5A  1  8A                   txa
00BE5B  1  18                   clc
00BE5C  1  69 09                adc #$09                    ;add 9 bytes to offset (note two block objects are created
00BE5E  1  AA                   tax                         ;when using brick chunks, but only one offset for both)
00BE5F  1  88                   dey                         ;decrement Y to check for solid block state
00BE60  1  F0 33                beq BouncingBlockHandler    ;branch if found, otherwise continue for brick chunks
00BE62  1  20 86 BF             jsr ImposeGravityBlock      ;do sub to impose gravity on one block object object
00BE65  1  20 F1 BE             jsr MoveObjectHorizontally  ;do another sub to move horizontally
00BE68  1  8A                   txa
00BE69  1  18                   clc                         ;move onto next block object
00BE6A  1  69 02                adc #$02
00BE6C  1  AA                   tax
00BE6D  1  20 86 BF             jsr ImposeGravityBlock      ;do sub to impose gravity on other block object
00BE70  1  20 F1 BE             jsr MoveObjectHorizontally  ;do another sub to move horizontally
00BE73  1  A6 08                ldx ObjectOffset            ;get block object offset used for both
00BE75  1  20 F1 EB             jsr RelativeBlockPosition   ;get relative coordinates
00BE78  1  20 4E EC             jsr GetBlockOffscreenBits   ;get offscreen information
00BE7B  1  20 0B E7             jsr DrawBrickChunks         ;draw the brick chunks
00BE7E  1  68                   pla                         ;get lower nybble of saved state
00BE7F  1  B4 BE                ldy Block_Y_HighPos,x       ;check vertical high byte of block object
00BE81  1  F0 30                beq UpdSte                  ;if above the screen, branch to kill it
00BE83  1  48                   pha                         ;otherwise save state back into stack
00BE84  1  A9 F0                lda #$f0
00BE86  1  D5 D9                cmp Block_Y_Position+2,x    ;check to see if bottom block object went
00BE88  1  B0 02                bcs ChkTop                  ;to the bottom of the screen, and branch if not
00BE8A  1  95 D9                sta Block_Y_Position+2,x    ;otherwise set offscreen coordinate
00BE8C  1  B5 D7        ChkTop: lda Block_Y_Position,x      ;get top block object's vertical coordinate
00BE8E  1  C9 F0                cmp #$f0                    ;see if it went to the bottom of the screen
00BE90  1  68                   pla                         ;pull block object state from stack
00BE91  1  90 20                bcc UpdSte                  ;if not, branch to save state
00BE93  1  B0 1C                bcs KillBlock               ;otherwise do unconditional branch to kill it
00BE95  1               
00BE95  1               BouncingBlockHandler:
00BE95  1  20 86 BF                jsr ImposeGravityBlock     ;do sub to impose gravity on block object
00BE98  1  A6 08                   ldx ObjectOffset           ;get block object offset
00BE9A  1  20 F1 EB                jsr RelativeBlockPosition  ;get relative coordinates
00BE9D  1  20 4E EC                jsr GetBlockOffscreenBits  ;get offscreen information
00BEA0  1  20 89 E6                jsr DrawBlock              ;draw the block
00BEA3  1  B5 D7                   lda Block_Y_Position,x     ;get vertical coordinate
00BEA5  1  29 0F                   and #$0f                   ;mask out high nybble
00BEA7  1  C9 05                   cmp #$05                   ;check to see if low nybble wrapped around
00BEA9  1  68                      pla                        ;pull state from stack
00BEAA  1  B0 07                   bcs UpdSte                 ;if still above amount, not time to kill block yet, thus branch
00BEAC  1  A9 01                   lda #$01
00BEAE  1  9D EC 03                sta Block_RepFlag,x        ;otherwise set flag to replace metatile
00BEB1  1  A9 00        KillBlock: lda #$00                   ;if branched here, nullify object state
00BEB3  1  95 26        UpdSte:    sta Block_State,x          ;store contents of A in block object state
00BEB5  1  60                      rts
00BEB6  1               
00BEB6  1               ;-------------------------------------------------------------------------------------
00BEB6  1               ;$02 - used to store offset to block buffer
00BEB6  1               ;$06-$07 - used to store block buffer address
00BEB6  1               
00BEB6  1               BlockObjMT_Updater:
00BEB6  1  A2 01                    ldx #$01                  ;set offset to start with second block object
00BEB8  1  86 08        UpdateLoop: stx ObjectOffset          ;set offset here
00BEBA  1  AD 01 03                 lda VRAM_Buffer1          ;if vram buffer already being used here,
00BEBD  1  D0 21                    bne NextBUpd              ;branch to move onto next block object
00BEBF  1  BD EC 03                 lda Block_RepFlag,x       ;if flag for block object already clear,
00BEC2  1  F0 1C                    beq NextBUpd              ;branch to move onto next block object
00BEC4  1  BD E6 03                 lda Block_BBuf_Low,x      ;get low byte of block buffer
00BEC7  1  85 06                    sta $06                   ;store into block buffer address
00BEC9  1  A9 05                    lda #$05
00BECB  1  85 07                    sta $07                   ;set high byte of block buffer address
00BECD  1  BD E4 03                 lda Block_Orig_YPos,x     ;get original vertical coordinate of block object
00BED0  1  85 02                    sta $02                   ;store here and use as offset to block buffer
00BED2  1  A8                       tay
00BED3  1  BD E8 03                 lda Block_Metatile,x      ;get metatile to be written
00BED6  1  91 06                    sta ($06),y               ;write it to the block buffer
00BED8  1  20 3E EF                 jsr ReplaceBlockMetatile  ;do sub to replace metatile where block object is
00BEDB  1  A9 00                    lda #$00
00BEDD  1  9D EC 03                 sta Block_RepFlag,x       ;clear block object flag
00BEE0  1  CA           NextBUpd:   dex                       ;decrement block object offset
00BEE1  1  10 D5                    bpl UpdateLoop            ;do this until both block objects are dealt with
00BEE3  1  60                       rts                       ;then leave
00BEE4  1               
00BEE4  1               ;-------------------------------------------------------------------------------------
00BEE4  1               ;$00 - used to store high nybble of horizontal speed as adder
00BEE4  1               ;$01 - used to store low nybble of horizontal speed
00BEE4  1               ;$02 - used to store adder to page location
00BEE4  1               
00BEE4  1               MoveEnemyHorizontally:
00BEE4  1  E8                 inx                         ;increment offset for enemy offset
00BEE5  1  20 F1 BE           jsr MoveObjectHorizontally  ;position object horizontally according to
00BEE8  1  A6 08              ldx ObjectOffset            ;counters, return with saved value in A,
00BEEA  1  60                 rts                         ;put enemy offset back in X and leave
00BEEB  1               
00BEEB  1               MovePlayerHorizontally:
00BEEB  1  AD 0E 07           lda JumpspringAnimCtrl  ;if jumpspring currently animating,
00BEEE  1  D0 3E              bne ExXMove             ;branch to leave
00BEF0  1  AA                 tax                     ;otherwise set zero for offset to use player's stuff
00BEF1  1               
00BEF1  1               MoveObjectHorizontally:
00BEF1  1  B5 57                  lda SprObject_X_Speed,x     ;get currently saved value (horizontal
00BEF3  1  0A                     asl                         ;speed, secondary counter, whatever)
00BEF4  1  0A                     asl                         ;and move low nybble to high
00BEF5  1  0A                     asl
00BEF6  1  0A                     asl
00BEF7  1  85 01                  sta $01                     ;store result here
00BEF9  1  B5 57                  lda SprObject_X_Speed,x     ;get saved value again
00BEFB  1  4A                     lsr                         ;move high nybble to low
00BEFC  1  4A                     lsr
00BEFD  1  4A                     lsr
00BEFE  1  4A                     lsr
00BEFF  1  C9 08                  cmp #$08                    ;if < 8, branch, do not change
00BF01  1  90 02                  bcc SaveXSpd
00BF03  1  09 F0                  ora #%11110000              ;otherwise alter high nybble
00BF05  1  85 00        SaveXSpd: sta $00                     ;save result here
00BF07  1  A0 00                  ldy #$00                    ;load default Y value here
00BF09  1  C9 00                  cmp #$00                    ;if result positive, leave Y alone
00BF0B  1  10 01                  bpl UseAdder
00BF0D  1  88                     dey                         ;otherwise decrement Y
00BF0E  1  84 02        UseAdder: sty $02                     ;save Y here
00BF10  1  BD 00 04               lda SprObject_X_MoveForce,x ;get whatever number's here
00BF13  1  18                     clc
00BF14  1  65 01                  adc $01                     ;add low nybble moved to high
00BF16  1  9D 00 04               sta SprObject_X_MoveForce,x ;store result here
00BF19  1  A9 00                  lda #$00                    ;init A
00BF1B  1  2A                     rol                         ;rotate carry into d0
00BF1C  1  48                     pha                         ;push onto stack
00BF1D  1  6A                     ror                         ;rotate d0 back onto carry
00BF1E  1  B5 86                  lda SprObject_X_Position,x
00BF20  1  65 00                  adc $00                     ;add carry plus saved value (high nybble moved to low
00BF22  1  95 86                  sta SprObject_X_Position,x  ;plus $f0 if necessary) to object's horizontal position
00BF24  1  B5 6D                  lda SprObject_PageLoc,x
00BF26  1  65 02                  adc $02                     ;add carry plus other saved value to the
00BF28  1  95 6D                  sta SprObject_PageLoc,x     ;object's page location and save
00BF2A  1  68                     pla
00BF2B  1  18                     clc                         ;pull old carry from stack and add
00BF2C  1  65 00                  adc $00                     ;to high nybble moved to low
00BF2E  1  60           ExXMove:  rts                         ;and leave
00BF2F  1               
00BF2F  1               ;-------------------------------------------------------------------------------------
00BF2F  1               ;$00 - used for downward force
00BF2F  1               ;$01 - used for upward force
00BF2F  1               ;$02 - used for maximum vertical speed
00BF2F  1               
00BF2F  1               MovePlayerVertically:
00BF2F  1  A2 00                 ldx #$00                ;set X for player offset
00BF31  1  AD 47 07              lda TimerControl
00BF34  1  D0 05                 bne NoJSChk             ;if master timer control set, branch ahead
00BF36  1  AD 0E 07              lda JumpspringAnimCtrl  ;otherwise check to see if jumpspring is animating
00BF39  1  D0 F3                 bne ExXMove             ;branch to leave if so
00BF3B  1  AD 09 07     NoJSChk: lda VerticalForce       ;dump vertical force
00BF3E  1  85 00                 sta $00
00BF40  1  A9 04                 lda #$04                ;set maximum vertical speed here
00BF42  1  4C 8F BF              jmp ImposeGravitySprObj ;then jump to move player vertically
00BF45  1               
00BF45  1               ;--------------------------------
00BF45  1               
00BF45  1               MoveD_EnemyVertically:
00BF45  1  A0 3D              ldy #$3d           ;set quick movement amount downwards
00BF47  1  B5 1E              lda Enemy_State,x  ;then check enemy state
00BF49  1  C9 05              cmp #$05           ;if not set to unique state for spiny's egg, go ahead
00BF4B  1  D0 02              bne ContVMove      ;and use, otherwise set different movement amount, continue on
00BF4D  1               
00BF4D  1               MoveFallingPlatform:
00BF4D  1  A0 20                   ldy #$20       ;set movement amount
00BF4F  1  4C 76 BF     ContVMove: jmp SetHiMax   ;jump to skip the rest of this
00BF52  1               
00BF52  1               ;--------------------------------
00BF52  1               
00BF52  1               MoveRedPTroopaDown:
00BF52  1  A0 00              ldy #$00            ;set Y to move downwards
00BF54  1  4C 59 BF           jmp MoveRedPTroopa  ;skip to movement routine
00BF57  1               
00BF57  1               MoveRedPTroopaUp:
00BF57  1  A0 01              ldy #$01            ;set Y to move upwards
00BF59  1               
00BF59  1               MoveRedPTroopa:
00BF59  1  E8                 inx                 ;increment X for enemy offset
00BF5A  1  A9 03              lda #$03
00BF5C  1  85 00              sta $00             ;set downward movement amount here
00BF5E  1  A9 06              lda #$06
00BF60  1  85 01              sta $01             ;set upward movement amount here
00BF62  1  A9 02              lda #$02
00BF64  1  85 02              sta $02             ;set maximum speed here
00BF66  1  98                 tya                 ;set movement direction in A, and
00BF67  1  4C B3 BF           jmp RedPTroopaGrav  ;jump to move this thing
00BF6A  1               
00BF6A  1               ;--------------------------------
00BF6A  1               
00BF6A  1               MoveDropPlatform:
00BF6A  1  A0 7F              ldy #$7f      ;set movement amount for drop platform
00BF6C  1  D0 02              bne SetMdMax  ;skip ahead of other value set here
00BF6E  1               
00BF6E  1               MoveEnemySlowVert:
00BF6E  1  A0 0F                  ldy #$0f         ;set movement amount for bowser/other objects
00BF70  1  A9 02        SetMdMax: lda #$02         ;set maximum speed in A
00BF72  1  D0 04                  bne SetXMoveAmt  ;unconditional branch
00BF74  1               
00BF74  1               ;--------------------------------
00BF74  1               
00BF74  1               MoveJ_EnemyVertically:
00BF74  1  A0 1C                     ldy #$1c                ;set movement amount for podoboo/other objects
00BF76  1  A9 03        SetHiMax:    lda #$03                ;set maximum speed in A
00BF78  1  84 00        SetXMoveAmt: sty $00                 ;set movement amount here
00BF7A  1  E8                        inx                     ;increment X for enemy offset
00BF7B  1  20 8F BF                  jsr ImposeGravitySprObj ;do a sub to move enemy object downwards
00BF7E  1  A6 08                     ldx ObjectOffset        ;get enemy object buffer offset and leave
00BF80  1  60                        rts
00BF81  1               
00BF81  1               ;--------------------------------
00BF81  1               
00BF81  1               MaxSpdBlockData:
00BF81  1  06 08              .byte $06, $08
00BF83  1               
00BF83  1               ResidualGravityCode:
00BF83  1  A0 00              ldy #$00       ;this part appears to be residual,
00BF85  1  2C                 .byte $2c        ;no code branches or jumps to it...
00BF86  1               
00BF86  1               ImposeGravityBlock:
00BF86  1  A0 01              ldy #$01       ;set offset for maximum speed
00BF88  1  A9 50              lda #$50       ;set movement amount here
00BF8A  1  85 00              sta $00
00BF8C  1  B9 81 BF           lda MaxSpdBlockData,y    ;get maximum speed
00BF8F  1               
00BF8F  1               ImposeGravitySprObj:
00BF8F  1  85 02              sta $02            ;set maximum speed here
00BF91  1  A9 00              lda #$00           ;set value to move downwards
00BF93  1  4C B9 BF           jmp ImposeGravity  ;jump to the code that actually moves it
00BF96  1               
00BF96  1               ;--------------------------------
00BF96  1               
00BF96  1               MovePlatformDown:
00BF96  1  A9 00              lda #$00    ;save value to stack (if branching here, execute next
00BF98  1  2C                 .byte $2c     ;part as BIT instruction)
00BF99  1               
00BF99  1               MovePlatformUp:
00BF99  1  A9 01                   lda #$01        ;save value to stack
00BF9B  1  48                      pha
00BF9C  1  B4 16                   ldy Enemy_ID,x  ;get enemy object identifier
00BF9E  1  E8                      inx             ;increment offset for enemy object
00BF9F  1  A9 05                   lda #$05        ;load default value here
00BFA1  1  C0 29                   cpy #$29        ;residual comparison, object #29 never executes
00BFA3  1  D0 02                   bne SetDplSpd   ;this code, thus unconditional branch here
00BFA5  1  A9 09                   lda #$09        ;residual code
00BFA7  1  85 00        SetDplSpd: sta $00         ;save downward movement amount here
00BFA9  1  A9 0A                   lda #$0a        ;save upward movement amount here
00BFAB  1  85 01                   sta $01
00BFAD  1  A9 03                   lda #$03        ;save maximum vertical speed here
00BFAF  1  85 02                   sta $02
00BFB1  1  68                      pla             ;get value from stack
00BFB2  1  A8                      tay             ;use as Y, then move onto code shared by red koopa
00BFB3  1               
00BFB3  1               RedPTroopaGrav:
00BFB3  1  20 B9 BF           jsr ImposeGravity  ;do a sub to move object gradually
00BFB6  1  A6 08              ldx ObjectOffset   ;get enemy object offset and leave
00BFB8  1  60                 rts
00BFB9  1               
00BFB9  1               ;-------------------------------------------------------------------------------------
00BFB9  1               ;$00 - used for downward force
00BFB9  1               ;$01 - used for upward force
00BFB9  1               ;$07 - used as adder for vertical position
00BFB9  1               
00BFB9  1               ImposeGravity:
00BFB9  1  48                    pha                          ;push value to stack
00BFBA  1  BD 16 04              lda SprObject_YMF_Dummy,x
00BFBD  1  18                    clc                          ;add value in movement force to contents of dummy variable
00BFBE  1  7D 33 04              adc SprObject_Y_MoveForce,x
00BFC1  1  9D 16 04              sta SprObject_YMF_Dummy,x
00BFC4  1  A0 00                 ldy #$00                     ;set Y to zero by default
00BFC6  1  B5 9F                 lda SprObject_Y_Speed,x      ;get current vertical speed
00BFC8  1  10 01                 bpl AlterYP                  ;if currently moving downwards, do not decrement Y
00BFCA  1  88                    dey                          ;otherwise decrement Y
00BFCB  1  84 07        AlterYP: sty $07                      ;store Y here
00BFCD  1  75 CE                 adc SprObject_Y_Position,x   ;add vertical position to vertical speed plus carry
00BFCF  1  95 CE                 sta SprObject_Y_Position,x   ;store as new vertical position
00BFD1  1  B5 B5                 lda SprObject_Y_HighPos,x
00BFD3  1  65 07                 adc $07                      ;add carry plus contents of $07 to vertical high byte
00BFD5  1  95 B5                 sta SprObject_Y_HighPos,x    ;store as new vertical high byte
00BFD7  1  BD 33 04              lda SprObject_Y_MoveForce,x
00BFDA  1  18                    clc
00BFDB  1  65 00                 adc $00                      ;add downward movement amount to contents of $0433
00BFDD  1  9D 33 04              sta SprObject_Y_MoveForce,x
00BFE0  1  B5 9F                 lda SprObject_Y_Speed,x      ;add carry to vertical speed and store
00BFE2  1  69 00                 adc #$00
00BFE4  1  95 9F                 sta SprObject_Y_Speed,x
00BFE6  1  C5 02                 cmp $02                      ;compare to maximum speed
00BFE8  1  30 10                 bmi ChkUpM                   ;if less than preset value, skip this part
00BFEA  1  BD 33 04              lda SprObject_Y_MoveForce,x
00BFED  1  C9 80                 cmp #$80                     ;if less positively than preset maximum, skip this part
00BFEF  1  90 09                 bcc ChkUpM
00BFF1  1  A5 02                 lda $02
00BFF3  1  95 9F                 sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
00BFF5  1  A9 00                 lda #$00
00BFF7  1  9D 33 04              sta SprObject_Y_MoveForce,x  ;clear fractional
00BFFA  1  68           ChkUpM:  pla                          ;get value from stack
00BFFB  1  F0 2B                 beq ExVMove                  ;if set to zero, branch to leave
00BFFD  1  A5 02                 lda $02
00BFFF  1  49 FF                 eor #%11111111               ;otherwise get two's compliment of maximum speed
00C001  1  A8                    tay
00C002  1  C8                    iny
00C003  1  84 07                 sty $07                      ;store two's compliment here
00C005  1  BD 33 04              lda SprObject_Y_MoveForce,x
00C008  1  38                    sec                          ;subtract upward movement amount from contents
00C009  1  E5 01                 sbc $01                      ;of movement force, note that $01 is twice as large as $00,
00C00B  1  9D 33 04              sta SprObject_Y_MoveForce,x  ;thus it effectively undoes add we did earlier
00C00E  1  B5 9F                 lda SprObject_Y_Speed,x
00C010  1  E9 00                 sbc #$00                     ;subtract borrow from vertical speed and store
00C012  1  95 9F                 sta SprObject_Y_Speed,x
00C014  1  C5 07                 cmp $07                      ;compare vertical speed to two's compliment
00C016  1  10 10                 bpl ExVMove                  ;if less negatively than preset maximum, skip this part
00C018  1  BD 33 04              lda SprObject_Y_MoveForce,x
00C01B  1  C9 80                 cmp #$80                     ;check if fractional part is above certain amount,
00C01D  1  B0 09                 bcs ExVMove                  ;and if so, branch to leave
00C01F  1  A5 07                 lda $07
00C021  1  95 9F                 sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
00C023  1  A9 FF                 lda #$ff
00C025  1  9D 33 04              sta SprObject_Y_MoveForce,x  ;clear fractional
00C028  1  60           ExVMove: rts                          ;leave!
00C029  1               
00C029  1               ;-------------------------------------------------------------------------------------
00C029  1               
00C029  1               NoInitCode:
00C029  1  60                 rts               ;this executed when enemy object has no init code
00C02A  1               
00C02A  1               ;--------------------------------
00C02A  1               
00C02A  1               InitGoomba:
00C02A  1  20 47 C0           jsr InitNormalEnemy  ;set appropriate horizontal speed
00C02D  1  4C 7F C0           jmp SmallBBox        ;set $09 as bounding box control, set other values
00C030  1               
00C030  1               
00C030  1               ;-------------------------------------------------------------------------------------
00C030  1               
00C030  1               InitPodoboo:
00C030  1  A9 02              lda #$02                  ;set enemy position to below
00C032  1  95 B6              sta Enemy_Y_HighPos,x     ;the bottom of the screen
00C034  1  95 CF              sta Enemy_Y_Position,x
00C036  1  4A                 lsr
00C037  1  9D 96 07           sta EnemyIntervalTimer,x  ;set timer for enemy
00C03A  1  4A                 lsr
00C03B  1  95 1E              sta Enemy_State,x         ;initialize enemy state, then jump to use
00C03D  1  4C 7F C0           jmp SmallBBox             ;$09 as bounding box size and set other things
00C040  1               
00C040  1               ;--------------------------------
00C040  1               
00C040  1               InitRetainerObj:
00C040  1  A9 B8              lda #$b8                ;set fixed vertical position for
00C042  1  95 CF              sta Enemy_Y_Position,x  ;princess/mushroom retainer object
00C044  1  60                 rts
00C045  1               
00C045  1               ;--------------------------------
00C045  1               
00C045  1               NormalXSpdData:
00C045  1  F8 F4              .byte $f8, $f4
00C047  1               
00C047  1               InitNormalEnemy:
00C047  1  A0 01                 ldy #$01              ;load offset of 1 by default
00C049  1  AD 6A 07              lda PrimaryHardMode   ;check for primary hard mode flag set
00C04C  1  D0 01                 bne GetESpd
00C04E  1  88                    dey                   ;if not set, decrement offset
00C04F  1  B9 45 C0     GetESpd: lda NormalXSpdData,y  ;get appropriate horizontal speed
00C052  1  95 58        SetESpd: sta Enemy_X_Speed,x   ;store as speed for enemy object
00C054  1  4C 93 C0              jmp TallBBox          ;branch to set bounding box control and other data
00C057  1               
00C057  1               ;--------------------------------
00C057  1               
00C057  1               InitRedKoopa:
00C057  1  20 47 C0           jsr InitNormalEnemy   ;load appropriate horizontal speed
00C05A  1  A9 01              lda #$01              ;set enemy state for red koopa troopa $03
00C05C  1  95 1E              sta Enemy_State,x
00C05E  1  60                 rts
00C05F  1               
00C05F  1               ;--------------------------------
00C05F  1               
00C05F  1               HBroWalkingTimerData:
00C05F  1  80 50              .byte $80, $50
00C061  1               
00C061  1               InitHammerBro:
00C061  1  A9 00              lda #$00                    ;init horizontal speed and timer used by hammer bro
00C063  1  9D A2 03           sta HammerThrowingTimer,x   ;apparently to time hammer throwing
00C066  1  95 58              sta Enemy_X_Speed,x
00C068  1  AC CC 06           ldy SecondaryHardMode       ;get secondary hard mode flag
00C06B  1  B9 5F C0           lda HBroWalkingTimerData,y
00C06E  1  9D 96 07           sta EnemyIntervalTimer,x    ;set value as delay for hammer bro to walk left
00C071  1  A9 0B              lda #$0b                    ;set specific value for bounding box size control
00C073  1  4C 95 C0           jmp SetBBox
00C076  1               
00C076  1               ;--------------------------------
00C076  1               
00C076  1               InitHorizFlySwimEnemy:
00C076  1  A9 00              lda #$00        ;initialize horizontal speed
00C078  1  4C 52 C0           jmp SetESpd
00C07B  1               
00C07B  1               ;--------------------------------
00C07B  1               
00C07B  1               InitBloober:
00C07B  1  A9 00                   lda #$00               ;initialize horizontal speed
00C07D  1  95 58                   sta BlooperMoveSpeed,x
00C07F  1  A9 09        SmallBBox: lda #$09               ;set specific bounding box size control
00C081  1  D0 12                   bne SetBBox            ;unconditional branch
00C083  1               
00C083  1               ;--------------------------------
00C083  1               
00C083  1               InitRedPTroopa:
00C083  1  A0 30                  ldy #$30                    ;load central position adder for 48 pixels down
00C085  1  B5 CF                  lda Enemy_Y_Position,x      ;set vertical coordinate into location to
00C087  1  9D 01 04               sta RedPTroopaOrigXPos,x    ;be used as original vertical coordinate
00C08A  1  10 02                  bpl GetCent                 ;if vertical coordinate < $80
00C08C  1  A0 E0                  ldy #$e0                    ;if => $80, load position adder for 32 pixels up
00C08E  1  98           GetCent:  tya                         ;send central position adder to A
00C08F  1  75 CF                  adc Enemy_Y_Position,x      ;add to current vertical coordinate
00C091  1  95 58                  sta RedPTroopaCenterYPos,x  ;store as central vertical coordinate
00C093  1  A9 03        TallBBox: lda #$03                    ;set specific bounding box size control
00C095  1  9D 9A 04     SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
00C098  1  A9 02                  lda #$02                    ;set moving direction for left
00C09A  1  95 46                  sta Enemy_MovingDir,x
00C09C  1  A9 00        InitVStf: lda #$00                    ;initialize vertical speed
00C09E  1  95 A0                  sta Enemy_Y_Speed,x         ;and movement force
00C0A0  1  9D 34 04               sta Enemy_Y_MoveForce,x
00C0A3  1  60                     rts
00C0A4  1               
00C0A4  1               ;--------------------------------
00C0A4  1               
00C0A4  1               InitBulletBill:
00C0A4  1  A9 02              lda #$02                  ;set moving direction for left
00C0A6  1  95 46              sta Enemy_MovingDir,x
00C0A8  1  A9 09              lda #$09                  ;set bounding box control for $09
00C0AA  1  9D 9A 04           sta Enemy_BoundBoxCtrl,x
00C0AD  1  60                 rts
00C0AE  1               
00C0AE  1               ;--------------------------------
00C0AE  1               
00C0AE  1               InitCheepCheep:
00C0AE  1  20 7F C0           jsr SmallBBox              ;set vertical bounding box, speed, init others
00C0B1  1  BD A7 07           lda PseudoRandomBitReg,x   ;check one portion of LSFR
00C0B4  1  29 10              and #%00010000             ;get d4 from it
00C0B6  1  95 58              sta CheepCheepMoveMFlag,x  ;save as movement flag of some sort
00C0B8  1  B5 CF              lda Enemy_Y_Position,x
00C0BA  1  9D 34 04           sta CheepCheepOrigYPos,x   ;save original vertical coordinate here
00C0BD  1  60                 rts
00C0BE  1               
00C0BE  1               ;--------------------------------
00C0BE  1               
00C0BE  1               InitLakitu:
00C0BE  1  AD CB 06           lda EnemyFrenzyBuffer      ;check to see if an enemy is already in
00C0C1  1  D0 0B              bne KillLakitu             ;the frenzy buffer, and branch to kill lakitu if so
00C0C3  1               
00C0C3  1               SetupLakitu:
00C0C3  1  A9 00              lda #$00                   ;erase counter for lakitu's reappearance
00C0C5  1  8D D1 06           sta LakituReappearTimer
00C0C8  1  20 76 C0           jsr InitHorizFlySwimEnemy  ;set $03 as bounding box, set other attributes
00C0CB  1  4C FE C3           jmp TallBBox2              ;set $03 as bounding box again (not necessary) and leave
00C0CE  1               
00C0CE  1               KillLakitu:
00C0CE  1  4C CE C5           jmp EraseEnemyObject
00C0D1  1               
00C0D1  1               ;--------------------------------
00C0D1  1               ;$01-$03 - used to hold pseudorandom difference adjusters
00C0D1  1               
00C0D1  1               PRDiffAdjustData:
00C0D1  1  26 2C 32 38        .byte $26, $2c, $32, $38
00C0D5  1  20 22 24 26        .byte $20, $22, $24, $26
00C0D9  1  13 14 15 16        .byte $13, $14, $15, $16
00C0DD  1               
00C0DD  1               LakituAndSpinyHandler:
00C0DD  1  AD 8F 07               lda FrenzyEnemyTimer    ;if timer here not expired, leave
00C0E0  1  D0 3C                  bne ExLSHand
00C0E2  1  E0 05                  cpx #$05                ;if we are on the special use slot, leave
00C0E4  1  B0 38                  bcs ExLSHand
00C0E6  1  A9 80                  lda #$80                ;set timer
00C0E8  1  8D 8F 07               sta FrenzyEnemyTimer
00C0EB  1  A0 04                  ldy #$04                ;start with the last enemy slot
00C0ED  1  B9 16 00     ChkLak:   lda Enemy_ID,y          ;check all enemy slots to see
00C0F0  1  C9 11                  cmp #Lakitu             ;if lakitu is on one of them
00C0F2  1  F0 2B                  beq CreateSpiny         ;if so, branch out of this loop
00C0F4  1  88                     dey                     ;otherwise check another slot
00C0F5  1  10 F6                  bpl ChkLak              ;loop until all slots are checked
00C0F7  1  EE D1 06               inc LakituReappearTimer ;increment reappearance timer
00C0FA  1  AD D1 06               lda LakituReappearTimer
00C0FD  1  C9 07                  cmp #$07                ;check to see if we're up to a certain value yet
00C0FF  1  90 1D                  bcc ExLSHand            ;if not, leave
00C101  1  A2 04                  ldx #$04                ;start with the last enemy slot again
00C103  1  B5 0F        ChkNoEn:  lda Enemy_Flag,x        ;check enemy buffer flag for non-active enemy slot
00C105  1  F0 05                  beq CreateL             ;branch out of loop if found
00C107  1  CA                     dex                     ;otherwise check next slot
00C108  1  10 F9                  bpl ChkNoEn             ;branch until all slots are checked
00C10A  1  30 10                  bmi RetEOfs             ;if no empty slots were found, branch to leave
00C10C  1  A9 00        CreateL:  lda #$00                ;initialize enemy state
00C10E  1  95 1E                  sta Enemy_State,x
00C110  1  A9 11                  lda #Lakitu             ;create lakitu enemy object
00C112  1  95 16                  sta Enemy_ID,x
00C114  1  20 C3 C0               jsr SetupLakitu         ;do a sub to set up lakitu
00C117  1  A9 20                  lda #$20
00C119  1  20 11 C3               jsr PutAtRightExtent    ;finish setting up lakitu
00C11C  1  A6 08        RetEOfs:  ldx ObjectOffset        ;get enemy object buffer offset again and leave
00C11E  1  60           ExLSHand: rts
00C11F  1               
00C11F  1               ;--------------------------------
00C11F  1               
00C11F  1               CreateSpiny:
00C11F  1  A5 CE                  lda Player_Y_Position      ;if player above a certain point, branch to leave
00C121  1  C9 2C                  cmp #$2c
00C123  1  90 F9                  bcc ExLSHand
00C125  1  B9 1E 00               lda Enemy_State,y          ;if lakitu is not in normal state, branch to leave
00C128  1  D0 F4                  bne ExLSHand
00C12A  1  B9 6E 00               lda Enemy_PageLoc,y        ;store horizontal coordinates (high and low) of lakitu
00C12D  1  95 6E                  sta Enemy_PageLoc,x        ;into the coordinates of the spiny we're going to create
00C12F  1  B9 87 00               lda Enemy_X_Position,y
00C132  1  95 87                  sta Enemy_X_Position,x
00C134  1  A9 01                  lda #$01                   ;put spiny within vertical screen unit
00C136  1  95 B6                  sta Enemy_Y_HighPos,x
00C138  1  B9 CF 00               lda Enemy_Y_Position,y     ;put spiny eight pixels above where lakitu is
00C13B  1  38                     sec
00C13C  1  E9 08                  sbc #$08
00C13E  1  95 CF                  sta Enemy_Y_Position,x
00C140  1  BD A7 07               lda PseudoRandomBitReg,x   ;get 2 LSB of LSFR and save to Y
00C143  1  29 03                  and #%00000011
00C145  1  A8                     tay
00C146  1  A2 02                  ldx #$02
00C148  1  B9 D1 C0     DifLoop:  lda PRDiffAdjustData,y     ;get three values and save them
00C14B  1  95 01                  sta $01,x                  ;to $01-$03
00C14D  1  C8                     iny
00C14E  1  C8                     iny                        ;increment Y four bytes for each value
00C14F  1  C8                     iny
00C150  1  C8                     iny
00C151  1  CA                     dex                        ;decrement X for each one
00C152  1  10 F4                  bpl DifLoop                ;loop until all three are written
00C154  1  A6 08                  ldx ObjectOffset           ;get enemy object buffer offset
00C156  1  20 A2 CB               jsr PlayerLakituDiff       ;move enemy, change direction, get value - difference
00C159  1  A4 57                  ldy Player_X_Speed         ;check player's horizontal speed
00C15B  1  C0 08                  cpy #$08
00C15D  1  B0 0E                  bcs SetSpSpd               ;if moving faster than a certain amount, branch elsewhere
00C15F  1  A8                     tay                        ;otherwise save value in A to Y for now
00C160  1  BD A8 07               lda PseudoRandomBitReg+1,x
00C163  1  29 03                  and #%00000011             ;get one of the LSFR parts and save the 2 LSB
00C165  1  F0 05                  beq UsePosv                ;branch if neither bits are set
00C167  1  98                     tya
00C168  1  49 FF                  eor #%11111111             ;otherwise get two's compliment of Y
00C16A  1  A8                     tay
00C16B  1  C8                     iny
00C16C  1  98           UsePosv:  tya                        ;put value from A in Y back to A (they will be lost anyway)
00C16D  1  20 7F C0     SetSpSpd: jsr SmallBBox              ;set bounding box control, init attributes, lose contents of A
00C170  1  A0 02                  ldy #$02
00C172  1  95 58                  sta Enemy_X_Speed,x        ;set horizontal speed to zero because previous contents
00C174  1  C9 00                  cmp #$00                   ;of A were lost...branch here will never be taken for
00C176  1  30 01                  bmi SpinyRte               ;the same reason
00C178  1  88                     dey
00C179  1  94 46        SpinyRte: sty Enemy_MovingDir,x      ;set moving direction to the right
00C17B  1  A9 FD                  lda #$fd
00C17D  1  95 A0                  sta Enemy_Y_Speed,x        ;set vertical speed to move upwards
00C17F  1  A9 01                  lda #$01
00C181  1  95 0F                  sta Enemy_Flag,x           ;enable enemy object by setting flag
00C183  1  A9 05                  lda #$05
00C185  1  95 1E                  sta Enemy_State,x          ;put spiny in egg state and leave
00C187  1  60           ChpChpEx: rts
00C188  1               
00C188  1               ;--------------------------------
00C188  1               
00C188  1               FirebarSpinSpdData:
00C188  1  28 38 28 38        .byte $28, $38, $28, $38, $28
00C18C  1  28           
00C18D  1               
00C18D  1               FirebarSpinDirData:
00C18D  1  00 00 10 10        .byte $00, $00, $10, $10, $00
00C191  1  00           
00C192  1               
00C192  1               InitLongFirebar:
00C192  1  20 AE C2           jsr DuplicateEnemyObj       ;create enemy object for long firebar
00C195  1               
00C195  1               InitShortFirebar:
00C195  1  A9 00              lda #$00                    ;initialize low byte of spin state
00C197  1  95 58              sta FirebarSpinState_Low,x
00C199  1  B5 16              lda Enemy_ID,x              ;subtract $1b from enemy identifier
00C19B  1  38                 sec                         ;to get proper offset for firebar data
00C19C  1  E9 1B              sbc #$1b
00C19E  1  A8                 tay
00C19F  1  B9 88 C1           lda FirebarSpinSpdData,y    ;get spinning speed of firebar
00C1A2  1  9D 88 03           sta FirebarSpinSpeed,x
00C1A5  1  B9 8D C1           lda FirebarSpinDirData,y    ;get spinning direction of firebar
00C1A8  1  95 34              sta FirebarSpinDirection,x
00C1AA  1  B5 CF              lda Enemy_Y_Position,x
00C1AC  1  18                 clc                         ;add four pixels to vertical coordinate
00C1AD  1  69 04              adc #$04
00C1AF  1  95 CF              sta Enemy_Y_Position,x
00C1B1  1  B5 87              lda Enemy_X_Position,x
00C1B3  1  18                 clc                         ;add four pixels to horizontal coordinate
00C1B4  1  69 04              adc #$04
00C1B6  1  95 87              sta Enemy_X_Position,x
00C1B8  1  B5 6E              lda Enemy_PageLoc,x
00C1BA  1  69 00              adc #$00                    ;add carry to page location
00C1BC  1  95 6E              sta Enemy_PageLoc,x
00C1BE  1  4C FE C3           jmp TallBBox2               ;set bounding box control (not used) and leave
00C1C1  1               
00C1C1  1               ;--------------------------------
00C1C1  1               ;$00-$01 - used to hold pseudorandom bits
00C1C1  1               
00C1C1  1               FlyCCXPositionData:
00C1C1  1  80 30 40 80        .byte $80, $30, $40, $80
00C1C5  1  30 50 50 70        .byte $30, $50, $50, $70
00C1C9  1  20 40 80 A0        .byte $20, $40, $80, $a0
00C1CD  1  70 40 90 68        .byte $70, $40, $90, $68
00C1D1  1               
00C1D1  1               FlyCCXSpeedData:
00C1D1  1  0E 05 06 0E        .byte $0e, $05, $06, $0e
00C1D5  1  1C 20 10 0C        .byte $1c, $20, $10, $0c
00C1D9  1  1E 22 18 14        .byte $1e, $22, $18, $14
00C1DD  1               
00C1DD  1               FlyCCTimerData:
00C1DD  1  10 60 20 48        .byte $10, $60, $20, $48
00C1E1  1               
00C1E1  1               InitFlyingCheepCheep:
00C1E1  1  AD 8F 07              lda FrenzyEnemyTimer       ;if timer here not expired yet, branch to leave
00C1E4  1  D0 A1                 bne ChpChpEx
00C1E6  1  20 7F C0              jsr SmallBBox              ;jump to set bounding box size $09 and init other values
00C1E9  1  BD A8 07              lda PseudoRandomBitReg+1,x
00C1EC  1  29 03                 and #%00000011             ;set pseudorandom offset here
00C1EE  1  A8                    tay
00C1EF  1  B9 DD C1              lda FlyCCTimerData,y       ;load timer with pseudorandom offset
00C1F2  1  8D 8F 07              sta FrenzyEnemyTimer
00C1F5  1  A0 03                 ldy #$03                   ;load Y with default value
00C1F7  1  AD CC 06              lda SecondaryHardMode
00C1FA  1  F0 01                 beq MaxCC                  ;if secondary hard mode flag not set, do not increment Y
00C1FC  1  C8                    iny                        ;otherwise, increment Y to allow as many as four onscreen
00C1FD  1  84 00        MaxCC:   sty $00                    ;store whatever pseudorandom bits are in Y
00C1FF  1  E4 00                 cpx $00                    ;compare enemy object buffer offset with Y
00C201  1  B0 84                 bcs ChpChpEx               ;if X => Y, branch to leave
00C203  1  BD A7 07              lda PseudoRandomBitReg,x
00C206  1  29 03                 and #%00000011             ;get last two bits of LSFR, first part
00C208  1  85 00                 sta $00                    ;and store in two places
00C20A  1  85 01                 sta $01
00C20C  1  A9 FB                 lda #$fb                   ;set vertical speed for cheep-cheep
00C20E  1  95 A0                 sta Enemy_Y_Speed,x
00C210  1  A9 00                 lda #$00                   ;load default value
00C212  1  A4 57                 ldy Player_X_Speed         ;check player's horizontal speed
00C214  1  F0 07                 beq GSeed                  ;if player not moving left or right, skip this part
00C216  1  A9 04                 lda #$04
00C218  1  C0 19                 cpy #$19                   ;if moving to the right but not very quickly,
00C21A  1  90 01                 bcc GSeed                  ;do not change A
00C21C  1  0A                    asl                        ;otherwise, multiply A by 2
00C21D  1  48           GSeed:   pha                        ;save to stack
00C21E  1  18                    clc
00C21F  1  65 00                 adc $00                    ;add to last two bits of LSFR we saved earlier
00C221  1  85 00                 sta $00                    ;save it there
00C223  1  BD A8 07              lda PseudoRandomBitReg+1,x
00C226  1  29 03                 and #%00000011             ;if neither of the last two bits of second LSFR set,
00C228  1  F0 07                 beq RSeed                  ;skip this part and save contents of $00
00C22A  1  BD A9 07              lda PseudoRandomBitReg+2,x
00C22D  1  29 0F                 and #%00001111             ;otherwise overwrite with lower nybble of
00C22F  1  85 00                 sta $00                    ;third LSFR part
00C231  1  68           RSeed:   pla                        ;get value from stack we saved earlier
00C232  1  18                    clc
00C233  1  65 01                 adc $01                    ;add to last two bits of LSFR we saved in other place
00C235  1  A8                    tay                        ;use as pseudorandom offset here
00C236  1  B9 D1 C1              lda FlyCCXSpeedData,y      ;get horizontal speed using pseudorandom offset
00C239  1  95 58                 sta Enemy_X_Speed,x
00C23B  1  A9 01                 lda #$01                   ;set to move towards the right
00C23D  1  95 46                 sta Enemy_MovingDir,x
00C23F  1  A5 57                 lda Player_X_Speed         ;if player moving left or right, branch ahead of this part
00C241  1  D0 12                 bne D2XPos1
00C243  1  A4 00                 ldy $00                    ;get first LSFR or third LSFR lower nybble
00C245  1  98                    tya                        ;and check for d1 set
00C246  1  29 02                 and #%00000010
00C248  1  F0 0B                 beq D2XPos1                ;if d1 not set, branch
00C24A  1  B5 58                 lda Enemy_X_Speed,x
00C24C  1  49 FF                 eor #$ff                   ;if d1 set, change horizontal speed
00C24E  1  18                    clc                        ;into two's compliment, thus moving in the opposite
00C24F  1  69 01                 adc #$01                   ;direction
00C251  1  95 58                 sta Enemy_X_Speed,x
00C253  1  F6 46                 inc Enemy_MovingDir,x      ;increment to move towards the left
00C255  1  98           D2XPos1: tya                        ;get first LSFR or third LSFR lower nybble again
00C256  1  29 02                 and #%00000010
00C258  1  F0 0F                 beq D2XPos2                ;check for d1 set again, branch again if not set
00C25A  1  A5 86                 lda Player_X_Position      ;get player's horizontal position
00C25C  1  18                    clc
00C25D  1  79 C1 C1              adc FlyCCXPositionData,y   ;if d1 set, add value obtained from pseudorandom offset
00C260  1  95 87                 sta Enemy_X_Position,x     ;and save as enemy's horizontal position
00C262  1  A5 6D                 lda Player_PageLoc         ;get player's page location
00C264  1  69 00                 adc #$00                   ;add carry and jump past this part
00C266  1  4C 75 C2              jmp FinCCSt
00C269  1  A5 86        D2XPos2: lda Player_X_Position      ;get player's horizontal position
00C26B  1  38                    sec
00C26C  1  F9 C1 C1              sbc FlyCCXPositionData,y   ;if d1 not set, subtract value obtained from pseudorandom
00C26F  1  95 87                 sta Enemy_X_Position,x     ;offset and save as enemy's horizontal position
00C271  1  A5 6D                 lda Player_PageLoc         ;get player's page location
00C273  1  E9 00                 sbc #$00                   ;subtract borrow
00C275  1  95 6E        FinCCSt: sta Enemy_PageLoc,x        ;save as enemy's page location
00C277  1  A9 01                 lda #$01
00C279  1  95 0F                 sta Enemy_Flag,x           ;set enemy's buffer flag
00C27B  1  95 B6                 sta Enemy_Y_HighPos,x      ;set enemy's high vertical byte
00C27D  1  A9 F8                 lda #$f8
00C27F  1  95 CF                 sta Enemy_Y_Position,x     ;put enemy below the screen, and we are done
00C281  1  60                    rts
00C282  1               
00C282  1               ;--------------------------------
00C282  1               
00C282  1               InitBowser:
00C282  1  20 AE C2           jsr DuplicateEnemyObj     ;jump to create another bowser object
00C285  1  8E 68 03           stx BowserFront_Offset    ;save offset of first here
00C288  1  A9 00              lda #$00
00C28A  1  8D 63 03           sta BowserBodyControls    ;initialize bowser's body controls
00C28D  1  8D 69 03           sta BridgeCollapseOffset  ;and bridge collapse offset
00C290  1  B5 87              lda Enemy_X_Position,x
00C292  1  8D 66 03           sta BowserOrigXPos        ;store original horizontal position here
00C295  1  A9 DF              lda #$df
00C297  1  8D 90 07           sta BowserFireBreathTimer ;store something here
00C29A  1  95 46              sta Enemy_MovingDir,x     ;and in moving direction
00C29C  1  A9 20              lda #$20
00C29E  1  8D 64 03           sta BowserFeetCounter     ;set bowser's feet timer and in enemy timer
00C2A1  1  9D 8A 07           sta EnemyFrameTimer,x
00C2A4  1  A9 05              lda #$05
00C2A6  1  8D 83 04           sta BowserHitPoints       ;give bowser 5 hit points
00C2A9  1  4A                 lsr
00C2AA  1  8D 65 03           sta BowserMovementSpeed   ;set default movement speed here
00C2AD  1  60                 rts
00C2AE  1               
00C2AE  1               ;--------------------------------
00C2AE  1               
00C2AE  1               DuplicateEnemyObj:
00C2AE  1  A0 FF                ldy #$ff                ;start at beginning of enemy slots
00C2B0  1  C8           FSLoop: iny                     ;increment one slot
00C2B1  1  B9 0F 00             lda Enemy_Flag,y        ;check enemy buffer flag for empty slot
00C2B4  1  D0 FA                bne FSLoop              ;if set, branch and keep checking
00C2B6  1  8C CF 06             sty DuplicateObj_Offset ;otherwise set offset here
00C2B9  1  8A                   txa                     ;transfer original enemy buffer offset
00C2BA  1  09 80                ora #%10000000          ;store with d7 set as flag in new enemy
00C2BC  1  99 0F 00             sta Enemy_Flag,y        ;slot as well as enemy offset
00C2BF  1  B5 6E                lda Enemy_PageLoc,x
00C2C1  1  99 6E 00             sta Enemy_PageLoc,y     ;copy page location and horizontal coordinates
00C2C4  1  B5 87                lda Enemy_X_Position,x  ;from original enemy to new enemy
00C2C6  1  99 87 00             sta Enemy_X_Position,y
00C2C9  1  A9 01                lda #$01
00C2CB  1  95 0F                sta Enemy_Flag,x        ;set flag as normal for original enemy
00C2CD  1  99 B6 00             sta Enemy_Y_HighPos,y   ;set high vertical byte for new enemy
00C2D0  1  B5 CF                lda Enemy_Y_Position,x
00C2D2  1  99 CF 00             sta Enemy_Y_Position,y  ;copy vertical coordinate from original to new
00C2D5  1  60           FlmEx:  rts                     ;and then leave
00C2D6  1               
00C2D6  1               ;--------------------------------
00C2D6  1               
00C2D6  1               FlameYPosData:
00C2D6  1  90 80 70 90        .byte $90, $80, $70, $90
00C2DA  1               
00C2DA  1               FlameYMFAdderData:
00C2DA  1  FF 01              .byte $ff, $01
00C2DC  1               
00C2DC  1               InitBowserFlame:
00C2DC  1  AD 8F 07             lda FrenzyEnemyTimer        ;if timer not expired yet, branch to leave
00C2DF  1  D0 F4                bne FlmEx
00C2E1  1  9D 34 04             sta Enemy_Y_MoveForce,x     ;reset something here
00C2E4  1  A5 FD                lda NoiseSoundQueue
00C2E6  1  09 02                ora #Sfx_BowserFlame        ;load bowser's flame sound into queue
00C2E8  1  85 FD                sta NoiseSoundQueue
00C2EA  1  AC 68 03             ldy BowserFront_Offset      ;get bowser's buffer offset
00C2ED  1  B9 16 00             lda Enemy_ID,y              ;check for bowser
00C2F0  1  C9 2D                cmp #Bowser
00C2F2  1  F0 31                beq SpawnFromMouth          ;branch if found
00C2F4  1  20 0F CE             jsr SetFlameTimer           ;get timer data based on flame counter
00C2F7  1  18                   clc
00C2F8  1  69 20                adc #$20                    ;add 32 frames by default
00C2FA  1  AC CC 06             ldy SecondaryHardMode
00C2FD  1  F0 03                beq SetFrT                  ;if secondary mode flag not set, use as timer setting
00C2FF  1  38                   sec
00C300  1  E9 10                sbc #$10                    ;otherwise subtract 16 frames for secondary hard mode
00C302  1  8D 8F 07     SetFrT: sta FrenzyEnemyTimer        ;set timer accordingly
00C305  1  BD A7 07             lda PseudoRandomBitReg,x
00C308  1  29 03                and #%00000011              ;get 2 LSB from first part of LSFR
00C30A  1  9D 17 04             sta BowserFlamePRandomOfs,x ;set here
00C30D  1  A8                   tay                         ;use as offset
00C30E  1  B9 D6 C2             lda FlameYPosData,y         ;load vertical position based on pseudorandom offset
00C311  1               
00C311  1               PutAtRightExtent:
00C311  1  95 CF              sta Enemy_Y_Position,x    ;set vertical position
00C313  1  AD 1D 07           lda ScreenRight_X_Pos
00C316  1  18                 clc
00C317  1  69 20              adc #$20                  ;place enemy 32 pixels beyond right side of screen
00C319  1  95 87              sta Enemy_X_Position,x
00C31B  1  AD 1B 07           lda ScreenRight_PageLoc
00C31E  1  69 00              adc #$00                  ;add carry
00C320  1  95 6E              sta Enemy_PageLoc,x
00C322  1  4C 58 C3           jmp FinishFlame           ;skip this part to finish setting values
00C325  1               
00C325  1               SpawnFromMouth:
00C325  1  B9 87 00            lda Enemy_X_Position,y    ;get bowser's horizontal position
00C328  1  38                  sec
00C329  1  E9 0E               sbc #$0e                  ;subtract 14 pixels
00C32B  1  95 87               sta Enemy_X_Position,x    ;save as flame's horizontal position
00C32D  1  B9 6E 00            lda Enemy_PageLoc,y
00C330  1  95 6E               sta Enemy_PageLoc,x       ;copy page location from bowser to flame
00C332  1  B9 CF 00            lda Enemy_Y_Position,y
00C335  1  18                  clc                       ;add 8 pixels to bowser's vertical position
00C336  1  69 08               adc #$08
00C338  1  95 CF               sta Enemy_Y_Position,x    ;save as flame's vertical position
00C33A  1  BD A7 07            lda PseudoRandomBitReg,x
00C33D  1  29 03               and #%00000011            ;get 2 LSB from first part of LSFR
00C33F  1  9D 17 04            sta Enemy_YMF_Dummy,x     ;save here
00C342  1  A8                  tay                       ;use as offset
00C343  1  B9 D6 C2            lda FlameYPosData,y       ;get value here using bits as offset
00C346  1  A0 00               ldy #$00                  ;load default offset
00C348  1  D5 CF               cmp Enemy_Y_Position,x    ;compare value to flame's current vertical position
00C34A  1  90 01               bcc SetMF                 ;if less, do not increment offset
00C34C  1  C8                  iny                       ;otherwise increment now
00C34D  1  B9 DA C2     SetMF: lda FlameYMFAdderData,y   ;get value here and save
00C350  1  9D 34 04            sta Enemy_Y_MoveForce,x   ;to vertical movement force
00C353  1  A9 00               lda #$00
00C355  1  8D CB 06            sta EnemyFrenzyBuffer     ;clear enemy frenzy buffer
00C358  1               
00C358  1               FinishFlame:
00C358  1  A9 08              lda #$08                 ;set $08 for bounding box control
00C35A  1  9D 9A 04           sta Enemy_BoundBoxCtrl,x
00C35D  1  A9 01              lda #$01                 ;set high byte of vertical and
00C35F  1  95 B6              sta Enemy_Y_HighPos,x    ;enemy buffer flag
00C361  1  95 0F              sta Enemy_Flag,x
00C363  1  4A                 lsr
00C364  1  9D 01 04           sta Enemy_X_MoveForce,x  ;initialize horizontal movement force, and
00C367  1  95 1E              sta Enemy_State,x        ;enemy state
00C369  1  60                 rts
00C36A  1               
00C36A  1               ;--------------------------------
00C36A  1               
00C36A  1               FireworksXPosData:
00C36A  1  00 30 60 60        .byte $00, $30, $60, $60, $00, $20
00C36E  1  00 20        
00C370  1               
00C370  1               FireworksYPosData:
00C370  1  60 40 70 40        .byte $60, $40, $70, $40, $60, $30
00C374  1  60 30        
00C376  1               
00C376  1               InitFireworks:
00C376  1  AD 8F 07               lda FrenzyEnemyTimer         ;if timer not expired yet, branch to leave
00C379  1  D0 47                  bne ExitFWk
00C37B  1  A9 20                  lda #$20                     ;otherwise reset timer
00C37D  1  8D 8F 07               sta FrenzyEnemyTimer
00C380  1  CE D7 06               dec FireworksCounter         ;decrement for each explosion
00C383  1  A0 06                  ldy #$06                     ;start at last slot
00C385  1  88           StarFChk: dey
00C386  1  B9 16 00               lda Enemy_ID,y               ;check for presence of star flag object
00C389  1  C9 31                  cmp #StarFlagObject          ;if there isn't a star flag object,
00C38B  1  D0 F8                  bne StarFChk                 ;routine goes into infinite loop = crash
00C38D  1  B9 87 00               lda Enemy_X_Position,y
00C390  1  38                     sec                          ;get horizontal coordinate of star flag object, then
00C391  1  E9 30                  sbc #$30                     ;subtract 48 pixels from it and save to
00C393  1  48                     pha                          ;the stack
00C394  1  B9 6E 00               lda Enemy_PageLoc,y
00C397  1  E9 00                  sbc #$00                     ;subtract the carry from the page location
00C399  1  85 00                  sta $00                      ;of the star flag object
00C39B  1  AD D7 06               lda FireworksCounter         ;get fireworks counter
00C39E  1  18                     clc
00C39F  1  79 1E 00               adc Enemy_State,y            ;add state of star flag object (possibly not necessary)
00C3A2  1  A8                     tay                          ;use as offset
00C3A3  1  68                     pla                          ;get saved horizontal coordinate of star flag - 48 pixels
00C3A4  1  18                     clc
00C3A5  1  79 6A C3               adc FireworksXPosData,y      ;add number based on offset of fireworks counter
00C3A8  1  95 87                  sta Enemy_X_Position,x       ;store as the fireworks object horizontal coordinate
00C3AA  1  A5 00                  lda $00
00C3AC  1  69 00                  adc #$00                     ;add carry and store as page location for
00C3AE  1  95 6E                  sta Enemy_PageLoc,x          ;the fireworks object
00C3B0  1  B9 70 C3               lda FireworksYPosData,y      ;get vertical position using same offset
00C3B3  1  95 CF                  sta Enemy_Y_Position,x       ;and store as vertical coordinate for fireworks object
00C3B5  1  A9 01                  lda #$01
00C3B7  1  95 B6                  sta Enemy_Y_HighPos,x        ;store in vertical high byte
00C3B9  1  95 0F                  sta Enemy_Flag,x             ;and activate enemy buffer flag
00C3BB  1  4A                     lsr
00C3BC  1  95 58                  sta ExplosionGfxCounter,x    ;initialize explosion counter
00C3BE  1  A9 08                  lda #$08
00C3C0  1  95 A0                  sta ExplosionTimerCounter,x  ;set explosion timing counter
00C3C2  1  60           ExitFWk:  rts
00C3C3  1               
00C3C3  1               InitPiranhaPlant:
00C3C3  1  A9 01              lda #$01                     ;set initial speed
00C3C5  1  95 58              sta PiranhaPlant_Y_Speed,x
00C3C7  1  4A                 lsr
00C3C8  1  95 1E              sta Enemy_State,x            ;initialize enemy state and what would normally
00C3CA  1  95 A0              sta PiranhaPlant_MoveFlag,x  ;be used as vertical speed, but not in this case
00C3CC  1  B5 CF              lda Enemy_Y_Position,x
00C3CE  1  9D 34 04           sta PiranhaPlantDownYPos,x   ;save original vertical coordinate here
00C3D1  1  38                 sec
00C3D2  1  E9 18              sbc #$18
00C3D4  1  9D 17 04           sta PiranhaPlantUpYPos,x     ;save original vertical coordinate - 24 pixels here
00C3D7  1  A9 09              lda #$09
00C3D9  1  4C 00 C4           jmp SetBBox2                 ;set specific value for bounding box control
00C3DC  1               
00C3DC  1               ;--------------------------------
00C3DC  1               
00C3DC  1               NoFrenzyCode:
00C3DC  1  60                 rts
00C3DD  1               
00C3DD  1               ;--------------------------------
00C3DD  1               
00C3DD  1               EndFrenzy:
00C3DD  1  A0 05                   ldy #$05               ;start at last slot
00C3DF  1  B9 16 00     LakituChk: lda Enemy_ID,y         ;check enemy identifiers
00C3E2  1  C9 11                   cmp #Lakitu            ;for lakitu
00C3E4  1  D0 05                   bne NextFSlot
00C3E6  1  A9 01                   lda #$01               ;if found, set state
00C3E8  1  99 1E 00                sta Enemy_State,y
00C3EB  1  88           NextFSlot: dey                    ;move onto the next slot
00C3EC  1  10 F1                   bpl LakituChk          ;do this until all slots are checked
00C3EE  1  A9 00                   lda #$00
00C3F0  1  8D CB 06                sta EnemyFrenzyBuffer  ;empty enemy frenzy buffer
00C3F3  1  95 0F                   sta Enemy_Flag,x       ;disable enemy buffer flag for this object
00C3F5  1  60                      rts
00C3F6  1               
00C3F6  1               ;--------------------------------
00C3F6  1               
00C3F6  1               InitJumpGPTroopa:
00C3F6  1  A9 02                   lda #$02                  ;set for movement to the left
00C3F8  1  95 46                   sta Enemy_MovingDir,x
00C3FA  1  A9 F8                   lda #$f8                  ;set horizontal speed
00C3FC  1  95 58                   sta Enemy_X_Speed,x
00C3FE  1  A9 03        TallBBox2: lda #$03                  ;set specific value for bounding box control
00C400  1  9D 9A 04     SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
00C403  1  60                      rts
00C404  1               
00C404  1               ;--------------------------------
00C404  1               
00C404  1               InitBalPlatform:
00C404  1  D6 CF                dec Enemy_Y_Position,x    ;raise vertical position by two pixels
00C406  1  D6 CF                dec Enemy_Y_Position,x
00C408  1  AC CC 06             ldy SecondaryHardMode     ;if secondary hard mode flag not set,
00C40B  1  D0 05                bne AlignP                ;branch ahead
00C40D  1  A0 02                ldy #$02                  ;otherwise set value here
00C40F  1  20 96 C4             jsr PosPlatform           ;do a sub to add or subtract pixels
00C412  1  A0 FF        AlignP: ldy #$ff                  ;set default value here for now
00C414  1  AD A0 03             lda BalPlatformAlignment  ;get current balance platform alignment
00C417  1  95 1E                sta Enemy_State,x         ;set platform alignment to object state here
00C419  1  10 02                bpl SetBPA                ;if old alignment $ff, put $ff as alignment for negative
00C41B  1  8A                   txa                       ;if old contents already $ff, put
00C41C  1  A8                   tay                       ;object offset as alignment to make next positive
00C41D  1  8C A0 03     SetBPA: sty BalPlatformAlignment  ;store whatever value's in Y here
00C420  1  A9 00                lda #$00
00C422  1  95 46                sta Enemy_MovingDir,x     ;init moving direction
00C424  1  A8                   tay                       ;init Y
00C425  1  20 96 C4             jsr PosPlatform           ;do a sub to add 8 pixels, then run shared code here
00C428  1               
00C428  1               ;--------------------------------
00C428  1               
00C428  1               InitDropPlatform:
00C428  1  A9 FF              lda #$ff
00C42A  1  9D A2 03           sta PlatformCollisionFlag,x  ;set some value here
00C42D  1  4C 4D C4           jmp CommonPlatCode           ;then jump ahead to execute more code
00C430  1               
00C430  1               ;--------------------------------
00C430  1               
00C430  1               InitHoriPlatform:
00C430  1  A9 00              lda #$00
00C432  1  95 58              sta XMoveSecondaryCounter,x  ;init one of the moving counters
00C434  1  4C 4D C4           jmp CommonPlatCode           ;jump ahead to execute more code
00C437  1               
00C437  1               ;--------------------------------
00C437  1               
00C437  1               InitVertPlatform:
00C437  1  A0 40               ldy #$40                    ;set default value here
00C439  1  B5 CF               lda Enemy_Y_Position,x      ;check vertical position
00C43B  1  10 07               bpl SetYO                   ;if above a certain point, skip this part
00C43D  1  49 FF               eor #$ff
00C43F  1  18                  clc                         ;otherwise get two's compliment
00C440  1  69 01               adc #$01
00C442  1  A0 C0               ldy #$c0                    ;get alternate value to add to vertical position
00C444  1  9D 01 04     SetYO: sta YPlatformTopYPos,x      ;save as top vertical position
00C447  1  98                  tya
00C448  1  18                  clc                         ;load value from earlier, add number of pixels
00C449  1  75 CF               adc Enemy_Y_Position,x      ;to vertical position
00C44B  1  95 58               sta YPlatformCenterYPos,x   ;save result as central vertical position
00C44D  1               
00C44D  1               ;--------------------------------
00C44D  1               
00C44D  1               CommonPlatCode:
00C44D  1  20 9C C0             jsr InitVStf              ;do a sub to init certain other values
00C450  1  A9 05        SPBBox: lda #$05                  ;set default bounding box size control
00C452  1  AC 4E 07             ldy AreaType
00C455  1  C0 03                cpy #$03                  ;check for castle-type level
00C457  1  F0 07                beq CasPBB                ;use default value if found
00C459  1  AC CC 06             ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
00C45C  1  D0 02                bne CasPBB                ;if set, use default value
00C45E  1  A9 06                lda #$06                  ;use alternate value if not castle or secondary not set
00C460  1  9D 9A 04     CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
00C463  1  60                   rts
00C464  1               
00C464  1               ;--------------------------------
00C464  1               
00C464  1               LargeLiftUp:
00C464  1  20 70 C4           jsr PlatLiftUp       ;execute code for platforms going up
00C467  1  4C 6D C4           jmp LargeLiftBBox    ;overwrite bounding box for large platforms
00C46A  1               
00C46A  1               LargeLiftDown:
00C46A  1  20 7C C4           jsr PlatLiftDown     ;execute code for platforms going down
00C46D  1               
00C46D  1               LargeLiftBBox:
00C46D  1  4C 50 C4           jmp SPBBox           ;jump to overwrite bounding box size control
00C470  1               
00C470  1               ;--------------------------------
00C470  1               
00C470  1               PlatLiftUp:
00C470  1  A9 10              lda #$10                 ;set movement amount here
00C472  1  9D 34 04           sta Enemy_Y_MoveForce,x
00C475  1  A9 FF              lda #$ff                 ;set moving speed for platforms going up
00C477  1  95 A0              sta Enemy_Y_Speed,x
00C479  1  4C 85 C4           jmp CommonSmallLift      ;skip ahead to part we should be executing
00C47C  1               
00C47C  1               ;--------------------------------
00C47C  1               
00C47C  1               PlatLiftDown:
00C47C  1  A9 F0              lda #$f0                 ;set movement amount here
00C47E  1  9D 34 04           sta Enemy_Y_MoveForce,x
00C481  1  A9 00              lda #$00                 ;set moving speed for platforms going down
00C483  1  95 A0              sta Enemy_Y_Speed,x
00C485  1               
00C485  1               ;--------------------------------
00C485  1               
00C485  1               CommonSmallLift:
00C485  1  A0 01              ldy #$01
00C487  1  20 96 C4           jsr PosPlatform           ;do a sub to add 12 pixels due to preset value
00C48A  1  A9 04              lda #$04
00C48C  1  9D 9A 04           sta Enemy_BoundBoxCtrl,x  ;set bounding box control for small platforms
00C48F  1  60                 rts
00C490  1               
00C490  1               ;--------------------------------
00C490  1               
00C490  1               PlatPosDataLow:
00C490  1  08 0C F8           .byte $08,$0c,$f8
00C493  1               
00C493  1               PlatPosDataHigh:
00C493  1  00 00 FF           .byte $00,$00,$ff
00C496  1               
00C496  1               PosPlatform:
00C496  1  B5 87              lda Enemy_X_Position,x  ;get horizontal coordinate
00C498  1  18                 clc
00C499  1  79 90 C4           adc PlatPosDataLow,y    ;add or subtract pixels depending on offset
00C49C  1  95 87              sta Enemy_X_Position,x  ;store as new horizontal coordinate
00C49E  1  B5 6E              lda Enemy_PageLoc,x
00C4A0  1  79 93 C4           adc PlatPosDataHigh,y   ;add or subtract page location depending on offset
00C4A3  1  95 6E              sta Enemy_PageLoc,x     ;store as new page location
00C4A5  1  60                 rts                     ;and go back
00C4A6  1               
00C4A6  1               ;--------------------------------
00C4A6  1               
00C4A6  1               EndOfEnemyInitCode:
00C4A6  1  60                 rts
00C4A7  1               
00C4A7  1               ;-------------------------------------------------------------------------------------
00C4A7  1               
00C4A7  1               RunEnemyObjectsCore:
00C4A7  1  A6 08               ldx ObjectOffset  ;get offset for enemy object buffer
00C4A9  1  A9 00               lda #$00          ;load value 0 for jump engine by default
00C4AB  1  B4 16               ldy Enemy_ID,x
00C4AD  1  C0 15               cpy #$15          ;if enemy object < $15, use default value
00C4AF  1  90 03               bcc JmpEO
00C4B1  1  98                  tya               ;otherwise subtract $14 from the value and use
00C4B2  1  E9 14               sbc #$14          ;as value for jump engine
00C4B4  1  20 A8 BA     JmpEO: jsr JumpEngine
00C4B7  1               
00C4B7  1  05 C5              .word RunNormalEnemies  ;for objects $00-$14
00C4B9  1               
00C4B9  1  5A C5              .word RunBowserFlame    ;for objects $15-$1f
00C4BB  1  8D B9              .word RunFireworks
00C4BD  1  FB C4              .word NoRunCode
00C4BF  1  FB C4              .word NoRunCode
00C4C1  1  FB C4              .word NoRunCode
00C4C3  1  FB C4              .word NoRunCode
00C4C5  1  6C C5              .word RunFirebarObj
00C4C7  1  6C C5              .word RunFirebarObj
00C4C9  1  6C C5              .word RunFirebarObj
00C4CB  1  6C C5              .word RunFirebarObj
00C4CD  1  6C C5              .word RunFirebarObj
00C4CF  1               
00C4CF  1  6C C5              .word RunFirebarObj     ;for objects $20-$2f
00C4D1  1  6C C5              .word RunFirebarObj
00C4D3  1  6C C5              .word RunFirebarObj
00C4D5  1  FB C4              .word NoRunCode
00C4D7  1  8A C5              .word RunLargePlatform
00C4D9  1  8A C5              .word RunLargePlatform
00C4DB  1  8A C5              .word RunLargePlatform
00C4DD  1  8A C5              .word RunLargePlatform
00C4DF  1  8A C5              .word RunLargePlatform
00C4E1  1  8A C5              .word RunLargePlatform
00C4E3  1  8A C5              .word RunLargePlatform
00C4E5  1  72 C5              .word RunSmallPlatform
00C4E7  1  72 C5              .word RunSmallPlatform
00C4E9  1  9B CC              .word RunBowser
00C4EB  1  67 BC              .word PowerUpObjHandler
00C4ED  1  E7 EF              .word VineObjectHandler
00C4EF  1               
00C4EF  1  FB C4              .word NoRunCode         ;for objects $30-$35
00C4F1  1  D1 B9              .word RunStarFlagObj
00C4F3  1  54 EE              .word JumpspringHandler
00C4F5  1  FB C4              .word NoRunCode
00C4F7  1  BD C5              .word WarpZoneObject
00C4F9  1  FC C4              .word RunRetainerObj
00C4FB  1               
00C4FB  1               ;--------------------------------
00C4FB  1               
00C4FB  1               NoRunCode:
00C4FB  1  60                 rts
00C4FC  1               
00C4FC  1               ;--------------------------------
00C4FC  1               
00C4FC  1               RunRetainerObj:
00C4FC  1  20 47 EC           jsr GetEnemyOffscreenBits
00C4FF  1  20 EA EB           jsr RelativeEnemyPosition
00C502  1  4C 35 E3           jmp EnemyGfxHandler
00C505  1               
00C505  1               ;--------------------------------
00C505  1               
00C505  1               RunNormalEnemies:
00C505  1  A9 00                  lda #$00                  ;init sprite attributes
00C507  1  9D C5 03               sta Enemy_SprAttrib,x
00C50A  1  20 47 EC               jsr GetEnemyOffscreenBits
00C50D  1  20 EA EB               jsr RelativeEnemyPosition
00C510  1  20 35 E3               jsr EnemyGfxHandler
00C513  1  20 FB DC               jsr GetEnemyBoundBox
00C516  1  20 79 DA               jsr EnemyToBGCollisionDet
00C519  1  20 4E D5               jsr EnemiesCollision
00C51C  1  20 6E D3               jsr PlayerEnemyCollision
00C51F  1  AC 47 07               ldy TimerControl          ;if master timer control set, skip to last routine
00C522  1  D0 03                  bne SkipMove
00C524  1  20 2A C5               jsr EnemyMovementSubs
00C527  1  4C 95 D1     SkipMove: jmp OffscreenBoundsCheck
00C52A  1               
00C52A  1               EnemyMovementSubs:
00C52A  1  B5 16              lda Enemy_ID,x
00C52C  1  20 A8 BA           jsr JumpEngine
00C52F  1               
00C52F  1  AD C6              .word MoveNormalEnemy      ;only objects $00-$14 use this table
00C531  1  AD C6              .word MoveNormalEnemy
00C533  1  AD C6              .word MoveNormalEnemy
00C535  1  AD C6              .word MoveNormalEnemy
00C537  1  AD C6              .word MoveNormalEnemy
00C539  1  0E C6              .word ProcHammerBro
00C53B  1  AD C6              .word MoveNormalEnemy
00C53D  1  BF C7              .word MoveBloober
00C53F  1  6C C8              .word MoveBulletBill
00C541  1  59 C5              .word NoMoveCode
00C543  1  80 C8              .word MoveSwimmingCheepCheep
00C545  1  80 C8              .word MoveSwimmingCheepCheep
00C547  1  E6 C5              .word MovePodoboo
00C549  1  CB CE              .word MovePiranhaPlant
00C54B  1  2F C7              .word MoveJumpingEnemy
00C54D  1  35 C7              .word ProcMoveRedPTroopa
00C54F  1  5B C7              .word MoveFlyGreenPTroopa
00C551  1  5E CB              .word MoveLakitu
00C553  1  AD C6              .word MoveNormalEnemy
00C555  1  59 C5              .word NoMoveCode   ;dummy
00C557  1  15 CB              .word MoveFlyingCheepCheep
00C559  1               
00C559  1               ;--------------------------------
00C559  1               
00C559  1               NoMoveCode:
00C559  1  60                 rts
00C55A  1               
00C55A  1               ;--------------------------------
00C55A  1               
00C55A  1               RunBowserFlame:
00C55A  1  20 21 CE           jsr ProcBowserFlame
00C55D  1  20 47 EC           jsr GetEnemyOffscreenBits
00C560  1  20 EA EB           jsr RelativeEnemyPosition
00C563  1  20 FB DC           jsr GetEnemyBoundBox
00C566  1  20 6E D3           jsr PlayerEnemyCollision
00C569  1  4C 95 D1           jmp OffscreenBoundsCheck
00C56C  1               
00C56C  1               ;--------------------------------
00C56C  1               
00C56C  1               RunFirebarObj:
00C56C  1  20 72 C9           jsr ProcFirebar
00C56F  1  4C 95 D1           jmp OffscreenBoundsCheck
00C572  1               
00C572  1               ;--------------------------------
00C572  1               
00C572  1               RunSmallPlatform:
00C572  1  20 47 EC           jsr GetEnemyOffscreenBits
00C575  1  20 EA EB           jsr RelativeEnemyPosition
00C578  1  20 04 DD           jsr SmallPlatformBoundBox
00C57B  1  20 96 D6           jsr SmallPlatformCollision
00C57E  1  20 EA EB           jsr RelativeEnemyPosition
00C581  1  20 1E E8           jsr DrawSmallPlatform
00C584  1  20 70 D1           jsr MoveSmallPlatform
00C587  1  4C 95 D1           jmp OffscreenBoundsCheck
00C58A  1               
00C58A  1               ;--------------------------------
00C58A  1               
00C58A  1               RunLargePlatform:
00C58A  1  20 47 EC             jsr GetEnemyOffscreenBits
00C58D  1  20 EA EB             jsr RelativeEnemyPosition
00C590  1  20 2B DD             jsr LargePlatformBoundBox
00C593  1  20 60 D6             jsr LargePlatformCollision
00C596  1  AD 47 07             lda TimerControl             ;if master timer control set,
00C599  1  D0 03                bne SkipPT                   ;skip subroutine tree
00C59B  1  20 A7 C5             jsr LargePlatformSubroutines
00C59E  1  20 EA EB     SkipPT: jsr RelativeEnemyPosition
00C5A1  1  20 80 E0             jsr DrawLargePlatform
00C5A4  1  4C 95 D1             jmp OffscreenBoundsCheck
00C5A7  1               
00C5A7  1               ;--------------------------------
00C5A7  1               
00C5A7  1               LargePlatformSubroutines:
00C5A7  1  B5 16              lda Enemy_ID,x  ;subtract $24 to get proper offset for jump table
00C5A9  1  38                 sec
00C5AA  1  E9 24              sbc #$24
00C5AC  1  20 A8 BA           jsr JumpEngine
00C5AF  1               
00C5AF  1  4D CF              .word BalancePlatform   ;table used by objects $24-$2a
00C5B1  1  EE D0              .word YMovingPlatform
00C5B3  1  6A D1              .word MoveLargeLiftPlat
00C5B5  1  6A D1              .word MoveLargeLiftPlat
00C5B7  1  22 D1              .word XMovingPlatform
00C5B9  1  4C D1              .word DropPlatform
00C5BB  1  58 D1              .word RightPlatform
00C5BD  1               
00C5BD  1               ;-------------------------------------------------------------------------------------
00C5BD  1               
00C5BD  1               WarpZoneObject:
00C5BD  1  AD 23 07           lda ScrollLock         ;check for scroll lock flag
00C5C0  1  F0 23              beq ExitWarpObject           ;branch if not set to leave
00C5C2  1  A5 CE              lda Player_Y_Position  ;check to see if player's vertical coordinate has
00C5C4  1  25 B5              and Player_Y_HighPos   ;same bits set as in vertical high byte (why?)
00C5C6  1  D0 1D              bne ExitWarpObject           ;if so, branch to leave
00C5C8  1  8D 23 07           sta ScrollLock         ;otherwise nullify scroll lock flag
00C5CB  1  EE D6 06           inc WarpZoneControl    ;increment warp zone flag to make warp pipes for warp zone
00C5CE  1                     ; jmp EraseEnemyObject   ;kill this object
00C5CE  1               EraseEnemyObject:
00C5CE  1  A9 00              lda #$00                 ;clear all enemy object variables
00C5D0  1  95 0F              sta Enemy_Flag,x
00C5D2  1  95 16              sta Enemy_ID,x
00C5D4  1  95 1E              sta Enemy_State,x
00C5D6  1  9D 10 01           sta FloateyNum_Control,x
00C5D9  1  9D 96 07           sta EnemyIntervalTimer,x
00C5DC  1  9D 25 01           sta ShellChainCounter,x
00C5DF  1  9D C5 03           sta Enemy_SprAttrib,x
00C5E2  1  9D 8A 07           sta EnemyFrameTimer,x
00C5E5  1               ExitWarpObject:
00C5E5  1  60                 rts
00C5E6  1               
00C5E6  1               ;-------------------------------------------------------------------------------------
00C5E6  1               
00C5E6  1               MovePodoboo:
00C5E6  1  BD 96 07           lda EnemyIntervalTimer,x   ;check enemy timer
00C5E9  1  D0 16              bne PdbM                   ;branch to move enemy if not expired
00C5EB  1  20 30 C0           jsr InitPodoboo            ;otherwise set up podoboo again
00C5EE  1  BD A8 07           lda PseudoRandomBitReg+1,x ;get part of LSFR
00C5F1  1  09 80              ora #%10000000             ;set d7
00C5F3  1  9D 34 04           sta Enemy_Y_MoveForce,x    ;store as movement force
00C5F6  1  29 0F              and #%00001111             ;mask out high nybble
00C5F8  1  09 06              ora #$06                   ;set for at least six intervals
00C5FA  1  9D 96 07           sta EnemyIntervalTimer,x   ;store as new enemy timer
00C5FD  1  A9 F9              lda #$f9
00C5FF  1  95 A0              sta Enemy_Y_Speed,x        ;set vertical speed to move podoboo upwards
00C601  1  4C 74 BF     PdbM: jmp MoveJ_EnemyVertically  ;branch to impose gravity on podoboo
00C604  1               
00C604  1               ;--------------------------------
00C604  1               ;$00 - used in HammerBroJumpCode as bitmask
00C604  1               
00C604  1               HammerThrowTmrData:
00C604  1  30 1C              .byte $30, $1c
00C606  1               
00C606  1               XSpeedAdderData:
00C606  1  00 E8 00 18        .byte $00, $e8, $00, $18
00C60A  1               
00C60A  1               RevivedXSpeed:
00C60A  1  08 F8 0C F4        .byte $08, $f8, $0c, $f4
00C60E  1               
00C60E  1               ProcHammerBro:
00C60E  1  B5 1E               lda Enemy_State,x          ;check hammer bro's enemy state for d5 set
00C610  1  29 20               and #%00100000
00C612  1  F0 03               beq ChkJH                  ;if not set, go ahead with code
00C614  1  4C 1B C7            jmp MoveDefeatedEnemy      ;otherwise jump to something else
00C617  1  B5 3C        ChkJH: lda HammerBroJumpTimer,x   ;check jump timer
00C619  1  F0 2D               beq HammerBroJumpCode      ;if expired, branch to jump
00C61B  1  D6 3C               dec HammerBroJumpTimer,x   ;otherwise decrement jump timer
00C61D  1  AD D1 03            lda Enemy_OffscreenBits
00C620  1  29 0C               and #%00001100             ;check offscreen bits
00C622  1  D0 6A               bne MoveHammerBroXDir      ;if hammer bro a little offscreen, skip to movement code
00C624  1  BD A2 03            lda HammerThrowingTimer,x  ;check hammer throwing timer
00C627  1  D0 17               bne DecHT                  ;if not expired, skip ahead, do not throw hammer
00C629  1  AC CC 06            ldy SecondaryHardMode      ;otherwise get secondary hard mode flag
00C62C  1  B9 04 C6            lda HammerThrowTmrData,y   ;get timer data using flag as offset
00C62F  1  9D A2 03            sta HammerThrowingTimer,x  ;set as new timer
00C632  1  20 61 F0            jsr SpawnHammerObj         ;do a sub here to spawn hammer object
00C635  1  90 09               bcc DecHT                  ;if carry clear, hammer not spawned, skip to decrement timer
00C637  1  B5 1E               lda Enemy_State,x
00C639  1  09 08               ora #%00001000             ;set d3 in enemy state for hammer throw
00C63B  1  95 1E               sta Enemy_State,x
00C63D  1  4C 8E C6            jmp MoveHammerBroXDir      ;jump to move hammer bro
00C640  1  DE A2 03     DecHT: dec HammerThrowingTimer,x  ;decrement timer
00C643  1  4C 8E C6            jmp MoveHammerBroXDir      ;jump to move hammer bro
00C646  1               
00C646  1               HammerBroJumpLData:
00C646  1  20 37              .byte $20, $37
00C648  1               
00C648  1               HammerBroJumpCode:
00C648  1  B5 1E               lda Enemy_State,x           ;get hammer bro's enemy state
00C64A  1  29 07               and #%00000111              ;mask out all but 3 LSB
00C64C  1  C9 01               cmp #$01                    ;check for d0 set (for jumping)
00C64E  1  F0 3E               beq MoveHammerBroXDir       ;if set, branch ahead to moving code
00C650  1  A9 00               lda #$00                    ;load default value here
00C652  1  85 00               sta $00                     ;save into temp variable for now
00C654  1  A0 FA               ldy #$fa                    ;set default vertical speed
00C656  1  B5 CF               lda Enemy_Y_Position,x      ;check hammer bro's vertical coordinate
00C658  1  30 13               bmi SetHJ                   ;if on the bottom half of the screen, use current speed
00C65A  1  A0 FD               ldy #$fd                    ;otherwise set alternate vertical speed
00C65C  1  C9 70               cmp #$70                    ;check to see if hammer bro is above the middle of screen
00C65E  1  E6 00               inc $00                     ;increment preset value to $01
00C660  1  90 0B               bcc SetHJ                   ;if above the middle of the screen, use current speed and $01
00C662  1  C6 00               dec $00                     ;otherwise return value to $00
00C664  1  BD A8 07            lda PseudoRandomBitReg+1,x  ;get part of LSFR, mask out all but LSB
00C667  1  29 01               and #$01
00C669  1  D0 02               bne SetHJ                   ;if d0 of LSFR set, branch and use current speed and $00
00C66B  1  A0 FA               ldy #$fa                    ;otherwise reset to default vertical speed
00C66D  1  94 A0        SetHJ: sty Enemy_Y_Speed,x         ;set vertical speed for jumping
00C66F  1  B5 1E               lda Enemy_State,x           ;set d0 in enemy state for jumping
00C671  1  09 01               ora #$01
00C673  1  95 1E               sta Enemy_State,x
00C675  1  A5 00               lda $00                     ;load preset value here to use as bitmask
00C677  1  3D A9 07            and PseudoRandomBitReg+2,x  ;and do bit-wise comparison with part of LSFR
00C67A  1  A8                  tay                         ;then use as offset
00C67B  1  AD CC 06            lda SecondaryHardMode       ;check secondary hard mode flag
00C67E  1  D0 01               bne HJump
00C680  1  A8                  tay                         ;if secondary hard mode flag clear, set offset to 0
00C681  1  B9 46 C6     HJump: lda HammerBroJumpLData,y    ;get jump length timer data using offset from before
00C684  1  9D 8A 07            sta EnemyFrameTimer,x       ;save in enemy timer
00C687  1  BD A8 07            lda PseudoRandomBitReg+1,x
00C68A  1  09 C0               ora #%11000000              ;get contents of part of LSFR, set d7 and d6, then
00C68C  1  95 3C               sta HammerBroJumpTimer,x    ;store in jump timer
00C68E  1               
00C68E  1               MoveHammerBroXDir:
00C68E  1  A0 FC                 ldy #$fc                  ;move hammer bro a little to the left
00C690  1  A5 09                 lda FrameCounter
00C692  1  29 40                 and #%01000000            ;change hammer bro's direction every 64 frames
00C694  1  D0 02                 bne Shimmy
00C696  1  A0 04                 ldy #$04                  ;if d6 set in counter, move him a little to the right
00C698  1  94 58        Shimmy:  sty Enemy_X_Speed,x       ;store horizontal speed
00C69A  1  A0 01                 ldy #$01                  ;set to face right by default
00C69C  1  20 FB DB              jsr PlayerEnemyDiff       ;get horizontal difference between player and hammer bro
00C69F  1  30 0A                 bmi SetShim               ;if enemy to the left of player, skip this part
00C6A1  1  C8                    iny                       ;set to face left
00C6A2  1  BD 96 07              lda EnemyIntervalTimer,x  ;check walking timer
00C6A5  1  D0 04                 bne SetShim               ;if not yet expired, skip to set moving direction
00C6A7  1  A9 F8                 lda #$f8
00C6A9  1  95 58                 sta Enemy_X_Speed,x       ;otherwise, make the hammer bro walk left towards player
00C6AB  1  94 46        SetShim: sty Enemy_MovingDir,x     ;set moving direction
00C6AD  1               
00C6AD  1               MoveNormalEnemy:
00C6AD  1  A0 00               ldy #$00                   ;init Y to leave horizontal movement as-is
00C6AF  1  B5 1E               lda Enemy_State,x
00C6B1  1  29 40               and #%01000000             ;check enemy state for d6 set, if set skip
00C6B3  1  D0 19               bne FallE                  ;to move enemy vertically, then horizontally if necessary
00C6B5  1  B5 1E               lda Enemy_State,x
00C6B7  1  0A                  asl                        ;check enemy state for d7 set
00C6B8  1  B0 30               bcs SteadM                 ;if set, branch to move enemy horizontally
00C6BA  1  B5 1E               lda Enemy_State,x
00C6BC  1  29 20               and #%00100000             ;check enemy state for d5 set
00C6BE  1  D0 5B               bne MoveDefeatedEnemy      ;if set, branch to move defeated enemy object
00C6C0  1  B5 1E               lda Enemy_State,x
00C6C2  1  29 07               and #%00000111             ;check d2-d0 of enemy state for any set bits
00C6C4  1  F0 24               beq SteadM                 ;if enemy in normal state, branch to move enemy horizontally
00C6C6  1  C9 05               cmp #$05
00C6C8  1  F0 04               beq FallE                  ;if enemy in state used by spiny's egg, go ahead here
00C6CA  1  C9 03               cmp #$03
00C6CC  1  B0 30               bcs ReviveStunned          ;if enemy in states $03 or $04, skip ahead to yet another part
00C6CE  1  20 45 BF     FallE: jsr MoveD_EnemyVertically  ;do a sub here to move enemy downwards
00C6D1  1  A0 00               ldy #$00
00C6D3  1  B5 1E               lda Enemy_State,x          ;check for enemy state $02
00C6D5  1  C9 02               cmp #$02
00C6D7  1  F0 0C               beq MEHor                  ;if found, branch to move enemy horizontally
00C6D9  1  29 40               and #%01000000             ;check for d6 set
00C6DB  1  F0 0D               beq SteadM                 ;if not set, branch to something else
00C6DD  1  B5 16               lda Enemy_ID,x
00C6DF  1  C9 2E               cmp #PowerUpObject         ;check for power-up object
00C6E1  1  F0 07               beq SteadM
00C6E3  1  D0 03               bne SlowM                  ;if any other object where d6 set, jump to set Y
00C6E5  1  4C E4 BE     MEHor: jmp MoveEnemyHorizontally  ;jump here to move enemy horizontally for <> $2e and d6 set
00C6E8  1               
00C6E8  1  A0 01        SlowM:  ldy #$01                  ;if branched here, increment Y to slow horizontal movement
00C6EA  1  B5 58        SteadM: lda Enemy_X_Speed,x       ;get current horizontal speed
00C6EC  1  48                   pha                       ;save to stack
00C6ED  1  10 02                bpl AddHS                 ;if not moving or moving right, skip, leave Y alone
00C6EF  1  C8                   iny
00C6F0  1  C8                   iny                       ;otherwise increment Y to next data
00C6F1  1  18           AddHS:  clc
00C6F2  1  79 06 C6             adc XSpeedAdderData,y     ;add value here to slow enemy down if necessary
00C6F5  1  95 58                sta Enemy_X_Speed,x       ;save as horizontal speed temporarily
00C6F7  1  20 E4 BE             jsr MoveEnemyHorizontally ;then do a sub to move horizontally
00C6FA  1  68                   pla
00C6FB  1  95 58                sta Enemy_X_Speed,x       ;get old horizontal speed from stack and return to
00C6FD  1  60                   rts                       ;original memory location, then leave
00C6FE  1               
00C6FE  1               ReviveStunned:
00C6FE  1  BD 96 07              lda EnemyIntervalTimer,x  ;if enemy timer not expired yet,
00C701  1  D0 1E                 bne ChkKillGoomba         ;skip ahead to something else
00C703  1  95 1E                 sta Enemy_State,x         ;otherwise initialize enemy state to normal
00C705  1  A5 09                 lda FrameCounter
00C707  1  29 01                 and #$01                  ;get d0 of frame counter
00C709  1  A8                    tay                       ;use as Y and increment for movement direction
00C70A  1  C8                    iny
00C70B  1  94 46                 sty Enemy_MovingDir,x     ;store as pseudorandom movement direction
00C70D  1  88                    dey                       ;decrement for use as pointer
00C70E  1  AD 6A 07              lda PrimaryHardMode       ;check primary hard mode flag
00C711  1  F0 02                 beq SetRSpd               ;if not set, use pointer as-is
00C713  1  C8                    iny
00C714  1  C8                    iny                       ;otherwise increment 2 bytes to next data
00C715  1  B9 0A C6     SetRSpd: lda RevivedXSpeed,y       ;load and store new horizontal speed
00C718  1  95 58                 sta Enemy_X_Speed,x       ;and leave
00C71A  1  60                    rts
00C71B  1               
00C71B  1               MoveDefeatedEnemy:
00C71B  1  20 45 BF           jsr MoveD_EnemyVertically      ;execute sub to move defeated enemy downwards
00C71E  1  4C E4 BE           jmp MoveEnemyHorizontally      ;now move defeated enemy horizontally
00C721  1               
00C721  1               ChkKillGoomba:
00C721  1  C9 0E                cmp #$0e              ;check to see if enemy timer has reached
00C723  1  D0 09                bne NKGmba            ;a certain point, and branch to leave if not
00C725  1  B5 16                lda Enemy_ID,x
00C727  1  C9 06                cmp #Goomba           ;check for goomba object
00C729  1  D0 03                bne NKGmba            ;branch if not found
00C72B  1  20 CE C5             jsr EraseEnemyObject  ;otherwise, kill this goomba object
00C72E  1  60           NKGmba: rts                   ;leave!
00C72F  1               
00C72F  1               ;--------------------------------
00C72F  1               
00C72F  1               MoveJumpingEnemy:
00C72F  1  20 74 BF           jsr MoveJ_EnemyVertically  ;do a sub to impose gravity on green paratroopa
00C732  1  4C E4 BE           jmp MoveEnemyHorizontally  ;jump to move enemy horizontally
00C735  1               
00C735  1               ;--------------------------------
00C735  1               
00C735  1               ProcMoveRedPTroopa:
00C735  1  B5 A0                  lda Enemy_Y_Speed,x
00C737  1  1D 34 04               ora Enemy_Y_MoveForce,x     ;check for any vertical force or speed
00C73A  1  D0 13                  bne MoveRedPTUpOrDown       ;branch if any found
00C73C  1  9D 17 04               sta Enemy_YMF_Dummy,x       ;initialize something here
00C73F  1  B5 CF                  lda Enemy_Y_Position,x      ;check current vs. original vertical coordinate
00C741  1  DD 01 04               cmp RedPTroopaOrigXPos,x
00C744  1  B0 09                  bcs MoveRedPTUpOrDown       ;if current => original, skip ahead to more code
00C746  1  A5 09                  lda FrameCounter            ;get frame counter
00C748  1  29 07                  and #%00000111              ;mask out all but 3 LSB
00C74A  1  D0 02                  bne NoIncPT                 ;if any bits set, branch to leave
00C74C  1  F6 CF                  inc Enemy_Y_Position,x      ;otherwise increment red paratroopa's vertical position
00C74E  1  60           NoIncPT:  rts                         ;leave
00C74F  1               
00C74F  1               MoveRedPTUpOrDown:
00C74F  1  B5 CF                  lda Enemy_Y_Position,x      ;check current vs. central vertical coordinate
00C751  1  D5 58                  cmp RedPTroopaCenterYPos,x
00C753  1  90 03                  bcc MovPTDwn                ;if current < central, jump to move downwards
00C755  1  4C 57 BF               jmp MoveRedPTroopaUp        ;otherwise jump to move upwards
00C758  1  4C 52 BF     MovPTDwn: jmp MoveRedPTroopaDown      ;move downwards
00C75B  1               
00C75B  1               ;--------------------------------
00C75B  1               ;$00 - used to store adder for movement, also used as adder for platform
00C75B  1               ;$01 - used to store maximum value for secondary counter
00C75B  1               
00C75B  1               MoveFlyGreenPTroopa:
00C75B  1  20 7B C7             jsr XMoveCntr_GreenPTroopa ;do sub to increment primary and secondary counters
00C75E  1  20 9C C7             jsr MoveWithXMCntrs        ;do sub to move green paratroopa accordingly, and horizontally
00C761  1  A0 01                ldy #$01                   ;set Y to move green paratroopa down
00C763  1  A5 09                lda FrameCounter
00C765  1  29 03                and #%00000011             ;check frame counter 2 LSB for any bits set
00C767  1  D0 11                bne NoMGPT                 ;branch to leave if set to move up/down every fourth frame
00C769  1  A5 09                lda FrameCounter
00C76B  1  29 40                and #%01000000             ;check frame counter for d6 set
00C76D  1  D0 02                bne YSway                  ;branch to move green paratroopa down if set
00C76F  1  A0 FF                ldy #$ff                   ;otherwise set Y to move green paratroopa up
00C771  1  84 00        YSway:  sty $00                    ;store adder here
00C773  1  B5 CF                lda Enemy_Y_Position,x
00C775  1  18                   clc                        ;add or subtract from vertical position
00C776  1  65 00                adc $00                    ;to give green paratroopa a wavy flight
00C778  1  95 CF                sta Enemy_Y_Position,x
00C77A  1  60           NoMGPT: rts                        ;leave!
00C77B  1               
00C77B  1               XMoveCntr_GreenPTroopa:
00C77B  1  A9 13                 lda #$13                    ;load preset maximum value for secondary counter
00C77D  1               
00C77D  1               XMoveCntr_Platform:
00C77D  1  85 01                 sta $01                     ;store value here
00C77F  1  A5 09                 lda FrameCounter
00C781  1  29 03                 and #%00000011              ;branch to leave if not on
00C783  1  D0 0D                 bne NoIncXM                 ;every fourth frame
00C785  1  B4 58                 ldy XMoveSecondaryCounter,x ;get secondary counter
00C787  1  B5 A0                 lda XMovePrimaryCounter,x   ;get primary counter
00C789  1  4A                    lsr
00C78A  1  B0 0A                 bcs DecSeXM                 ;if d0 of primary counter set, branch elsewhere
00C78C  1  C4 01                 cpy $01                     ;compare secondary counter to preset maximum value
00C78E  1  F0 03                 beq IncPXM                  ;if equal, branch ahead of this part
00C790  1  F6 58                 inc XMoveSecondaryCounter,x ;increment secondary counter and leave
00C792  1  60           NoIncXM: rts
00C793  1  F6 A0        IncPXM:  inc XMovePrimaryCounter,x   ;increment primary counter and leave
00C795  1  60                    rts
00C796  1  98           DecSeXM: tya                         ;put secondary counter in A
00C797  1  F0 FA                 beq IncPXM                  ;if secondary counter at zero, branch back
00C799  1  D6 58                 dec XMoveSecondaryCounter,x ;otherwise decrement secondary counter and leave
00C79B  1  60                    rts
00C79C  1               
00C79C  1               MoveWithXMCntrs:
00C79C  1  B5 58                 lda XMoveSecondaryCounter,x  ;save secondary counter to stack
00C79E  1  48                    pha
00C79F  1  A0 01                 ldy #$01                     ;set value here by default
00C7A1  1  B5 A0                 lda XMovePrimaryCounter,x
00C7A3  1  29 02                 and #%00000010               ;if d1 of primary counter is
00C7A5  1  D0 0B                 bne XMRight                  ;set, branch ahead of this part here
00C7A7  1  B5 58                 lda XMoveSecondaryCounter,x
00C7A9  1  49 FF                 eor #$ff                     ;otherwise change secondary
00C7AB  1  18                    clc                          ;counter to two's compliment
00C7AC  1  69 01                 adc #$01
00C7AE  1  95 58                 sta XMoveSecondaryCounter,x
00C7B0  1  A0 02                 ldy #$02                     ;load alternate value here
00C7B2  1  94 46        XMRight: sty Enemy_MovingDir,x        ;store as moving direction
00C7B4  1  20 E4 BE              jsr MoveEnemyHorizontally
00C7B7  1  85 00                 sta $00                      ;save value obtained from sub here
00C7B9  1  68                    pla                          ;get secondary counter from stack
00C7BA  1  95 58                 sta XMoveSecondaryCounter,x  ;and return to original place
00C7BC  1  60                    rts
00C7BD  1               
00C7BD  1               ;--------------------------------
00C7BD  1               
00C7BD  1               BlooberBitmasks:
00C7BD  1  3F 03              .byte %00111111, %00000011
00C7BF  1               
00C7BF  1               MoveBloober:
00C7BF  1  B5 1E                lda Enemy_State,x
00C7C1  1  29 20                and #%00100000             ;check enemy state for d5 set
00C7C3  1  D0 4D                bne MoveDefeatedBloober    ;branch if set to move defeated bloober
00C7C5  1  AC CC 06             ldy SecondaryHardMode      ;use secondary hard mode flag as offset
00C7C8  1  BD A8 07             lda PseudoRandomBitReg+1,x ;get LSFR
00C7CB  1  39 BD C7             and BlooberBitmasks,y      ;mask out bits in LSFR using bitmask loaded with offset
00C7CE  1  D0 12                bne BlooberSwim            ;if any bits set, skip ahead to make swim
00C7D0  1  8A                   txa
00C7D1  1  4A                   lsr                        ;check to see if on second or fourth slot (1 or 3)
00C7D2  1  90 04                bcc FBLeft                 ;if not, branch to figure out moving direction
00C7D4  1  A4 45                ldy Player_MovingDir       ;otherwise, load player's moving direction and
00C7D6  1  B0 08                bcs SBMDir                 ;do an unconditional branch to set
00C7D8  1  A0 02        FBLeft: ldy #$02                   ;set left moving direction by default
00C7DA  1  20 FB DB             jsr PlayerEnemyDiff        ;get horizontal difference between player and bloober
00C7DD  1  10 01                bpl SBMDir                 ;if enemy to the right of player, keep left
00C7DF  1  88                   dey                        ;otherwise decrement to set right moving direction
00C7E0  1  94 46        SBMDir: sty Enemy_MovingDir,x      ;set moving direction of bloober, then continue on here
00C7E2  1               
00C7E2  1               BlooberSwim:
00C7E2  1  20 15 C8            jsr ProcSwimmingB        ;execute sub to make bloober swim characteristically
00C7E5  1  B5 CF               lda Enemy_Y_Position,x   ;get vertical coordinate
00C7E7  1  38                  sec
00C7E8  1  FD 34 04            sbc Enemy_Y_MoveForce,x  ;subtract movement force
00C7EB  1  C9 20               cmp #$20                 ;check to see if position is above edge of status bar
00C7ED  1  90 02               bcc SwimX                ;if so, don't do it
00C7EF  1  95 CF               sta Enemy_Y_Position,x   ;otherwise, set new vertical position, make bloober swim
00C7F1  1  B4 46        SwimX: ldy Enemy_MovingDir,x    ;check moving direction
00C7F3  1  88                  dey
00C7F4  1  D0 0E               bne LeftSwim             ;if moving to the left, branch to second part
00C7F6  1  B5 87               lda Enemy_X_Position,x
00C7F8  1  18                  clc                      ;add movement speed to horizontal coordinate
00C7F9  1  75 58               adc BlooperMoveSpeed,x
00C7FB  1  95 87               sta Enemy_X_Position,x   ;store result as new horizontal coordinate
00C7FD  1  B5 6E               lda Enemy_PageLoc,x
00C7FF  1  69 00               adc #$00                 ;add carry to page location
00C801  1  95 6E               sta Enemy_PageLoc,x      ;store as new page location and leave
00C803  1  60                  rts
00C804  1               
00C804  1               LeftSwim:
00C804  1  B5 87              lda Enemy_X_Position,x
00C806  1  38                 sec                      ;subtract movement speed from horizontal coordinate
00C807  1  F5 58              sbc BlooperMoveSpeed,x
00C809  1  95 87              sta Enemy_X_Position,x   ;store result as new horizontal coordinate
00C80B  1  B5 6E              lda Enemy_PageLoc,x
00C80D  1  E9 00              sbc #$00                 ;subtract borrow from page location
00C80F  1  95 6E              sta Enemy_PageLoc,x      ;store as new page location and leave
00C811  1  60                 rts
00C812  1               
00C812  1               MoveDefeatedBloober:
00C812  1  4C 6E BF           jmp MoveEnemySlowVert    ;jump to move defeated bloober downwards
00C815  1               
00C815  1               ProcSwimmingB:
00C815  1  B5 A0                lda BlooperMoveCounter,x  ;get enemy's movement counter
00C817  1  29 02                and #%00000010            ;check for d1 set
00C819  1  D0 37                bne ChkForFloatdown       ;branch if set
00C81B  1  A5 09                lda FrameCounter
00C81D  1  29 07                and #%00000111            ;get 3 LSB of frame counter
00C81F  1  48                   pha                       ;and save it to the stack
00C820  1  B5 A0                lda BlooperMoveCounter,x  ;get enemy's movement counter
00C822  1  4A                   lsr                       ;check for d0 set
00C823  1  B0 15                bcs SlowSwim              ;branch if set
00C825  1  68                   pla                       ;pull 3 LSB of frame counter from the stack
00C826  1  D0 11                bne BSwimE                ;branch to leave, execute code only every eighth frame
00C828  1  BD 34 04             lda Enemy_Y_MoveForce,x
00C82B  1  18                   clc                       ;add to movement force to speed up swim
00C82C  1  69 01                adc #$01
00C82E  1  9D 34 04             sta Enemy_Y_MoveForce,x   ;set movement force
00C831  1  95 58                sta BlooperMoveSpeed,x    ;set as movement speed
00C833  1  C9 02                cmp #$02
00C835  1  D0 02                bne BSwimE                ;if certain horizontal speed, branch to leave
00C837  1  F6 A0                inc BlooperMoveCounter,x  ;otherwise increment movement counter
00C839  1  60           BSwimE: rts
00C83A  1               
00C83A  1               SlowSwim:
00C83A  1  68                  pla                      ;pull 3 LSB of frame counter from the stack
00C83B  1  D0 14               bne NoSSw                ;branch to leave, execute code only every eighth frame
00C83D  1  BD 34 04            lda Enemy_Y_MoveForce,x
00C840  1  38                  sec                      ;subtract from movement force to slow swim
00C841  1  E9 01               sbc #$01
00C843  1  9D 34 04            sta Enemy_Y_MoveForce,x  ;set movement force
00C846  1  95 58               sta BlooperMoveSpeed,x   ;set as movement speed
00C848  1  D0 07               bne NoSSw                ;if any speed, branch to leave
00C84A  1  F6 A0               inc BlooperMoveCounter,x ;otherwise increment movement counter
00C84C  1  A9 02               lda #$02
00C84E  1  9D 96 07            sta EnemyIntervalTimer,x ;set enemy's timer
00C851  1  60           NoSSw: rts                      ;leave
00C852  1               
00C852  1               ChkForFloatdown:
00C852  1  BD 96 07           lda EnemyIntervalTimer,x ;get enemy timer
00C855  1  F0 08              beq ChkNearPlayer        ;branch if expired
00C857  1               
00C857  1               Floatdown:
00C857  1  A5 09              lda FrameCounter        ;get frame counter
00C859  1  4A                 lsr                     ;check for d0 set
00C85A  1  B0 02              bcs NoFD                ;branch to leave on every other frame
00C85C  1  F6 CF              inc Enemy_Y_Position,x  ;otherwise increment vertical coordinate
00C85E  1  60           NoFD: rts                     ;leave
00C85F  1               
00C85F  1               ChkNearPlayer:
00C85F  1  B5 CF              lda Enemy_Y_Position,x    ;get vertical coordinate
00C861  1  69 10              adc #$10                  ;add sixteen pixels
00C863  1  C5 CE              cmp Player_Y_Position     ;compare result with player's vertical coordinate
00C865  1  90 F0              bcc Floatdown             ;if modified vertical less than player's, branch
00C867  1  A9 00              lda #$00
00C869  1  95 A0              sta BlooperMoveCounter,x  ;otherwise nullify movement counter
00C86B  1  60                 rts
00C86C  1               
00C86C  1               ;--------------------------------
00C86C  1               
00C86C  1               MoveBulletBill:
00C86C  1  B5 1E                 lda Enemy_State,x          ;check bullet bill's enemy object state for d5 set
00C86E  1  29 20                 and #%00100000
00C870  1  F0 03                 beq NotDefB                ;if not set, continue with movement code
00C872  1  4C 74 BF              jmp MoveJ_EnemyVertically  ;otherwise jump to move defeated bullet bill downwards
00C875  1  A9 E8        NotDefB: lda #$e8                   ;set bullet bill's horizontal speed
00C877  1  95 58                 sta Enemy_X_Speed,x        ;and move it accordingly (note: this bullet bill
00C879  1  4C E4 BE              jmp MoveEnemyHorizontally  ;object occurs in frenzy object $17, not from cannons)
00C87C  1               
00C87C  1               ;--------------------------------
00C87C  1               ;$02 - used to hold preset values
00C87C  1               ;$03 - used to hold enemy state
00C87C  1               
00C87C  1               SwimCCXMoveData:
00C87C  1  40 80              .byte $40, $80
00C87E  1  04 04              .byte $04, $04 ;residual data, not used
00C880  1               
00C880  1               MoveSwimmingCheepCheep:
00C880  1  B5 1E                lda Enemy_State,x         ;check cheep-cheep's enemy object state
00C882  1  29 20                and #%00100000            ;for d5 set
00C884  1  F0 03                beq CCSwim                ;if not set, continue with movement code
00C886  1  4C 6E BF             jmp MoveEnemySlowVert     ;otherwise jump to move defeated cheep-cheep downwards
00C889  1  85 03        CCSwim: sta $03                   ;save enemy state in $03
00C88B  1  B5 16                lda Enemy_ID,x            ;get enemy identifier
00C88D  1  38                   sec
00C88E  1  E9 0A                sbc #$0a                  ;subtract ten for cheep-cheep identifiers
00C890  1  A8                   tay                       ;use as offset
00C891  1  B9 7C C8             lda SwimCCXMoveData,y     ;load value here
00C894  1  85 02                sta $02
00C896  1  BD 01 04             lda Enemy_X_MoveForce,x   ;load horizontal force
00C899  1  38                   sec
00C89A  1  E5 02                sbc $02                   ;subtract preset value from horizontal force
00C89C  1  9D 01 04             sta Enemy_X_MoveForce,x   ;store as new horizontal force
00C89F  1  B5 87                lda Enemy_X_Position,x    ;get horizontal coordinate
00C8A1  1  E9 00                sbc #$00                  ;subtract borrow (thus moving it slowly)
00C8A3  1  95 87                sta Enemy_X_Position,x    ;and save as new horizontal coordinate
00C8A5  1  B5 6E                lda Enemy_PageLoc,x
00C8A7  1  E9 00                sbc #$00                  ;subtract borrow again, this time from the
00C8A9  1  95 6E                sta Enemy_PageLoc,x       ;page location, then save
00C8AB  1  A9 20                lda #$20
00C8AD  1  85 02                sta $02                   ;save new value here
00C8AF  1  E0 02                cpx #$02                  ;check enemy object offset
00C8B1  1  90 49                bcc ExSwCC                ;if in first or second slot, branch to leave
00C8B3  1  B5 58                lda CheepCheepMoveMFlag,x ;check movement flag
00C8B5  1  C9 10                cmp #$10                  ;if movement speed set to $00,
00C8B7  1  90 16                bcc CCSwimUpwards         ;branch to move upwards
00C8B9  1  BD 17 04             lda Enemy_YMF_Dummy,x
00C8BC  1  18                   clc
00C8BD  1  65 02                adc $02                   ;add preset value to dummy variable to get carry
00C8BF  1  9D 17 04             sta Enemy_YMF_Dummy,x     ;and save dummy
00C8C2  1  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
00C8C4  1  65 03                adc $03                   ;add carry to it plus enemy state to slowly move it downwards
00C8C6  1  95 CF                sta Enemy_Y_Position,x    ;save as new vertical coordinate
00C8C8  1  B5 B6                lda Enemy_Y_HighPos,x
00C8CA  1  69 00                adc #$00                  ;add carry to page location and
00C8CC  1  4C E2 C8             jmp ChkSwimYPos           ;jump to end of movement code
00C8CF  1               
00C8CF  1               CCSwimUpwards:
00C8CF  1  BD 17 04             lda Enemy_YMF_Dummy,x
00C8D2  1  38                   sec
00C8D3  1  E5 02                sbc $02                   ;subtract preset value to dummy variable to get borrow
00C8D5  1  9D 17 04             sta Enemy_YMF_Dummy,x     ;and save dummy
00C8D8  1  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
00C8DA  1  E5 03                sbc $03                   ;subtract borrow to it plus enemy state to slowly move it upwards
00C8DC  1  95 CF                sta Enemy_Y_Position,x    ;save as new vertical coordinate
00C8DE  1  B5 B6                lda Enemy_Y_HighPos,x
00C8E0  1  E9 00                sbc #$00                  ;subtract borrow from page location
00C8E2  1               
00C8E2  1               ChkSwimYPos:
00C8E2  1  95 B6                sta Enemy_Y_HighPos,x     ;save new page location here
00C8E4  1  A0 00                ldy #$00                  ;load movement speed to upwards by default
00C8E6  1  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
00C8E8  1  38                   sec
00C8E9  1  FD 34 04             sbc CheepCheepOrigYPos,x  ;subtract original coordinate from current
00C8EC  1  10 07                bpl YPDiff                ;if result positive, skip to next part
00C8EE  1  A0 10                ldy #$10                  ;otherwise load movement speed to downwards
00C8F0  1  49 FF                eor #$ff
00C8F2  1  18                   clc                       ;get two's compliment of result
00C8F3  1  69 01                adc #$01                  ;to obtain total difference of original vs. current
00C8F5  1  C9 0F        YPDiff: cmp #$0f                  ;if difference between original vs. current vertical
00C8F7  1  90 03                bcc ExSwCC                ;coordinates < 15 pixels, leave movement speed alone
00C8F9  1  98                   tya
00C8FA  1  95 58                sta CheepCheepMoveMFlag,x ;otherwise change movement speed
00C8FC  1  60           ExSwCC: rts                       ;leave
00C8FD  1               
00C8FD  1               ;--------------------------------
00C8FD  1               ;$00 - used as counter for firebar parts
00C8FD  1               ;$01 - used for oscillated high byte of spin state or to hold horizontal adder
00C8FD  1               ;$02 - used for oscillated high byte of spin state or to hold vertical adder
00C8FD  1               ;$03 - used for mirror data
00C8FD  1               ;$04 - used to store player's sprite 1 X coordinate
00C8FD  1               ;$05 - used to evaluate mirror data
00C8FD  1               ;$06 - used to store either screen X coordinate or sprite data offset
00C8FD  1               ;$07 - used to store screen Y coordinate
00C8FD  1               ;$ed - used to hold maximum length of firebar
00C8FD  1               ;$ef - used to hold high byte of spinstate
00C8FD  1               
00C8FD  1               ;horizontal adder is at first byte + high byte of spinstate,
00C8FD  1               ;vertical adder is same + 8 bytes, two's compliment
00C8FD  1               ;if greater than $08 for proper oscillation
00C8FD  1               FirebarPosLookupTbl:
00C8FD  1  00 01 03 04        .byte $00, $01, $03, $04, $05, $06, $07, $07, $08
00C901  1  05 06 07 07  
00C905  1  08           
00C906  1  00 03 06 09        .byte $00, $03, $06, $09, $0b, $0d, $0e, $0f, $10
00C90A  1  0B 0D 0E 0F  
00C90E  1  10           
00C90F  1  00 04 09 0D        .byte $00, $04, $09, $0d, $10, $13, $16, $17, $18
00C913  1  10 13 16 17  
00C917  1  18           
00C918  1  00 06 0C 12        .byte $00, $06, $0c, $12, $16, $1a, $1d, $1f, $20
00C91C  1  16 1A 1D 1F  
00C920  1  20           
00C921  1  00 07 0F 16        .byte $00, $07, $0f, $16, $1c, $21, $25, $27, $28
00C925  1  1C 21 25 27  
00C929  1  28           
00C92A  1  00 09 12 1B        .byte $00, $09, $12, $1b, $21, $27, $2c, $2f, $30
00C92E  1  21 27 2C 2F  
00C932  1  30           
00C933  1  00 0B 15 1F        .byte $00, $0b, $15, $1f, $27, $2e, $33, $37, $38
00C937  1  27 2E 33 37  
00C93B  1  38           
00C93C  1  00 0C 18 24        .byte $00, $0c, $18, $24, $2d, $35, $3b, $3e, $40
00C940  1  2D 35 3B 3E  
00C944  1  40           
00C945  1  00 0E 1B 28        .byte $00, $0e, $1b, $28, $32, $3b, $42, $46, $48
00C949  1  32 3B 42 46  
00C94D  1  48           
00C94E  1  00 0F 1F 2D        .byte $00, $0f, $1f, $2d, $38, $42, $4a, $4e, $50
00C952  1  38 42 4A 4E  
00C956  1  50           
00C957  1  00 11 22 31        .byte $00, $11, $22, $31, $3e, $49, $51, $56, $58
00C95B  1  3E 49 51 56  
00C95F  1  58           
00C960  1               
00C960  1               FirebarMirrorData:
00C960  1  01 03 02 00        .byte $01, $03, $02, $00
00C964  1               
00C964  1               FirebarTblOffsets:
00C964  1  00 09 12 1B        .byte $00, $09, $12, $1b, $24, $2d
00C968  1  24 2D        
00C96A  1  36 3F 48 51        .byte $36, $3f, $48, $51, $5a, $63
00C96E  1  5A 63        
00C970  1               
00C970  1               FirebarYPos:
00C970  1  0C 18              .byte $0c, $18
00C972  1               
00C972  1               ProcFirebar:
00C972  1  20 47 EC               jsr GetEnemyOffscreenBits   ;get offscreen information
00C975  1  AD D1 03               lda Enemy_OffscreenBits     ;check for d3 set
00C978  1  29 08                  and #%00001000              ;if so, branch to leave
00C97A  1  D0 74                  bne SkipFBar
00C97C  1  AD 47 07               lda TimerControl            ;if master timer control set, branch
00C97F  1  D0 0A                  bne SusFbar                 ;ahead of this part
00C981  1  BD 88 03               lda FirebarSpinSpeed,x      ;load spinning speed of firebar
00C984  1  20 2B CF               jsr FirebarSpin             ;modify current spinstate
00C987  1  29 1F                  and #%00011111              ;mask out all but 5 LSB
00C989  1  95 A0                  sta FirebarSpinState_High,x ;and store as new high byte of spinstate
00C98B  1  B5 A0        SusFbar:  lda FirebarSpinState_High,x ;get high byte of spinstate
00C98D  1  B4 16                  ldy Enemy_ID,x              ;check enemy identifier
00C98F  1  C0 1F                  cpy #$1f
00C991  1  90 0D                  bcc SetupGFB                ;if < $1f (long firebar), branch
00C993  1  C9 08                  cmp #$08                    ;check high byte of spinstate
00C995  1  F0 04                  beq SkpFSte                 ;if eight, branch to change
00C997  1  C9 18                  cmp #$18
00C999  1  D0 05                  bne SetupGFB                ;if not at twenty-four branch to not change
00C99B  1  18           SkpFSte:  clc
00C99C  1  69 01                  adc #$01                    ;add one to spinning thing to avoid horizontal state
00C99E  1  95 A0                  sta FirebarSpinState_High,x
00C9A0  1  85 EF        SetupGFB: sta $ef                     ;save high byte of spinning thing, modified or otherwise
00C9A2  1  20 EA EB               jsr RelativeEnemyPosition   ;get relative coordinates to screen
00C9A5  1  20 C4 CA               jsr GetFirebarPosition      ;do a sub here (residual, too early to be used now)
00C9A8  1  BC E5 06               ldy Enemy_SprDataOffset,x   ;get OAM data offset
00C9AB  1  AD B9 03               lda Enemy_Rel_YPos          ;get relative vertical coordinate
00C9AE  1  99 00 02               sta Sprite_Y_Position,y     ;store as Y in OAM data
00C9B1  1  85 07                  sta $07                     ;also save here
00C9B3  1  AD AE 03               lda Enemy_Rel_XPos          ;get relative horizontal coordinate
00C9B6  1  99 03 02               sta Sprite_X_Position,y     ;store as X in OAM data
00C9B9  1  85 06                  sta $06                     ;also save here
00C9BB  1  A9 01                  lda #$01
00C9BD  1  85 00                  sta $00                     ;set $01 value here (not necessary)
00C9BF  1  20 3E CA               jsr FirebarCollision        ;draw fireball part and do collision detection
00C9C2  1  A0 05                  ldy #$05                    ;load value for short firebars by default
00C9C4  1  B5 16                  lda Enemy_ID,x
00C9C6  1  C9 1F                  cmp #$1f                    ;are we doing a long firebar?
00C9C8  1  90 02                  bcc SetMFbar                ;no, branch then
00C9CA  1  A0 0B                  ldy #$0b                    ;otherwise load value for long firebars
00C9CC  1  84 ED        SetMFbar: sty $ed                     ;store maximum value for length of firebars
00C9CE  1  A9 00                  lda #$00
00C9D0  1  85 00                  sta $00                     ;initialize counter here
00C9D2  1  A5 EF        DrawFbar: lda $ef                     ;load high byte of spinstate
00C9D4  1  20 C4 CA               jsr GetFirebarPosition      ;get fireball position data depending on firebar part
00C9D7  1  20 F1 C9               jsr DrawFirebar_Collision   ;position it properly, draw it and do collision detection
00C9DA  1  A5 00                  lda $00                     ;check which firebar part
00C9DC  1  C9 04                  cmp #$04
00C9DE  1  D0 08                  bne NextFbar
00C9E0  1  AC CF 06               ldy DuplicateObj_Offset     ;if we arrive at fifth firebar part,
00C9E3  1  B9 E5 06               lda Enemy_SprDataOffset,y   ;get offset from long firebar and load OAM data offset
00C9E6  1  85 06                  sta $06                     ;using long firebar offset, then store as new one here
00C9E8  1  E6 00        NextFbar: inc $00                     ;move onto the next firebar part
00C9EA  1  A5 00                  lda $00
00C9EC  1  C5 ED                  cmp $ed                     ;if we end up at the maximum part, go on and leave
00C9EE  1  90 E2                  bcc DrawFbar                ;otherwise go back and do another
00C9F0  1  60           SkipFBar: rts
00C9F1  1               
00C9F1  1               DrawFirebar_Collision:
00C9F1  1  A5 03                 lda $03                  ;store mirror data elsewhere
00C9F3  1  85 05                 sta $05
00C9F5  1  A4 06                 ldy $06                  ;load OAM data offset for firebar
00C9F7  1  A5 01                 lda $01                  ;load horizontal adder we got from position loader
00C9F9  1  46 05                 lsr $05                  ;shift LSB of mirror data
00C9FB  1  B0 04                 bcs AddHA                ;if carry was set, skip this part
00C9FD  1  49 FF                 eor #$ff
00C9FF  1  69 01                 adc #$01                 ;otherwise get two's compliment of horizontal adder
00CA01  1  18           AddHA:   clc                      ;add horizontal coordinate relative to screen to
00CA02  1  6D AE 03              adc Enemy_Rel_XPos       ;horizontal adder, modified or otherwise
00CA05  1  99 03 02              sta Sprite_X_Position,y  ;store as X coordinate here
00CA08  1  85 06                 sta $06                  ;store here for now, note offset is saved in Y still
00CA0A  1  CD AE 03              cmp Enemy_Rel_XPos       ;compare X coordinate of sprite to original X of firebar
00CA0D  1  B0 09                 bcs SubtR1               ;if sprite coordinate => original coordinate, branch
00CA0F  1  AD AE 03              lda Enemy_Rel_XPos
00CA12  1  38                    sec                      ;otherwise subtract sprite X from the
00CA13  1  E5 06                 sbc $06                  ;original one and skip this part
00CA15  1  4C 1C CA              jmp ChkFOfs
00CA18  1  38           SubtR1:  sec                      ;subtract original X from the
00CA19  1  ED AE 03              sbc Enemy_Rel_XPos       ;current sprite X
00CA1C  1  C9 59        ChkFOfs: cmp #$59                 ;if difference of coordinates within a certain range,
00CA1E  1  90 04                 bcc VAHandl              ;continue by handling vertical adder
00CA20  1  A9 F8                 lda #$f8                 ;otherwise, load offscreen Y coordinate
00CA22  1  D0 15                 bne SetVFbr              ;and unconditionally branch to move sprite offscreen
00CA24  1  AD B9 03     VAHandl: lda Enemy_Rel_YPos       ;if vertical relative coordinate offscreen,
00CA27  1  C9 F8                 cmp #$f8                 ;skip ahead of this part and write into sprite Y coordinate
00CA29  1  F0 0E                 beq SetVFbr
00CA2B  1  A5 02                 lda $02                  ;load vertical adder we got from position loader
00CA2D  1  46 05                 lsr $05                  ;shift LSB of mirror data one more time
00CA2F  1  B0 04                 bcs AddVA                ;if carry was set, skip this part
00CA31  1  49 FF                 eor #$ff
00CA33  1  69 01                 adc #$01                 ;otherwise get two's compliment of second part
00CA35  1  18           AddVA:   clc                      ;add vertical coordinate relative to screen to
00CA36  1  6D B9 03              adc Enemy_Rel_YPos       ;the second data, modified or otherwise
00CA39  1  99 00 02     SetVFbr: sta Sprite_Y_Position,y  ;store as Y coordinate here
00CA3C  1  85 07                 sta $07                  ;also store here for now
00CA3E  1               
00CA3E  1               FirebarCollision:
00CA3E  1  20 A5 E7              jsr DrawFirebar          ;run sub here to draw current tile of firebar
00CA41  1  98                    tya                      ;return OAM data offset and save
00CA42  1  48                    pha                      ;to the stack for now
00CA43  1  AD 9F 07              lda StarInvincibleTimer  ;if star mario invincibility timer
00CA46  1  0D 47 07              ora TimerControl         ;or master timer controls set
00CA49  1  D0 70                 bne NoColFB              ;then skip all of this
00CA4B  1  85 05                 sta $05                  ;otherwise initialize counter
00CA4D  1  A4 B5                 ldy Player_Y_HighPos
00CA4F  1  88                    dey                      ;if player's vertical high byte offscreen,
00CA50  1  D0 69                 bne NoColFB              ;skip all of this
00CA52  1  A4 CE                 ldy Player_Y_Position    ;get player's vertical position
00CA54  1  AD 54 07              lda PlayerSize           ;get player's size
00CA57  1  D0 05                 bne AdjSm                ;if player small, branch to alter variables
00CA59  1  AD 14 07              lda CrouchingFlag
00CA5C  1  F0 09                 beq BigJp                ;if player big and not crouching, jump ahead
00CA5E  1  E6 05        AdjSm:   inc $05                  ;if small or big but crouching, execute this part
00CA60  1  E6 05                 inc $05                  ;first increment our counter twice (setting $02 as flag)
00CA62  1  98                    tya
00CA63  1  18                    clc                      ;then add 24 pixels to the player's
00CA64  1  69 18                 adc #$18                 ;vertical coordinate
00CA66  1  A8                    tay
00CA67  1  98           BigJp:   tya                      ;get vertical coordinate, altered or otherwise, from Y
00CA68  1  38           FBCLoop: sec                      ;subtract vertical position of firebar
00CA69  1  E5 07                 sbc $07                  ;from the vertical coordinate of the player
00CA6B  1  10 05                 bpl ChkVFBD              ;if player lower on the screen than firebar,
00CA6D  1  49 FF                 eor #$ff                 ;skip two's compliment part
00CA6F  1  18                    clc                      ;otherwise get two's compliment
00CA70  1  69 01                 adc #$01
00CA72  1  C9 08        ChkVFBD: cmp #$08                 ;if difference => 8 pixels, skip ahead of this part
00CA74  1  B0 1C                 bcs Chk2Ofs
00CA76  1  A5 06                 lda $06                  ;if firebar on far right on the screen, skip this,
00CA78  1  C9 F0                 cmp #$f0                 ;because, really, what's the point?
00CA7A  1  B0 16                 bcs Chk2Ofs
00CA7C  1  AD 07 02              lda Sprite_X_Position+4  ;get OAM X coordinate for sprite #1
00CA7F  1  18                    clc
00CA80  1  69 04                 adc #$04                 ;add four pixels
00CA82  1  85 04                 sta $04                  ;store here
00CA84  1  38                    sec                      ;subtract horizontal coordinate of firebar
00CA85  1  E5 06                 sbc $06                  ;from the X coordinate of player's sprite 1
00CA87  1  10 05                 bpl ChkFBCl              ;if modded X coordinate to the right of firebar
00CA89  1  49 FF                 eor #$ff                 ;skip two's compliment part
00CA8B  1  18                    clc                      ;otherwise get two's compliment
00CA8C  1  69 01                 adc #$01
00CA8E  1  C9 08        ChkFBCl: cmp #$08                 ;if difference < 8 pixels, collision, thus branch
00CA90  1  90 13                 bcc ChgSDir              ;to process
00CA92  1  A5 05        Chk2Ofs: lda $05                  ;if value of $02 was set earlier for whatever reason,
00CA94  1  C9 02                 cmp #$02                 ;branch to increment OAM offset and leave, no collision
00CA96  1  F0 23                 beq NoColFB
00CA98  1  A4 05                 ldy $05                  ;otherwise get temp here and use as offset
00CA9A  1  A5 CE                 lda Player_Y_Position
00CA9C  1  18                    clc
00CA9D  1  79 70 C9              adc FirebarYPos,y        ;add value loaded with offset to player's vertical coordinate
00CAA0  1  E6 05                 inc $05                  ;then increment temp and jump back
00CAA2  1  4C 68 CA              jmp FBCLoop
00CAA5  1  A2 01        ChgSDir: ldx #$01                 ;set movement direction by default
00CAA7  1  A5 04                 lda $04                  ;if OAM X coordinate of player's sprite 1
00CAA9  1  C5 06                 cmp $06                  ;is greater than horizontal coordinate of firebar
00CAAB  1  B0 01                 bcs SetSDir              ;then do not alter movement direction
00CAAD  1  E8                    inx                      ;otherwise increment it
00CAAE  1  86 46        SetSDir: stx Enemy_MovingDir      ;store movement direction here
00CAB0  1  A2 00                 ldx #$00
00CAB2  1  A5 00                 lda $00                  ;save value written to $00 to stack
00CAB4  1  48                    pha
00CAB5  1  20 47 D4              jsr InjurePlayer         ;perform sub to hurt or kill player
00CAB8  1  68                    pla
00CAB9  1  85 00                 sta $00                  ;get value of $00 from stack
00CABB  1  68           NoColFB: pla                      ;get OAM data offset
00CABC  1  18                    clc                      ;add four to it and save
00CABD  1  69 04                 adc #$04
00CABF  1  85 06                 sta $06
00CAC1  1  A6 08                 ldx ObjectOffset         ;get enemy object buffer offset and leave
00CAC3  1  60                    rts
00CAC4  1               
00CAC4  1               GetFirebarPosition:
00CAC4  1  48                      pha                        ;save high byte of spinstate to the stack
00CAC5  1  29 0F                   and #%00001111             ;mask out low nybble
00CAC7  1  C9 09                   cmp #$09
00CAC9  1  90 05                   bcc GetHAdder              ;if lower than $09, branch ahead
00CACB  1  49 0F                   eor #%00001111             ;otherwise get two's compliment to oscillate
00CACD  1  18                      clc
00CACE  1  69 01                   adc #$01
00CAD0  1  85 01        GetHAdder: sta $01                    ;store result, modified or not, here
00CAD2  1  A4 00                   ldy $00                    ;load number of firebar ball where we're at
00CAD4  1  B9 64 C9                lda FirebarTblOffsets,y    ;load offset to firebar position data
00CAD7  1  18                      clc
00CAD8  1  65 01                   adc $01                    ;add oscillated high byte of spinstate
00CADA  1  A8                      tay                        ;to offset here and use as new offset
00CADB  1  B9 FD C8                lda FirebarPosLookupTbl,y  ;get data here and store as horizontal adder
00CADE  1  85 01                   sta $01
00CAE0  1  68                      pla                        ;pull whatever was in A from the stack
00CAE1  1  48                      pha                        ;save it again because we still need it
00CAE2  1  18                      clc
00CAE3  1  69 08                   adc #$08                   ;add eight this time, to get vertical adder
00CAE5  1  29 0F                   and #%00001111             ;mask out high nybble
00CAE7  1  C9 09                   cmp #$09                   ;if lower than $09, branch ahead
00CAE9  1  90 05                   bcc GetVAdder
00CAEB  1  49 0F                   eor #%00001111             ;otherwise get two's compliment
00CAED  1  18                      clc
00CAEE  1  69 01                   adc #$01
00CAF0  1  85 02        GetVAdder: sta $02                    ;store result here
00CAF2  1  A4 00                   ldy $00
00CAF4  1  B9 64 C9                lda FirebarTblOffsets,y    ;load offset to firebar position data again
00CAF7  1  18                      clc
00CAF8  1  65 02                   adc $02                    ;this time add value in $02 to offset here and use as offset
00CAFA  1  A8                      tay
00CAFB  1  B9 FD C8                lda FirebarPosLookupTbl,y  ;get data here and store as vertica adder
00CAFE  1  85 02                   sta $02
00CB00  1  68                      pla                        ;pull out whatever was in A one last time
00CB01  1  4A                      lsr                        ;divide by eight or shift three to the right
00CB02  1  4A                      lsr
00CB03  1  4A                      lsr
00CB04  1  A8                      tay                        ;use as offset
00CB05  1  B9 60 C9                lda FirebarMirrorData,y    ;load mirroring data here
00CB08  1  85 03                   sta $03                    ;store
00CB0A  1  60                      rts
00CB0B  1               
00CB0B  1               ;--------------------------------
00CB0B  1               
00CB0B  1               PRandomSubtracter:
00CB0B  1  F8 A0 70 BD        .byte $f8, $a0, $70, $bd, $00
00CB0F  1  00           
00CB10  1               
00CB10  1               FlyCCBPriority:
00CB10  1  20 20 20 00        .byte $20, $20, $20, $00, $00
00CB14  1  00           
00CB15  1               
00CB15  1               MoveFlyingCheepCheep:
00CB15  1  B5 1E                lda Enemy_State,x          ;check cheep-cheep's enemy state
00CB17  1  29 20                and #%00100000             ;for d5 set
00CB19  1  F0 08                beq FlyCC                  ;branch to continue code if not set
00CB1B  1  A9 00                lda #$00
00CB1D  1  9D C5 03             sta Enemy_SprAttrib,x      ;otherwise clear sprite attributes
00CB20  1  4C 74 BF             jmp MoveJ_EnemyVertically  ;and jump to move defeated cheep-cheep downwards
00CB23  1  20 E4 BE     FlyCC:  jsr MoveEnemyHorizontally  ;move cheep-cheep horizontally based on speed and force
00CB26  1  A0 0D                ldy #$0d                   ;set vertical movement amount
00CB28  1  A9 05                lda #$05                   ;set maximum speed
00CB2A  1  20 78 BF             jsr SetXMoveAmt            ;branch to impose gravity on flying cheep-cheep
00CB2D  1  BD 34 04             lda Enemy_Y_MoveForce,x
00CB30  1  4A                   lsr                        ;get vertical movement force and
00CB31  1  4A                   lsr                        ;move high nybble to low
00CB32  1  4A                   lsr
00CB33  1  4A                   lsr
00CB34  1  A8                   tay                        ;save as offset (note this tends to go into reach of code)
00CB35  1  B5 CF                lda Enemy_Y_Position,x     ;get vertical position
00CB37  1  38                   sec                        ;subtract pseudorandom value based on offset from position
00CB38  1  F9 0B CB             sbc PRandomSubtracter,y
00CB3B  1  10 05                bpl AddCCF                  ;if result within top half of screen, skip this part
00CB3D  1  49 FF                eor #$ff
00CB3F  1  18                   clc                        ;otherwise get two's compliment
00CB40  1  69 01                adc #$01
00CB42  1  C9 08        AddCCF: cmp #$08                   ;if result or two's compliment greater than eight,
00CB44  1  B0 0E                bcs BPGet                  ;skip to the end without changing movement force
00CB46  1  BD 34 04             lda Enemy_Y_MoveForce,x
00CB49  1  18                   clc
00CB4A  1  69 10                adc #$10                   ;otherwise add to it
00CB4C  1  9D 34 04             sta Enemy_Y_MoveForce,x
00CB4F  1  4A                   lsr                        ;move high nybble to low again
00CB50  1  4A                   lsr
00CB51  1  4A                   lsr
00CB52  1  4A                   lsr
00CB53  1  A8                   tay
00CB54  1  B9 10 CB     BPGet:  lda FlyCCBPriority,y       ;load bg priority data and store (this is very likely
00CB57  1  9D C5 03             sta Enemy_SprAttrib,x      ;broken or residual code, value is overwritten before
00CB5A  1  60                   rts                        ;drawing it next frame), then leave
00CB5B  1               
00CB5B  1               ;--------------------------------
00CB5B  1               ;$00 - used to hold horizontal difference
00CB5B  1               ;$01-$03 - used to hold difference adjusters
00CB5B  1               
00CB5B  1               LakituDiffAdj:
00CB5B  1  15 30 40           .byte $15, $30, $40
00CB5E  1               
00CB5E  1               MoveLakitu:
00CB5E  1  B5 1E                 lda Enemy_State,x          ;check lakitu's enemy state
00CB60  1  29 20                 and #%00100000             ;for d5 set
00CB62  1  F0 03                 beq ChkLS                  ;if not set, continue with code
00CB64  1  4C 45 BF              jmp MoveD_EnemyVertically  ;otherwise jump to move defeated lakitu downwards
00CB67  1  B5 1E        ChkLS:   lda Enemy_State,x          ;if lakitu's enemy state not set at all,
00CB69  1  F0 0B                 beq Fr12S                  ;go ahead and continue with code
00CB6B  1  A9 00                 lda #$00
00CB6D  1  95 A0                 sta LakituMoveDirection,x  ;otherwise initialize moving direction to move to left
00CB6F  1  8D CB 06              sta EnemyFrenzyBuffer      ;initialize frenzy buffer
00CB72  1  A9 10                 lda #$10
00CB74  1  D0 13                 bne SetLSpd                ;load horizontal speed and do unconditional branch
00CB76  1  A9 12        Fr12S:   lda #Spiny
00CB78  1  8D CB 06              sta EnemyFrenzyBuffer      ;set spiny identifier in frenzy buffer
00CB7B  1  A0 02                 ldy #$02
00CB7D  1  B9 5B CB     LdLDa:   lda LakituDiffAdj,y        ;load values
00CB80  1  99 01 00              sta $0001,y                ;store in zero page
00CB83  1  88                    dey
00CB84  1  10 F7                 bpl LdLDa                  ;do this until all values are stired
00CB86  1  20 A2 CB              jsr PlayerLakituDiff       ;execute sub to set speed and create spinys
00CB89  1  95 58        SetLSpd: sta LakituMoveSpeed,x      ;set movement speed returned from sub
00CB8B  1  A0 01                 ldy #$01                   ;set moving direction to right by default
00CB8D  1  B5 A0                 lda LakituMoveDirection,x
00CB8F  1  29 01                 and #$01                   ;get LSB of moving direction
00CB91  1  D0 0A                 bne SetLMov                ;if set, branch to the end to use moving direction
00CB93  1  B5 58                 lda LakituMoveSpeed,x
00CB95  1  49 FF                 eor #$ff                   ;get two's compliment of moving speed
00CB97  1  18                    clc
00CB98  1  69 01                 adc #$01
00CB9A  1  95 58                 sta LakituMoveSpeed,x      ;store as new moving speed
00CB9C  1  C8                    iny                        ;increment moving direction to left
00CB9D  1  94 46        SetLMov: sty Enemy_MovingDir,x      ;store moving direction
00CB9F  1  4C E4 BE              jmp MoveEnemyHorizontally  ;move lakitu horizontally
00CBA2  1               
00CBA2  1               PlayerLakituDiff:
00CBA2  1  A0 00                   ldy #$00                   ;set Y for default value
00CBA4  1  20 FB DB                jsr PlayerEnemyDiff        ;get horizontal difference between enemy and player
00CBA7  1  10 0A                   bpl ChkLakDif              ;branch if enemy is to the right of the player
00CBA9  1  C8                      iny                        ;increment Y for left of player
00CBAA  1  A5 00                   lda $00
00CBAC  1  49 FF                   eor #$ff                   ;get two's compliment of low byte of horizontal difference
00CBAE  1  18                      clc
00CBAF  1  69 01                   adc #$01                   ;store two's compliment as horizontal difference
00CBB1  1  85 00                   sta $00
00CBB3  1  A5 00        ChkLakDif: lda $00                    ;get low byte of horizontal difference
00CBB5  1  C9 3C                   cmp #$3c                   ;if within a certain distance of player, branch
00CBB7  1  90 1C                   bcc ChkPSpeed
00CBB9  1  A9 3C                   lda #$3c                   ;otherwise set maximum distance
00CBBB  1  85 00                   sta $00
00CBBD  1  B5 16                   lda Enemy_ID,x             ;check if lakitu is in our current enemy slot
00CBBF  1  C9 11                   cmp #Lakitu
00CBC1  1  D0 12                   bne ChkPSpeed              ;if not, branch elsewhere
00CBC3  1  98                      tya                        ;compare contents of Y, now in A
00CBC4  1  D5 A0                   cmp LakituMoveDirection,x  ;to what is being used as horizontal movement direction
00CBC6  1  F0 0D                   beq ChkPSpeed              ;if moving toward the player, branch, do not alter
00CBC8  1  B5 A0                   lda LakituMoveDirection,x  ;if moving to the left beyond maximum distance,
00CBCA  1  F0 06                   beq SetLMovD               ;branch and alter without delay
00CBCC  1  D6 58                   dec LakituMoveSpeed,x      ;decrement horizontal speed
00CBCE  1  B5 58                   lda LakituMoveSpeed,x      ;if horizontal speed not yet at zero, branch to leave
00CBD0  1  D0 40                   bne ExMoveLak
00CBD2  1  98           SetLMovD:  tya                        ;set horizontal direction depending on horizontal
00CBD3  1  95 A0                   sta LakituMoveDirection,x  ;difference between enemy and player if necessary
00CBD5  1  A5 00        ChkPSpeed: lda $00
00CBD7  1  29 3C                   and #%00111100             ;mask out all but four bits in the middle
00CBD9  1  4A                      lsr                        ;divide masked difference by four
00CBDA  1  4A                      lsr
00CBDB  1  85 00                   sta $00                    ;store as new value
00CBDD  1  A0 00                   ldy #$00                   ;init offset
00CBDF  1  A5 57                   lda Player_X_Speed
00CBE1  1  F0 24                   beq SubDifAdj              ;if player not moving horizontally, branch
00CBE3  1  AD 75 07                lda ScrollAmount
00CBE6  1  F0 1F                   beq SubDifAdj              ;if scroll speed not set, branch to same place
00CBE8  1  C8                      iny                        ;otherwise increment offset
00CBE9  1  A5 57                   lda Player_X_Speed
00CBEB  1  C9 19                   cmp #$19                   ;if player not running, branch
00CBED  1  90 08                   bcc ChkSpinyO
00CBEF  1  AD 75 07                lda ScrollAmount
00CBF2  1  C9 02                   cmp #$02                   ;if scroll speed below a certain amount, branch
00CBF4  1  90 01                   bcc ChkSpinyO              ;to same place
00CBF6  1  C8                      iny                        ;otherwise increment once more
00CBF7  1  B5 16        ChkSpinyO: lda Enemy_ID,x             ;check for spiny object
00CBF9  1  C9 12                   cmp #Spiny
00CBFB  1  D0 04                   bne ChkEmySpd              ;branch if not found
00CBFD  1  A5 57                   lda Player_X_Speed         ;if player not moving, skip this part
00CBFF  1  D0 06                   bne SubDifAdj
00CC01  1  B5 A0        ChkEmySpd: lda Enemy_Y_Speed,x        ;check vertical speed
00CC03  1  D0 02                   bne SubDifAdj              ;branch if nonzero
00CC05  1  A0 00                   ldy #$00                   ;otherwise reinit offset
00CC07  1  B9 01 00     SubDifAdj: lda $0001,y                ;get one of three saved values from earlier
00CC0A  1  A4 00                   ldy $00                    ;get saved horizontal difference
00CC0C  1  38           SPixelLak: sec                        ;subtract one for each pixel of horizontal difference
00CC0D  1  E9 01                   sbc #$01                   ;from one of three saved values
00CC0F  1  88                      dey
00CC10  1  10 FA                   bpl SPixelLak              ;branch until all pixels are subtracted, to adjust difference
00CC12  1  60           ExMoveLak: rts                        ;leave!!!
00CC13  1               
00CC13  1               ;-------------------------------------------------------------------------------------
00CC13  1               ;$04-$05 - used to store name table address in little endian order
00CC13  1               
00CC13  1               BridgeCollapseData:
00CC13  1  1A                 .byte $1a ;axe
00CC14  1  58                 .byte $58 ;chain
00CC15  1  98 96 94 92        .byte $98, $96, $94, $92, $90, $8e, $8c ;bridge
00CC19  1  90 8E 8C     
00CC1C  1  8A 88 86 84        .byte $8a, $88, $86, $84, $82, $80
00CC20  1  82 80        
00CC22  1               
00CC22  1               BridgeCollapse:
00CC22  1  AE 68 03            ldx BowserFront_Offset    ;get enemy offset for bowser
00CC25  1  B5 16               lda Enemy_ID,x            ;check enemy object identifier for bowser
00CC27  1  C9 2D               cmp #Bowser               ;if not found, branch ahead,
00CC29  1  D0 10               bne SetM2                 ;metatile removal not necessary
00CC2B  1  86 08               stx ObjectOffset          ;store as enemy offset here
00CC2D  1  B5 1E               lda Enemy_State,x         ;if bowser in normal state, skip all of this
00CC2F  1  F0 1A               beq RemoveBridge
00CC31  1  29 40               and #%01000000            ;if bowser's state has d6 clear, skip to silence music
00CC33  1  F0 06               beq SetM2
00CC35  1  B5 CF               lda Enemy_Y_Position,x    ;check bowser's vertical coordinate
00CC37  1  C9 E0               cmp #$e0                  ;if bowser not yet low enough, skip this part ahead
00CC39  1  90 0A               bcc MoveD_Bowser
00CC3B  1  A9 80        SetM2: lda #Silence              ;silence music
00CC3D  1  85 FC               sta EventMusicQueue
00CC3F  1  EE 72 07            inc OperMode_Task         ;move onto next secondary mode in autoctrl mode
00CC42  1  4C A7 CC            jmp KillAllEnemies        ;jump to empty all enemy slots and then leave
00CC45  1               
00CC45  1               MoveD_Bowser:
00CC45  1  20 6E BF            jsr MoveEnemySlowVert     ;do a sub to move bowser downwards
00CC48  1  4C B1 CD            jmp BowserGfxHandler      ;jump to draw bowser's front and rear, then leave
00CC4B  1               
00CC4B  1               RemoveBridge:
00CC4B  1  CE 64 03              dec BowserFeetCounter     ;decrement timer to control bowser's feet
00CC4E  1  D0 44                 bne NoBFall               ;if not expired, skip all of this
00CC50  1  A9 04                 lda #$04
00CC52  1  8D 64 03              sta BowserFeetCounter     ;otherwise, set timer now
00CC55  1  AD 63 03              lda BowserBodyControls
00CC58  1  49 01                 eor #$01                  ;invert bit to control bowser's feet
00CC5A  1  8D 63 03              sta BowserBodyControls
00CC5D  1  A9 22                 lda #$22                  ;put high byte of name table address here for now
00CC5F  1  85 05                 sta $05
00CC61  1  AC 69 03              ldy BridgeCollapseOffset  ;get bridge collapse offset here
00CC64  1  B9 13 CC              lda BridgeCollapseData,y  ;load low byte of name table address and store here
00CC67  1  85 04                 sta $04
00CC69  1  AC 00 03              ldy VRAM_Buffer1_Offset   ;increment vram buffer offset
00CC6C  1  C8                    iny
00CC6D  1  A2 0C                 ldx #$0c                  ;set offset for tile data for sub to draw blank metatile
00CC6F  1  20 AA EF              jsr RemBridge             ;do sub here to remove bowser's bridge metatiles
00CC72  1  A6 08                 ldx ObjectOffset          ;get enemy offset
00CC74  1  20 6C EF              jsr MoveVOffset           ;set new vram buffer offset
00CC77  1  A9 08                 lda #Sfx_Blast            ;load the fireworks/gunfire sound into the square 2 sfx
00CC79  1  85 FE                 sta Square2SoundQueue     ;queue while at the same time loading the brick
00CC7B  1  A9 01                 lda #Sfx_BrickShatter     ;shatter sound into the noise sfx queue thus
00CC7D  1  85 FD                 sta NoiseSoundQueue       ;producing the unique sound of the bridge collapsing
00CC7F  1  EE 69 03              inc BridgeCollapseOffset  ;increment bridge collapse offset
00CC82  1  AD 69 03              lda BridgeCollapseOffset
00CC85  1  C9 0F                 cmp #$0f                  ;if bridge collapse offset has not yet reached
00CC87  1  D0 0B                 bne NoBFall               ;the end, go ahead and skip this part
00CC89  1  20 9C C0              jsr InitVStf              ;initialize whatever vertical speed bowser has
00CC8C  1  A9 40                 lda #%01000000
00CC8E  1  95 1E                 sta Enemy_State,x         ;set bowser's state to one of defeated states (d6 set)
00CC90  1  A9 80                 lda #Sfx_BowserFall
00CC92  1  85 FE                 sta Square2SoundQueue     ;play bowser defeat sound
00CC94  1  4C B1 CD     NoBFall: jmp BowserGfxHandler      ;jump to code that draws bowser
00CC97  1               
00CC97  1               ;--------------------------------
00CC97  1               
00CC97  1               PRandomRange:
00CC97  1  21 41 11 31        .byte $21, $41, $11, $31
00CC9B  1               
00CC9B  1               RunBowser:
00CC9B  1  B5 1E              lda Enemy_State,x       ;if d5 in enemy state is not set
00CC9D  1  29 20              and #%00100000          ;then branch elsewhere to run bowser
00CC9F  1  F0 14              beq BowserControl
00CCA1  1  B5 CF              lda Enemy_Y_Position,x  ;otherwise check vertical position
00CCA3  1  C9 E0              cmp #$e0                ;if above a certain point, branch to move defeated bowser
00CCA5  1  90 9E              bcc MoveD_Bowser        ;otherwise proceed to KillAllEnemies
00CCA7  1               
00CCA7  1               KillAllEnemies:
00CCA7  1  A2 04                  ldx #$04              ;start with last enemy slot
00CCA9  1  20 CE C5     KillLoop: jsr EraseEnemyObject  ;branch to kill enemy objects
00CCAC  1  CA                     dex                   ;move onto next enemy slot
00CCAD  1  10 FA                  bpl KillLoop          ;do this until all slots are emptied
00CCAF  1  8D CB 06               sta EnemyFrenzyBuffer ;empty frenzy buffer
00CCB2  1  A6 08                  ldx ObjectOffset      ;get enemy object offset and leave
00CCB4  1  60                     rts
00CCB5  1               
00CCB5  1               BowserControl:
00CCB5  1  A9 00                   lda #$00
00CCB7  1  8D CB 06                sta EnemyFrenzyBuffer      ;empty frenzy buffer
00CCBA  1  AD 47 07                lda TimerControl           ;if master timer control not set,
00CCBD  1  F0 03                   beq ChkMouth               ;skip jump and execute code here
00CCBF  1  4C 6F CD                jmp SkipToFB               ;otherwise, jump over a bunch of code
00CCC2  1  AD 63 03     ChkMouth:  lda BowserBodyControls     ;check bowser's mouth
00CCC5  1  10 03                   bpl FeetTmr                ;if bit clear, go ahead with code here
00CCC7  1  4C 45 CD                jmp HammerChk              ;otherwise skip a whole section starting here
00CCCA  1  CE 64 03     FeetTmr:   dec BowserFeetCounter      ;decrement timer to control bowser's feet
00CCCD  1  D0 0D                   bne ResetMDr               ;if not expired, skip this part
00CCCF  1  A9 20                   lda #$20                   ;otherwise, reset timer
00CCD1  1  8D 64 03                sta BowserFeetCounter
00CCD4  1  AD 63 03                lda BowserBodyControls     ;and invert bit used
00CCD7  1  49 01                   eor #%00000001             ;to control bowser's feet
00CCD9  1  8D 63 03                sta BowserBodyControls
00CCDC  1  A5 09        ResetMDr:  lda FrameCounter           ;check frame counter
00CCDE  1  29 0F                   and #%00001111             ;if not on every sixteenth frame, skip
00CCE0  1  D0 04                   bne B_FaceP                ;ahead to continue code
00CCE2  1  A9 02                   lda #$02                   ;otherwise reset moving/facing direction every
00CCE4  1  95 46                   sta Enemy_MovingDir,x      ;sixteen frames
00CCE6  1  BD 8A 07     B_FaceP:   lda EnemyFrameTimer,x      ;if timer set here expired,
00CCE9  1  F0 1C                   beq GetPRCmp               ;branch to next section
00CCEB  1  20 FB DB                jsr PlayerEnemyDiff        ;get horizontal difference between player and bowser,
00CCEE  1  10 17                   bpl GetPRCmp               ;and branch if bowser to the right of the player
00CCF0  1  A9 01                   lda #$01
00CCF2  1  95 46                   sta Enemy_MovingDir,x      ;set bowser to move and face to the right
00CCF4  1  A9 02                   lda #$02
00CCF6  1  8D 65 03                sta BowserMovementSpeed    ;set movement speed
00CCF9  1  A9 20                   lda #$20
00CCFB  1  9D 8A 07                sta EnemyFrameTimer,x      ;set timer here
00CCFE  1  8D 90 07                sta BowserFireBreathTimer  ;set timer used for bowser's flame
00CD01  1  B5 87                   lda Enemy_X_Position,x
00CD03  1  C9 C8                   cmp #$c8                   ;if bowser to the right past a certain point,
00CD05  1  B0 3E                   bcs HammerChk              ;skip ahead to some other section
00CD07  1  A5 09        GetPRCmp:  lda FrameCounter           ;get frame counter
00CD09  1  29 03                   and #%00000011
00CD0B  1  D0 38                   bne HammerChk              ;execute this code every fourth frame, otherwise branch
00CD0D  1  B5 87                   lda Enemy_X_Position,x
00CD0F  1  CD 66 03                cmp BowserOrigXPos         ;if bowser not at original horizontal position,
00CD12  1  D0 0C                   bne GetDToO                ;branch to skip this part
00CD14  1  BD A7 07                lda PseudoRandomBitReg,x
00CD17  1  29 03                   and #%00000011             ;get pseudorandom offset
00CD19  1  A8                      tay
00CD1A  1  B9 97 CC                lda PRandomRange,y         ;load value using pseudorandom offset
00CD1D  1  8D DC 06                sta MaxRangeFromOrigin     ;and store here
00CD20  1  B5 87        GetDToO:   lda Enemy_X_Position,x
00CD22  1  18                      clc                        ;add movement speed to bowser's horizontal
00CD23  1  6D 65 03                adc BowserMovementSpeed    ;coordinate and save as new horizontal position
00CD26  1  95 87                   sta Enemy_X_Position,x
00CD28  1  B4 46                   ldy Enemy_MovingDir,x
00CD2A  1  C0 01                   cpy #$01                   ;if bowser moving and facing to the right, skip ahead
00CD2C  1  F0 17                   beq HammerChk
00CD2E  1  A0 FF                   ldy #$ff                   ;set default movement speed here (move left)
00CD30  1  38                      sec                        ;get difference of current vs. original
00CD31  1  ED 66 03                sbc BowserOrigXPos         ;horizontal position
00CD34  1  10 07                   bpl CompDToO               ;if current position to the right of original, skip ahead
00CD36  1  49 FF                   eor #$ff
00CD38  1  18                      clc                        ;get two's compliment
00CD39  1  69 01                   adc #$01
00CD3B  1  A0 01                   ldy #$01                   ;set alternate movement speed here (move right)
00CD3D  1  CD DC 06     CompDToO:  cmp MaxRangeFromOrigin     ;compare difference with pseudorandom value
00CD40  1  90 03                   bcc HammerChk              ;if difference < pseudorandom value, leave speed alone
00CD42  1  8C 65 03                sty BowserMovementSpeed    ;otherwise change bowser's movement speed
00CD45  1  BD 8A 07     HammerChk: lda EnemyFrameTimer,x      ;if timer set here not expired yet, skip ahead to
00CD48  1  D0 28                   bne MakeBJump              ;some other section of code
00CD4A  1  20 6E BF                jsr MoveEnemySlowVert      ;otherwise start by moving bowser downwards
00CD4D  1  AD 5F 07                lda WorldNumber            ;check world number
00CD50  1  C9 05                   cmp #World6
00CD52  1  90 09                   bcc SetHmrTmr              ;if world 1-5, skip this part (not time to throw hammers yet)
00CD54  1  A5 09                   lda FrameCounter
00CD56  1  29 03                   and #%00000011             ;check to see if it's time to execute sub
00CD58  1  D0 03                   bne SetHmrTmr              ;if not, skip sub, otherwise
00CD5A  1  20 61 F0                jsr SpawnHammerObj         ;execute sub on every fourth frame to spawn misc object (hammer)
00CD5D  1  B5 CF        SetHmrTmr: lda Enemy_Y_Position,x     ;get current vertical position
00CD5F  1  C9 80                   cmp #$80                   ;if still above a certain point
00CD61  1  90 1C                   bcc ChkFireB               ;then skip to world number check for flames
00CD63  1  BD A7 07                lda PseudoRandomBitReg,x
00CD66  1  29 03                   and #%00000011             ;get pseudorandom offset
00CD68  1  A8                      tay
00CD69  1  B9 97 CC                lda PRandomRange,y         ;get value using pseudorandom offset
00CD6C  1  9D 8A 07                sta EnemyFrameTimer,x      ;set for timer here
00CD6F  1  4C 7F CD     SkipToFB:  jmp ChkFireB               ;jump to execute flames code
00CD72  1  C9 01        MakeBJump: cmp #$01                   ;if timer not yet about to expire,
00CD74  1  D0 09                   bne ChkFireB               ;skip ahead to next part
00CD76  1  D6 CF                   dec Enemy_Y_Position,x     ;otherwise decrement vertical coordinate
00CD78  1  20 9C C0                jsr InitVStf               ;initialize movement amount
00CD7B  1  A9 FE                   lda #$fe
00CD7D  1  95 A0                   sta Enemy_Y_Speed,x        ;set vertical speed to move bowser upwards
00CD7F  1  AD 5F 07     ChkFireB:  lda WorldNumber            ;check world number here
00CD82  1  C9 07                   cmp #World8                ;world 8?
00CD84  1  F0 04                   beq SpawnFBr               ;if so, execute this part here
00CD86  1  C9 05                   cmp #World6                ;world 6-7?
00CD88  1  B0 27                   bcs BowserGfxHandler       ;if so, skip this part here
00CD8A  1  AD 90 07     SpawnFBr:  lda BowserFireBreathTimer  ;check timer here
00CD8D  1  D0 22                   bne BowserGfxHandler       ;if not expired yet, skip all of this
00CD8F  1  A9 20                   lda #$20
00CD91  1  8D 90 07                sta BowserFireBreathTimer  ;set timer here
00CD94  1  AD 63 03                lda BowserBodyControls
00CD97  1  49 80                   eor #%10000000             ;invert bowser's mouth bit to open
00CD99  1  8D 63 03                sta BowserBodyControls     ;and close bowser's mouth
00CD9C  1  30 E1                   bmi ChkFireB               ;if bowser's mouth open, loop back
00CD9E  1  20 0F CE                jsr SetFlameTimer          ;get timing for bowser's flame
00CDA1  1  AC CC 06                ldy SecondaryHardMode
00CDA4  1  F0 03                   beq SetFBTmr               ;if secondary hard mode flag not set, skip this
00CDA6  1  38                      sec
00CDA7  1  E9 10                   sbc #$10                   ;otherwise subtract from value in A
00CDA9  1  8D 90 07     SetFBTmr:  sta BowserFireBreathTimer  ;set value as timer here
00CDAC  1  A9 15                   lda #BowserFlame           ;put bowser's flame identifier
00CDAE  1  8D CB 06                sta EnemyFrenzyBuffer      ;in enemy frenzy buffer
00CDB1  1               
00CDB1  1               ;--------------------------------
00CDB1  1               
00CDB1  1               BowserGfxHandler:
00CDB1  1  20 F2 CD               jsr ProcessBowserHalf    ;do a sub here to process bowser's front
00CDB4  1  A0 10                  ldy #$10                 ;load default value here to position bowser's rear
00CDB6  1  B5 46                  lda Enemy_MovingDir,x    ;check moving direction
00CDB8  1  4A                     lsr
00CDB9  1  90 02                  bcc CopyFToR             ;if moving left, use default
00CDBB  1  A0 F0                  ldy #$f0                 ;otherwise load alternate positioning value here
00CDBD  1  98           CopyFToR: tya                      ;move bowser's rear object position value to A
00CDBE  1  18                     clc
00CDBF  1  75 87                  adc Enemy_X_Position,x   ;add to bowser's front object horizontal coordinate
00CDC1  1  AC CF 06               ldy DuplicateObj_Offset  ;get bowser's rear object offset
00CDC4  1  99 87 00               sta Enemy_X_Position,y   ;store A as bowser's rear horizontal coordinate
00CDC7  1  B5 CF                  lda Enemy_Y_Position,x
00CDC9  1  18                     clc                      ;add eight pixels to bowser's front object
00CDCA  1  69 08                  adc #$08                 ;vertical coordinate and store as vertical coordinate
00CDCC  1  99 CF 00               sta Enemy_Y_Position,y   ;for bowser's rear
00CDCF  1  B5 1E                  lda Enemy_State,x
00CDD1  1  99 1E 00               sta Enemy_State,y        ;copy enemy state directly from front to rear
00CDD4  1  B5 46                  lda Enemy_MovingDir,x
00CDD6  1  99 46 00               sta Enemy_MovingDir,y    ;copy moving direction also
00CDD9  1  A5 08                  lda ObjectOffset         ;save enemy object offset of front to stack
00CDDB  1  48                     pha
00CDDC  1  AE CF 06               ldx DuplicateObj_Offset  ;put enemy object offset of rear as current
00CDDF  1  86 08                  stx ObjectOffset
00CDE1  1  A9 2D                  lda #Bowser              ;set bowser's enemy identifier
00CDE3  1  95 16                  sta Enemy_ID,x           ;store in bowser's rear object
00CDE5  1  20 F2 CD               jsr ProcessBowserHalf    ;do a sub here to process bowser's rear
00CDE8  1  68                     pla
00CDE9  1  85 08                  sta ObjectOffset         ;get original enemy object offset
00CDEB  1  AA                     tax
00CDEC  1  A9 00                  lda #$00                 ;nullify bowser's front/rear graphics flag
00CDEE  1  8D 6A 03               sta BowserGfxFlag
00CDF1  1  60           ExBGfxH:  rts                      ;leave!
00CDF2  1               
00CDF2  1               ProcessBowserHalf:
00CDF2  1  EE 6A 03           inc BowserGfxFlag         ;increment bowser's graphics flag, then run subroutines
00CDF5  1  20 FC C4           jsr RunRetainerObj        ;to get offscreen bits, relative position and draw bowser (finally!)
00CDF8  1  B5 1E              lda Enemy_State,x
00CDFA  1  D0 F5              bne ExBGfxH               ;if either enemy object not in normal state, branch to leave
00CDFC  1  A9 0A              lda #$0a
00CDFE  1  9D 9A 04           sta Enemy_BoundBoxCtrl,x  ;set bounding box size control
00CE01  1  20 FB DC           jsr GetEnemyBoundBox      ;get bounding box coordinates
00CE04  1  4C 6E D3           jmp PlayerEnemyCollision  ;do player-to-enemy collision detection
00CE07  1               
00CE07  1               ;-------------------------------------------------------------------------------------
00CE07  1               ;$00 - used to hold movement force and tile number
00CE07  1               ;$01 - used to hold sprite attribute data
00CE07  1               
00CE07  1               FlameTimerData:
00CE07  1  BF 40 BF BF        .byte $bf, $40, $bf, $bf, $bf, $40, $40, $bf
00CE0B  1  BF 40 40 BF  
00CE0F  1               
00CE0F  1               SetFlameTimer:
00CE0F  1  AC 67 03           ldy BowserFlameTimerCtrl  ;load counter as offset
00CE12  1  EE 67 03           inc BowserFlameTimerCtrl  ;increment
00CE15  1  AD 67 03           lda BowserFlameTimerCtrl  ;mask out all but 3 LSB
00CE18  1  29 07              and #%00000111            ;to keep in range of 0-7
00CE1A  1  8D 67 03           sta BowserFlameTimerCtrl
00CE1D  1  B9 07 CE           lda FlameTimerData,y      ;load value to be used then leave
00CE20  1  60           ExFl: rts
00CE21  1               
00CE21  1               ProcBowserFlame:
00CE21  1  AD 47 07              lda TimerControl            ;if master timer control flag set,
00CE24  1  D0 30                 bne SetGfxF                 ;skip all of this
00CE26  1  A9 40                 lda #$40                    ;load default movement force
00CE28  1  AC CC 06              ldy SecondaryHardMode
00CE2B  1  F0 02                 beq SFlmX                   ;if secondary hard mode flag not set, use default
00CE2D  1  A9 60                 lda #$60                    ;otherwise load alternate movement force to go faster
00CE2F  1  85 00        SFlmX:   sta $00                     ;store value here
00CE31  1  BD 01 04              lda Enemy_X_MoveForce,x
00CE34  1  38                    sec                         ;subtract value from movement force
00CE35  1  E5 00                 sbc $00
00CE37  1  9D 01 04              sta Enemy_X_MoveForce,x     ;save new value
00CE3A  1  B5 87                 lda Enemy_X_Position,x
00CE3C  1  E9 01                 sbc #$01                    ;subtract one from horizontal position to move
00CE3E  1  95 87                 sta Enemy_X_Position,x      ;to the left
00CE40  1  B5 6E                 lda Enemy_PageLoc,x
00CE42  1  E9 00                 sbc #$00                    ;subtract borrow from page location
00CE44  1  95 6E                 sta Enemy_PageLoc,x
00CE46  1  BC 17 04              ldy BowserFlamePRandomOfs,x ;get some value here and use as offset
00CE49  1  B5 CF                 lda Enemy_Y_Position,x      ;load vertical coordinate
00CE4B  1  D9 D6 C2              cmp FlameYPosData,y         ;compare against coordinate data using $0417,x as offset
00CE4E  1  F0 06                 beq SetGfxF                 ;if equal, branch and do not modify coordinate
00CE50  1  18                    clc
00CE51  1  7D 34 04              adc Enemy_Y_MoveForce,x     ;otherwise add value here to coordinate and store
00CE54  1  95 CF                 sta Enemy_Y_Position,x      ;as new vertical coordinate
00CE56  1  20 EA EB     SetGfxF: jsr RelativeEnemyPosition   ;get new relative coordinates
00CE59  1  B5 1E                 lda Enemy_State,x           ;if bowser's flame not in normal state,
00CE5B  1  D0 C3                 bne ExFl                    ;branch to leave
00CE5D  1  A9 51                 lda #$51                    ;otherwise, continue
00CE5F  1  85 00                 sta $00                     ;write first tile number
00CE61  1  A0 02                 ldy #$02                    ;load attributes without vertical flip by default
00CE63  1  A5 09                 lda FrameCounter
00CE65  1  29 02                 and #%00000010              ;invert vertical flip bit every 2 frames
00CE67  1  F0 02                 beq FlmeAt                  ;if d1 not set, write default value
00CE69  1  A0 82                 ldy #$82                    ;otherwise write value with vertical flip bit set
00CE6B  1  84 01        FlmeAt:  sty $01                     ;set bowser's flame sprite attributes here
00CE6D  1  BC E5 06              ldy Enemy_SprDataOffset,x   ;get OAM data offset
00CE70  1  A2 00                 ldx #$00
00CE72  1               
00CE72  1               DrawFlameLoop:
00CE72  1  AD B9 03              lda Enemy_Rel_YPos         ;get Y relative coordinate of current enemy object
00CE75  1  99 00 02              sta Sprite_Y_Position,y    ;write into Y coordinate of OAM data
00CE78  1  A5 00                 lda $00
00CE7A  1  99 01 02              sta Sprite_Tilenumber,y    ;write current tile number into OAM data
00CE7D  1  E6 00                 inc $00                    ;increment tile number to draw more bowser's flame
00CE7F  1  A5 01                 lda $01
00CE81  1  99 02 02              sta Sprite_Attributes,y    ;write saved attributes into OAM data
00CE84  1  AD AE 03              lda Enemy_Rel_XPos
00CE87  1  99 03 02              sta Sprite_X_Position,y    ;write X relative coordinate of current enemy object
00CE8A  1  18                    clc
00CE8B  1  69 08                 adc #$08
00CE8D  1  8D AE 03              sta Enemy_Rel_XPos         ;then add eight to it and store
00CE90  1  C8                    iny
00CE91  1  C8                    iny
00CE92  1  C8                    iny
00CE93  1  C8                    iny                        ;increment Y four times to move onto the next OAM
00CE94  1  E8                    inx                        ;move onto the next OAM, and branch if three
00CE95  1  E0 03                 cpx #$03                   ;have not yet been done
00CE97  1  90 D9                 bcc DrawFlameLoop
00CE99  1  A6 08                 ldx ObjectOffset           ;reload original enemy offset
00CE9B  1  20 47 EC              jsr GetEnemyOffscreenBits  ;get offscreen information
00CE9E  1  BC E5 06              ldy Enemy_SprDataOffset,x  ;get OAM data offset
00CEA1  1  AD D1 03              lda Enemy_OffscreenBits    ;get enemy object offscreen bits
00CEA4  1  4A                    lsr                        ;move d0 to carry and result to stack
00CEA5  1  48                    pha
00CEA6  1  90 05                 bcc M3FOfs                 ;branch if carry not set
00CEA8  1  A9 F8                 lda #$f8                   ;otherwise move sprite offscreen, this part likely
00CEAA  1  99 0C 02              sta Sprite_Y_Position+12,y ;residual since flame is only made of three sprites
00CEAD  1  68           M3FOfs:  pla                        ;get bits from stack
00CEAE  1  4A                    lsr                        ;move d1 to carry and move bits back to stack
00CEAF  1  48                    pha
00CEB0  1  90 05                 bcc M2FOfs                 ;branch if carry not set again
00CEB2  1  A9 F8                 lda #$f8                   ;otherwise move third sprite offscreen
00CEB4  1  99 08 02              sta Sprite_Y_Position+8,y
00CEB7  1  68           M2FOfs:  pla                        ;get bits from stack again
00CEB8  1  4A                    lsr                        ;move d2 to carry and move bits back to stack again
00CEB9  1  48                    pha
00CEBA  1  90 05                 bcc M1FOfs                 ;branch if carry not set yet again
00CEBC  1  A9 F8                 lda #$f8                   ;otherwise move second sprite offscreen
00CEBE  1  99 04 02              sta Sprite_Y_Position+4,y
00CEC1  1  68           M1FOfs:  pla                        ;get bits from stack one last time
00CEC2  1  4A                    lsr                        ;move d3 to carry
00CEC3  1  90 05                 bcc ExFlmeD                ;branch if carry not set one last time
00CEC5  1  A9 F8                 lda #$f8
00CEC7  1  99 00 02              sta Sprite_Y_Position,y    ;otherwise move first sprite offscreen
00CECA  1  60           ExFlmeD: rts                        ;leave
00CECB  1               
00CECB  1               ;--------------------------------
00CECB  1               ;$00 - used to store horizontal difference between player and piranha plant
00CECB  1               
00CECB  1               MovePiranhaPlant:
00CECB  1  B5 1E              lda Enemy_State,x           ;check enemy state
00CECD  1  D0 56              bne PutinPipe               ;if set at all, branch to leave
00CECF  1  BD 8A 07           lda EnemyFrameTimer,x       ;check enemy's timer here
00CED2  1  D0 51              bne PutinPipe               ;branch to end if not yet expired
00CED4  1  B5 A0              lda PiranhaPlant_MoveFlag,x ;check movement flag
00CED6  1  D0 23              bne SetupToMovePPlant       ;if moving, skip to part ahead
00CED8  1  B5 58              lda PiranhaPlant_Y_Speed,x  ;if currently rising, branch
00CEDA  1  30 14              bmi ReversePlantSpeed       ;to move enemy upwards out of pipe
00CEDC  1  20 FB DB           jsr PlayerEnemyDiff         ;get horizontal difference between player and
00CEDF  1  10 09              bpl ChkPlayerNearPipe       ;piranha plant, and branch if enemy to right of player
00CEE1  1  A5 00              lda $00                     ;otherwise get saved horizontal difference
00CEE3  1  49 FF              eor #$ff
00CEE5  1  18                 clc                         ;and change to two's compliment
00CEE6  1  69 01              adc #$01
00CEE8  1  85 00              sta $00                     ;save as new horizontal difference
00CEEA  1               
00CEEA  1               ChkPlayerNearPipe:
00CEEA  1  A5 00              lda $00                     ;get saved horizontal difference
00CEEC  1  C9 21              cmp #$21
00CEEE  1  90 35              bcc PutinPipe               ;if player within a certain distance, branch to leave
00CEF0  1               
00CEF0  1               ReversePlantSpeed:
00CEF0  1  B5 58              lda PiranhaPlant_Y_Speed,x  ;get vertical speed
00CEF2  1  49 FF              eor #$ff
00CEF4  1  18                 clc                         ;change to two's compliment
00CEF5  1  69 01              adc #$01
00CEF7  1  95 58              sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
00CEF9  1  F6 A0              inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
00CEFB  1               
00CEFB  1               SetupToMovePPlant:
00CEFB  1  BD 34 04           lda PiranhaPlantDownYPos,x  ;get original vertical coordinate (lowest point)
00CEFE  1  B4 58              ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
00CF00  1  10 03              bpl RiseFallPiranhaPlant    ;branch if moving downwards
00CF02  1  BD 17 04           lda PiranhaPlantUpYPos,x    ;otherwise get other vertical coordinate (highest point)
00CF05  1               
00CF05  1               RiseFallPiranhaPlant:
00CF05  1  85 00              sta $00                     ;save vertical coordinate here
00CF07  1  A5 09              lda FrameCounter            ;get frame counter
00CF09  1  4A                 lsr
00CF0A  1  90 19              bcc PutinPipe               ;branch to leave if d0 set (execute code every other frame)
00CF0C  1  AD 47 07           lda TimerControl            ;get master timer control
00CF0F  1  D0 14              bne PutinPipe               ;branch to leave if set (likely not necessary)
00CF11  1  B5 CF              lda Enemy_Y_Position,x      ;get current vertical coordinate
00CF13  1  18                 clc
00CF14  1  75 58              adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
00CF16  1  95 CF              sta Enemy_Y_Position,x      ;save as new vertical coordinate
00CF18  1  C5 00              cmp $00                     ;compare against low or high coordinate
00CF1A  1  D0 09              bne PutinPipe               ;branch to leave if not yet reached
00CF1C  1  A9 00              lda #$00
00CF1E  1  95 A0              sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
00CF20  1  A9 40              lda #$40
00CF22  1  9D 8A 07           sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
00CF25  1               
00CF25  1               PutinPipe:
00CF25  1  A9 20              lda #%00100000              ;set background priority bit in sprite
00CF27  1  9D C5 03           sta Enemy_SprAttrib,x       ;attributes to give illusion of being inside pipe
00CF2A  1  60                 rts                         ;then leave
00CF2B  1               
00CF2B  1               ;-------------------------------------------------------------------------------------
00CF2B  1               ;$07 - spinning speed
00CF2B  1               
00CF2B  1               FirebarSpin:
00CF2B  1  85 07              sta $07                     ;save spinning speed here
00CF2D  1  B5 34              lda FirebarSpinDirection,x  ;check spinning direction
00CF2F  1  D0 0E              bne SpinCounterClockwise    ;if moving counter-clockwise, branch to other part
00CF31  1  A0 18              ldy #$18                    ;possibly residual ldy
00CF33  1  B5 58              lda FirebarSpinState_Low,x
00CF35  1  18                 clc                         ;add spinning speed to what would normally be
00CF36  1  65 07              adc $07                     ;the horizontal speed
00CF38  1  95 58              sta FirebarSpinState_Low,x
00CF3A  1  B5 A0              lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
00CF3C  1  69 00              adc #$00
00CF3E  1  60                 rts
00CF3F  1               
00CF3F  1               SpinCounterClockwise:
00CF3F  1  A0 08              ldy #$08                    ;possibly residual ldy
00CF41  1  B5 58              lda FirebarSpinState_Low,x
00CF43  1  38                 sec                         ;subtract spinning speed to what would normally be
00CF44  1  E5 07              sbc $07                     ;the horizontal speed
00CF46  1  95 58              sta FirebarSpinState_Low,x
00CF48  1  B5 A0              lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
00CF4A  1  E9 00              sbc #$00
00CF4C  1  60                 rts
00CF4D  1               
00CF4D  1               ;-------------------------------------------------------------------------------------
00CF4D  1               ;$00 - used to hold collision flag, Y movement force + 5 or low byte of name table for rope
00CF4D  1               ;$01 - used to hold high byte of name table for rope
00CF4D  1               ;$02 - used to hold page location of rope
00CF4D  1               
00CF4D  1               BalancePlatform:
00CF4D  1  B5 B6               lda Enemy_Y_HighPos,x       ;check high byte of vertical position
00CF4F  1  C9 03               cmp #$03
00CF51  1  D0 03               bne DoBPl
00CF53  1  4C CE C5            jmp EraseEnemyObject        ;if far below screen, kill the object
00CF56  1  B5 1E        DoBPl: lda Enemy_State,x           ;get object's state (set to $ff or other platform offset)
00CF58  1  10 01               bpl CheckBalPlatform        ;if doing other balance platform, branch to leave
00CF5A  1  60                  rts
00CF5B  1               
00CF5B  1               CheckBalPlatform:
00CF5B  1  A8                  tay                         ;save offset from state as Y
00CF5C  1  BD A2 03            lda PlatformCollisionFlag,x ;get collision flag of platform
00CF5F  1  85 00               sta $00                     ;store here
00CF61  1  B5 46               lda Enemy_MovingDir,x       ;get moving direction
00CF63  1  F0 03               beq ChkForFall
00CF65  1  4C D6 D0            jmp PlatformFall            ;if set, jump here
00CF68  1               
00CF68  1               ChkForFall:
00CF68  1  A9 2D               lda #$2d                    ;check if platform is above a certain point
00CF6A  1  D5 CF               cmp Enemy_Y_Position,x
00CF6C  1  90 0F               bcc ChkOtherForFall         ;if not, branch elsewhere
00CF6E  1  C4 00               cpy $00                     ;if collision flag is set to same value as
00CF70  1  F0 08               beq MakePlatformFall        ;enemy state, branch to make platforms fall
00CF72  1  18                  clc
00CF73  1  69 02               adc #$02                    ;otherwise add 2 pixels to vertical position
00CF75  1  95 CF               sta Enemy_Y_Position,x      ;of current platform and branch elsewhere
00CF77  1  4C CC D0            jmp StopPlatforms           ;to make platforms stop
00CF7A  1               
00CF7A  1               MakePlatformFall:
00CF7A  1  4C B3 D0            jmp InitPlatformFall        ;make platforms fall
00CF7D  1               
00CF7D  1               ChkOtherForFall:
00CF7D  1  D9 CF 00            cmp Enemy_Y_Position,y      ;check if other platform is above a certain point
00CF80  1  90 0D               bcc ChkToMoveBalPlat        ;if not, branch elsewhere
00CF82  1  E4 00               cpx $00                     ;if collision flag is set to same value as
00CF84  1  F0 F4               beq MakePlatformFall        ;enemy state, branch to make platforms fall
00CF86  1  18                  clc
00CF87  1  69 02               adc #$02                    ;otherwise add 2 pixels to vertical position
00CF89  1  99 CF 00            sta Enemy_Y_Position,y      ;of other platform and branch elsewhere
00CF8C  1  4C CC D0            jmp StopPlatforms           ;jump to stop movement and do not return
00CF8F  1               
00CF8F  1               ChkToMoveBalPlat:
00CF8F  1  B5 CF                lda Enemy_Y_Position,x      ;save vertical position to stack
00CF91  1  48                   pha
00CF92  1  BD A2 03             lda PlatformCollisionFlag,x ;get collision flag
00CF95  1  10 18                bpl ColFlg                  ;branch if collision
00CF97  1  BD 34 04             lda Enemy_Y_MoveForce,x
00CF9A  1  18                   clc                         ;add $05 to contents of moveforce, whatever they be
00CF9B  1  69 05                adc #$05
00CF9D  1  85 00                sta $00                     ;store here
00CF9F  1  B5 A0                lda Enemy_Y_Speed,x
00CFA1  1  69 00                adc #$00                    ;add carry to vertical speed
00CFA3  1  30 1A                bmi PlatDn                  ;branch if moving downwards
00CFA5  1  D0 0C                bne PlatUp                  ;branch elsewhere if moving upwards
00CFA7  1  A5 00                lda $00
00CFA9  1  C9 0B                cmp #$0b                    ;check if there's still a little force left
00CFAB  1  90 0C                bcc PlatSt                  ;if not enough, branch to stop movement
00CFAD  1  B0 04                bcs PlatUp                  ;otherwise keep branch to move upwards
00CFAF  1  C5 08        ColFlg: cmp ObjectOffset            ;if collision flag matches
00CFB1  1  F0 0C                beq PlatDn                  ;current enemy object offset, branch
00CFB3  1  20 99 BF     PlatUp: jsr MovePlatformUp          ;do a sub to move upwards
00CFB6  1  4C C2 CF             jmp DoOtherPlatform         ;jump ahead to remaining code
00CFB9  1  20 CC D0     PlatSt: jsr StopPlatforms           ;do a sub to stop movement
00CFBC  1  4C C2 CF             jmp DoOtherPlatform         ;jump ahead to remaining code
00CFBF  1  20 96 BF     PlatDn: jsr MovePlatformDown        ;do a sub to move downwards
00CFC2  1               
00CFC2  1               DoOtherPlatform:
00CFC2  1  B4 1E               ldy Enemy_State,x           ;get offset of other platform
00CFC4  1  68                  pla                         ;get old vertical coordinate from stack
00CFC5  1  38                  sec
00CFC6  1  F5 CF               sbc Enemy_Y_Position,x      ;get difference of old vs. new coordinate
00CFC8  1  18                  clc
00CFC9  1  79 CF 00            adc Enemy_Y_Position,y      ;add difference to vertical coordinate of other
00CFCC  1  99 CF 00            sta Enemy_Y_Position,y      ;platform to move it in the opposite direction
00CFCF  1  BD A2 03            lda PlatformCollisionFlag,x ;if no collision, skip this part here
00CFD2  1  30 04               bmi DrawEraseRope
00CFD4  1  AA                  tax                         ;put offset which collision occurred here
00CFD5  1  20 3C D7            jsr PositionPlayerOnVPlat   ;and use it to position player accordingly
00CFD8  1               
00CFD8  1               DrawEraseRope:
00CFD8  1  A4 08                 ldy ObjectOffset            ;get enemy object offset
00CFDA  1  B9 A0 00              lda Enemy_Y_Speed,y         ;check to see if current platform is
00CFDD  1  19 34 04              ora Enemy_Y_MoveForce,y     ;moving at all
00CFE0  1  F0 77                 beq ExitRp                  ;if not, skip all of this and branch to leave
00CFE2  1  AE 00 03              ldx VRAM_Buffer1_Offset     ;get vram buffer offset
00CFE5  1  E0 20                 cpx #$20                    ;if offset beyond a certain point, go ahead
00CFE7  1  B0 70                 bcs ExitRp                  ;and skip this, branch to leave
00CFE9  1  B9 A0 00              lda Enemy_Y_Speed,y
00CFEC  1  48                    pha                         ;save two copies of vertical speed to stack
00CFED  1  48                    pha
00CFEE  1  20 5C D0              jsr SetupPlatformRope       ;do a sub to figure out where to put new bg tiles
00CFF1  1  A5 01                 lda $01                     ;write name table address to vram buffer
00CFF3  1  9D 01 03              sta VRAM_Buffer1,x          ;first the high byte, then the low
00CFF6  1  A5 00                 lda $00
00CFF8  1  9D 02 03              sta VRAM_Buffer1+1,x
00CFFB  1  A9 02                 lda #$02                    ;set length for 2 bytes
00CFFD  1  9D 03 03              sta VRAM_Buffer1+2,x
00D000  1  B9 A0 00              lda Enemy_Y_Speed,y         ;if platform moving upwards, branch
00D003  1  30 0D                 bmi EraseR1                 ;to do something else
00D005  1  A9 A2                 lda #$a2
00D007  1  9D 04 03              sta VRAM_Buffer1+3,x        ;otherwise put tile numbers for left
00D00A  1  A9 A3                 lda #$a3                    ;and right sides of rope in vram buffer
00D00C  1  9D 05 03              sta VRAM_Buffer1+4,x
00D00F  1  4C 1A D0              jmp OtherRope               ;jump to skip this part
00D012  1  A9 24        EraseR1: lda #$24                    ;put blank tiles in vram buffer
00D014  1  9D 04 03              sta VRAM_Buffer1+3,x        ;to erase rope
00D017  1  9D 05 03              sta VRAM_Buffer1+4,x
00D01A  1               
00D01A  1               OtherRope:
00D01A  1  B9 1E 00              lda Enemy_State,y           ;get offset of other platform from state
00D01D  1  A8                    tay                         ;use as Y here
00D01E  1  68                    pla                         ;pull second copy of vertical speed from stack
00D01F  1  49 FF                 eor #$ff                    ;invert bits to reverse speed
00D021  1  20 5C D0              jsr SetupPlatformRope       ;do sub again to figure out where to put bg tiles
00D024  1  A5 01                 lda $01                     ;write name table address to vram buffer
00D026  1  9D 06 03              sta VRAM_Buffer1+5,x        ;this time we're doing putting tiles for
00D029  1  A5 00                 lda $00                     ;the other platform
00D02B  1  9D 07 03              sta VRAM_Buffer1+6,x
00D02E  1  A9 02                 lda #$02
00D030  1  9D 08 03              sta VRAM_Buffer1+7,x        ;set length again for 2 bytes
00D033  1  68                    pla                         ;pull first copy of vertical speed from stack
00D034  1  10 0D                 bpl EraseR2                 ;if moving upwards (note inversion earlier), skip this
00D036  1  A9 A2                 lda #$a2
00D038  1  9D 09 03              sta VRAM_Buffer1+8,x        ;otherwise put tile numbers for left
00D03B  1  A9 A3                 lda #$a3                    ;and right sides of rope in vram
00D03D  1  9D 0A 03              sta VRAM_Buffer1+9,x        ;transfer buffer
00D040  1  4C 4B D0              jmp EndRp                   ;jump to skip this part
00D043  1  A9 24        EraseR2: lda #$24                    ;put blank tiles in vram buffer
00D045  1  9D 09 03              sta VRAM_Buffer1+8,x        ;to erase rope
00D048  1  9D 0A 03              sta VRAM_Buffer1+9,x
00D04B  1  A9 00        EndRp:   lda #$00                    ;put null terminator at the end
00D04D  1  9D 0B 03              sta VRAM_Buffer1+10,x
00D050  1  AD 00 03              lda VRAM_Buffer1_Offset     ;add ten bytes to the vram buffer offset
00D053  1  18                    clc                         ;and store
00D054  1  69 0A                 adc #10
00D056  1  8D 00 03              sta VRAM_Buffer1_Offset
00D059  1  A6 08        ExitRp:  ldx ObjectOffset            ;get enemy object buffer offset and leave
00D05B  1  60                    rts
00D05C  1               
00D05C  1               SetupPlatformRope:
00D05C  1  48                   pha                     ;save second/third copy to stack
00D05D  1  B9 87 00             lda Enemy_X_Position,y  ;get horizontal coordinate
00D060  1  18                   clc
00D061  1  69 08                adc #$08                ;add eight pixels
00D063  1  AE CC 06             ldx SecondaryHardMode   ;if secondary hard mode flag set,
00D066  1  D0 03                bne GetLRp              ;use coordinate as-is
00D068  1  18                   clc
00D069  1  69 10                adc #$10                ;otherwise add sixteen more pixels
00D06B  1  48           GetLRp: pha                     ;save modified horizontal coordinate to stack
00D06C  1  B9 6E 00             lda Enemy_PageLoc,y
00D06F  1  69 00                adc #$00                ;add carry to page location
00D071  1  85 02                sta $02                 ;and save here
00D073  1  68                   pla                     ;pull modified horizontal coordinate
00D074  1  29 F0                and #%11110000          ;from the stack, mask out low nybble
00D076  1  4A                   lsr                     ;and shift three bits to the right
00D077  1  4A                   lsr
00D078  1  4A                   lsr
00D079  1  85 00                sta $00                 ;store result here as part of name table low byte
00D07B  1  B6 CF                ldx Enemy_Y_Position,y  ;get vertical coordinate
00D07D  1  68                   pla                     ;get second/third copy of vertical speed from stack
00D07E  1  10 05                bpl GetHRp              ;skip this part if moving downwards or not at all
00D080  1  8A                   txa
00D081  1  18                   clc
00D082  1  69 08                adc #$08                ;add eight to vertical coordinate and
00D084  1  AA                   tax                     ;save as X
00D085  1  8A           GetHRp: txa                     ;move vertical coordinate to A
00D086  1  AE 00 03             ldx VRAM_Buffer1_Offset ;get vram buffer offset
00D089  1  0A                   asl
00D08A  1  2A                   rol                     ;rotate d7 to d0 and d6 into carry
00D08B  1  48                   pha                     ;save modified vertical coordinate to stack
00D08C  1  2A                   rol                     ;rotate carry to d0, thus d7 and d6 are at 2 LSB
00D08D  1  29 03                and #%00000011          ;mask out all bits but d7 and d6, then set
00D08F  1  09 20                ora #%00100000          ;d5 to get appropriate high byte of name table
00D091  1  85 01                sta $01                 ;address, then store
00D093  1  A5 02                lda $02                 ;get saved page location from earlier
00D095  1  29 01                and #$01                ;mask out all but LSB
00D097  1  0A                   asl
00D098  1  0A                   asl                     ;shift twice to the left and save with the
00D099  1  05 01                ora $01                 ;rest of the bits of the high byte, to get
00D09B  1  85 01                sta $01                 ;the proper name table and the right place on it
00D09D  1  68                   pla                     ;get modified vertical coordinate from stack
00D09E  1  29 E0                and #%11100000          ;mask out low nybble and LSB of high nybble
00D0A0  1  18                   clc
00D0A1  1  65 00                adc $00                 ;add to horizontal part saved here
00D0A3  1  85 00                sta $00                 ;save as name table low byte
00D0A5  1  B9 CF 00             lda Enemy_Y_Position,y
00D0A8  1  C9 E8                cmp #$e8                ;if vertical position not below the
00D0AA  1  90 06                bcc ExPRp               ;bottom of the screen, we're done, branch to leave
00D0AC  1  A5 00                lda $00
00D0AE  1  29 BF                and #%10111111          ;mask out d6 of low byte of name table address
00D0B0  1  85 00                sta $00
00D0B2  1  60           ExPRp:  rts                     ;leave!
00D0B3  1               
00D0B3  1               InitPlatformFall:
00D0B3  1  98                 tya                        ;move offset of other platform from Y to X
00D0B4  1  AA                 tax
00D0B5  1  20 47 EC           jsr GetEnemyOffscreenBits  ;get offscreen bits
00D0B8  1  A9 06              lda #$06
00D0BA  1  20 3A D5           jsr SetupFloateyNumber     ;award 1000 points to player
00D0BD  1  AD AD 03           lda Player_Rel_XPos
00D0C0  1  9D 17 01           sta FloateyNum_X_Pos,x     ;put floatey number coordinates where player is
00D0C3  1  A5 CE              lda Player_Y_Position
00D0C5  1  9D 1E 01           sta FloateyNum_Y_Pos,x
00D0C8  1  A9 01              lda #$01                   ;set moving direction as flag for
00D0CA  1  95 46              sta Enemy_MovingDir,x      ;falling platforms
00D0CC  1               
00D0CC  1               StopPlatforms:
00D0CC  1  20 9C C0           jsr InitVStf             ;initialize vertical speed and low byte
00D0CF  1  99 A0 00           sta Enemy_Y_Speed,y      ;for both platforms and leave
00D0D2  1  99 34 04           sta Enemy_Y_MoveForce,y
00D0D5  1  60                 rts
00D0D6  1               
00D0D6  1               PlatformFall:
00D0D6  1  98                 tya                         ;save offset for other platform to stack
00D0D7  1  48                 pha
00D0D8  1  20 4D BF           jsr MoveFallingPlatform     ;make current platform fall
00D0DB  1  68                 pla
00D0DC  1  AA                 tax                         ;pull offset from stack and save to X
00D0DD  1  20 4D BF           jsr MoveFallingPlatform     ;make other platform fall
00D0E0  1  A6 08              ldx ObjectOffset
00D0E2  1  BD A2 03           lda PlatformCollisionFlag,x ;if player not standing on either platform,
00D0E5  1  30 04              bmi ExPF                    ;skip this part
00D0E7  1  AA                 tax                         ;transfer collision flag offset as offset to X
00D0E8  1  20 3C D7           jsr PositionPlayerOnVPlat   ;and position player appropriately
00D0EB  1  A6 08        ExPF: ldx ObjectOffset            ;get enemy object buffer offset and leave
00D0ED  1  60                 rts
00D0EE  1               
00D0EE  1               ;--------------------------------
00D0EE  1               
00D0EE  1               YMovingPlatform:
00D0EE  1  B5 A0                lda Enemy_Y_Speed,x          ;if platform moving up or down, skip ahead to
00D0F0  1  1D 34 04             ora Enemy_Y_MoveForce,x      ;check on other position
00D0F3  1  D0 15                bne ChkYCenterPos
00D0F5  1  9D 17 04             sta Enemy_YMF_Dummy,x        ;initialize dummy variable
00D0F8  1  B5 CF                lda Enemy_Y_Position,x
00D0FA  1  DD 01 04             cmp YPlatformTopYPos,x       ;if current vertical position => top position, branch
00D0FD  1  B0 0B                bcs ChkYCenterPos            ;ahead of all this
00D0FF  1  A5 09                lda FrameCounter
00D101  1  29 07                and #%00000111               ;check for every eighth frame
00D103  1  D0 02                bne SkipIY
00D105  1  F6 CF                inc Enemy_Y_Position,x       ;increase vertical position every eighth frame
00D107  1  4C 19 D1     SkipIY: jmp ChkYPCollision           ;skip ahead to last part
00D10A  1               
00D10A  1               ChkYCenterPos:
00D10A  1  B5 CF                lda Enemy_Y_Position,x       ;if current vertical position < central position, branch
00D10C  1  D5 58                cmp YPlatformCenterYPos,x    ;to slow ascent/move downwards
00D10E  1  90 06                bcc YMDown
00D110  1  20 99 BF             jsr MovePlatformUp           ;otherwise start slowing descent/moving upwards
00D113  1  4C 19 D1             jmp ChkYPCollision
00D116  1  20 96 BF     YMDown: jsr MovePlatformDown         ;start slowing ascent/moving downwards
00D119  1               
00D119  1               ChkYPCollision:
00D119  1  BD A2 03            lda PlatformCollisionFlag,x  ;if collision flag not set here, branch
00D11C  1  30 03               bmi ExYPl                    ;to leave
00D11E  1  20 3C D7            jsr PositionPlayerOnVPlat    ;otherwise position player appropriately
00D121  1  60           ExYPl: rts                          ;leave
00D122  1               
00D122  1               ;--------------------------------
00D122  1               ;$00 - used as adder to position player hotizontally
00D122  1               
00D122  1               XMovingPlatform:
00D122  1  A9 0E              lda #$0e                     ;load preset maximum value for secondary counter
00D124  1  20 7D C7           jsr XMoveCntr_Platform       ;do a sub to increment counters for movement
00D127  1  20 9C C7           jsr MoveWithXMCntrs          ;do a sub to move platform accordingly, and return value
00D12A  1  BD A2 03           lda PlatformCollisionFlag,x  ;if no collision with player,
00D12D  1  30 1C              bmi ExXMP                    ;branch ahead to leave
00D12F  1               
00D12F  1               PositionPlayerOnHPlat:
00D12F  1  A5 86                 lda Player_X_Position
00D131  1  18                    clc                       ;add saved value from second subroutine to
00D132  1  65 00                 adc $00                   ;current player's position to position
00D134  1  85 86                 sta Player_X_Position     ;player accordingly in horizontal position
00D136  1  A5 6D                 lda Player_PageLoc        ;get player's page location
00D138  1  A4 00                 ldy $00                   ;check to see if saved value here is positive or negative
00D13A  1  30 05                 bmi PPHSubt               ;if negative, branch to subtract
00D13C  1  69 00                 adc #$00                  ;otherwise add carry to page location
00D13E  1  4C 43 D1              jmp SetPVar               ;jump to skip subtraction
00D141  1  E9 00        PPHSubt: sbc #$00                  ;subtract borrow from page location
00D143  1  85 6D        SetPVar: sta Player_PageLoc        ;save result to player's page location
00D145  1  8C A1 03              sty Platform_X_Scroll     ;put saved value from second sub here to be used later
00D148  1  20 3C D7              jsr PositionPlayerOnVPlat ;position player vertically and appropriately
00D14B  1  60           ExXMP:   rts                       ;and we are done here
00D14C  1               
00D14C  1               ;--------------------------------
00D14C  1               
00D14C  1               DropPlatform:
00D14C  1  BD A2 03            lda PlatformCollisionFlag,x  ;if no collision between platform and player
00D14F  1  30 06               bmi ExDPl                    ;occurred, just leave without moving anything
00D151  1  20 6A BF            jsr MoveDropPlatform         ;otherwise do a sub to move platform down very quickly
00D154  1  20 3C D7            jsr PositionPlayerOnVPlat    ;do a sub to position player appropriately
00D157  1  60           ExDPl: rts                          ;leave
00D158  1               
00D158  1               ;--------------------------------
00D158  1               ;$00 - residual value from sub
00D158  1               
00D158  1               RightPlatform:
00D158  1  20 E4 BE            jsr MoveEnemyHorizontally     ;move platform with current horizontal speed, if any
00D15B  1  85 00               sta $00                       ;store saved value here (residual code)
00D15D  1  BD A2 03            lda PlatformCollisionFlag,x   ;check collision flag, if no collision between player
00D160  1  30 07               bmi ExRPl                     ;and platform, branch ahead, leave speed unaltered
00D162  1  A9 10               lda #$10
00D164  1  95 58               sta Enemy_X_Speed,x           ;otherwise set new speed (gets moving if motionless)
00D166  1  20 2F D1            jsr PositionPlayerOnHPlat     ;use saved value from earlier sub to position player
00D169  1  60           ExRPl: rts                           ;then leave
00D16A  1               
00D16A  1               ;--------------------------------
00D16A  1               
00D16A  1               MoveLargeLiftPlat:
00D16A  1  20 76 D1           jsr MoveLiftPlatforms  ;execute common to all large and small lift platforms
00D16D  1  4C 19 D1           jmp ChkYPCollision     ;branch to position player correctly
00D170  1               
00D170  1               MoveSmallPlatform:
00D170  1  20 76 D1           jsr MoveLiftPlatforms      ;execute common to all large and small lift platforms
00D173  1  4C 8C D1           jmp ChkSmallPlatCollision  ;branch to position player correctly
00D176  1               
00D176  1               MoveLiftPlatforms:
00D176  1  AD 47 07           lda TimerControl         ;if master timer control set, skip all of this
00D179  1  D0 19              bne ExLiftP              ;and branch to leave
00D17B  1  BD 17 04           lda Enemy_YMF_Dummy,x
00D17E  1  18                 clc                      ;add contents of movement amount to whatever's here
00D17F  1  7D 34 04           adc Enemy_Y_MoveForce,x
00D182  1  9D 17 04           sta Enemy_YMF_Dummy,x
00D185  1  B5 CF              lda Enemy_Y_Position,x   ;add whatever vertical speed is set to current
00D187  1  75 A0              adc Enemy_Y_Speed,x      ;vertical position plus carry to move up or down
00D189  1  95 CF              sta Enemy_Y_Position,x   ;and then leave
00D18B  1  60                 rts
00D18C  1               
00D18C  1               ChkSmallPlatCollision:
00D18C  1  BD A2 03              lda PlatformCollisionFlag,x ;get bounding box counter saved in collision flag
00D18F  1  F0 03                 beq ExLiftP                 ;if none found, leave player position alone
00D191  1  20 34 D7              jsr PositionPlayerOnS_Plat  ;use to position player correctly
00D194  1  60           ExLiftP: rts                         ;then leave
00D195  1               
00D195  1               ;-------------------------------------------------------------------------------------
00D195  1               ;$00 - page location of extended left boundary
00D195  1               ;$01 - extended left boundary position
00D195  1               ;$02 - page location of extended right boundary
00D195  1               ;$03 - extended right boundary position
00D195  1               
00D195  1               OffscreenBoundsCheck:
00D195  1  B5 16                  lda Enemy_ID,x          ;check for cheep-cheep object
00D197  1  C9 14                  cmp #FlyingCheepCheep   ;branch to leave if found
00D199  1  F0 55                  beq ExScrnBd
00D19B  1  AD 1C 07               lda ScreenLeft_X_Pos    ;get horizontal coordinate for left side of screen
00D19E  1  B4 16                  ldy Enemy_ID,x
00D1A0  1  C0 05                  cpy #HammerBro          ;check for hammer bro object
00D1A2  1  F0 04                  beq LimitB
00D1A4  1  C0 0D                  cpy #PiranhaPlant       ;check for piranha plant object
00D1A6  1  D0 02                  bne ExtendLB            ;these two will be erased sooner than others if too far left
00D1A8  1  69 38        LimitB:   adc #$38                ;add 56 pixels to coordinate if hammer bro or piranha plant
00D1AA  1  E9 48        ExtendLB: sbc #$48                ;subtract 72 pixels regardless of enemy object
00D1AC  1  85 01                  sta $01                 ;store result here
00D1AE  1  AD 1A 07               lda ScreenLeft_PageLoc
00D1B1  1  E9 00                  sbc #$00                ;subtract borrow from page location of left side
00D1B3  1  85 00                  sta $00                 ;store result here
00D1B5  1  AD 1D 07               lda ScreenRight_X_Pos   ;add 72 pixels to the right side horizontal coordinate
00D1B8  1  69 48                  adc #$48
00D1BA  1  85 03                  sta $03                 ;store result here
00D1BC  1  AD 1B 07               lda ScreenRight_PageLoc
00D1BF  1  69 00                  adc #$00                ;then add the carry to the page location
00D1C1  1  85 02                  sta $02                 ;and store result here
00D1C3  1  B5 87                  lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
00D1C5  1  C5 01                  cmp $01                 ;to modified horizontal left edge coordinate to get carry
00D1C7  1  B5 6E                  lda Enemy_PageLoc,x
00D1C9  1  E5 00                  sbc $00                 ;then subtract it from the page coordinate of the enemy object
00D1CB  1  30 20                  bmi TooFar              ;if enemy object is too far left, branch to erase it
00D1CD  1  B5 87                  lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
00D1CF  1  C5 03                  cmp $03                 ;to modified horizontal right edge coordinate to get carry
00D1D1  1  B5 6E                  lda Enemy_PageLoc,x
00D1D3  1  E5 02                  sbc $02                 ;then subtract it from the page coordinate of the enemy object
00D1D5  1  30 19                  bmi ExScrnBd            ;if enemy object is on the screen, leave, do not erase enemy
00D1D7  1  B5 1E                  lda Enemy_State,x       ;if at this point, enemy is offscreen to the right, so check
00D1D9  1  C9 05                  cmp #HammerBro          ;if in state used by spiny's egg, do not erase
00D1DB  1  F0 13                  beq ExScrnBd
00D1DD  1  C0 0D                  cpy #PiranhaPlant       ;if piranha plant, do not erase
00D1DF  1  F0 0F                  beq ExScrnBd
00D1E1  1  C0 30                  cpy #FlagpoleFlagObject ;if flagpole flag, do not erase
00D1E3  1  F0 0B                  beq ExScrnBd
00D1E5  1  C0 31                  cpy #StarFlagObject     ;if star flag, do not erase
00D1E7  1  F0 07                  beq ExScrnBd
00D1E9  1  C0 32                  cpy #JumpspringObject   ;if jumpspring, do not erase
00D1EB  1  F0 03                  beq ExScrnBd            ;erase all others too far to the right
00D1ED  1  20 CE C5     TooFar:   jsr EraseEnemyObject    ;erase object if necessary
00D1F0  1  60           ExScrnBd: rts                     ;leave
00D1F1  1               
00D1F1  1               ;-------------------------------------------------------------------------------------
00D1F1  1               
00D1F1  1               ;some unused space
00D1F1  1  FF FF FF           .byte $ff, $ff, $ff
00D1F4  1               
00D1F4  1               ;-------------------------------------------------------------------------------------
00D1F4  1               ;$01 - enemy buffer offset
00D1F4  1               
00D1F4  1               FireballEnemyCollision:
00D1F4  1  B5 24              lda Fireball_State,x  ;check to see if fireball state is set at all
00D1F6  1  F0 56              beq ExitFBallEnemy    ;branch to leave if not
00D1F8  1  0A                 asl
00D1F9  1  B0 53              bcs ExitFBallEnemy    ;branch to leave also if d7 in state is set
00D1FB  1  A5 09              lda FrameCounter
00D1FD  1  4A                 lsr                   ;get LSB of frame counter
00D1FE  1  B0 4E              bcs ExitFBallEnemy    ;branch to leave if set (do routine every other frame)
00D200  1  8A                 txa
00D201  1  0A                 asl                   ;multiply fireball offset by four
00D202  1  0A                 asl
00D203  1  18                 clc
00D204  1  69 1C              adc #$1c              ;then add $1c or 28 bytes to it
00D206  1  A8                 tay                   ;to use fireball's bounding box coordinates
00D207  1  A2 04              ldx #$04
00D209  1               
00D209  1               FireballEnemyCDLoop:
00D209  1  86 01                   stx $01                     ;store enemy object offset here
00D20B  1  98                      tya
00D20C  1  48                      pha                         ;push fireball offset to the stack
00D20D  1  B5 1E                   lda Enemy_State,x
00D20F  1  29 20                   and #%00100000              ;check to see if d5 is set in enemy state
00D211  1  D0 34                   bne NoFToECol               ;if so, skip to next enemy slot
00D213  1  B5 0F                   lda Enemy_Flag,x            ;check to see if buffer flag is set
00D215  1  F0 30                   beq NoFToECol               ;if not, skip to next enemy slot
00D217  1  B5 16                   lda Enemy_ID,x              ;check enemy identifier
00D219  1  C9 24                   cmp #$24
00D21B  1  90 04                   bcc GoombaDie               ;if < $24, branch to check further
00D21D  1  C9 2B                   cmp #$2b
00D21F  1  90 26                   bcc NoFToECol               ;if in range $24-$2a, skip to next enemy slot
00D221  1  C9 06        GoombaDie: cmp #Goomba                 ;check for goomba identifier
00D223  1  D0 06                   bne NotGoomba               ;if not found, continue with code
00D225  1  B5 1E                   lda Enemy_State,x           ;otherwise check for defeated state
00D227  1  C9 02                   cmp #$02                    ;if stomped or otherwise defeated,
00D229  1  B0 1C                   bcs NoFToECol               ;skip to next enemy slot
00D22B  1  BD D8 03     NotGoomba: lda EnemyOffscrBitsMasked,x ;if any masked offscreen bits set,
00D22E  1  D0 17                   bne NoFToECol               ;skip to next enemy slot
00D230  1  8A                      txa
00D231  1  0A                      asl                         ;otherwise multiply enemy offset by four
00D232  1  0A                      asl
00D233  1  18                      clc
00D234  1  69 04                   adc #$04                    ;add 4 bytes to it
00D236  1  AA                      tax                         ;to use enemy's bounding box coordinates
00D237  1  20 DF DD                jsr SprObjectCollisionCore  ;do fireball-to-enemy collision detection
00D23A  1  A6 08                   ldx ObjectOffset            ;return fireball's original offset
00D23C  1  90 09                   bcc NoFToECol               ;if carry clear, no collision, thus do next enemy slot
00D23E  1  A9 80                   lda #%10000000
00D240  1  95 24                   sta Fireball_State,x        ;set d7 in enemy state
00D242  1  A6 01                   ldx $01                     ;get enemy offset
00D244  1  20 59 D2                jsr HandleEnemyFBallCol     ;jump to handle fireball to enemy collision
00D247  1  68           NoFToECol: pla                         ;pull fireball offset from stack
00D248  1  A8                      tay                         ;put it in Y
00D249  1  A6 01                   ldx $01                     ;get enemy object offset
00D24B  1  CA                      dex                         ;decrement it
00D24C  1  10 BB                   bpl FireballEnemyCDLoop     ;loop back until collision detection done on all enemies
00D24E  1               
00D24E  1               ExitFBallEnemy:
00D24E  1  A6 08              ldx ObjectOffset                 ;get original fireball offset and leave
00D250  1  60                 rts
00D251  1               
00D251  1               BowserIdentities:
00D251  1  06 00 02 12        .byte Goomba, GreenKoopa, BuzzyBeetle, Spiny, Lakitu, Bloober, HammerBro, Bowser
00D255  1  11 07 05 2D  
00D259  1               
00D259  1               HandleEnemyFBallCol:
00D259  1  20 EA EB           jsr RelativeEnemyPosition  ;get relative coordinate of enemy
00D25C  1  A6 01              ldx $01                    ;get current enemy object offset
00D25E  1  B5 0F              lda Enemy_Flag,x           ;check buffer flag for d7 set
00D260  1  10 0B              bpl ChkBuzzyBeetle         ;branch if not set to continue
00D262  1  29 0F              and #%00001111             ;otherwise mask out high nybble and
00D264  1  AA                 tax                        ;use low nybble as enemy offset
00D265  1  B5 16              lda Enemy_ID,x
00D267  1  C9 2D              cmp #Bowser                ;check enemy identifier for bowser
00D269  1  F0 0C              beq HurtBowser             ;branch if found
00D26B  1  A6 01              ldx $01                    ;otherwise retrieve current enemy offset
00D26D  1               
00D26D  1               ChkBuzzyBeetle:
00D26D  1  B5 16              lda Enemy_ID,x
00D26F  1  C9 02              cmp #BuzzyBeetle           ;check for buzzy beetle
00D271  1  F0 6B              beq ExHCF                  ;branch if found to leave (buzzy beetles fireproof)
00D273  1  C9 2D              cmp #Bowser                ;check for bowser one more time (necessary if d7 of flag was clear)
00D275  1  D0 2D              bne ChkOtherEnemies        ;if not found, branch to check other enemies
00D277  1               
00D277  1               HurtBowser:
00D277  1  CE 83 04               dec BowserHitPoints        ;decrement bowser's hit points
00D27A  1  D0 62                  bne ExHCF                  ;if bowser still has hit points, branch to leave
00D27C  1  20 9C C0               jsr InitVStf               ;otherwise do sub to init vertical speed and movement force
00D27F  1  95 58                  sta Enemy_X_Speed,x        ;initialize horizontal speed
00D281  1  8D CB 06               sta EnemyFrenzyBuffer      ;init enemy frenzy buffer
00D284  1  A9 FE                  lda #$fe
00D286  1  95 A0                  sta Enemy_Y_Speed,x        ;set vertical speed to make defeated bowser jump a little
00D288  1  AC 5F 07               ldy WorldNumber            ;use world number as offset
00D28B  1  B9 51 D2               lda BowserIdentities,y     ;get enemy identifier to replace bowser with
00D28E  1  95 16                  sta Enemy_ID,x             ;set as new enemy identifier
00D290  1  A9 20                  lda #$20                   ;set A to use starting value for state
00D292  1  C0 03                  cpy #$03                   ;check to see if using offset of 3 or more
00D294  1  B0 02                  bcs SetDBSte               ;branch if so
00D296  1  09 03                  ora #$03                   ;otherwise add 3 to enemy state
00D298  1  95 1E        SetDBSte: sta Enemy_State,x          ;set defeated enemy state
00D29A  1  A9 80                  lda #Sfx_BowserFall
00D29C  1  85 FE                  sta Square2SoundQueue      ;load bowser defeat sound
00D29E  1  A6 01                  ldx $01                    ;get enemy offset
00D2A0  1  A9 09                  lda #$09                   ;award 5000 points to player for defeating bowser
00D2A2  1  D0 33                  bne EnemySmackScore        ;unconditional branch to award points
00D2A4  1               
00D2A4  1               ChkOtherEnemies:
00D2A4  1  C9 08              cmp #BulletBill_FrenzyVar
00D2A6  1  F0 36              beq ExHCF                 ;branch to leave if bullet bill (frenzy variant)
00D2A8  1  C9 0C              cmp #Podoboo
00D2AA  1  F0 32              beq ExHCF                 ;branch to leave if podoboo
00D2AC  1  C9 15              cmp #$15
00D2AE  1  B0 2E              bcs ExHCF                 ;branch to leave if identifier => $15
00D2B0  1               
00D2B0  1               ShellOrBlockDefeat:
00D2B0  1  B5 16              lda Enemy_ID,x            ;check for piranha plant
00D2B2  1  C9 0D              cmp #PiranhaPlant
00D2B4  1  D0 06              bne StnE                  ;branch if not found
00D2B6  1  B5 CF              lda Enemy_Y_Position,x
00D2B8  1  69 18              adc #$18                  ;add 24 pixels to enemy object's vertical position
00D2BA  1  95 CF              sta Enemy_Y_Position,x
00D2BC  1  20 D3 DA     StnE: jsr ChkToStunEnemies      ;do yet another sub
00D2BF  1  B5 1E              lda Enemy_State,x
00D2C1  1  29 1F              and #%00011111            ;mask out 2 MSB of enemy object's state
00D2C3  1  09 20              ora #%00100000            ;set d5 to defeat enemy and save as new state
00D2C5  1  95 1E              sta Enemy_State,x
00D2C7  1  A9 02              lda #$02                  ;award 200 points by default
00D2C9  1  B4 16              ldy Enemy_ID,x            ;check for hammer bro
00D2CB  1  C0 05              cpy #HammerBro
00D2CD  1  D0 02              bne GoombaPoints          ;branch if not found
00D2CF  1  A9 06              lda #$06                  ;award 1000 points for hammer bro
00D2D1  1               
00D2D1  1               GoombaPoints:
00D2D1  1  C0 06              cpy #Goomba               ;check for goomba
00D2D3  1  D0 02              bne EnemySmackScore       ;branch if not found
00D2D5  1  A9 01              lda #$01                  ;award 100 points for goomba
00D2D7  1               
00D2D7  1               EnemySmackScore:
00D2D7  1  20 3A D5            jsr SetupFloateyNumber   ;update necessary score variables
00D2DA  1  A9 08               lda #Sfx_EnemySmack      ;play smack enemy sound
00D2DC  1  85 FF               sta Square1SoundQueue
00D2DE  1  60           ExHCF: rts                      ;and now let's leave
00D2DF  1               
00D2DF  1               ;-------------------------------------------------------------------------------------
00D2DF  1               
00D2DF  1               PlayerHammerCollision:
00D2DF  1  A5 09                lda FrameCounter          ;get frame counter
00D2E1  1  4A                   lsr                       ;shift d0 into carry
00D2E2  1  90 36                bcc ExPHC                 ;branch to leave if d0 not set to execute every other frame
00D2E4  1  AD 47 07             lda TimerControl          ;if either master timer control
00D2E7  1  0D D6 03             ora Misc_OffscreenBits    ;or any offscreen bits for hammer are set,
00D2EA  1  D0 2E                bne ExPHC                 ;branch to leave
00D2EC  1  8A                   txa
00D2ED  1  0A                   asl                       ;multiply misc object offset by four
00D2EE  1  0A                   asl
00D2EF  1  18                   clc
00D2F0  1  69 24                adc #$24                  ;add 36 or $24 bytes to get proper offset
00D2F2  1  A8                   tay                       ;for misc object bounding box coordinates
00D2F3  1  20 DD DD             jsr PlayerCollisionCore   ;do player-to-hammer collision detection
00D2F6  1  A6 08                ldx ObjectOffset          ;get misc object offset
00D2F8  1  90 1B                bcc ClHCol                ;if no collision, then branch
00D2FA  1  BD BE 06             lda Misc_Collision_Flag,x ;otherwise read collision flag
00D2FD  1  D0 1B                bne ExPHC                 ;if collision flag already set, branch to leave
00D2FF  1  A9 01                lda #$01
00D301  1  9D BE 06             sta Misc_Collision_Flag,x ;otherwise set collision flag now
00D304  1  B5 64                lda Misc_X_Speed,x
00D306  1  49 FF                eor #$ff                  ;get two's compliment of
00D308  1  18                   clc                       ;hammer's horizontal speed
00D309  1  69 01                adc #$01
00D30B  1  95 64                sta Misc_X_Speed,x        ;set to send hammer flying the opposite direction
00D30D  1  AD 9F 07             lda StarInvincibleTimer   ;if star mario invincibility timer set,
00D310  1  D0 08                bne ExPHC                 ;branch to leave
00D312  1  4C 47 D4             jmp InjurePlayer          ;otherwise jump to hurt player, do not return
00D315  1  A9 00        ClHCol: lda #$00                  ;clear collision flag
00D317  1  9D BE 06             sta Misc_Collision_Flag,x
00D31A  1  60           ExPHC:  rts
00D31B  1               
00D31B  1               ;-------------------------------------------------------------------------------------
00D31B  1               
00D31B  1               HandlePowerUpCollision:
00D31B  1  20 CE C5           jsr EraseEnemyObject    ;erase the power-up object
00D31E  1  A9 06              lda #$06
00D320  1  20 3A D5           jsr SetupFloateyNumber  ;award 1000 points to player by default
00D323  1  A9 20              lda #Sfx_PowerUpGrab
00D325  1  85 FE              sta Square2SoundQueue   ;play the power-up sound
00D327  1  A5 39              lda PowerUpType         ;check power-up type
00D329  1  C9 02              cmp #$02
00D32B  1  90 0E              bcc Shroom_Flower_PUp   ;if mushroom or fire flower, branch
00D32D  1  C9 03              cmp #$03
00D32F  1  F0 24              beq SetFor1Up           ;if 1-up mushroom, branch
00D331  1  A9 23              lda #$23                ;otherwise set star mario invincibility
00D333  1  8D 9F 07           sta StarInvincibleTimer ;timer, and load the star mario music
00D336  1  A9 40              lda #StarPowerMusic     ;into the area music queue, then leave
00D338  1  85 FB              sta AreaMusicQueue
00D33A  1  60                 rts
00D33B  1               
00D33B  1               Shroom_Flower_PUp:
00D33B  1  AD 56 07           lda PlayerStatus    ;if player status = small, branch
00D33E  1  F0 1B              beq UpToSuper
00D340  1  C9 01              cmp #$01            ;if player status not super, leave
00D342  1  D0 23              bne NoPUp
00D344  1  A6 08              ldx ObjectOffset    ;get enemy offset, not necessary
00D346  1  A9 02              lda #$02            ;set player status to fiery
00D348  1  8D 56 07           sta PlayerStatus
00D34B  1  20 EE ED           jsr GetPlayerColors ;run sub to change colors of player
00D34E  1  A6 08              ldx ObjectOffset    ;get enemy offset again, and again not necessary
00D350  1  A9 0C              lda #$0c            ;set value to be used by subroutine tree (fiery)
00D352  1  4C 62 D3           jmp UpToFiery       ;jump to set values accordingly
00D355  1               
00D355  1               SetFor1Up:
00D355  1  A9 0B              lda #$0b                 ;change 1000 points into 1-up instead
00D357  1  9D 10 01           sta FloateyNum_Control,x ;and then leave
00D35A  1  60                 rts
00D35B  1               
00D35B  1               UpToSuper:
00D35B  1  A9 01               lda #$01         ;set player status to super
00D35D  1  8D 56 07            sta PlayerStatus
00D360  1  A9 09               lda #$09         ;set value to be used by subroutine tree (super)
00D362  1               
00D362  1               UpToFiery:
00D362  1  A0 00               ldy #$00         ;set value to be used as new player state
00D364  1  20 63 D4            jsr SetPRout     ;set values to stop certain things in motion
00D367  1  60           NoPUp: rts
00D368  1               
00D368  1               ;--------------------------------
00D368  1               
00D368  1               ResidualXSpdData:
00D368  1  18 E8              .byte $18, $e8
00D36A  1               
00D36A  1               KickedShellXSpdData:
00D36A  1  30 D0              .byte $30, $d0
00D36C  1               
00D36C  1               DemotedKoopaXSpdData:
00D36C  1  08 F8              .byte $08, $f8
00D36E  1               
00D36E  1               PlayerEnemyCollision:
00D36E  1  A5 09                 lda FrameCounter            ;check counter for d0 set
00D370  1  4A                    lsr
00D371  1  B0 F4                 bcs NoPUp                   ;if set, branch to leave
00D373  1  20 5C D7              jsr CheckPlayerVertical     ;if player object is completely offscreen or
00D376  1  B0 23                 bcs NoPECol                 ;if down past 224th pixel row, branch to leave
00D378  1  BD D8 03              lda EnemyOffscrBitsMasked,x ;if current enemy is offscreen by any amount,
00D37B  1  D0 1E                 bne NoPECol                 ;go ahead and branch to leave
00D37D  1  A5 0E                 lda GameEngineSubroutine
00D37F  1  C9 08                 cmp #$08                    ;if not set to run player control routine
00D381  1  D0 18                 bne NoPECol                 ;on next frame, branch to leave
00D383  1  B5 1E                 lda Enemy_State,x
00D385  1  29 20                 and #%00100000              ;if enemy state has d5 set, branch to leave
00D387  1  D0 12                 bne NoPECol
00D389  1  20 6D D7              jsr GetEnemyBoundBoxOfs     ;get bounding box offset for current enemy object
00D38C  1  20 DD DD              jsr PlayerCollisionCore     ;do collision detection on player vs. enemy
00D38F  1  A6 08                 ldx ObjectOffset            ;get enemy object buffer offset
00D391  1  B0 09                 bcs CheckForPUpCollision    ;if collision, branch past this part here
00D393  1  BD 91 04              lda Enemy_CollisionBits,x
00D396  1  29 FE                 and #%11111110              ;otherwise, clear d0 of current enemy object's
00D398  1  9D 91 04              sta Enemy_CollisionBits,x   ;collision bit
00D39B  1  60           NoPECol: rts
00D39C  1               
00D39C  1               CheckForPUpCollision:
00D39C  1  B4 16               ldy Enemy_ID,x
00D39E  1  C0 2E               cpy #PowerUpObject            ;check for power-up object
00D3A0  1  D0 03               bne EColl                     ;if not found, branch to next part
00D3A2  1  4C 1B D3            jmp HandlePowerUpCollision    ;otherwise, unconditional jump backwards
00D3A5  1  AD 9F 07     EColl: lda StarInvincibleTimer       ;if star mario invincibility timer expired,
00D3A8  1  F0 06               beq HandlePECollisions        ;perform task here, otherwise kill enemy like
00D3AA  1  4C B0 D2            jmp ShellOrBlockDefeat        ;hit with a shell, or from beneath
00D3AD  1               
00D3AD  1               KickedShellPtsData:
00D3AD  1  0A 06 04           .byte $0a, $06, $04
00D3B0  1               
00D3B0  1               HandlePECollisions:
00D3B0  1  BD 91 04            lda Enemy_CollisionBits,x    ;check enemy collision bits for d0 set
00D3B3  1  29 01               and #%00000001               ;or for being offscreen at all
00D3B5  1  1D D8 03            ora EnemyOffscrBitsMasked,x
00D3B8  1  D0 59               bne ExPEC                    ;branch to leave if either is true
00D3BA  1  A9 01               lda #$01
00D3BC  1  1D 91 04            ora Enemy_CollisionBits,x    ;otherwise set d0 now
00D3BF  1  9D 91 04            sta Enemy_CollisionBits,x
00D3C2  1  C0 12               cpy #Spiny                   ;branch if spiny
00D3C4  1  F0 4E               beq ChkForPlayerInjury
00D3C6  1  C0 0D               cpy #PiranhaPlant            ;branch if piranha plant
00D3C8  1  F0 7D               beq InjurePlayer
00D3CA  1  C0 0C               cpy #Podoboo                 ;branch if podoboo
00D3CC  1  F0 79               beq InjurePlayer
00D3CE  1  C0 33               cpy #BulletBill_CannonVar    ;branch if bullet bill
00D3D0  1  F0 42               beq ChkForPlayerInjury
00D3D2  1  C0 15               cpy #$15                     ;branch if object => $15
00D3D4  1  B0 71               bcs InjurePlayer
00D3D6  1  AD 4E 07            lda AreaType                 ;branch if water type level
00D3D9  1  F0 6C               beq InjurePlayer
00D3DB  1  B5 1E               lda Enemy_State,x            ;branch if d7 of enemy state was set
00D3DD  1  0A                  asl
00D3DE  1  B0 34               bcs ChkForPlayerInjury
00D3E0  1  B5 1E               lda Enemy_State,x            ;mask out all but 3 LSB of enemy state
00D3E2  1  29 07               and #%00000111
00D3E4  1  C9 02               cmp #$02                     ;branch if enemy is in normal or falling state
00D3E6  1  90 2C               bcc ChkForPlayerInjury
00D3E8  1  B5 16               lda Enemy_ID,x               ;branch to leave if goomba in defeated state
00D3EA  1  C9 06               cmp #Goomba
00D3EC  1  F0 25               beq ExPEC
00D3EE  1  A9 08               lda #Sfx_EnemySmack          ;play smack enemy sound
00D3F0  1  85 FF               sta Square1SoundQueue
00D3F2  1  B5 1E               lda Enemy_State,x            ;set d7 in enemy state, thus become moving shell
00D3F4  1  09 80               ora #%10000000
00D3F6  1  95 1E               sta Enemy_State,x
00D3F8  1  20 20 D5            jsr EnemyFacePlayer          ;set moving direction and get offset
00D3FB  1  B9 6A D3            lda KickedShellXSpdData,y    ;load and set horizontal speed data with offset
00D3FE  1  95 58               sta Enemy_X_Speed,x
00D400  1  A9 03               lda #$03                     ;add three to whatever the stomp counter contains
00D402  1  18                  clc                          ;to give points for kicking the shell
00D403  1  6D 84 04            adc StompChainCounter
00D406  1  BC 96 07            ldy EnemyIntervalTimer,x     ;check shell enemy's timer
00D409  1  C0 03               cpy #$03                     ;if above a certain point, branch using the points
00D40B  1  B0 03               bcs KSPts                    ;data obtained from the stomp counter + 3
00D40D  1  B9 AD D3            lda KickedShellPtsData,y     ;otherwise, set points based on proximity to timer expiration
00D410  1  20 3A D5     KSPts: jsr SetupFloateyNumber       ;set values for floatey number now
00D413  1  60           ExPEC: rts                          ;leave!!!
00D414  1               
00D414  1               ChkForPlayerInjury:
00D414  1  A5 9F                  lda Player_Y_Speed     ;check player's vertical speed
00D416  1  30 02                  bmi ChkInj             ;perform procedure below if player moving upwards
00D418  1  D0 6A                  bne EnemyStomped       ;or not at all, and branch elsewhere if moving downwards
00D41A  1  B5 16        ChkInj:   lda Enemy_ID,x         ;branch if enemy object < $07
00D41C  1  C9 07                  cmp #Bloober
00D41E  1  90 09                  bcc ChkETmrs
00D420  1  A5 CE                  lda Player_Y_Position  ;add 12 pixels to player's vertical position
00D422  1  18                     clc
00D423  1  69 0C                  adc #$0c
00D425  1  D5 CF                  cmp Enemy_Y_Position,x ;compare modified player's position to enemy's position
00D427  1  90 5B                  bcc EnemyStomped       ;branch if this player's position above (less than) enemy's
00D429  1  AD 91 07     ChkETmrs: lda StompTimer         ;check stomp timer
00D42C  1  D0 56                  bne EnemyStomped       ;branch if set
00D42E  1  AD 9E 07               lda InjuryTimer        ;check to see if injured invincibility timer still
00D431  1  D0 3D                  bne ExInjColRoutines   ;counting down, and branch elsewhere to leave if so
00D433  1  AD AD 03               lda Player_Rel_XPos
00D436  1  CD AE 03               cmp Enemy_Rel_XPos     ;if player's relative position to the left of enemy's
00D439  1  90 03                  bcc TInjE              ;relative position, branch here
00D43B  1  4C 11 D5               jmp ChkEnemyFaceRight  ;otherwise do a jump here
00D43E  1  B5 46        TInjE:    lda Enemy_MovingDir,x  ;if enemy moving towards the left,
00D440  1  C9 01                  cmp #$01               ;branch, otherwise do a jump here
00D442  1  D0 03                  bne InjurePlayer       ;to turn the enemy around
00D444  1  4C 1A D5               jmp LInj
00D447  1               
00D447  1               InjurePlayer:
00D447  1  AD 9E 07           lda InjuryTimer          ;check again to see if injured invincibility timer is
00D44A  1  D0 24              bne ExInjColRoutines     ;at zero, and branch to leave if so
00D44C  1               
00D44C  1               ForceInjury:
00D44C  1  AE 56 07               ldx PlayerStatus          ;check player's status
00D44F  1  F0 22                  beq KillPlayer            ;branch if small
00D451  1  8D 56 07               sta PlayerStatus          ;otherwise set player's status to small
00D454  1  A9 08                  lda #$08
00D456  1  8D 9E 07               sta InjuryTimer           ;set injured invincibility timer
00D459  1  0A                     asl
00D45A  1  85 FF                  sta Square1SoundQueue     ;play pipedown/injury sound
00D45C  1  20 EE ED               jsr GetPlayerColors       ;change player's palette if necessary
00D45F  1  A9 0A                  lda #$0a                  ;set subroutine to run on next frame
00D461  1  A0 01        SetKRout: ldy #$01                  ;set new player state
00D463  1  85 0E        SetPRout: sta GameEngineSubroutine  ;load new value to run subroutine on next frame
00D465  1  84 1D                  sty Player_State          ;store new player state
00D467  1  A0 FF                  ldy #$ff
00D469  1  8C 47 07               sty TimerControl          ;set master timer control flag to halt timers
00D46C  1  C8                     iny
00D46D  1  8C 75 07               sty ScrollAmount          ;initialize scroll speed
00D470  1               
00D470  1               ExInjColRoutines:
00D470  1  A6 08              ldx ObjectOffset              ;get enemy offset and leave
00D472  1  60                 rts
00D473  1               
00D473  1               KillPlayer:
00D473  1  86 57              stx Player_X_Speed   ;halt player's horizontal movement by initializing speed
00D475  1  E8                 inx
00D476  1  86 FC              stx EventMusicQueue  ;set event music queue to death music
00D478  1  A9 FC              lda #$fc
00D47A  1  85 9F              sta Player_Y_Speed   ;set new vertical speed
00D47C  1  A9 0B              lda #$0b             ;set subroutine to run on next frame
00D47E  1  D0 E1              bne SetKRout         ;branch to set player's state and other things
00D480  1               
00D480  1               StompedEnemyPtsData:
00D480  1  02 06 05 06        .byte $02, $06, $05, $06
00D484  1               
00D484  1               EnemyStomped:
00D484  1  B5 16              lda Enemy_ID,x             ;check for spiny, branch to hurt player
00D486  1  C9 12              cmp #Spiny                 ;if found
00D488  1  F0 BD              beq InjurePlayer
00D48A  1  A9 04              lda #Sfx_EnemyStomp        ;otherwise play stomp/swim sound
00D48C  1  85 FF              sta Square1SoundQueue
00D48E  1  B5 16              lda Enemy_ID,x
00D490  1  A0 00              ldy #$00                   ;initialize points data offset for stomped enemies
00D492  1  C9 14              cmp #FlyingCheepCheep      ;branch for cheep-cheep
00D494  1  F0 1B              beq EnemyStompedPts
00D496  1  C9 08              cmp #BulletBill_FrenzyVar  ;branch for either bullet bill object
00D498  1  F0 17              beq EnemyStompedPts
00D49A  1  C9 33              cmp #BulletBill_CannonVar
00D49C  1  F0 13              beq EnemyStompedPts
00D49E  1  C9 0C              cmp #Podoboo               ;branch for podoboo (this branch is logically impossible
00D4A0  1  F0 0F              beq EnemyStompedPts        ;for cpu to take due to earlier checking of podoboo)
00D4A2  1  C8                 iny                        ;increment points data offset
00D4A3  1  C9 05              cmp #HammerBro             ;branch for hammer bro
00D4A5  1  F0 0A              beq EnemyStompedPts
00D4A7  1  C8                 iny                        ;increment points data offset
00D4A8  1  C9 11              cmp #Lakitu                ;branch for lakitu
00D4AA  1  F0 05              beq EnemyStompedPts
00D4AC  1  C8                 iny                        ;increment points data offset
00D4AD  1  C9 07              cmp #Bloober               ;branch if NOT bloober
00D4AF  1  D0 1D              bne ChkForDemoteKoopa
00D4B1  1               
00D4B1  1               EnemyStompedPts:
00D4B1  1  B9 80 D4           lda StompedEnemyPtsData,y  ;load points data using offset in Y
00D4B4  1  20 3A D5           jsr SetupFloateyNumber     ;run sub to set floatey number controls
00D4B7  1  B5 46              lda Enemy_MovingDir,x
00D4B9  1  48                 pha                        ;save enemy movement direction to stack
00D4BA  1  20 E7 DA           jsr SetStun                ;run sub to kill enemy
00D4BD  1  68                 pla
00D4BE  1  95 46              sta Enemy_MovingDir,x      ;return enemy movement direction from stack
00D4C0  1  A9 20              lda #%00100000
00D4C2  1  95 1E              sta Enemy_State,x          ;set d5 in enemy state
00D4C4  1  20 9C C0           jsr InitVStf               ;nullify vertical speed, physics-related thing,
00D4C7  1  95 58              sta Enemy_X_Speed,x        ;and horizontal speed
00D4C9  1  A9 FD              lda #$fd                   ;set player's vertical speed, to give bounce
00D4CB  1  85 9F              sta Player_Y_Speed
00D4CD  1  60                 rts
00D4CE  1               
00D4CE  1               ChkForDemoteKoopa:
00D4CE  1  C9 09              cmp #$09                   ;branch elsewhere if enemy object < $09
00D4D0  1  90 1D              bcc HandleStompedShellE
00D4D2  1  29 01              and #%00000001             ;demote koopa paratroopas to ordinary troopas
00D4D4  1  95 16              sta Enemy_ID,x
00D4D6  1  A0 00              ldy #$00                   ;return enemy to normal state
00D4D8  1  94 1E              sty Enemy_State,x
00D4DA  1  A9 03              lda #$03                   ;award 400 points to the player
00D4DC  1  20 3A D5           jsr SetupFloateyNumber
00D4DF  1  20 9C C0           jsr InitVStf               ;nullify physics-related thing and vertical speed
00D4E2  1  20 20 D5           jsr EnemyFacePlayer        ;turn enemy around if necessary
00D4E5  1  B9 6C D3           lda DemotedKoopaXSpdData,y
00D4E8  1  95 58              sta Enemy_X_Speed,x        ;set appropriate moving speed based on direction
00D4EA  1  4C 0C D5           jmp SBnce                  ;then move onto something else
00D4ED  1               
00D4ED  1               RevivalRateData:
00D4ED  1  10 0B              .byte $10, $0b
00D4EF  1               
00D4EF  1               HandleStompedShellE:
00D4EF  1  A9 04               lda #$04                   ;set defeated state for enemy
00D4F1  1  95 1E               sta Enemy_State,x
00D4F3  1  EE 84 04            inc StompChainCounter      ;increment the stomp counter
00D4F6  1  AD 84 04            lda StompChainCounter      ;add whatever is in the stomp counter
00D4F9  1  18                  clc                        ;to whatever is in the stomp timer
00D4FA  1  6D 91 07            adc StompTimer
00D4FD  1  20 3A D5            jsr SetupFloateyNumber     ;award points accordingly
00D500  1  EE 91 07            inc StompTimer             ;increment stomp timer of some sort
00D503  1  AC 6A 07            ldy PrimaryHardMode        ;check primary hard mode flag
00D506  1  B9 ED D4            lda RevivalRateData,y      ;load timer setting according to flag
00D509  1  9D 96 07            sta EnemyIntervalTimer,x   ;set as enemy timer to revive stomped enemy
00D50C  1  A9 FC        SBnce: lda #$fc                   ;set player's vertical speed for bounce
00D50E  1  85 9F               sta Player_Y_Speed         ;and then leave!!!
00D510  1  60                  rts
00D511  1               
00D511  1               ChkEnemyFaceRight:
00D511  1  B5 46               lda Enemy_MovingDir,x ;check to see if enemy is moving to the right
00D513  1  C9 01               cmp #$01
00D515  1  D0 03               bne LInj              ;if not, branch
00D517  1  4C 47 D4            jmp InjurePlayer      ;otherwise go back to hurt player
00D51A  1  20 37 D6     LInj:  jsr EnemyTurnAround   ;turn the enemy around, if necessary
00D51D  1  4C 47 D4            jmp InjurePlayer      ;go back to hurt player
00D520  1               
00D520  1               
00D520  1               EnemyFacePlayer:
00D520  1  A0 01               ldy #$01               ;set to move right by default
00D522  1  20 FB DB            jsr PlayerEnemyDiff    ;get horizontal difference between player and enemy
00D525  1  10 01               bpl SFcRt              ;if enemy is to the right of player, do not increment
00D527  1  C8                  iny                    ;otherwise, increment to set to move to the left
00D528  1  94 46        SFcRt: sty Enemy_MovingDir,x  ;set moving direction here
00D52A  1  88                  dey                    ;then decrement to use as a proper offset
00D52B  1  60                  rts
00D52C  1               
00D52C  1               ;-------------------------------------------------------------------------------------
00D52C  1               ;$01 - used to hold enemy offset for second enemy
00D52C  1               
00D52C  1               SetBitsMask:
00D52C  1  80 40 20 10        .byte %10000000, %01000000, %00100000, %00010000, %00001000, %00000100, %00000010
00D530  1  08 04 02     
00D533  1               
00D533  1               ClearBitsMask:
00D533  1  7F BF DF EF        .byte %01111111, %10111111, %11011111, %11101111, %11110111, %11111011, %11111101
00D537  1  F7 FB FD     
00D53A  1               
00D53A  1               SetupFloateyNumber:
00D53A  1  9D 10 01            sta FloateyNum_Control,x ;set number of points control for floatey numbers
00D53D  1  A9 30               lda #$30
00D53F  1  9D 2C 01            sta FloateyNum_Timer,x   ;set timer for floatey numbers
00D542  1  B5 CF               lda Enemy_Y_Position,x
00D544  1  9D 1E 01            sta FloateyNum_Y_Pos,x   ;set vertical coordinate
00D547  1  AD AE 03            lda Enemy_Rel_XPos
00D54A  1  9D 17 01            sta FloateyNum_X_Pos,x   ;set horizontal coordinate and leave
00D54D  1  60           ExSFN: rts
00D54E  1               
00D54E  1               EnemiesCollision:
00D54E  1  A5 09                lda FrameCounter            ;check counter for d0 set
00D550  1  4A                   lsr
00D551  1  90 FA                bcc ExSFN                   ;if d0 not set, leave
00D553  1  AD 4E 07             lda AreaType
00D556  1  F0 F5                beq ExSFN                   ;if water area type, leave
00D558  1  B5 16                lda Enemy_ID,x
00D55A  1  C9 15                cmp #$15                    ;if enemy object => $15, branch to leave
00D55C  1  B0 6E                bcs ExitECRoutine
00D55E  1  C9 11                cmp #Lakitu                 ;if lakitu, branch to leave
00D560  1  F0 6A                beq ExitECRoutine
00D562  1  C9 0D                cmp #PiranhaPlant           ;if piranha plant, branch to leave
00D564  1  F0 66                beq ExitECRoutine
00D566  1  BD D8 03             lda EnemyOffscrBitsMasked,x ;if masked offscreen bits nonzero, branch to leave
00D569  1  D0 61                bne ExitECRoutine
00D56B  1  20 6D D7             jsr GetEnemyBoundBoxOfs     ;otherwise, do sub, get appropriate bounding box offset for
00D56E  1  CA                   dex                         ;first enemy we're going to compare, then decrement for second
00D56F  1  30 5B                bmi ExitECRoutine           ;branch to leave if there are no other enemies
00D571  1  86 01        ECLoop: stx $01                     ;save enemy object buffer offset for second enemy here
00D573  1  98                   tya                         ;save first enemy's bounding box offset to stack
00D574  1  48                   pha
00D575  1  B5 0F                lda Enemy_Flag,x            ;check enemy object enable flag
00D577  1  F0 4C                beq ReadyNextEnemy          ;branch if flag not set
00D579  1  B5 16                lda Enemy_ID,x
00D57B  1  C9 15                cmp #$15                    ;check for enemy object => $15
00D57D  1  B0 46                bcs ReadyNextEnemy          ;branch if true
00D57F  1  C9 11                cmp #Lakitu
00D581  1  F0 42                beq ReadyNextEnemy          ;branch if enemy object is lakitu
00D583  1  C9 0D                cmp #PiranhaPlant
00D585  1  F0 3E                beq ReadyNextEnemy          ;branch if enemy object is piranha plant
00D587  1  BD D8 03             lda EnemyOffscrBitsMasked,x
00D58A  1  D0 39                bne ReadyNextEnemy          ;branch if masked offscreen bits set
00D58C  1  8A                   txa                         ;get second enemy object's bounding box offset
00D58D  1  0A                   asl                         ;multiply by four, then add four
00D58E  1  0A                   asl
00D58F  1  18                   clc
00D590  1  69 04                adc #$04
00D592  1  AA                   tax                         ;use as new contents of X
00D593  1  20 DF DD             jsr SprObjectCollisionCore  ;do collision detection using the two enemies here
00D596  1  A6 08                ldx ObjectOffset            ;use first enemy offset for X
00D598  1  A4 01                ldy $01                     ;use second enemy offset for Y
00D59A  1  90 20                bcc NoEnemyCollision        ;if carry clear, no collision, branch ahead of this
00D59C  1  B5 1E                lda Enemy_State,x
00D59E  1  19 1E 00             ora Enemy_State,y           ;check both enemy states for d7 set
00D5A1  1  29 80                and #%10000000
00D5A3  1  D0 11                bne YesEC                   ;branch if at least one of them is set
00D5A5  1  B9 91 04             lda Enemy_CollisionBits,y   ;load first enemy's collision-related bits
00D5A8  1  3D 2C D5             and SetBitsMask,x           ;check to see if bit connected to second enemy is
00D5AB  1  D0 18                bne ReadyNextEnemy          ;already set, and move onto next enemy slot if set
00D5AD  1  B9 91 04             lda Enemy_CollisionBits,y
00D5B0  1  1D 2C D5             ora SetBitsMask,x           ;if the bit is not set, set it now
00D5B3  1  99 91 04             sta Enemy_CollisionBits,y
00D5B6  1  20 CF D5     YesEC:  jsr ProcEnemyCollisions     ;react according to the nature of collision
00D5B9  1  4C C5 D5             jmp ReadyNextEnemy          ;move onto next enemy slot
00D5BC  1               
00D5BC  1               NoEnemyCollision:
00D5BC  1  B9 91 04           lda Enemy_CollisionBits,y     ;load first enemy's collision-related bits
00D5BF  1  3D 33 D5           and ClearBitsMask,x           ;clear bit connected to second enemy
00D5C2  1  99 91 04           sta Enemy_CollisionBits,y     ;then move onto next enemy slot
00D5C5  1               
00D5C5  1               ReadyNextEnemy:
00D5C5  1  68                 pla              ;get first enemy's bounding box offset from the stack
00D5C6  1  A8                 tay              ;use as Y again
00D5C7  1  A6 01              ldx $01          ;get and decrement second enemy's object buffer offset
00D5C9  1  CA                 dex
00D5CA  1  10 A5              bpl ECLoop       ;loop until all enemy slots have been checked
00D5CC  1               
00D5CC  1               ExitECRoutine:
00D5CC  1  A6 08              ldx ObjectOffset ;get enemy object buffer offset
00D5CE  1  60                 rts              ;leave
00D5CF  1               
00D5CF  1               ProcEnemyCollisions:
00D5CF  1  B9 1E 00           lda Enemy_State,y        ;check both enemy states for d5 set
00D5D2  1  15 1E              ora Enemy_State,x
00D5D4  1  29 20              and #%00100000           ;if d5 is set in either state, or both, branch
00D5D6  1  D0 33              bne ExitProcessEColl     ;to leave and do nothing else at this point
00D5D8  1  B5 1E              lda Enemy_State,x
00D5DA  1  C9 06              cmp #$06                 ;if second enemy state < $06, branch elsewhere
00D5DC  1  90 2E              bcc ProcSecondEnemyColl
00D5DE  1  B5 16              lda Enemy_ID,x           ;check second enemy identifier for hammer bro
00D5E0  1  C9 05              cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
00D5E2  1  F0 27              beq ExitProcessEColl
00D5E4  1  B9 1E 00           lda Enemy_State,y        ;check first enemy state for d7 set
00D5E7  1  0A                 asl
00D5E8  1  90 0A              bcc ShellCollisions      ;branch if d7 is clear
00D5EA  1  A9 06              lda #$06
00D5EC  1  20 3A D5           jsr SetupFloateyNumber   ;award 1000 points for killing enemy
00D5EF  1  20 B0 D2           jsr ShellOrBlockDefeat   ;then kill enemy, then load
00D5F2  1  A4 01              ldy $01                  ;original offset of second enemy
00D5F4  1               
00D5F4  1               ShellCollisions:
00D5F4  1  98                 tya                      ;move Y to X
00D5F5  1  AA                 tax
00D5F6  1  20 B0 D2           jsr ShellOrBlockDefeat   ;kill second enemy
00D5F9  1  A6 08              ldx ObjectOffset
00D5FB  1  BD 25 01           lda ShellChainCounter,x  ;get chain counter for shell
00D5FE  1  18                 clc
00D5FF  1  69 04              adc #$04                 ;add four to get appropriate point offset
00D601  1  A6 01              ldx $01
00D603  1  20 3A D5           jsr SetupFloateyNumber   ;award appropriate number of points for second enemy
00D606  1  A6 08              ldx ObjectOffset         ;load original offset of first enemy
00D608  1  FE 25 01           inc ShellChainCounter,x  ;increment chain counter for additional enemies
00D60B  1               
00D60B  1               ExitProcessEColl:
00D60B  1  60                 rts                      ;leave!!!
00D60C  1               
00D60C  1               ProcSecondEnemyColl:
00D60C  1  B9 1E 00           lda Enemy_State,y        ;if first enemy state < $06, branch elsewhere
00D60F  1  C9 06              cmp #$06
00D611  1  90 1D              bcc MoveEOfs
00D613  1  B9 16 00           lda Enemy_ID,y           ;check first enemy identifier for hammer bro
00D616  1  C9 05              cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
00D618  1  F0 F1              beq ExitProcessEColl
00D61A  1  20 B0 D2           jsr ShellOrBlockDefeat   ;otherwise, kill first enemy
00D61D  1  A4 01              ldy $01
00D61F  1  B9 25 01           lda ShellChainCounter,y  ;get chain counter for shell
00D622  1  18                 clc
00D623  1  69 04              adc #$04                 ;add four to get appropriate point offset
00D625  1  A6 08              ldx ObjectOffset
00D627  1  20 3A D5           jsr SetupFloateyNumber   ;award appropriate number of points for first enemy
00D62A  1  A6 01              ldx $01                  ;load original offset of second enemy
00D62C  1  FE 25 01           inc ShellChainCounter,x  ;increment chain counter for additional enemies
00D62F  1  60                 rts                      ;leave!!!
00D630  1               
00D630  1               MoveEOfs:
00D630  1  98                 tya                      ;move Y ($01) to X
00D631  1  AA                 tax
00D632  1  20 37 D6           jsr EnemyTurnAround      ;do the sub here using value from $01
00D635  1  A6 08              ldx ObjectOffset         ;then do it again using value from $08
00D637  1               
00D637  1               EnemyTurnAround:
00D637  1  B5 16               lda Enemy_ID,x           ;check for specific enemies
00D639  1  C9 0D               cmp #PiranhaPlant
00D63B  1  F0 22               beq ExTA                 ;if piranha plant, leave
00D63D  1  C9 11               cmp #Lakitu
00D63F  1  F0 1E               beq ExTA                 ;if lakitu, leave
00D641  1  C9 05               cmp #HammerBro
00D643  1  F0 1A               beq ExTA                 ;if hammer bro, leave
00D645  1  C9 12               cmp #Spiny
00D647  1  F0 08               beq RXSpd                ;if spiny, turn it around
00D649  1  C9 0E               cmp #GreenParatroopaJump
00D64B  1  F0 04               beq RXSpd                ;if green paratroopa, turn it around
00D64D  1  C9 07               cmp #$07
00D64F  1  B0 0E               bcs ExTA                 ;if any OTHER enemy object => $07, leave
00D651  1  B5 58        RXSpd: lda Enemy_X_Speed,x      ;load horizontal speed
00D653  1  49 FF               eor #$ff                 ;get two's compliment for horizontal speed
00D655  1  A8                  tay
00D656  1  C8                  iny
00D657  1  94 58               sty Enemy_X_Speed,x      ;store as new horizontal speed
00D659  1  B5 46               lda Enemy_MovingDir,x
00D65B  1  49 03               eor #%00000011           ;invert moving direction and store, then leave
00D65D  1  95 46               sta Enemy_MovingDir,x    ;thus effectively turning the enemy around
00D65F  1  60           ExTA:  rts                      ;leave!!!
00D660  1               
00D660  1               ;-------------------------------------------------------------------------------------
00D660  1               ;$00 - vertical position of platform
00D660  1               
00D660  1               LargePlatformCollision:
00D660  1  A9 FF               lda #$ff                     ;save value here
00D662  1  9D A2 03            sta PlatformCollisionFlag,x
00D665  1  AD 47 07            lda TimerControl             ;check master timer control
00D668  1  D0 29               bne ExLPC                    ;if set, branch to leave
00D66A  1  B5 1E               lda Enemy_State,x            ;if d7 set in object state,
00D66C  1  30 25               bmi ExLPC                    ;branch to leave
00D66E  1  B5 16               lda Enemy_ID,x
00D670  1  C9 24               cmp #$24                     ;check enemy object identifier for
00D672  1  D0 06               bne ChkForPlayerC_LargeP     ;balance platform, branch if not found
00D674  1  B5 1E               lda Enemy_State,x
00D676  1  AA                  tax                          ;set state as enemy offset here
00D677  1  20 7A D6            jsr ChkForPlayerC_LargeP     ;perform code with state offset, then original offset, in X
00D67A  1               
00D67A  1               ChkForPlayerC_LargeP:
00D67A  1  20 5C D7            jsr CheckPlayerVertical      ;figure out if player is below a certain point
00D67D  1  B0 14               bcs ExLPC                    ;or offscreen, branch to leave if true
00D67F  1  8A                  txa
00D680  1  20 6F D7            jsr GetEnemyBoundBoxOfsArg   ;get bounding box offset in Y
00D683  1  B5 CF               lda Enemy_Y_Position,x       ;store vertical coordinate in
00D685  1  85 00               sta $00                      ;temp variable for now
00D687  1  8A                  txa                          ;send offset we're on to the stack
00D688  1  48                  pha
00D689  1  20 DD DD            jsr PlayerCollisionCore      ;do player-to-platform collision detection
00D68C  1  68                  pla                          ;retrieve offset from the stack
00D68D  1  AA                  tax
00D68E  1  90 03               bcc ExLPC                    ;if no collision, branch to leave
00D690  1  20 D7 D6            jsr ProcLPlatCollisions      ;otherwise collision, perform sub
00D693  1  A6 08        ExLPC: ldx ObjectOffset             ;get enemy object buffer offset and leave
00D695  1  60                  rts
00D696  1               
00D696  1               ;--------------------------------
00D696  1               ;$00 - counter for bounding boxes
00D696  1               
00D696  1               SmallPlatformCollision:
00D696  1  AD 47 07           lda TimerControl             ;if master timer control set,
00D699  1  D0 37              bne ExSPC                    ;branch to leave
00D69B  1  9D A2 03           sta PlatformCollisionFlag,x  ;otherwise initialize collision flag
00D69E  1  20 5C D7           jsr CheckPlayerVertical      ;do a sub to see if player is below a certain point
00D6A1  1  B0 2F              bcs ExSPC                    ;or entirely offscreen, and branch to leave if true
00D6A3  1  A9 02              lda #$02
00D6A5  1  85 00              sta $00                      ;load counter here for 2 bounding boxes
00D6A7  1               
00D6A7  1               ChkSmallPlatLoop:
00D6A7  1  A6 08              ldx ObjectOffset           ;get enemy object offset
00D6A9  1  20 6D D7           jsr GetEnemyBoundBoxOfs    ;get bounding box offset in Y
00D6AC  1  29 02              and #%00000010             ;if d1 of offscreen lower nybble bits was set
00D6AE  1  D0 22              bne ExSPC                  ;then branch to leave
00D6B0  1  B9 AD 04           lda BoundingBox_UL_YPos,y  ;check top of platform's bounding box for being
00D6B3  1  C9 20              cmp #$20                   ;above a specific point
00D6B5  1  90 05              bcc MoveBoundBox           ;if so, branch, don't do collision detection
00D6B7  1  20 DD DD           jsr PlayerCollisionCore    ;otherwise, perform player-to-platform collision detection
00D6BA  1  B0 19              bcs ProcSPlatCollisions    ;skip ahead if collision
00D6BC  1               
00D6BC  1               MoveBoundBox:
00D6BC  1  B9 AD 04            lda BoundingBox_UL_YPos,y  ;move bounding box vertical coordinates
00D6BF  1  18                  clc                        ;128 pixels downwards
00D6C0  1  69 80               adc #$80
00D6C2  1  99 AD 04            sta BoundingBox_UL_YPos,y
00D6C5  1  B9 AF 04            lda BoundingBox_DR_YPos,y
00D6C8  1  18                  clc
00D6C9  1  69 80               adc #$80
00D6CB  1  99 AF 04            sta BoundingBox_DR_YPos,y
00D6CE  1  C6 00               dec $00                    ;decrement counter we set earlier
00D6D0  1  D0 D5               bne ChkSmallPlatLoop       ;loop back until both bounding boxes are checked
00D6D2  1  A6 08        ExSPC: ldx ObjectOffset           ;get enemy object buffer offset, then leave
00D6D4  1  60                  rts
00D6D5  1               
00D6D5  1               ;--------------------------------
00D6D5  1               
00D6D5  1               ProcSPlatCollisions:
00D6D5  1  A6 08              ldx ObjectOffset             ;return enemy object buffer offset to X, then continue
00D6D7  1               
00D6D7  1               ProcLPlatCollisions:
00D6D7  1  B9 AF 04           lda BoundingBox_DR_YPos,y    ;get difference by subtracting the top
00D6DA  1  38                 sec                          ;of the player's bounding box from the bottom
00D6DB  1  ED AD 04           sbc BoundingBox_UL_YPos      ;of the platform's bounding box
00D6DE  1  C9 04              cmp #$04                     ;if difference too large or negative,
00D6E0  1  B0 08              bcs ChkForTopCollision       ;branch, do not alter vertical speed of player
00D6E2  1  A5 9F              lda Player_Y_Speed           ;check to see if player's vertical speed is moving down
00D6E4  1  10 04              bpl ChkForTopCollision       ;if so, don't mess with it
00D6E6  1  A9 01              lda #$01                     ;otherwise, set vertical
00D6E8  1  85 9F              sta Player_Y_Speed           ;speed of player to kill jump
00D6EA  1               
00D6EA  1               ChkForTopCollision:
00D6EA  1  AD AF 04           lda BoundingBox_DR_YPos      ;get difference by subtracting the top
00D6ED  1  38                 sec                          ;of the platform's bounding box from the bottom
00D6EE  1  F9 AD 04           sbc BoundingBox_UL_YPos,y    ;of the player's bounding box
00D6F1  1  C9 06              cmp #$06
00D6F3  1  B0 1B              bcs PlatformSideCollisions   ;if difference not close enough, skip all of this
00D6F5  1  A5 9F              lda Player_Y_Speed
00D6F7  1  30 17              bmi PlatformSideCollisions   ;if player's vertical speed moving upwards, skip this
00D6F9  1  A5 00              lda $00                      ;get saved bounding box counter from earlier
00D6FB  1  B4 16              ldy Enemy_ID,x
00D6FD  1  C0 2B              cpy #$2b                     ;if either of the two small platform objects are found,
00D6FF  1  F0 05              beq SetCollisionFlag         ;regardless of which one, branch to use bounding box counter
00D701  1  C0 2C              cpy #$2c                     ;as contents of collision flag
00D703  1  F0 01              beq SetCollisionFlag
00D705  1  8A                 txa                          ;otherwise use enemy object buffer offset
00D706  1               
00D706  1               SetCollisionFlag:
00D706  1  A6 08              ldx ObjectOffset             ;get enemy object buffer offset
00D708  1  9D A2 03           sta PlatformCollisionFlag,x  ;save either bounding box counter or enemy offset here
00D70B  1  A9 00              lda #$00
00D70D  1  85 1D              sta Player_State             ;set player state to normal then leave
00D70F  1  60                 rts
00D710  1               
00D710  1               PlatformSideCollisions:
00D710  1  A9 01                 lda #$01                   ;set value here to indicate possible horizontal
00D712  1  85 00                 sta $00                    ;collision on left side of platform
00D714  1  AD AE 04              lda BoundingBox_DR_XPos    ;get difference by subtracting platform's left edge
00D717  1  38                    sec                        ;from player's right edge
00D718  1  F9 AC 04              sbc BoundingBox_UL_XPos,y
00D71B  1  C9 08                 cmp #$08                   ;if difference close enough, skip all of this
00D71D  1  90 0D                 bcc SideC
00D71F  1  E6 00                 inc $00                    ;otherwise increment value set here for right side collision
00D721  1  B9 AE 04              lda BoundingBox_DR_XPos,y  ;get difference by subtracting player's left edge
00D724  1  18                    clc                        ;from platform's right edge
00D725  1  ED AC 04              sbc BoundingBox_UL_XPos
00D728  1  C9 09                 cmp #$09                   ;if difference not close enough, skip subroutine
00D72A  1  B0 03                 bcs NoSideC                ;and instead branch to leave (no collision)
00D72C  1  20 03 DA     SideC:   jsr ImpedePlayerMove       ;deal with horizontal collision
00D72F  1  A6 08        NoSideC: ldx ObjectOffset           ;return with enemy object buffer offset
00D731  1  60                    rts
00D732  1               
00D732  1               ;-------------------------------------------------------------------------------------
00D732  1               
00D732  1               PlayerPosSPlatData:
00D732  1  80 00              .byte $80, $00
00D734  1               
00D734  1               PositionPlayerOnS_Plat:
00D734  1  A8                 tay                        ;use bounding box counter saved in collision flag
00D735  1  B5 CF              lda Enemy_Y_Position,x     ;for offset
00D737  1  18                 clc                        ;add positioning data using offset to the vertical
00D738  1  79 31 D7           adc PlayerPosSPlatData-1,y ;coordinate
00D73B  1  2C                 .byte $2c                    ;BIT instruction opcode
00D73C  1               
00D73C  1               PositionPlayerOnVPlat:
00D73C  1  B5 CF                 lda Enemy_Y_Position,x    ;get vertical coordinate
00D73E  1  A4 0E                 ldy GameEngineSubroutine
00D740  1  C0 0B                 cpy #$0b                  ;if certain routine being executed on this frame,
00D742  1  F0 17                 beq ExPlPos               ;skip all of this
00D744  1  B4 B6                 ldy Enemy_Y_HighPos,x
00D746  1  C0 01                 cpy #$01                  ;if vertical high byte offscreen, skip this
00D748  1  D0 11                 bne ExPlPos
00D74A  1  38                    sec                       ;subtract 32 pixels from vertical coordinate
00D74B  1  E9 20                 sbc #$20                  ;for the player object's height
00D74D  1  85 CE                 sta Player_Y_Position     ;save as player's new vertical coordinate
00D74F  1  98                    tya
00D750  1  E9 00                 sbc #$00                  ;subtract borrow and store as player's
00D752  1  85 B5                 sta Player_Y_HighPos      ;new vertical high byte
00D754  1  A9 00                 lda #$00
00D756  1  85 9F                 sta Player_Y_Speed        ;initialize vertical speed and low byte of force
00D758  1  8D 33 04              sta Player_Y_MoveForce    ;and then leave
00D75B  1  60           ExPlPos: rts
00D75C  1               
00D75C  1               ;-------------------------------------------------------------------------------------
00D75C  1               
00D75C  1               CheckPlayerVertical:
00D75C  1  AD D0 03            lda Player_OffscreenBits  ;if player object is completely offscreen
00D75F  1  C9 F0               cmp #$f0                  ;vertically, leave this routine
00D761  1  B0 09               bcs ExCPV
00D763  1  A4 B5               ldy Player_Y_HighPos      ;if player high vertical byte is not
00D765  1  88                  dey                       ;within the screen, leave this routine
00D766  1  D0 04               bne ExCPV
00D768  1  A5 CE               lda Player_Y_Position     ;if on the screen, check to see how far down
00D76A  1  C9 D0               cmp #$d0                  ;the player is vertically
00D76C  1  60           ExCPV: rts
00D76D  1               
00D76D  1               ;-------------------------------------------------------------------------------------
00D76D  1               
00D76D  1               GetEnemyBoundBoxOfs:
00D76D  1  A5 08              lda ObjectOffset         ;get enemy object buffer offset
00D76F  1               
00D76F  1               GetEnemyBoundBoxOfsArg:
00D76F  1  0A                 asl                      ;multiply A by four, then add four
00D770  1  0A                 asl                      ;to skip player's bounding box
00D771  1  18                 clc
00D772  1  69 04              adc #$04
00D774  1  A8                 tay                      ;send to Y
00D775  1  AD D1 03           lda Enemy_OffscreenBits  ;get offscreen bits for enemy object
00D778  1  29 0F              and #%00001111           ;save low nybble
00D77A  1  C9 0F              cmp #%00001111           ;check for all bits set
00D77C  1  60                 rts
00D77D  1               
00D77D  1               ;-------------------------------------------------------------------------------------
00D77D  1               ;$00-$01 - used to hold many values, essentially temp variables
00D77D  1               ;$04 - holds lower nybble of vertical coordinate from block buffer routine
00D77D  1               ;$eb - used to hold block buffer adder
00D77D  1               
00D77D  1               PlayerBGUpperExtent:
00D77D  1  20 10              .byte $20, $10
00D77F  1               
00D77F  1               PlayerBGCollision:
00D77F  1  AD 16 07               lda DisableCollisionDet   ;if collision detection disabled flag set,
00D782  1  D0 2E                  bne ExPBGCol              ;branch to leave
00D784  1  A5 0E                  lda GameEngineSubroutine
00D786  1  C9 0B                  cmp #$0b                  ;if running routine #11 or $0b
00D788  1  F0 28                  beq ExPBGCol              ;branch to leave
00D78A  1  C9 04                  cmp #$04
00D78C  1  90 24                  bcc ExPBGCol              ;if running routines $00-$03 branch to leave
00D78E  1  A9 01                  lda #$01                  ;load default player state for swimming
00D790  1  AC 04 07               ldy SwimmingFlag          ;if swimming flag set,
00D793  1  D0 0A                  bne SetPSte               ;branch ahead to set default state
00D795  1  A5 1D                  lda Player_State          ;if player in normal state,
00D797  1  F0 04                  beq SetFallS              ;branch to set default state for falling
00D799  1  C9 03                  cmp #$03
00D79B  1  D0 04                  bne ChkOnScr              ;if in any other state besides climbing, skip to next part
00D79D  1  A9 02        SetFallS: lda #$02                  ;load default player state for falling
00D79F  1  85 1D        SetPSte:  sta Player_State          ;set whatever player state is appropriate
00D7A1  1  A5 B5        ChkOnScr: lda Player_Y_HighPos
00D7A3  1  C9 01                  cmp #$01                  ;check player's vertical high byte for still on the screen
00D7A5  1  D0 0B                  bne ExPBGCol              ;branch to leave if not
00D7A7  1  A9 FF                  lda #$ff
00D7A9  1  8D 90 04               sta Player_CollisionBits  ;initialize player's collision flag
00D7AC  1  A5 CE                  lda Player_Y_Position
00D7AE  1  C9 CF                  cmp #$cf                  ;check player's vertical coordinate
00D7B0  1  90 01                  bcc ChkCollSize           ;if not too close to the bottom of screen, continue
00D7B2  1  60           ExPBGCol: rts                       ;otherwise leave
00D7B3  1               
00D7B3  1               ChkCollSize:
00D7B3  1  A0 02                 ldy #$02                    ;load default offset
00D7B5  1  AD 14 07              lda CrouchingFlag
00D7B8  1  D0 0C                 bne GBBAdr                  ;if player crouching, skip ahead
00D7BA  1  AD 54 07              lda PlayerSize
00D7BD  1  D0 07                 bne GBBAdr                  ;if player small, skip ahead
00D7BF  1  88                    dey                         ;otherwise decrement offset for big player not crouching
00D7C0  1  AD 04 07              lda SwimmingFlag
00D7C3  1  D0 01                 bne GBBAdr                  ;if swimming flag set, skip ahead
00D7C5  1  88                    dey                         ;otherwise decrement offset
00D7C6  1  B9 65 DE     GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
00D7C9  1  85 EB                 sta $eb                     ;store value here
00D7CB  1  A8                    tay                         ;put value into Y, as offset for block buffer routine
00D7CC  1  AE 54 07              ldx PlayerSize              ;get player's size as offset
00D7CF  1  AD 14 07              lda CrouchingFlag
00D7D2  1  F0 01                 beq HeadChk                 ;if player not crouching, branch ahead
00D7D4  1  E8                    inx                         ;otherwise increment size as offset
00D7D5  1  A5 CE        HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
00D7D7  1  DD 7D D7              cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
00D7DA  1  90 35                 bcc DoFootCheck             ;if player is too high, skip this part
00D7DC  1  20 A1 DE              jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
00D7DF  1  F0 30                 beq DoFootCheck             ;player, and branch if nothing above player's head
00D7E1  1  20 59 DA              jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
00D7E4  1  B0 4F                 bcs AwardTouchedCoin        ;if so, branch to some other part of code
00D7E6  1  A4 9F                 ldy Player_Y_Speed          ;check player's vertical speed
00D7E8  1  10 27                 bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
00D7EA  1  A4 04                 ldy $04                     ;check lower nybble of vertical coordinate returned
00D7EC  1  C0 04                 cpy #$04                    ;from collision detection routine
00D7EE  1  90 21                 bcc DoFootCheck             ;if low nybble < 4, branch
00D7F0  1  20 47 DA              jsr CheckForSolidMTiles     ;check to see what player's head bumped on
00D7F3  1  B0 10                 bcs SolidOrClimb            ;if player collided with solid metatile, branch
00D7F5  1  AC 4E 07              ldy AreaType                ;otherwise check area type
00D7F8  1  F0 13                 beq NYSpd                   ;if water level, branch ahead
00D7FA  1  AC 84 07              ldy BlockBounceTimer        ;if block bounce timer not expired,
00D7FD  1  D0 0E                 bne NYSpd                   ;branch ahead, do not process collision
00D7FF  1  20 CF BC              jsr PlayerHeadCollision     ;otherwise do a sub to process collision
00D802  1  4C 11 D8              jmp DoFootCheck             ;jump ahead to skip these other parts here
00D805  1               
00D805  1               SolidOrClimb:
00D805  1  C9 26               cmp #$26               ;if climbing metatile,
00D807  1  F0 04               beq NYSpd              ;branch ahead and do not play sound
00D809  1  A9 02               lda #Sfx_Bump
00D80B  1  85 FF               sta Square1SoundQueue  ;otherwise load bump sound
00D80D  1  A9 01        NYSpd: lda #$01               ;set player's vertical speed to nullify
00D80F  1  85 9F               sta Player_Y_Speed     ;jump or swim
00D811  1               
00D811  1               DoFootCheck:
00D811  1  A4 EB              ldy $eb                    ;get block buffer adder offset
00D813  1  A5 CE              lda Player_Y_Position
00D815  1  C9 CF              cmp #$cf                   ;check to see how low player is
00D817  1  B0 60              bcs DoPlayerSideCheck      ;if player is too far down on screen, skip all of this
00D819  1  20 A0 DE           jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom left of player
00D81C  1  20 59 DA           jsr CheckForCoinMTiles     ;check to see if player touched coin with their left foot
00D81F  1  B0 14              bcs AwardTouchedCoin       ;if so, branch to some other part of code
00D821  1  48                 pha                        ;save bottom left metatile to stack
00D822  1  20 A0 DE           jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom right of player
00D825  1  85 00              sta $00                    ;save bottom right metatile here
00D827  1  68                 pla
00D828  1  85 01              sta $01                    ;pull bottom left metatile and save here
00D82A  1  D0 0C              bne ChkFootMTile           ;if anything here, skip this part
00D82C  1  A5 00              lda $00                    ;otherwise check for anything in bottom right metatile
00D82E  1  F0 49              beq DoPlayerSideCheck      ;and skip ahead if not
00D830  1  20 59 DA           jsr CheckForCoinMTiles     ;check to see if player touched coin with their right foot
00D833  1  90 03              bcc ChkFootMTile           ;if not, skip unconditional jump and continue code
00D835  1               
00D835  1               AwardTouchedCoin:
00D835  1  4C 20 D9           jmp HandleCoinMetatile     ;follow the code to erase coin and award to player 1 coin
00D838  1               
00D838  1               ChkFootMTile:
00D838  1  20 52 DA               jsr CheckForClimbMTiles    ;check to see if player landed on climbable metatiles
00D83B  1  B0 3C                  bcs DoPlayerSideCheck      ;if so, branch
00D83D  1  A4 9F                  ldy Player_Y_Speed         ;check player's vertical speed
00D83F  1  30 38                  bmi DoPlayerSideCheck      ;if player moving upwards, branch
00D841  1  C9 C5                  cmp #$c5
00D843  1  D0 03                  bne ContChk                ;if player did not touch axe, skip ahead
00D845  1  4C 29 D9               jmp HandleAxeMetatile      ;otherwise jump to set modes of operation
00D848  1  20 D8 D9     ContChk:  jsr ChkInvisibleMTiles     ;do sub to check for hidden coin or 1-up blocks
00D84B  1  F0 2C                  beq DoPlayerSideCheck      ;if either found, branch
00D84D  1  AC 0E 07               ldy JumpspringAnimCtrl     ;if jumpspring animating right now,
00D850  1  D0 23                  bne InitSteP               ;branch ahead
00D852  1  A4 04                  ldy $04                    ;check lower nybble of vertical coordinate returned
00D854  1  C0 05                  cpy #$05                   ;from collision detection routine
00D856  1  90 07                  bcc LandPlyr               ;if lower nybble < 5, branch
00D858  1  A5 45                  lda Player_MovingDir
00D85A  1  85 00                  sta $00                    ;use player's moving direction as temp variable
00D85C  1  4C 03 DA               jmp ImpedePlayerMove       ;jump to impede player's movement in that direction
00D85F  1  20 DF D9     LandPlyr: jsr ChkForLandJumpSpring   ;do sub to check for jumpspring metatiles and deal with it
00D862  1  A9 F0                  lda #$f0
00D864  1  25 CE                  and Player_Y_Position      ;mask out lower nybble of player's vertical position
00D866  1  85 CE                  sta Player_Y_Position      ;and store as new vertical position to land player properly
00D868  1  20 B6 B4               jsr HandlePipeEntry        ;do sub to process potential pipe entry
00D86B  1  A9 00                  lda #$00
00D86D  1  85 9F                  sta Player_Y_Speed         ;initialize vertical speed and fractional
00D86F  1  8D 33 04               sta Player_Y_MoveForce     ;movement force to stop player's vertical movement
00D872  1  8D 84 04               sta StompChainCounter      ;initialize enemy stomp counter
00D875  1  A9 00        InitSteP: lda #$00
00D877  1  85 1D                  sta Player_State           ;set player's state to normal
00D879  1               
00D879  1               DoPlayerSideCheck:
00D879  1  A4 EB              ldy $eb       ;get block buffer adder offset
00D87B  1  C8                 iny
00D87C  1  C8                 iny           ;increment offset 2 bytes to use adders for side collisions
00D87D  1  A9 02              lda #$02      ;set value here to be used as counter
00D87F  1  85 00              sta $00
00D881  1               
00D881  1               SideCheckLoop:
00D881  1  C8                  iny                       ;move onto the next one
00D882  1  84 EB               sty $eb                   ;store it
00D884  1  A5 CE               lda Player_Y_Position
00D886  1  C9 20               cmp #$20                  ;check player's vertical position
00D888  1  90 16               bcc BHalf                 ;if player is in status bar area, branch ahead to skip this part
00D88A  1  C9 E4               cmp #$e4
00D88C  1  B0 28               bcs ExSCH                 ;branch to leave if player is too far down
00D88E  1  20 A4 DE            jsr BlockBufferColli_Side ;do player-to-bg collision detection on one half of player
00D891  1  F0 0D               beq BHalf                 ;branch ahead if nothing found
00D893  1  C9 1C               cmp #$1c                  ;otherwise check for pipe metatiles
00D895  1  F0 09               beq BHalf                 ;if collided with sideways pipe (top), branch ahead
00D897  1  C9 6B               cmp #$6b
00D899  1  F0 05               beq BHalf                 ;if collided with water pipe (top), branch ahead
00D89B  1  20 52 DA            jsr CheckForClimbMTiles   ;do sub to see if player bumped into anything climbable
00D89E  1  90 17               bcc CheckSideMTiles       ;if not, branch to alternate section of code
00D8A0  1  A4 EB        BHalf: ldy $eb                   ;load block adder offset
00D8A2  1  C8                  iny                       ;increment it
00D8A3  1  A5 CE               lda Player_Y_Position     ;get player's vertical position
00D8A5  1  C9 08               cmp #$08
00D8A7  1  90 0D               bcc ExSCH                 ;if too high, branch to leave
00D8A9  1  C9 D0               cmp #$d0
00D8AB  1  B0 09               bcs ExSCH                 ;if too low, branch to leave
00D8AD  1  20 A4 DE            jsr BlockBufferColli_Side ;do player-to-bg collision detection on other half of player
00D8B0  1  D0 05               bne CheckSideMTiles       ;if something found, branch
00D8B2  1  C6 00               dec $00                   ;otherwise decrement counter
00D8B4  1  D0 CB               bne SideCheckLoop         ;run code until both sides of player are checked
00D8B6  1  60           ExSCH: rts                       ;leave
00D8B7  1               
00D8B7  1               CheckSideMTiles:
00D8B7  1  20 D8 D9               jsr ChkInvisibleMTiles     ;check for hidden or coin 1-up blocks
00D8BA  1  F0 61                  beq ExCSM                  ;branch to leave if either found
00D8BC  1  20 52 DA               jsr CheckForClimbMTiles    ;check for climbable metatiles
00D8BF  1  90 03                  bcc ContSChk               ;if not found, skip and continue with code
00D8C1  1  4C 49 D9               jmp HandleClimbing         ;otherwise jump to handle climbing
00D8C4  1  20 59 DA     ContSChk: jsr CheckForCoinMTiles     ;check to see if player touched coin
00D8C7  1  B0 57                  bcs HandleCoinMetatile     ;if so, execute code to erase coin and award to player 1 coin
00D8C9  1  20 F8 D9               jsr ChkJumpspringMetatiles ;check for jumpspring metatiles
00D8CC  1  90 08                  bcc ChkPBtm                ;if not found, branch ahead to continue cude
00D8CE  1  AD 0E 07               lda JumpspringAnimCtrl     ;otherwise check jumpspring animation control
00D8D1  1  D0 4A                  bne ExCSM                  ;branch to leave if set
00D8D3  1  4C 1A D9               jmp StopPlayerMove         ;otherwise jump to impede player's movement
00D8D6  1  A4 1D        ChkPBtm:  ldy Player_State           ;get player's state
00D8D8  1  C0 00                  cpy #$00                   ;check for player's state set to normal
00D8DA  1  D0 3E                  bne StopPlayerMove         ;if not, branch to impede player's movement
00D8DC  1  A4 33                  ldy PlayerFacingDir        ;get player's facing direction
00D8DE  1  88                     dey
00D8DF  1  D0 39                  bne StopPlayerMove         ;if facing left, branch to impede movement
00D8E1  1  C9 6C                  cmp #$6c                   ;otherwise check for pipe metatiles
00D8E3  1  F0 04                  beq PipeDwnS               ;if collided with sideways pipe (bottom), branch
00D8E5  1  C9 1F                  cmp #$1f                   ;if collided with water pipe (bottom), continue
00D8E7  1  D0 31                  bne StopPlayerMove         ;otherwise branch to impede player's movement
00D8E9  1  AD C4 03     PipeDwnS: lda Player_SprAttrib       ;check player's attributes
00D8EC  1  D0 04                  bne PlyrPipe               ;if already set, branch, do not play sound again
00D8EE  1  A0 10                  ldy #Sfx_PipeDown_Injury
00D8F0  1  84 FF                  sty Square1SoundQueue      ;otherwise load pipedown/injury sound
00D8F2  1  09 20        PlyrPipe: ora #%00100000
00D8F4  1  8D C4 03               sta Player_SprAttrib       ;set background priority bit in player attributes
00D8F7  1  A5 86                  lda Player_X_Position
00D8F9  1  29 0F                  and #%00001111             ;get lower nybble of player's horizontal coordinate
00D8FB  1  F0 0E                  beq ChkGERtn               ;if at zero, branch ahead to skip this part
00D8FD  1  A0 00                  ldy #$00                   ;set default offset for timer setting data
00D8FF  1  AD 1A 07               lda ScreenLeft_PageLoc     ;load page location for left side of screen
00D902  1  F0 01                  beq SetCATmr               ;if at page zero, use default offset
00D904  1  C8                     iny                        ;otherwise increment offset
00D905  1  B9 1E D9     SetCATmr: lda AreaChangeTimerData,y  ;set timer for change of area as appropriate
00D908  1  8D DE 06               sta ChangeAreaTimer
00D90B  1  A5 0E        ChkGERtn: lda GameEngineSubroutine   ;get number of game engine routine running
00D90D  1  C9 07                  cmp #$07
00D90F  1  F0 0C                  beq ExCSM                  ;if running player entrance routine or
00D911  1  C9 08                  cmp #$08                   ;player control routine, go ahead and branch to leave
00D913  1  D0 08                  bne ExCSM
00D915  1  A9 02                  lda #$02
00D917  1  85 0E                  sta GameEngineSubroutine   ;otherwise set sideways pipe entry routine to run
00D919  1  60                     rts                        ;and leave
00D91A  1               
00D91A  1               ;--------------------------------
00D91A  1               ;$02 - high nybble of vertical coordinate from block buffer
00D91A  1               ;$04 - low nybble of horizontal coordinate from block buffer
00D91A  1               ;$06-$07 - block buffer address
00D91A  1               
00D91A  1               StopPlayerMove:
00D91A  1  20 03 DA            jsr ImpedePlayerMove      ;stop player's movement
00D91D  1  60           ExCSM: rts                       ;leave
00D91E  1               
00D91E  1               AreaChangeTimerData:
00D91E  1  A0 34              .byte $a0, $34
00D920  1               
00D920  1               HandleCoinMetatile:
00D920  1  20 37 D9           jsr ErACM             ;do sub to erase coin metatile from block buffer
00D923  1  EE 48 07           inc CoinTallyFor1Ups  ;increment coin tally used for 1-up blocks
00D926  1  4C 11 B4           jmp GiveOneCoin       ;update coin amount and tally on the screen
00D929  1               
00D929  1               HandleAxeMetatile:
00D929  1  A9 00               lda #$00
00D92B  1  8D 72 07            sta OperMode_Task   ;reset secondary mode
00D92E  1  A9 02               lda #$02
00D930  1  8D 70 07            sta OperMode        ;set primary mode to autoctrl mode
00D933  1  A9 18               lda #$18
00D935  1  85 57               sta Player_X_Speed  ;set horizontal speed and continue to erase axe metatile
00D937  1  A4 02        ErACM: ldy $02             ;load vertical high nybble offset for block buffer
00D939  1  A9 00               lda #$00            ;load blank metatile
00D93B  1  91 06               sta ($06),y         ;store to remove old contents from block buffer
00D93D  1  4C 2A EF            jmp RemoveCoin_Axe  ;update the screen accordingly
00D940  1               
00D940  1               ;--------------------------------
00D940  1               ;$02 - high nybble of vertical coordinate from block buffer
00D940  1               ;$04 - low nybble of horizontal coordinate from block buffer
00D940  1               ;$06-$07 - block buffer address
00D940  1               
00D940  1               ClimbXPosAdder:
00D940  1  F9 07              .byte $f9, $07
00D942  1               
00D942  1               ClimbPLocAdder:
00D942  1  FF 00              .byte $ff, $00
00D944  1               
00D944  1               FlagpoleYPosData:
00D944  1  18 22 50 68        .byte $18, $22, $50, $68, $90
00D948  1  90           
00D949  1               
00D949  1               HandleClimbing:
00D949  1  A4 04              ldy $04            ;check low nybble of horizontal coordinate returned from
00D94B  1  C0 06              cpy #$06           ;collision detection routine against certain values, this
00D94D  1  90 04              bcc ExHC           ;makes actual physical part of vine or flagpole thinner
00D94F  1  C0 0A              cpy #$0a           ;than 16 pixels
00D951  1  90 01              bcc ChkForFlagpole
00D953  1  60           ExHC: rts                ;leave if too far left or too far right
00D954  1               
00D954  1               ChkForFlagpole:
00D954  1  C9 24              cmp #$24               ;check climbing metatiles
00D956  1  F0 04              beq FlagpoleCollision  ;branch if flagpole ball found
00D958  1  C9 25              cmp #$25
00D95A  1  D0 39              bne VineCollision      ;branch to alternate code if flagpole shaft not found
00D95C  1               
00D95C  1               FlagpoleCollision:
00D95C  1  A5 0E              lda GameEngineSubroutine
00D95E  1  C9 05              cmp #$05                  ;check for end-of-level routine running
00D960  1  F0 41              beq PutPlayerOnVine       ;if running, branch to end of climbing code
00D962  1  A9 01              lda #$01
00D964  1  85 33              sta PlayerFacingDir       ;set player's facing direction to right
00D966  1  EE 23 07           inc ScrollLock            ;set scroll lock flag
00D969  1  A5 0E              lda GameEngineSubroutine
00D96B  1  C9 04              cmp #$04                  ;check for flagpole slide routine running
00D96D  1  F0 1F              beq RunFR                 ;if running, branch to end of flagpole code here
00D96F  1  A9 33              lda #BulletBill_CannonVar ;load identifier for bullet bills (cannon variant)
00D971  1  20 A6 ED           jsr KillEnemies           ;get rid of them
00D974  1  A9 80              lda #Silence
00D976  1  85 FC              sta EventMusicQueue       ;silence music
00D978  1  4A                 lsr
00D979  1  8D 13 07           sta FlagpoleSoundQueue    ;load flagpole sound into flagpole sound queue
00D97C  1  A2 04              ldx #$04                  ;start at end of vertical coordinate data
00D97E  1  A5 CE              lda Player_Y_Position
00D980  1  8D 0F 07           sta FlagpoleCollisionYPos ;store player's vertical coordinate here to be used later
00D983  1               
00D983  1               ChkFlagpoleYPosLoop:
00D983  1  DD 44 D9            cmp FlagpoleYPosData,x    ;compare with current vertical coordinate data
00D986  1  B0 03               bcs MtchF                 ;if player's => current, branch to use current offset
00D988  1  CA                  dex                       ;otherwise decrement offset to use
00D989  1  D0 F8               bne ChkFlagpoleYPosLoop   ;do this until all data is checked (use last one if all checked)
00D98B  1  8E 0F 01     MtchF: stx FlagpoleScore         ;store offset here to be used later
00D98E  1  A9 04        RunFR: lda #$04
00D990  1  85 0E               sta GameEngineSubroutine  ;set value to run flagpole slide routine
00D992  1  4C A3 D9            jmp PutPlayerOnVine       ;jump to end of climbing code
00D995  1               
00D995  1               VineCollision:
00D995  1  C9 26              cmp #$26                  ;check for climbing metatile used on vines
00D997  1  D0 0A              bne PutPlayerOnVine
00D999  1  A5 CE              lda Player_Y_Position     ;check player's vertical coordinate
00D99B  1  C9 20              cmp #$20                  ;for being in status bar area
00D99D  1  B0 04              bcs PutPlayerOnVine       ;branch if not that far up
00D99F  1  A9 01              lda #$01
00D9A1  1  85 0E              sta GameEngineSubroutine  ;otherwise set to run autoclimb routine next frame
00D9A3  1               
00D9A3  1               PutPlayerOnVine:
00D9A3  1  A9 03                 lda #$03                ;set player state to climbing
00D9A5  1  85 1D                 sta Player_State
00D9A7  1  A9 00                 lda #$00                ;nullify player's horizontal speed
00D9A9  1  85 57                 sta Player_X_Speed      ;and fractional horizontal movement force
00D9AB  1  8D 05 07              sta Player_X_MoveForce
00D9AE  1  A5 86                 lda Player_X_Position   ;get player's horizontal coordinate
00D9B0  1  38                    sec
00D9B1  1  ED 1C 07              sbc ScreenLeft_X_Pos    ;subtract from left side horizontal coordinate
00D9B4  1  C9 10                 cmp #$10
00D9B6  1  B0 04                 bcs SetVXPl             ;if 16 or more pixels difference, do not alter facing direction
00D9B8  1  A9 02                 lda #$02
00D9BA  1  85 33                 sta PlayerFacingDir     ;otherwise force player to face left
00D9BC  1  A4 33        SetVXPl: ldy PlayerFacingDir     ;get current facing direction, use as offset
00D9BE  1  A5 06                 lda $06                 ;get low byte of block buffer address
00D9C0  1  0A                    asl
00D9C1  1  0A                    asl                     ;move low nybble to high
00D9C2  1  0A                    asl
00D9C3  1  0A                    asl
00D9C4  1  18                    clc
00D9C5  1  79 3F D9              adc ClimbXPosAdder-1,y  ;add pixels depending on facing direction
00D9C8  1  85 86                 sta Player_X_Position   ;store as player's horizontal coordinate
00D9CA  1  A5 06                 lda $06                 ;get low byte of block buffer address again
00D9CC  1  D0 09                 bne ExPVne              ;if not zero, branch
00D9CE  1  AD 1B 07              lda ScreenRight_PageLoc ;load page location of right side of screen
00D9D1  1  18                    clc
00D9D2  1  79 41 D9              adc ClimbPLocAdder-1,y  ;add depending on facing location
00D9D5  1  85 6D                 sta Player_PageLoc      ;store as player's page location
00D9D7  1  60           ExPVne:  rts                     ;finally, we're done!
00D9D8  1               
00D9D8  1               ;--------------------------------
00D9D8  1               
00D9D8  1               ChkInvisibleMTiles:
00D9D8  1  C9 5F                 cmp #$5f       ;check for hidden coin block
00D9DA  1  F0 02                 beq ExCInvT    ;branch to leave if found
00D9DC  1  C9 60                 cmp #$60       ;check for hidden 1-up block
00D9DE  1  60           ExCInvT: rts            ;leave with zero flag set if either found
00D9DF  1               
00D9DF  1               ;--------------------------------
00D9DF  1               ;$00-$01 - used to hold bottom right and bottom left metatiles (in that order)
00D9DF  1               ;$00 - used as flag by ImpedePlayerMove to restrict specific movement
00D9DF  1               
00D9DF  1               ChkForLandJumpSpring:
00D9DF  1  20 F8 D9             jsr ChkJumpspringMetatiles  ;do sub to check if player landed on jumpspring
00D9E2  1  90 13                bcc ExCJSp                  ;if carry not set, jumpspring not found, therefore leave
00D9E4  1  A9 70                lda #$70
00D9E6  1  8D 09 07             sta VerticalForce           ;otherwise set vertical movement force for player
00D9E9  1  A9 F9                lda #$f9
00D9EB  1  8D DB 06             sta JumpspringForce         ;set default jumpspring force
00D9EE  1  A9 03                lda #$03
00D9F0  1  8D 86 07             sta JumpspringTimer         ;set jumpspring timer to be used later
00D9F3  1  4A                   lsr
00D9F4  1  8D 0E 07             sta JumpspringAnimCtrl      ;set jumpspring animation control to start animating
00D9F7  1  60           ExCJSp: rts                         ;and leave
00D9F8  1               
00D9F8  1               ChkJumpspringMetatiles:
00D9F8  1  C9 67                 cmp #$67      ;check for top jumpspring metatile
00D9FA  1  F0 05                 beq JSFnd     ;branch to set carry if found
00D9FC  1  C9 68                 cmp #$68      ;check for bottom jumpspring metatile
00D9FE  1  18                    clc           ;clear carry flag
00D9FF  1  D0 01                 bne NoJSFnd   ;branch to use cleared carry if not found
00DA01  1  38           JSFnd:   sec           ;set carry if found
00DA02  1  60           NoJSFnd: rts           ;leave
00DA03  1               
00DA03  1               ImpedePlayerMove:
00DA03  1  A9 00               lda #$00                  ;initialize value here
00DA05  1  A4 57               ldy Player_X_Speed        ;get player's horizontal speed
00DA07  1  A6 00               ldx $00                   ;check value set earlier for
00DA09  1  CA                  dex                       ;left side collision
00DA0A  1  D0 0A               bne RImpd                 ;if right side collision, skip this part
00DA0C  1  E8                  inx                       ;return value to X
00DA0D  1  C0 00               cpy #$00                  ;if player moving to the left,
00DA0F  1  30 28               bmi ExIPM                 ;branch to invert bit and leave
00DA11  1  A9 FF               lda #$ff                  ;otherwise load A with value to be used later
00DA13  1  4C 1E DA            jmp NXSpd                 ;and jump to affect movement
00DA16  1  A2 02        RImpd: ldx #$02                  ;return $02 to X
00DA18  1  C0 01               cpy #$01                  ;if player moving to the right,
00DA1A  1  10 1D               bpl ExIPM                 ;branch to invert bit and leave
00DA1C  1  A9 01               lda #$01                  ;otherwise load A with value to be used here
00DA1E  1  A0 10        NXSpd: ldy #$10
00DA20  1  8C 85 07            sty SideCollisionTimer    ;set timer of some sort
00DA23  1  A0 00               ldy #$00
00DA25  1  84 57               sty Player_X_Speed        ;nullify player's horizontal speed
00DA27  1  C9 00               cmp #$00                  ;if value set in A not set to $ff,
00DA29  1  10 01               bpl PlatF                 ;branch ahead, do not decrement Y
00DA2B  1  88                  dey                       ;otherwise decrement Y now
00DA2C  1  84 00        PlatF: sty $00                   ;store Y as high bits of horizontal adder
00DA2E  1  18                  clc
00DA2F  1  65 86               adc Player_X_Position     ;add contents of A to player's horizontal
00DA31  1  85 86               sta Player_X_Position     ;position to move player left or right
00DA33  1  A5 6D               lda Player_PageLoc
00DA35  1  65 00               adc $00                   ;add high bits and carry to
00DA37  1  85 6D               sta Player_PageLoc        ;page location if necessary
00DA39  1  8A           ExIPM: txa                       ;invert contents of X
00DA3A  1  49 FF               eor #$ff
00DA3C  1  2D 90 04            and Player_CollisionBits  ;mask out bit that was set here
00DA3F  1  8D 90 04            sta Player_CollisionBits  ;store to clear bit
00DA42  1  60                  rts
00DA43  1               
00DA43  1               ;--------------------------------
00DA43  1               
00DA43  1               SolidMTileUpperExt:
00DA43  1  10 61 88 C4        .byte $10, $61, $88, $c4
00DA47  1               
00DA47  1               CheckForSolidMTiles:
00DA47  1  20 68 DA           jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
00DA4A  1  DD 43 DA           cmp SolidMTileUpperExt,x  ;compare current metatile with solid metatiles
00DA4D  1  60                 rts
00DA4E  1               
00DA4E  1               ClimbMTileUpperExt:
00DA4E  1  24 6D 8A C6        .byte $24, $6d, $8a, $c6
00DA52  1               
00DA52  1               CheckForClimbMTiles:
00DA52  1  20 68 DA           jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
00DA55  1  DD 4E DA           cmp ClimbMTileUpperExt,x  ;compare current metatile with climbable metatiles
00DA58  1  60                 rts
00DA59  1               
00DA59  1               CheckForCoinMTiles:
00DA59  1  C9 C2                 cmp #$c2              ;check for regular coin
00DA5B  1  F0 06                 beq CoinSd            ;branch if found
00DA5D  1  C9 C3                 cmp #$c3              ;check for underwater coin
00DA5F  1  F0 02                 beq CoinSd            ;branch if found
00DA61  1  18                    clc                   ;otherwise clear carry and leave
00DA62  1  60                    rts
00DA63  1  A9 01        CoinSd:  lda #Sfx_CoinGrab
00DA65  1  85 FE                 sta Square2SoundQueue ;load coin grab sound and leave
00DA67  1  60                    rts
00DA68  1               
00DA68  1               GetMTileAttrib:
00DA68  1  A8                  tay            ;save metatile value into Y
00DA69  1  29 C0               and #%11000000 ;mask out all but 2 MSB
00DA6B  1  0A                  asl
00DA6C  1  2A                  rol            ;shift and rotate d7-d6 to d1-d0
00DA6D  1  2A                  rol
00DA6E  1  AA                  tax            ;use as offset for metatile data
00DA6F  1  98                  tya            ;get original metatile value back
00DA70  1  60           ExEBG: rts            ;leave
00DA71  1               
00DA71  1               ;-------------------------------------------------------------------------------------
00DA71  1               ;$06-$07 - address from block buffer routine
00DA71  1               
00DA71  1               EnemyBGCStateData:
00DA71  1  01 01 02 02        .byte $01, $01, $02, $02, $02, $05
00DA75  1  02 05        
00DA77  1               
00DA77  1               EnemyBGCXSpdData:
00DA77  1  10 F0              .byte $10, $f0
00DA79  1               
00DA79  1               EnemyToBGCollisionDet:
00DA79  1  B5 1E              lda Enemy_State,x        ;check enemy state for d6 set
00DA7B  1  29 20              and #%00100000
00DA7D  1  D0 F1              bne ExEBG                ;if set, branch to leave
00DA7F  1  20 13 DC           jsr SubtEnemyYPos        ;otherwise, do a subroutine here
00DA82  1  90 EC              bcc ExEBG                ;if enemy vertical coord + 62 < 68, branch to leave
00DA84  1  B4 16              ldy Enemy_ID,x
00DA86  1  C0 12              cpy #Spiny               ;if enemy object is not spiny, branch elsewhere
00DA88  1  D0 06              bne DoIDCheckBGColl
00DA8A  1  B5 CF              lda Enemy_Y_Position,x
00DA8C  1  C9 25              cmp #$25                 ;if enemy vertical coordinate < 36 branch to leave
00DA8E  1  90 E0              bcc ExEBG
00DA90  1               
00DA90  1               DoIDCheckBGColl:
00DA90  1  C0 0E               cpy #GreenParatroopaJump ;check for some other enemy object
00DA92  1  D0 03               bne HBChk                ;branch if not found
00DA94  1  4C 1B DC            jmp EnemyJump            ;otherwise jump elsewhere
00DA97  1  C0 05        HBChk: cpy #HammerBro           ;check for hammer bro
00DA99  1  D0 03               bne CInvu                ;branch if not found
00DA9B  1  4C 3D DC            jmp HammerBroBGColl      ;otherwise jump elsewhere
00DA9E  1  C0 12        CInvu: cpy #Spiny               ;if enemy object is spiny, branch
00DAA0  1  F0 08               beq YesIn
00DAA2  1  C0 2E               cpy #PowerUpObject       ;if special power-up object, branch
00DAA4  1  F0 04               beq YesIn
00DAA6  1  C0 07               cpy #$07                 ;if enemy object =>$07, branch to leave
00DAA8  1  B0 74               bcs ExEBGChk
00DAAA  1  20 66 DC     YesIn: jsr ChkUnderEnemy        ;if enemy object < $07, or = $12 or $2e, do this sub
00DAAD  1  D0 03               bne HandleEToBGCollision ;if block underneath enemy, branch
00DAAF  1               
00DAAF  1               NoEToBGCollision:
00DAAF  1  4C 9A DB            jmp ChkForRedKoopa       ;otherwise skip and do something else
00DAB2  1               
00DAB2  1               ;--------------------------------
00DAB2  1               ;$02 - vertical coordinate from block buffer routine
00DAB2  1               
00DAB2  1               HandleEToBGCollision:
00DAB2  1  20 6D DC           jsr ChkForNonSolids       ;if something is underneath enemy, find out what
00DAB5  1  F0 F8              beq NoEToBGCollision      ;if blank $26, coins, or hidden blocks, jump, enemy falls through
00DAB7  1  C9 23              cmp #$23
00DAB9  1  D0 64              bne LandEnemyProperly     ;check for blank metatile $23 and branch if not found
00DABB  1  A4 02              ldy $02                   ;get vertical coordinate used to find block
00DABD  1  A9 00              lda #$00                  ;store default blank metatile in that spot so we won't
00DABF  1  91 06              sta ($06),y               ;trigger this routine accidentally again
00DAC1  1  B5 16              lda Enemy_ID,x
00DAC3  1  C9 15              cmp #$15                  ;if enemy object => $15, branch ahead
00DAC5  1  B0 0C              bcs ChkToStunEnemies
00DAC7  1  C9 06              cmp #Goomba               ;if enemy object not goomba, branch ahead of this routine
00DAC9  1  D0 03              bne GiveOEPoints
00DACB  1  20 46 DC           jsr KillEnemyAboveBlock   ;if enemy object IS goomba, do this sub
00DACE  1               
00DACE  1               GiveOEPoints:
00DACE  1  A9 01              lda #$01                  ;award 100 points for hitting block beneath enemy
00DAD0  1  20 3A D5           jsr SetupFloateyNumber
00DAD3  1               
00DAD3  1               ChkToStunEnemies:
00DAD3  1  C9 09                  cmp #$09                   ;perform many comparisons on enemy object identifier
00DAD5  1  90 10                  bcc SetStun
00DAD7  1  C9 11                  cmp #$11                   ;if the enemy object identifier is equal to the values
00DAD9  1  B0 0C                  bcs SetStun                ;$09, $0e, $0f or $10, it will be modified, and not
00DADB  1  C9 0A                  cmp #$0a                   ;modified if not any of those values, note that piranha plant will
00DADD  1  90 04                  bcc Demote                 ;always fail this test because A will still have vertical
00DADF  1  C9 0D                  cmp #PiranhaPlant          ;coordinate from previous addition, also these comparisons
00DAE1  1  90 04                  bcc SetStun                ;are only necessary if branching from $d7a1
00DAE3  1  29 01        Demote:   and #%00000001             ;erase all but LSB, essentially turning enemy object
00DAE5  1  95 16                  sta Enemy_ID,x             ;into green or red koopa troopa to demote them
00DAE7  1  B5 1E        SetStun:  lda Enemy_State,x          ;load enemy state
00DAE9  1  29 F0                  and #%11110000             ;save high nybble
00DAEB  1  09 02                  ora #%00000010
00DAED  1  95 1E                  sta Enemy_State,x          ;set d1 of enemy state
00DAEF  1  D6 CF                  dec Enemy_Y_Position,x
00DAF1  1  D6 CF                  dec Enemy_Y_Position,x     ;subtract two pixels from enemy's vertical position
00DAF3  1  B5 16                  lda Enemy_ID,x
00DAF5  1  C9 07                  cmp #Bloober               ;check for bloober object
00DAF7  1  F0 07                  beq SetWYSpd
00DAF9  1  A9 FD                  lda #$fd                   ;set default vertical speed
00DAFB  1  AC 4E 07               ldy AreaType
00DAFE  1  D0 02                  bne SetNotW                ;if area type not water, set as speed, otherwise
00DB00  1  A9 FF        SetWYSpd: lda #$ff                   ;change the vertical speed
00DB02  1  95 A0        SetNotW:  sta Enemy_Y_Speed,x        ;set vertical speed now
00DB04  1  A0 01                  ldy #$01
00DB06  1  20 FB DB               jsr PlayerEnemyDiff        ;get horizontal difference between player and enemy object
00DB09  1  10 01                  bpl ChkBBill               ;branch if enemy is to the right of player
00DB0B  1  C8                     iny                        ;increment Y if not
00DB0C  1  B5 16        ChkBBill: lda Enemy_ID,x
00DB0E  1  C9 33                  cmp #BulletBill_CannonVar  ;check for bullet bill (cannon variant)
00DB10  1  F0 06                  beq NoCDirF
00DB12  1  C9 08                  cmp #BulletBill_FrenzyVar  ;check for bullet bill (frenzy variant)
00DB14  1  F0 02                  beq NoCDirF                ;branch if either found, direction does not change
00DB16  1  94 46                  sty Enemy_MovingDir,x      ;store as moving direction
00DB18  1  88           NoCDirF:  dey                        ;decrement and use as offset
00DB19  1  B9 77 DA               lda EnemyBGCXSpdData,y     ;get proper horizontal speed
00DB1C  1  95 58                  sta Enemy_X_Speed,x        ;and store, then leave
00DB1E  1  60           ExEBGChk: rts
00DB1F  1               
00DB1F  1               ;--------------------------------
00DB1F  1               ;$04 - low nybble of vertical coordinate from block buffer routine
00DB1F  1               
00DB1F  1               LandEnemyProperly:
00DB1F  1  A5 04               lda $04                 ;check lower nybble of vertical coordinate saved earlier
00DB21  1  38                  sec
00DB22  1  E9 08               sbc #$08                ;subtract eight pixels
00DB24  1  C9 05               cmp #$05                ;used to determine whether enemy landed from falling
00DB26  1  B0 72               bcs ChkForRedKoopa      ;branch if lower nybble in range of $0d-$0f before subtract
00DB28  1  B5 1E               lda Enemy_State,x
00DB2A  1  29 40               and #%01000000          ;branch if d6 in enemy state is set
00DB2C  1  D0 57               bne LandEnemyInitState
00DB2E  1  B5 1E               lda Enemy_State,x
00DB30  1  0A                  asl                     ;branch if d7 in enemy state is not set
00DB31  1  90 03               bcc ChkLandedEnemyState
00DB33  1  4C B6 DB     SChkA: jmp DoEnemySideCheck    ;if lower nybble < $0d, d7 set but d6 not set, jump here
00DB36  1               
00DB36  1               ChkLandedEnemyState:
00DB36  1  B5 1E                   lda Enemy_State,x         ;if enemy in normal state, branch back to jump here
00DB38  1  F0 F9                   beq SChkA
00DB3A  1  C9 05                   cmp #$05                  ;if in state used by spiny's egg
00DB3C  1  F0 1F                   beq ProcEnemyDirection    ;then branch elsewhere
00DB3E  1  C9 03                   cmp #$03                  ;if already in state used by koopas and buzzy beetles
00DB40  1  B0 1A                   bcs ExSteChk              ;or in higher numbered state, branch to leave
00DB42  1  B5 1E                   lda Enemy_State,x         ;load enemy state again (why?)
00DB44  1  C9 02                   cmp #$02                  ;if not in $02 state (used by koopas and buzzy beetles)
00DB46  1  D0 15                   bne ProcEnemyDirection    ;then branch elsewhere
00DB48  1  A9 10                   lda #$10                  ;load default timer here
00DB4A  1  B4 16                   ldy Enemy_ID,x            ;check enemy identifier for spiny
00DB4C  1  C0 12                   cpy #Spiny
00DB4E  1  D0 02                   bne SetForStn             ;branch if not found
00DB50  1  A9 00                   lda #$00                  ;set timer for $00 if spiny
00DB52  1  9D 96 07     SetForStn: sta EnemyIntervalTimer,x  ;set timer here
00DB55  1  A9 03                   lda #$03                  ;set state here, apparently used to render
00DB57  1  95 1E                   sta Enemy_State,x         ;upside-down koopas and buzzy beetles
00DB59  1  20 07 DC                jsr EnemyLanding          ;then land it properly
00DB5C  1  60           ExSteChk:  rts                       ;then leave
00DB5D  1               
00DB5D  1               ProcEnemyDirection:
00DB5D  1  B5 16                 lda Enemy_ID,x            ;check enemy identifier for goomba
00DB5F  1  C9 06                 cmp #Goomba               ;branch if found
00DB61  1  F0 22                 beq LandEnemyInitState
00DB63  1  C9 12                 cmp #Spiny                ;check for spiny
00DB65  1  D0 0E                 bne InvtD                 ;branch if not found
00DB67  1  A9 01                 lda #$01
00DB69  1  95 46                 sta Enemy_MovingDir,x     ;send enemy moving to the right by default
00DB6B  1  A9 08                 lda #$08
00DB6D  1  95 58                 sta Enemy_X_Speed,x       ;set horizontal speed accordingly
00DB6F  1  A5 09                 lda FrameCounter
00DB71  1  29 07                 and #%00000111            ;if timed appropriately, spiny will skip over
00DB73  1  F0 10                 beq LandEnemyInitState    ;trying to face the player
00DB75  1  A0 01        InvtD:   ldy #$01                  ;load 1 for enemy to face the left (inverted here)
00DB77  1  20 FB DB              jsr PlayerEnemyDiff       ;get horizontal difference between player and enemy
00DB7A  1  10 01                 bpl CNwCDir               ;if enemy to the right of player, branch
00DB7C  1  C8                    iny                       ;if to the left, increment by one for enemy to face right (inverted)
00DB7D  1  98           CNwCDir: tya
00DB7E  1  D5 46                 cmp Enemy_MovingDir,x     ;compare direction in A with current direction in memory
00DB80  1  D0 03                 bne LandEnemyInitState
00DB82  1  20 DC DB              jsr ChkForBump_HammerBroJ ;if equal, not facing in correct dir, do sub to turn around
00DB85  1               
00DB85  1               LandEnemyInitState:
00DB85  1  20 07 DC           jsr EnemyLanding       ;land enemy properly
00DB88  1  B5 1E              lda Enemy_State,x
00DB8A  1  29 80              and #%10000000         ;if d7 of enemy state is set, branch
00DB8C  1  D0 05              bne NMovShellFallBit
00DB8E  1  A9 00              lda #$00               ;otherwise initialize enemy state and leave
00DB90  1  95 1E              sta Enemy_State,x      ;note this will also turn spiny's egg into spiny
00DB92  1  60                 rts
00DB93  1               
00DB93  1               NMovShellFallBit:
00DB93  1  B5 1E              lda Enemy_State,x   ;nullify d6 of enemy state, save other bits
00DB95  1  29 BF              and #%10111111      ;and store, then leave
00DB97  1  95 1E              sta Enemy_State,x
00DB99  1  60                 rts
00DB9A  1               
00DB9A  1               ;--------------------------------
00DB9A  1               
00DB9A  1               ChkForRedKoopa:
00DB9A  1  B5 16                     lda Enemy_ID,x            ;check for red koopa troopa $03
00DB9C  1  C9 03                     cmp #RedKoopa
00DB9E  1  D0 04                     bne Chk2MSBSt             ;branch if not found
00DBA0  1  B5 1E                     lda Enemy_State,x
00DBA2  1  F0 38                     beq ChkForBump_HammerBroJ ;if enemy found and in normal state, branch
00DBA4  1  B5 1E        Chk2MSBSt:   lda Enemy_State,x         ;save enemy state into Y
00DBA6  1  A8                        tay
00DBA7  1  0A                        asl                       ;check for d7 set
00DBA8  1  90 07                     bcc GetSteFromD           ;branch if not set
00DBAA  1  B5 1E                     lda Enemy_State,x
00DBAC  1  09 40                     ora #%01000000            ;set d6
00DBAE  1  4C B4 DB                  jmp SetD6Ste              ;jump ahead of this part
00DBB1  1  B9 71 DA     GetSteFromD: lda EnemyBGCStateData,y   ;load new enemy state with old as offset
00DBB4  1  95 1E        SetD6Ste:    sta Enemy_State,x         ;set as new state
00DBB6  1               
00DBB6  1               ;--------------------------------
00DBB6  1               ;$00 - used to store bitmask (not used but initialized here)
00DBB6  1               ;$eb - used in DoEnemySideCheck as counter and to compare moving directions
00DBB6  1               
00DBB6  1               DoEnemySideCheck:
00DBB6  1  B5 CF                  lda Enemy_Y_Position,x     ;if enemy within status bar, branch to leave
00DBB8  1  C9 20                  cmp #$20                   ;because there's nothing there that impedes movement
00DBBA  1  90 1F                  bcc ExESdeC
00DBBC  1  A0 16                  ldy #$16                   ;start by finding block to the left of enemy ($00,$14)
00DBBE  1  A9 02                  lda #$02                   ;set value here in what is also used as
00DBC0  1  85 EB                  sta $eb                    ;OAM data offset
00DBC2  1  A5 EB        SdeCLoop: lda $eb                    ;check value
00DBC4  1  D5 46                  cmp Enemy_MovingDir,x      ;compare value against moving direction
00DBC6  1  D0 0C                  bne NextSdeC               ;branch if different and do not seek block there
00DBC8  1  A9 01                  lda #$01                   ;set flag in A for save horizontal coordinate
00DBCA  1  20 40 DE               jsr BlockBufferChk_Enemy   ;find block to left or right of enemy object
00DBCD  1  F0 05                  beq NextSdeC               ;if nothing found, branch
00DBCF  1  20 6D DC               jsr ChkForNonSolids        ;check for non-solid blocks
00DBD2  1  D0 08                  bne ChkForBump_HammerBroJ  ;branch if not found
00DBD4  1  C6 EB        NextSdeC: dec $eb                    ;move to the next direction
00DBD6  1  C8                     iny
00DBD7  1  C0 18                  cpy #$18                   ;increment Y, loop only if Y < $18, thus we check
00DBD9  1  90 E7                  bcc SdeCLoop               ;enemy ($00, $14) and ($10, $14) pixel coordinates
00DBDB  1  60           ExESdeC:  rts
00DBDC  1               
00DBDC  1               ChkForBump_HammerBroJ:
00DBDC  1  E0 05                cpx #$05               ;check if we're on the special use slot
00DBDE  1  F0 09                beq NoBump             ;and if so, branch ahead and do not play sound
00DBE0  1  B5 1E                lda Enemy_State,x      ;if enemy state d7 not set, branch
00DBE2  1  0A                   asl                    ;ahead and do not play sound
00DBE3  1  90 04                bcc NoBump
00DBE5  1  A9 02                lda #Sfx_Bump          ;otherwise, play bump sound
00DBE7  1  85 FF                sta Square1SoundQueue  ;sound will never be played if branching from ChkForRedKoopa
00DBE9  1  B5 16        NoBump: lda Enemy_ID,x         ;check for hammer bro
00DBEB  1  C9 05                cmp #$05
00DBED  1  D0 09                bne InvEnemyDir        ;branch if not found
00DBEF  1  A9 00                lda #$00
00DBF1  1  85 00                sta $00                ;initialize value here for bitmask
00DBF3  1  A0 FA                ldy #$fa               ;load default vertical speed for jumping
00DBF5  1  4C 6D C6             jmp SetHJ              ;jump to code that makes hammer bro jump
00DBF8  1               
00DBF8  1               InvEnemyDir:
00DBF8  1  4C 51 D6           jmp RXSpd     ;jump to turn the enemy around
00DBFB  1               
00DBFB  1               ;--------------------------------
00DBFB  1               ;$00 - used to hold horizontal difference between player and enemy
00DBFB  1               
00DBFB  1               PlayerEnemyDiff:
00DBFB  1  B5 87              lda Enemy_X_Position,x  ;get distance between enemy object's
00DBFD  1  38                 sec                     ;horizontal coordinate and the player's
00DBFE  1  E5 86              sbc Player_X_Position   ;horizontal coordinate
00DC00  1  85 00              sta $00                 ;and store here
00DC02  1  B5 6E              lda Enemy_PageLoc,x
00DC04  1  E5 6D              sbc Player_PageLoc      ;subtract borrow, then leave
00DC06  1  60                 rts
00DC07  1               
00DC07  1               ;--------------------------------
00DC07  1               
00DC07  1               EnemyLanding:
00DC07  1  20 9C C0           jsr InitVStf            ;do something here to vertical speed and something else
00DC0A  1  B5 CF              lda Enemy_Y_Position,x
00DC0C  1  29 F0              and #%11110000          ;save high nybble of vertical coordinate, and
00DC0E  1  09 08              ora #%00001000          ;set d3, then store, probably used to set enemy object
00DC10  1  95 CF              sta Enemy_Y_Position,x  ;neatly on whatever it's landing on
00DC12  1  60                 rts
00DC13  1               
00DC13  1               SubtEnemyYPos:
00DC13  1  B5 CF              lda Enemy_Y_Position,x  ;add 62 pixels to enemy object's
00DC15  1  18                 clc                     ;vertical coordinate
00DC16  1  69 3E              adc #$3e
00DC18  1  C9 44              cmp #$44                ;compare against a certain range
00DC1A  1  60                 rts                     ;and leave with flags set for conditional branch
00DC1B  1               
00DC1B  1               EnemyJump:
00DC1B  1  20 13 DC             jsr SubtEnemyYPos     ;do a sub here
00DC1E  1  90 1A                bcc DoSide            ;if enemy vertical coord + 62 < 68, branch to leave
00DC20  1  B5 A0                lda Enemy_Y_Speed,x
00DC22  1  18                   clc                   ;add two to vertical speed
00DC23  1  69 02                adc #$02
00DC25  1  C9 03                cmp #$03              ;if green paratroopa not falling, branch ahead
00DC27  1  90 11                bcc DoSide
00DC29  1  20 66 DC             jsr ChkUnderEnemy     ;otherwise, check to see if green paratroopa is
00DC2C  1  F0 0C                beq DoSide            ;standing on anything, then branch to same place if not
00DC2E  1  20 6D DC             jsr ChkForNonSolids   ;check for non-solid blocks
00DC31  1  F0 07                beq DoSide            ;branch if found
00DC33  1  20 07 DC             jsr EnemyLanding      ;change vertical coordinate and speed
00DC36  1  A9 FD                lda #$fd
00DC38  1  95 A0                sta Enemy_Y_Speed,x   ;make the paratroopa jump again
00DC3A  1  4C B6 DB     DoSide: jmp DoEnemySideCheck  ;check for horizontal blockage, then leave
00DC3D  1               
00DC3D  1               ;--------------------------------
00DC3D  1               
00DC3D  1               HammerBroBGColl:
00DC3D  1  20 66 DC           jsr ChkUnderEnemy    ;check to see if hammer bro is standing on anything
00DC40  1  F0 1D              beq NoUnderHammerBro
00DC42  1  C9 23              cmp #$23             ;check for blank metatile $23 and branch if not found
00DC44  1  D0 08              bne UnderHammerBro
00DC46  1               
00DC46  1               KillEnemyAboveBlock:
00DC46  1  20 B0 D2           jsr ShellOrBlockDefeat  ;do this sub to kill enemy
00DC49  1  A9 FC              lda #$fc                ;alter vertical speed of enemy and leave
00DC4B  1  95 A0              sta Enemy_Y_Speed,x
00DC4D  1  60                 rts
00DC4E  1               
00DC4E  1               UnderHammerBro:
00DC4E  1  BD 8A 07           lda EnemyFrameTimer,x ;check timer used by hammer bro
00DC51  1  D0 0C              bne NoUnderHammerBro  ;branch if not expired
00DC53  1  B5 1E              lda Enemy_State,x
00DC55  1  29 88              and #%10001000        ;save d7 and d3 from enemy state, nullify other bits
00DC57  1  95 1E              sta Enemy_State,x     ;and store
00DC59  1  20 07 DC           jsr EnemyLanding      ;modify vertical coordinate, speed and something else
00DC5C  1  4C B6 DB           jmp DoEnemySideCheck  ;then check for horizontal blockage and leave
00DC5F  1               
00DC5F  1               NoUnderHammerBro:
00DC5F  1  B5 1E              lda Enemy_State,x  ;if hammer bro is not standing on anything, set d0
00DC61  1  09 01              ora #$01           ;in the enemy state to indicate jumping or falling, then leave
00DC63  1  95 1E              sta Enemy_State,x
00DC65  1  60                 rts
00DC66  1               
00DC66  1               ChkUnderEnemy:
00DC66  1  A9 00              lda #$00                  ;set flag in A for save vertical coordinate
00DC68  1  A0 15              ldy #$15                  ;set Y to check the bottom middle (8,18) of enemy object
00DC6A  1  4C 40 DE           jmp BlockBufferChk_Enemy  ;hop to it!
00DC6D  1               
00DC6D  1               ChkForNonSolids:
00DC6D  1  C9 26               cmp #$26       ;blank metatile used for vines?
00DC6F  1  F0 0E               beq NSFnd
00DC71  1  C9 C2               cmp #$c2       ;regular coin?
00DC73  1  F0 0A               beq NSFnd
00DC75  1  C9 C3               cmp #$c3       ;underwater coin?
00DC77  1  F0 06               beq NSFnd
00DC79  1  C9 5F               cmp #$5f       ;hidden coin block?
00DC7B  1  F0 02               beq NSFnd
00DC7D  1  C9 60               cmp #$60       ;hidden 1-up block?
00DC7F  1  60           NSFnd: rts
00DC80  1               
00DC80  1               ;-------------------------------------------------------------------------------------
00DC80  1               
00DC80  1               FireballBGCollision:
00DC80  1  B5 D5              lda Fireball_Y_Position,x   ;check fireball's vertical coordinate
00DC82  1  C9 18              cmp #$18
00DC84  1  90 21              bcc ClearBounceFlag         ;if within the status bar area of the screen, branch ahead
00DC86  1  20 54 DE           jsr BlockBufferChk_FBall    ;do fireball to background collision detection on bottom of it
00DC89  1  F0 1C              beq ClearBounceFlag         ;if nothing underneath fireball, branch
00DC8B  1  20 6D DC           jsr ChkForNonSolids         ;check for non-solid metatiles
00DC8E  1  F0 17              beq ClearBounceFlag         ;branch if any found
00DC90  1  B5 A6              lda Fireball_Y_Speed,x      ;if fireball's vertical speed set to move upwards,
00DC92  1  30 18              bmi InitFireballExplode     ;branch to set exploding bit in fireball's state
00DC94  1  B5 3A              lda FireballBouncingFlag,x  ;if bouncing flag already set,
00DC96  1  D0 14              bne InitFireballExplode     ;branch to set exploding bit in fireball's state
00DC98  1  A9 FD              lda #$fd
00DC9A  1  95 A6              sta Fireball_Y_Speed,x      ;otherwise set vertical speed to move upwards (give it bounce)
00DC9C  1  A9 01              lda #$01
00DC9E  1  95 3A              sta FireballBouncingFlag,x  ;set bouncing flag
00DCA0  1  B5 D5              lda Fireball_Y_Position,x
00DCA2  1  29 F8              and #$f8                    ;modify vertical coordinate to land it properly
00DCA4  1  95 D5              sta Fireball_Y_Position,x   ;store as new vertical coordinate
00DCA6  1  60                 rts                         ;leave
00DCA7  1               
00DCA7  1               ClearBounceFlag:
00DCA7  1  A9 00              lda #$00
00DCA9  1  95 3A              sta FireballBouncingFlag,x  ;clear bouncing flag by default
00DCAB  1  60                 rts                         ;leave
00DCAC  1               
00DCAC  1               InitFireballExplode:
00DCAC  1  A9 80              lda #$80
00DCAE  1  95 24              sta Fireball_State,x        ;set exploding flag in fireball's state
00DCB0  1  A9 02              lda #Sfx_Bump
00DCB2  1  85 FF              sta Square1SoundQueue       ;load bump sound
00DCB4  1  60                 rts                         ;leave
00DCB5  1               
00DCB5  1               ;-------------------------------------------------------------------------------------
00DCB5  1               ;$00 - used to hold one of bitmasks, or offset
00DCB5  1               ;$01 - used for relative X coordinate, also used to store middle screen page location
00DCB5  1               ;$02 - used for relative Y coordinate, also used to store middle screen coordinate
00DCB5  1               
00DCB5  1               ;this data added to relative coordinates of sprite objects
00DCB5  1               ;stored in order: left edge, top edge, right edge, bottom edge
00DCB5  1               BoundBoxCtrlData:
00DCB5  1  02 08 0E 20        .byte $02, $08, $0e, $20
00DCB9  1  03 14 0D 20        .byte $03, $14, $0d, $20
00DCBD  1  02 14 0E 20        .byte $02, $14, $0e, $20
00DCC1  1  02 09 0E 15        .byte $02, $09, $0e, $15
00DCC5  1  00 00 18 06        .byte $00, $00, $18, $06
00DCC9  1  00 00 20 0D        .byte $00, $00, $20, $0d
00DCCD  1  00 00 30 0D        .byte $00, $00, $30, $0d
00DCD1  1  00 00 08 08        .byte $00, $00, $08, $08
00DCD5  1  06 04 0A 08        .byte $06, $04, $0a, $08
00DCD9  1  03 0E 0D 14        .byte $03, $0e, $0d, $14
00DCDD  1  00 02 10 15        .byte $00, $02, $10, $15
00DCE1  1  04 04 0C 1C        .byte $04, $04, $0c, $1c
00DCE5  1               
00DCE5  1               GetFireballBoundBox:
00DCE5  1  8A                 txa         ;add seven bytes to offset
00DCE6  1  18                 clc         ;to use in routines as offset for fireball
00DCE7  1  69 07              adc #$07
00DCE9  1  AA                 tax
00DCEA  1  A0 02              ldy #$02    ;set offset for relative coordinates
00DCEC  1  D0 07              bne FBallB  ;unconditional branch
00DCEE  1               
00DCEE  1               GetMiscBoundBox:
00DCEE  1  8A                   txa                       ;add nine bytes to offset
00DCEF  1  18                   clc                       ;to use in routines as offset for misc object
00DCF0  1  69 09                adc #$09
00DCF2  1  AA                   tax
00DCF3  1  A0 06                ldy #$06                  ;set offset for relative coordinates
00DCF5  1  20 54 DD     FBallB: jsr BoundingBoxCore       ;get bounding box coordinates
00DCF8  1  4C 96 DD             jmp CheckRightScreenBBox  ;jump to handle any offscreen coordinates
00DCFB  1               
00DCFB  1               GetEnemyBoundBox:
00DCFB  1  A0 48              ldy #$48                 ;store bitmask here for now
00DCFD  1  84 00              sty $00
00DCFF  1  A0 44              ldy #$44                 ;store another bitmask here for now and jump
00DD01  1  4C 0A DD           jmp GetMaskedOffScrBits
00DD04  1               
00DD04  1               SmallPlatformBoundBox:
00DD04  1  A0 08              ldy #$08                 ;store bitmask here for now
00DD06  1  84 00              sty $00
00DD08  1  A0 04              ldy #$04                 ;store another bitmask here for now
00DD0A  1               
00DD0A  1               GetMaskedOffScrBits:
00DD0A  1  B5 87                lda Enemy_X_Position,x      ;get enemy object position relative
00DD0C  1  38                   sec                         ;to the left side of the screen
00DD0D  1  ED 1C 07             sbc ScreenLeft_X_Pos
00DD10  1  85 01                sta $01                     ;store here
00DD12  1  B5 6E                lda Enemy_PageLoc,x         ;subtract borrow from current page location
00DD14  1  ED 1A 07             sbc ScreenLeft_PageLoc      ;of left side
00DD17  1  30 06                bmi CMBits                  ;if enemy object is beyond left edge, branch
00DD19  1  05 01                ora $01
00DD1B  1  F0 02                beq CMBits                  ;if precisely at the left edge, branch
00DD1D  1  A4 00                ldy $00                     ;if to the right of left edge, use value in $00 for A
00DD1F  1  98           CMBits: tya                         ;otherwise use contents of Y
00DD20  1  2D D1 03             and Enemy_OffscreenBits     ;preserve bitwise whatever's in here
00DD23  1  9D D8 03             sta EnemyOffscrBitsMasked,x ;save masked offscreen bits here
00DD26  1  D0 19                bne MoveBoundBoxOffscreen   ;if anything set here, branch
00DD28  1  4C 34 DD             jmp SetupEOffsetFBBox       ;otherwise, do something else
00DD2B  1               
00DD2B  1               LargePlatformBoundBox:
00DD2B  1  E8                 inx                        ;increment X to get the proper offset
00DD2C  1  20 8E EC           jsr GetXOffscreenBits      ;then jump directly to the sub for horizontal offscreen bits
00DD2F  1  CA                 dex                        ;decrement to return to original offset
00DD30  1  C9 FE              cmp #$fe                   ;if completely offscreen, branch to put entire bounding
00DD32  1  B0 0D              bcs MoveBoundBoxOffscreen  ;box offscreen, otherwise start getting coordinates
00DD34  1               
00DD34  1               SetupEOffsetFBBox:
00DD34  1  8A                 txa                        ;add 1 to offset to properly address
00DD35  1  18                 clc                        ;the enemy object memory locations
00DD36  1  69 01              adc #$01
00DD38  1  AA                 tax
00DD39  1  A0 01              ldy #$01                   ;load 1 as offset here, same reason
00DD3B  1  20 54 DD           jsr BoundingBoxCore        ;do a sub to get the coordinates of the bounding box
00DD3E  1  4C 96 DD           jmp CheckRightScreenBBox   ;jump to handle offscreen coordinates of bounding box
00DD41  1               
00DD41  1               MoveBoundBoxOffscreen:
00DD41  1  8A                 txa                            ;multiply offset by 4
00DD42  1  0A                 asl
00DD43  1  0A                 asl
00DD44  1  A8                 tay                            ;use as offset here
00DD45  1  A9 FF              lda #$ff
00DD47  1  99 B0 04           sta EnemyBoundingBoxCoord,y    ;load value into four locations here and leave
00DD4A  1  99 B1 04           sta EnemyBoundingBoxCoord+1,y
00DD4D  1  99 B2 04           sta EnemyBoundingBoxCoord+2,y
00DD50  1  99 B3 04           sta EnemyBoundingBoxCoord+3,y
00DD53  1  60                 rts
00DD54  1               
00DD54  1               BoundingBoxCore:
00DD54  1  86 00              stx $00                     ;save offset here
00DD56  1  B9 B8 03           lda SprObject_Rel_YPos,y    ;store object coordinates relative to screen
00DD59  1  85 02              sta $02                     ;vertically and horizontally, respectively
00DD5B  1  B9 AD 03           lda SprObject_Rel_XPos,y
00DD5E  1  85 01              sta $01
00DD60  1  8A                 txa                         ;multiply offset by four and save to stack
00DD61  1  0A                 asl
00DD62  1  0A                 asl
00DD63  1  48                 pha
00DD64  1  A8                 tay                         ;use as offset for Y, X is left alone
00DD65  1  BD 99 04           lda SprObj_BoundBoxCtrl,x   ;load value here to be used as offset for X
00DD68  1  0A                 asl                         ;multiply that by four and use as X
00DD69  1  0A                 asl
00DD6A  1  AA                 tax
00DD6B  1  A5 01              lda $01                     ;add the first number in the bounding box data to the
00DD6D  1  18                 clc                         ;relative horizontal coordinate using enemy object offset
00DD6E  1  7D B5 DC           adc BoundBoxCtrlData,x      ;and store somewhere using same offset * 4
00DD71  1  99 AC 04           sta BoundingBox_UL_Corner,y ;store here
00DD74  1  A5 01              lda $01
00DD76  1  18                 clc
00DD77  1  7D B7 DC           adc BoundBoxCtrlData+2,x    ;add the third number in the bounding box data to the
00DD7A  1  99 AE 04           sta BoundingBox_LR_Corner,y ;relative horizontal coordinate and store
00DD7D  1  E8                 inx                         ;increment both offsets
00DD7E  1  C8                 iny
00DD7F  1  A5 02              lda $02                     ;add the second number to the relative vertical coordinate
00DD81  1  18                 clc                         ;using incremented offset and store using the other
00DD82  1  7D B5 DC           adc BoundBoxCtrlData,x      ;incremented offset
00DD85  1  99 AC 04           sta BoundingBox_UL_Corner,y
00DD88  1  A5 02              lda $02
00DD8A  1  18                 clc
00DD8B  1  7D B7 DC           adc BoundBoxCtrlData+2,x    ;add the fourth number to the relative vertical coordinate
00DD8E  1  99 AE 04           sta BoundingBox_LR_Corner,y ;and store
00DD91  1  68                 pla                         ;get original offset loaded into $00 * y from stack
00DD92  1  A8                 tay                         ;use as Y
00DD93  1  A6 00              ldx $00                     ;get original offset and use as X again
00DD95  1  60                 rts
00DD96  1               
00DD96  1               CheckRightScreenBBox:
00DD96  1  AD 1C 07            lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
00DD99  1  18                  clc                        ;and store as horizontal coordinate of middle
00DD9A  1  69 80               adc #$80
00DD9C  1  85 02               sta $02
00DD9E  1  AD 1A 07            lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
00DDA1  1  69 00               adc #$00                   ;and store as page location of middle
00DDA3  1  85 01               sta $01
00DDA5  1  B5 86               lda SprObject_X_Position,x ;get horizontal coordinate
00DDA7  1  C5 02               cmp $02                    ;compare against middle horizontal coordinate
00DDA9  1  B5 6D               lda SprObject_PageLoc,x    ;get page location
00DDAB  1  E5 01               sbc $01                    ;subtract from middle page location
00DDAD  1  90 15               bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
00DDAF  1  B9 AE 04            lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
00DDB2  1  30 0D               bmi NoOfs                  ;coordinates, branch if still on the screen
00DDB4  1  A9 FF               lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
00DDB6  1  BE AC 04            ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
00DDB9  1  30 03               bmi SORte                  ;coordinates, and branch if still on the screen
00DDBB  1  99 AC 04            sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
00DDBE  1  99 AE 04     SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
00DDC1  1  A6 08        NoOfs: ldx ObjectOffset           ;get object offset and leave
00DDC3  1  60                  rts
00DDC4  1               
00DDC4  1               CheckLeftScreenBBox:
00DDC4  1  B9 AC 04             lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
00DDC7  1  10 11                bpl NoOfs2                 ;coordinates, and branch if still on the screen
00DDC9  1  C9 A0                cmp #$a0                   ;check to see if left-side edge is in the middle of the
00DDCB  1  90 0D                bcc NoOfs2                 ;screen or really offscreen, and branch if still on
00DDCD  1  A9 00                lda #$00
00DDCF  1  BE AE 04             ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
00DDD2  1  10 03                bpl SOLft                  ;coordinates, branch if still onscreen
00DDD4  1  99 AE 04             sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
00DDD7  1  99 AC 04     SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
00DDDA  1  A6 08        NoOfs2: ldx ObjectOffset           ;get object offset and leave
00DDDC  1  60                   rts
00DDDD  1               
00DDDD  1               ;-------------------------------------------------------------------------------------
00DDDD  1               ;$06 - second object's offset
00DDDD  1               ;$07 - counter
00DDDD  1               
00DDDD  1               PlayerCollisionCore:
00DDDD  1  A2 00              ldx #$00     ;initialize X to use player's bounding box for comparison
00DDDF  1               
00DDDF  1               SprObjectCollisionCore:
00DDDF  1  84 06              sty $06      ;save contents of Y here
00DDE1  1  A9 01              lda #$01
00DDE3  1  85 07              sta $07      ;save value 1 here as counter, compare horizontal coordinates first
00DDE5  1               
00DDE5  1               CollisionCoreLoop:
00DDE5  1  B9 AC 04           lda BoundingBox_UL_Corner,y  ;compare left/top coordinates
00DDE8  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;of first and second objects' bounding boxes
00DDEB  1  B0 2A              bcs FirstBoxGreater          ;if first left/top => second, branch
00DDED  1  DD AE 04           cmp BoundingBox_LR_Corner,x  ;otherwise compare to right/bottom of second
00DDF0  1  90 12              bcc SecondBoxVerticalChk     ;if first left/top < second right/bottom, branch elsewhere
00DDF2  1  F0 42              beq CollisionFound           ;if somehow equal, collision, thus branch
00DDF4  1  B9 AE 04           lda BoundingBox_LR_Corner,y  ;if somehow greater, check to see if bottom of
00DDF7  1  D9 AC 04           cmp BoundingBox_UL_Corner,y  ;first object's bounding box is greater than its top
00DDFA  1  90 3A              bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
00DDFC  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;otherwise compare bottom of first bounding box to the top
00DDFF  1  B0 35              bcs CollisionFound           ;of second box, and if equal or greater, collision, thus branch
00DE01  1  A4 06              ldy $06                      ;otherwise return with carry clear and Y = $0006
00DE03  1  60                 rts                          ;note horizontal wrapping never occurs
00DE04  1               
00DE04  1               SecondBoxVerticalChk:
00DE04  1  BD AE 04           lda BoundingBox_LR_Corner,x  ;check to see if the vertical bottom of the box
00DE07  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;is greater than the vertical top
00DE0A  1  90 2A              bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
00DE0C  1  B9 AE 04           lda BoundingBox_LR_Corner,y  ;otherwise compare horizontal right or vertical bottom
00DE0F  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;of first box with horizontal left or vertical top of second box
00DE12  1  B0 22              bcs CollisionFound           ;if equal or greater, collision, thus branch
00DE14  1  A4 06              ldy $06                      ;otherwise return with carry clear and Y = $0006
00DE16  1  60                 rts
00DE17  1               
00DE17  1               FirstBoxGreater:
00DE17  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;compare first and second box horizontal left/vertical top again
00DE1A  1  F0 1A              beq CollisionFound           ;if first coordinate = second, collision, thus branch
00DE1C  1  DD AE 04           cmp BoundingBox_LR_Corner,x  ;if not, compare with second object right or bottom edge
00DE1F  1  90 15              bcc CollisionFound           ;if left/top of first less than or equal to right/bottom of second
00DE21  1  F0 13              beq CollisionFound           ;then collision, thus branch
00DE23  1  D9 AE 04           cmp BoundingBox_LR_Corner,y  ;otherwise check to see if top of first box is greater than bottom
00DE26  1  90 0A              bcc NoCollisionFound         ;if less than or equal, no collision, branch to end
00DE28  1  F0 08              beq NoCollisionFound
00DE2A  1  B9 AE 04           lda BoundingBox_LR_Corner,y  ;otherwise compare bottom of first to top of second
00DE2D  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;if bottom of first is greater than top of second, vertical wrap
00DE30  1  B0 04              bcs CollisionFound           ;collision, and branch, otherwise, proceed onwards here
00DE32  1               
00DE32  1               NoCollisionFound:
00DE32  1  18                 clc          ;clear carry, then load value set earlier, then leave
00DE33  1  A4 06              ldy $06      ;like previous ones, if horizontal coordinates do not collide, we do
00DE35  1  60                 rts          ;not bother checking vertical ones, because what's the point?
00DE36  1               
00DE36  1               CollisionFound:
00DE36  1  E8                 inx                    ;increment offsets on both objects to check
00DE37  1  C8                 iny                    ;the vertical coordinates
00DE38  1  C6 07              dec $07                ;decrement counter to reflect this
00DE3A  1  10 A9              bpl CollisionCoreLoop  ;if counter not expired, branch to loop
00DE3C  1  38                 sec                    ;otherwise we already did both sets, therefore collision, so set carry
00DE3D  1  A4 06              ldy $06                ;load original value set here earlier, then leave
00DE3F  1  60                 rts
00DE40  1               
00DE40  1               ;-------------------------------------------------------------------------------------
00DE40  1               ;$02 - modified y coordinate
00DE40  1               ;$03 - stores metatile involved in block buffer collisions
00DE40  1               ;$04 - comes in with offset to block buffer adder data, goes out with low nybble x/y coordinate
00DE40  1               ;$05 - modified x coordinate
00DE40  1               ;$06-$07 - block buffer address
00DE40  1               
00DE40  1               BlockBufferChk_Enemy:
00DE40  1  48                 pha        ;save contents of A to stack
00DE41  1  8A                 txa
00DE42  1  18                 clc        ;add 1 to X to run sub with enemy offset in mind
00DE43  1  69 01              adc #$01
00DE45  1  AA                 tax
00DE46  1  68                 pla        ;pull A from stack and jump elsewhere
00DE47  1  4C 5D DE           jmp BBChk_E
00DE4A  1               
00DE4A  1               ResidualMiscObjectCode:
00DE4A  1  8A                 txa
00DE4B  1  18                 clc           ;supposedly used once to set offset for
00DE4C  1  69 0D              adc #$0d      ;miscellaneous objects
00DE4E  1  AA                 tax
00DE4F  1  A0 1B              ldy #$1b      ;supposedly used once to set offset for block buffer data
00DE51  1  4C 5B DE           jmp ResJmpM   ;probably used in early stages to do misc to bg collision detection
00DE54  1               
00DE54  1               BlockBufferChk_FBall:
00DE54  1  A0 1A                 ldy #$1a                  ;set offset for block buffer adder data
00DE56  1  8A                    txa
00DE57  1  18                    clc
00DE58  1  69 07                 adc #$07                  ;add seven bytes to use
00DE5A  1  AA                    tax
00DE5B  1  A9 00        ResJmpM: lda #$00                  ;set A to return vertical coordinate
00DE5D  1  20 A8 DE     BBChk_E: jsr BlockBufferCollision  ;do collision detection subroutine for sprite object
00DE60  1  A6 08                 ldx ObjectOffset          ;get object offset
00DE62  1  C9 00                 cmp #$00                  ;check to see if object bumped into anything
00DE64  1  60                    rts
00DE65  1               
00DE65  1               BlockBufferAdderData:
00DE65  1  00 07 0E           .byte $00, $07, $0e
00DE68  1               
00DE68  1               BlockBuffer_X_Adder:
00DE68  1  08 03 0C 02        .byte $08, $03, $0c, $02, $02, $0d, $0d, $08
00DE6C  1  02 0D 0D 08  
00DE70  1  03 0C 02 02        .byte $03, $0c, $02, $02, $0d, $0d, $08, $03
00DE74  1  0D 0D 08 03  
00DE78  1  0C 02 02 0D        .byte $0c, $02, $02, $0d, $0d, $08, $00, $10
00DE7C  1  0D 08 00 10  
00DE80  1  04 14 04 04        .byte $04, $14, $04, $04
00DE84  1               
00DE84  1               BlockBuffer_Y_Adder:
00DE84  1  04 20 20 08        .byte $04, $20, $20, $08, $18, $08, $18, $02
00DE88  1  18 08 18 02  
00DE8C  1  20 20 08 18        .byte $20, $20, $08, $18, $08, $18, $12, $20
00DE90  1  08 18 12 20  
00DE94  1  20 18 18 18        .byte $20, $18, $18, $18, $18, $18, $14, $14
00DE98  1  18 18 14 14  
00DE9C  1  06 06 08 10        .byte $06, $06, $08, $10
00DEA0  1               
00DEA0  1               BlockBufferColli_Feet:
00DEA0  1  C8                  iny            ;if branched here, increment to next set of adders
00DEA1  1               
00DEA1  1               BlockBufferColli_Head:
00DEA1  1  A9 00               lda #$00       ;set flag to return vertical coordinate
00DEA3  1  2C                  .byte $2c        ;BIT instruction opcode
00DEA4  1               
00DEA4  1               BlockBufferColli_Side:
00DEA4  1  A9 01               lda #$01       ;set flag to return horizontal coordinate
00DEA6  1  A2 00               ldx #$00       ;set offset for player object
00DEA8  1               
00DEA8  1               BlockBufferCollision:
00DEA8  1  48                  pha                         ;save contents of A to stack
00DEA9  1  84 04               sty $04                     ;save contents of Y here
00DEAB  1  B9 68 DE            lda BlockBuffer_X_Adder,y   ;add horizontal coordinate
00DEAE  1  18                  clc                         ;of object to value obtained using Y as offset
00DEAF  1  75 86               adc SprObject_X_Position,x
00DEB1  1  85 05               sta $05                     ;store here
00DEB3  1  B5 6D               lda SprObject_PageLoc,x
00DEB5  1  69 00               adc #$00                    ;add carry to page location
00DEB7  1  29 01               and #$01                    ;get LSB, mask out all other bits
00DEB9  1  4A                  lsr                         ;move to carry
00DEBA  1  05 05               ora $05                     ;get stored value
00DEBC  1  6A                  ror                         ;rotate carry to MSB of A
00DEBD  1  4A                  lsr                         ;and effectively move high nybble to
00DEBE  1  4A                  lsr                         ;lower, LSB which became MSB will be
00DEBF  1  4A                  lsr                         ;d4 at this point
00DEC0  1  20 66 ED            jsr GetBlockBufferAddr      ;get address of block buffer into $06, $07
00DEC3  1  A4 04               ldy $04                     ;get old contents of Y
00DEC5  1  B5 CE               lda SprObject_Y_Position,x  ;get vertical coordinate of object
00DEC7  1  18                  clc
00DEC8  1  79 84 DE            adc BlockBuffer_Y_Adder,y   ;add it to value obtained using Y as offset
00DECB  1  29 F0               and #%11110000              ;mask out low nybble
00DECD  1  38                  sec
00DECE  1  E9 20               sbc #$20                    ;subtract 32 pixels for the status bar
00DED0  1  85 02               sta $02                     ;store result here
00DED2  1  A8                  tay                         ;use as offset for block buffer
00DED3  1  B1 06               lda ($06),y                 ;check current content of block buffer
00DED5  1  85 03               sta $03                     ;and store here
00DED7  1  A4 04               ldy $04                     ;get old contents of Y again
00DED9  1  68                  pla                         ;pull A from stack
00DEDA  1  D0 05               bne RetXC                   ;if A = 1, branch
00DEDC  1  B5 CE               lda SprObject_Y_Position,x  ;if A = 0, load vertical coordinate
00DEDE  1  4C E3 DE            jmp RetYC                   ;and jump
00DEE1  1  B5 86        RetXC: lda SprObject_X_Position,x  ;otherwise load horizontal coordinate
00DEE3  1  29 0F        RetYC: and #%00001111              ;and mask out high nybble
00DEE5  1  85 04               sta $04                     ;store masked out result here
00DEE7  1  A5 03               lda $03                     ;get saved content of block buffer
00DEE9  1  60                  rts                         ;and leave
00DEEA  1               
00DEEA  1               ;-------------------------------------------------------------------------------------
00DEEA  1               
00DEEA  1               ;unused byte
00DEEA  1  FF                 .byte $ff
00DEEB  1               
00DEEB  1               ;-------------------------------------------------------------------------------------
00DEEB  1               ;$00 - offset to vine Y coordinate adder
00DEEB  1               ;$02 - offset to sprite data
00DEEB  1               
00DEEB  1               VineYPosAdder:
00DEEB  1  00 30              .byte $00, $30
00DEED  1               
00DEED  1               DrawVine:
00DEED  1  84 00                 sty $00                    ;save offset here
00DEEF  1  AD B9 03              lda Enemy_Rel_YPos         ;get relative vertical coordinate
00DEF2  1  18                    clc
00DEF3  1  79 EB DE              adc VineYPosAdder,y        ;add value using offset in Y to get value
00DEF6  1  BE 9A 03              ldx VineObjOffset,y        ;get offset to vine
00DEF9  1  BC E5 06              ldy Enemy_SprDataOffset,x  ;get sprite data offset
00DEFC  1  84 02                 sty $02                    ;store sprite data offset here
00DEFE  1  20 66 DF              jsr SixSpriteStacker       ;stack six sprites on top of each other vertically
00DF01  1  AD AE 03              lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00DF04  1  99 03 02              sta Sprite_X_Position,y    ;store in first, third and fifth sprites
00DF07  1  99 0B 02              sta Sprite_X_Position+8,y
00DF0A  1  99 13 02              sta Sprite_X_Position+16,y
00DF0D  1  18                    clc
00DF0E  1  69 06                 adc #$06                   ;add six pixels to second, fourth and sixth sprites
00DF10  1  99 07 02              sta Sprite_X_Position+4,y  ;to give characteristic staggered vine shape to
00DF13  1  99 0F 02              sta Sprite_X_Position+12,y ;our vertical stack of sprites
00DF16  1  99 17 02              sta Sprite_X_Position+20,y
00DF19  1  A9 21                 lda #%00100001             ;set bg priority and palette attribute bits
00DF1B  1  99 02 02              sta Sprite_Attributes,y    ;set in first, third and fifth sprites
00DF1E  1  99 0A 02              sta Sprite_Attributes+8,y
00DF21  1  99 12 02              sta Sprite_Attributes+16,y
00DF24  1  09 40                 ora #%01000000             ;additionally, set horizontal flip bit
00DF26  1  99 06 02              sta Sprite_Attributes+4,y  ;for second, fourth and sixth sprites
00DF29  1  99 0E 02              sta Sprite_Attributes+12,y
00DF2C  1  99 16 02              sta Sprite_Attributes+20,y
00DF2F  1  A2 05                 ldx #$05                   ;set tiles for six sprites
00DF31  1  A9 E1        VineTL:  lda #$e1                   ;set tile number for sprite
00DF33  1  99 01 02              sta Sprite_Tilenumber,y
00DF36  1  C8                    iny                        ;move offset to next sprite data
00DF37  1  C8                    iny
00DF38  1  C8                    iny
00DF39  1  C8                    iny
00DF3A  1  CA                    dex                        ;move onto next sprite
00DF3B  1  10 F4                 bpl VineTL                 ;loop until all sprites are done
00DF3D  1  A4 02                 ldy $02                    ;get original offset
00DF3F  1  A5 00                 lda $00                    ;get offset to vine adding data
00DF41  1  D0 05                 bne SkpVTop                ;if offset not zero, skip this part
00DF43  1  A9 E0                 lda #$e0
00DF45  1  99 01 02              sta Sprite_Tilenumber,y    ;set other tile number for top of vine
00DF48  1  A2 00        SkpVTop: ldx #$00                   ;start with the first sprite again
00DF4A  1  AD 9D 03     ChkFTop: lda VineStart_Y_Position   ;get original starting vertical coordinate
00DF4D  1  38                    sec
00DF4E  1  F9 00 02              sbc Sprite_Y_Position,y    ;subtract top-most sprite's Y coordinate
00DF51  1  C9 64                 cmp #$64                   ;if two coordinates are less than 100/$64 pixels
00DF53  1  90 05                 bcc NextVSp                ;apart, skip this to leave sprite alone
00DF55  1  A9 F8                 lda #$f8
00DF57  1  99 00 02              sta Sprite_Y_Position,y    ;otherwise move sprite offscreen
00DF5A  1  C8           NextVSp: iny                        ;move offset to next OAM data
00DF5B  1  C8                    iny
00DF5C  1  C8                    iny
00DF5D  1  C8                    iny
00DF5E  1  E8                    inx                        ;move onto next sprite
00DF5F  1  E0 06                 cpx #$06                   ;do this until all sprites are checked
00DF61  1  D0 E7                 bne ChkFTop
00DF63  1  A4 00                 ldy $00                    ;return offset set earlier
00DF65  1  60                    rts
00DF66  1               
00DF66  1               SixSpriteStacker:
00DF66  1  A2 06               ldx #$06           ;do six sprites
00DF68  1  99 00 02     StkLp: sta Sprite_Data,y  ;store X or Y coordinate into OAM data
00DF6B  1  18                  clc
00DF6C  1  69 08               adc #$08           ;add eight pixels
00DF6E  1  C8                  iny
00DF6F  1  C8                  iny                ;move offset four bytes forward
00DF70  1  C8                  iny
00DF71  1  C8                  iny
00DF72  1  CA                  dex                ;do another sprite
00DF73  1  D0 F3               bne StkLp          ;do this until all sprites are done
00DF75  1  A4 02               ldy $02            ;get saved OAM data offset and leave
00DF77  1  60                  rts
00DF78  1               
00DF78  1               ;-------------------------------------------------------------------------------------
00DF78  1               
00DF78  1               FirstSprXPos:
00DF78  1  04 00 04 00        .byte $04, $00, $04, $00
00DF7C  1               
00DF7C  1               FirstSprYPos:
00DF7C  1  00 04 00 04        .byte $00, $04, $00, $04
00DF80  1               
00DF80  1               SecondSprXPos:
00DF80  1  00 08 00 08        .byte $00, $08, $00, $08
00DF84  1               
00DF84  1               SecondSprYPos:
00DF84  1  08 00 08 00        .byte $08, $00, $08, $00
00DF88  1               
00DF88  1               FirstSprTilenum:
00DF88  1  80 82 81 83        .byte $80, $82, $81, $83
00DF8C  1               
00DF8C  1               SecondSprTilenum:
00DF8C  1  81 83 80 82        .byte $81, $83, $80, $82
00DF90  1               
00DF90  1               HammerSprAttrib:
00DF90  1  03 03 C3 C3        .byte $03, $03, $c3, $c3
00DF94  1               
00DF94  1               DrawHammer:
00DF94  1  BC F3 06                 ldy Misc_SprDataOffset,x    ;get misc object OAM data offset
00DF97  1  AD 47 07                 lda TimerControl
00DF9A  1  D0 08                    bne ForceHPose              ;if master timer control set, skip this part
00DF9C  1  B5 2A                    lda Misc_State,x            ;otherwise get hammer's state
00DF9E  1  29 7F                    and #%01111111              ;mask out d7
00DFA0  1  C9 01                    cmp #$01                    ;check to see if set to 1 yet
00DFA2  1  F0 04                    beq GetHPose                ;if so, branch
00DFA4  1  A2 00        ForceHPose: ldx #$00                    ;reset offset here
00DFA6  1  F0 07                    beq RenderH                 ;do unconditional branch to rendering part
00DFA8  1  A5 09        GetHPose:   lda FrameCounter            ;get frame counter
00DFAA  1  4A                       lsr                         ;move d3-d2 to d1-d0
00DFAB  1  4A                       lsr
00DFAC  1  29 03                    and #%00000011              ;mask out all but d1-d0 (changes every four frames)
00DFAE  1  AA                       tax                         ;use as timing offset
00DFAF  1  AD BE 03     RenderH:    lda Misc_Rel_YPos           ;get relative vertical coordinate
00DFB2  1  18                       clc
00DFB3  1  7D 7C DF                 adc FirstSprYPos,x          ;add first sprite vertical adder based on offset
00DFB6  1  99 00 02                 sta Sprite_Y_Position,y     ;store as sprite Y coordinate for first sprite
00DFB9  1  18                       clc
00DFBA  1  7D 84 DF                 adc SecondSprYPos,x         ;add second sprite vertical adder based on offset
00DFBD  1  99 04 02                 sta Sprite_Y_Position+4,y   ;store as sprite Y coordinate for second sprite
00DFC0  1  AD B3 03                 lda Misc_Rel_XPos           ;get relative horizontal coordinate
00DFC3  1  18                       clc
00DFC4  1  7D 78 DF                 adc FirstSprXPos,x          ;add first sprite horizontal adder based on offset
00DFC7  1  99 03 02                 sta Sprite_X_Position,y     ;store as sprite X coordinate for first sprite
00DFCA  1  18                       clc
00DFCB  1  7D 80 DF                 adc SecondSprXPos,x         ;add second sprite horizontal adder based on offset
00DFCE  1  99 07 02                 sta Sprite_X_Position+4,y   ;store as sprite X coordinate for second sprite
00DFD1  1  BD 88 DF                 lda FirstSprTilenum,x
00DFD4  1  99 01 02                 sta Sprite_Tilenumber,y     ;get and store tile number of first sprite
00DFD7  1  BD 8C DF                 lda SecondSprTilenum,x
00DFDA  1  99 05 02                 sta Sprite_Tilenumber+4,y   ;get and store tile number of second sprite
00DFDD  1  BD 90 DF                 lda HammerSprAttrib,x
00DFE0  1  99 02 02                 sta Sprite_Attributes,y     ;get and store attribute bytes for both
00DFE3  1  99 06 02                 sta Sprite_Attributes+4,y   ;note in this case they use the same data
00DFE6  1  A6 08                    ldx ObjectOffset            ;get misc object offset
00DFE8  1  AD D6 03                 lda Misc_OffscreenBits
00DFEB  1  29 FC                    and #%11111100              ;check offscreen bits
00DFED  1  F0 09                    beq NoHOffscr               ;if all bits clear, leave object alone
00DFEF  1  A9 00                    lda #$00
00DFF1  1  95 2A                    sta Misc_State,x            ;otherwise nullify misc object state
00DFF3  1  A9 F8                    lda #$f8
00DFF5  1  20 79 E0                 jsr DumpTwoSpr              ;do sub to move hammer sprites offscreen
00DFF8  1  60           NoHOffscr:  rts                         ;leave
00DFF9  1               
00DFF9  1               ;-------------------------------------------------------------------------------------
00DFF9  1               ;$00-$01 - used to hold tile numbers ($01 addressed in draw floatey number part)
00DFF9  1               ;$02 - used to hold Y coordinate for floatey number
00DFF9  1               ;$03 - residual byte used for flip (but value set here affects nothing)
00DFF9  1               ;$04 - attribute byte for floatey number
00DFF9  1               ;$05 - used as X coordinate for floatey number
00DFF9  1               
00DFF9  1               FlagpoleScoreNumTiles:
00DFF9  1  F9 50              .byte $f9, $50
00DFFB  1  F7 50              .byte $f7, $50
00DFFD  1  FA FB              .byte $fa, $fb
00DFFF  1  F8 FB              .byte $f8, $fb
00E001  1  F6 FB              .byte $f6, $fb
00E003  1               
00E003  1               FlagpoleGfxHandler:
00E003  1  BC E5 06           ldy Enemy_SprDataOffset,x      ;get sprite data offset for flagpole flag
00E006  1  AD AE 03           lda Enemy_Rel_XPos             ;get relative horizontal coordinate
00E009  1  99 03 02           sta Sprite_X_Position,y        ;store as X coordinate for first sprite
00E00C  1  18                 clc
00E00D  1  69 08              adc #$08                       ;add eight pixels and store
00E00F  1  99 07 02           sta Sprite_X_Position+4,y      ;as X coordinate for second and third sprites
00E012  1  99 0B 02           sta Sprite_X_Position+8,y
00E015  1  18                 clc
00E016  1  69 0C              adc #$0c                       ;add twelve more pixels and
00E018  1  85 05              sta $05                        ;store here to be used later by floatey number
00E01A  1  B5 CF              lda Enemy_Y_Position,x         ;get vertical coordinate
00E01C  1  20 79 E0           jsr DumpTwoSpr                 ;and do sub to dump into first and second sprites
00E01F  1  69 08              adc #$08                       ;add eight pixels
00E021  1  99 08 02           sta Sprite_Y_Position+8,y      ;and store into third sprite
00E024  1  AD 0D 01           lda FlagpoleFNum_Y_Pos         ;get vertical coordinate for floatey number
00E027  1  85 02              sta $02                        ;store it here
00E029  1  A9 01              lda #$01
00E02B  1  85 03              sta $03                        ;set value for flip which will not be used, and
00E02D  1  85 04              sta $04                        ;attribute byte for floatey number
00E02F  1  99 02 02           sta Sprite_Attributes,y        ;set attribute bytes for all three sprites
00E032  1  99 06 02           sta Sprite_Attributes+4,y
00E035  1  99 0A 02           sta Sprite_Attributes+8,y
00E038  1  A9 7E              lda #$7e
00E03A  1  99 01 02           sta Sprite_Tilenumber,y        ;put triangle shaped tile
00E03D  1  99 09 02           sta Sprite_Tilenumber+8,y      ;into first and third sprites
00E040  1  A9 7F              lda #$7f
00E042  1  99 05 02           sta Sprite_Tilenumber+4,y      ;put skull tile into second sprite
00E045  1  AD 0F 07           lda FlagpoleCollisionYPos      ;get vertical coordinate at time of collision
00E048  1  F0 15              beq ChkFlagOffscreen           ;if zero, branch ahead
00E04A  1  98                 tya
00E04B  1  18                 clc                            ;add 12 bytes to sprite data offset
00E04C  1  69 0C              adc #$0c
00E04E  1  A8                 tay                            ;put back in Y
00E04F  1  AD 0F 01           lda FlagpoleScore              ;get offset used to award points for touching flagpole
00E052  1  0A                 asl                            ;multiply by 2 to get proper offset here
00E053  1  AA                 tax
00E054  1  BD F9 DF           lda FlagpoleScoreNumTiles,x    ;get appropriate tile data
00E057  1  85 00              sta $00
00E059  1  BD FA DF           lda FlagpoleScoreNumTiles+1,x
00E05C  1  20 6A E6           jsr DrawOneSpriteRow           ;use it to render floatey number
00E05F  1               
00E05F  1               ChkFlagOffscreen:
00E05F  1  A6 08              ldx ObjectOffset               ;get object offset for flag
00E061  1  BC E5 06           ldy Enemy_SprDataOffset,x      ;get OAM data offset
00E064  1  AD D1 03           lda Enemy_OffscreenBits        ;get offscreen bits
00E067  1  29 0E              and #%00001110                 ;mask out all but d3-d1
00E069  1  F0 14              beq ExitDumpSpr                ;if none of these bits set, branch to leave
00E06B  1               
00E06B  1               ;-------------------------------------------------------------------------------------
00E06B  1               
00E06B  1               MoveSixSpritesOffscreen:
00E06B  1  A9 F8              lda #$f8                  ;set offscreen coordinate if jumping here
00E06D  1               
00E06D  1               DumpSixSpr:
00E06D  1  99 14 02           sta Sprite_Data+20,y      ;dump A contents
00E070  1  99 10 02           sta Sprite_Data+16,y      ;into third row sprites
00E073  1               
00E073  1               DumpFourSpr:
00E073  1  99 0C 02           sta Sprite_Data+12,y      ;into second row sprites
00E076  1               
00E076  1               DumpThreeSpr:
00E076  1  99 08 02           sta Sprite_Data+8,y
00E079  1               
00E079  1               DumpTwoSpr:
00E079  1  99 04 02           sta Sprite_Data+4,y       ;and into first row sprites
00E07C  1  99 00 02           sta Sprite_Data,y
00E07F  1               
00E07F  1               ExitDumpSpr:
00E07F  1  60                 rts
00E080  1               
00E080  1               ;-------------------------------------------------------------------------------------
00E080  1               
00E080  1               DrawLargePlatform:
00E080  1  BC E5 06           ldy Enemy_SprDataOffset,x   ;get OAM data offset
00E083  1  84 02              sty $02                     ;store here
00E085  1  C8                 iny                         ;add 3 to it for offset
00E086  1  C8                 iny                         ;to X coordinate
00E087  1  C8                 iny
00E088  1  AD AE 03           lda Enemy_Rel_XPos          ;get horizontal relative coordinate
00E08B  1  20 66 DF           jsr SixSpriteStacker        ;store X coordinates using A as base, stack horizontally
00E08E  1  A6 08              ldx ObjectOffset
00E090  1  B5 CF              lda Enemy_Y_Position,x      ;get vertical coordinate
00E092  1  20 73 E0           jsr DumpFourSpr             ;dump into first four sprites as Y coordinate
00E095  1  AC 4E 07           ldy AreaType
00E098  1  C0 03              cpy #$03                    ;check for castle-type level
00E09A  1  F0 05              beq ShrinkPlatform
00E09C  1  AC CC 06           ldy SecondaryHardMode       ;check for secondary hard mode flag set
00E09F  1  F0 02              beq SetLast2Platform        ;branch if not set elsewhere
00E0A1  1               
00E0A1  1               ShrinkPlatform:
00E0A1  1  A9 F8              lda #$f8                    ;load offscreen coordinate if flag set or castle-type level
00E0A3  1               
00E0A3  1               SetLast2Platform:
00E0A3  1  BC E5 06           ldy Enemy_SprDataOffset,x   ;get OAM data offset
00E0A6  1  99 10 02           sta Sprite_Y_Position+16,y  ;store vertical coordinate or offscreen
00E0A9  1  99 14 02           sta Sprite_Y_Position+20,y  ;coordinate into last two sprites as Y coordinate
00E0AC  1  A9 5B              lda #$5b                    ;load default tile for platform (girder)
00E0AE  1  AE 43 07           ldx CloudTypeOverride
00E0B1  1  F0 02              beq SetPlatformTilenum      ;if cloud level override flag not set, use
00E0B3  1  A9 75              lda #$75                    ;otherwise load other tile for platform (puff)
00E0B5  1               
00E0B5  1               SetPlatformTilenum:
00E0B5  1  A6 08                ldx ObjectOffset            ;get enemy object buffer offset
00E0B7  1  C8                   iny                         ;increment Y for tile offset
00E0B8  1  20 6D E0             jsr DumpSixSpr              ;dump tile number into all six sprites
00E0BB  1  A9 02                lda #$02                    ;set palette controls
00E0BD  1  C8                   iny                         ;increment Y for sprite attributes
00E0BE  1  20 6D E0             jsr DumpSixSpr              ;dump attributes into all six sprites
00E0C1  1  E8                   inx                         ;increment X for enemy objects
00E0C2  1  20 8E EC             jsr GetXOffscreenBits       ;get offscreen bits again
00E0C5  1  CA                   dex
00E0C6  1  BC E5 06             ldy Enemy_SprDataOffset,x   ;get OAM data offset
00E0C9  1  0A                   asl                         ;rotate d7 into carry, save remaining
00E0CA  1  48                   pha                         ;bits to the stack
00E0CB  1  90 05                bcc SChk2
00E0CD  1  A9 F8                lda #$f8                    ;if d7 was set, move first sprite offscreen
00E0CF  1  99 00 02             sta Sprite_Y_Position,y
00E0D2  1  68           SChk2:  pla                         ;get bits from stack
00E0D3  1  0A                   asl                         ;rotate d6 into carry
00E0D4  1  48                   pha                         ;save to stack
00E0D5  1  90 05                bcc SChk3
00E0D7  1  A9 F8                lda #$f8                    ;if d6 was set, move second sprite offscreen
00E0D9  1  99 04 02             sta Sprite_Y_Position+4,y
00E0DC  1  68           SChk3:  pla                         ;get bits from stack
00E0DD  1  0A                   asl                         ;rotate d5 into carry
00E0DE  1  48                   pha                         ;save to stack
00E0DF  1  90 05                bcc SChk4
00E0E1  1  A9 F8                lda #$f8                    ;if d5 was set, move third sprite offscreen
00E0E3  1  99 08 02             sta Sprite_Y_Position+8,y
00E0E6  1  68           SChk4:  pla                         ;get bits from stack
00E0E7  1  0A                   asl                         ;rotate d4 into carry
00E0E8  1  48                   pha                         ;save to stack
00E0E9  1  90 05                bcc SChk5
00E0EB  1  A9 F8                lda #$f8                    ;if d4 was set, move fourth sprite offscreen
00E0ED  1  99 0C 02             sta Sprite_Y_Position+12,y
00E0F0  1  68           SChk5:  pla                         ;get bits from stack
00E0F1  1  0A                   asl                         ;rotate d3 into carry
00E0F2  1  48                   pha                         ;save to stack
00E0F3  1  90 05                bcc SChk6
00E0F5  1  A9 F8                lda #$f8                    ;if d3 was set, move fifth sprite offscreen
00E0F7  1  99 10 02             sta Sprite_Y_Position+16,y
00E0FA  1  68           SChk6:  pla                         ;get bits from stack
00E0FB  1  0A                   asl                         ;rotate d2 into carry
00E0FC  1  90 05                bcc SLChk                   ;save to stack
00E0FE  1  A9 F8                lda #$f8
00E100  1  99 14 02             sta Sprite_Y_Position+20,y  ;if d2 was set, move sixth sprite offscreen
00E103  1  AD D1 03     SLChk:  lda Enemy_OffscreenBits     ;check d7 of offscreen bits
00E106  1  0A                   asl                         ;and if d7 is not set, skip sub
00E107  1  90 03                bcc ExDLPl
00E109  1  20 6B E0             jsr MoveSixSpritesOffscreen ;otherwise branch to move all sprites offscreen
00E10C  1  60           ExDLPl: rts
00E10D  1               
00E10D  1               ;-------------------------------------------------------------------------------------
00E10D  1               
00E10D  1               DrawFloateyNumber_Coin:
00E10D  1  A5 09                  lda FrameCounter          ;get frame counter
00E10F  1  4A                     lsr                       ;divide by 2
00E110  1  B0 02                  bcs NotRsNum              ;branch if d0 not set to raise number every other frame
00E112  1  D6 DB                  dec Misc_Y_Position,x     ;otherwise, decrement vertical coordinate
00E114  1  B5 DB        NotRsNum: lda Misc_Y_Position,x     ;get vertical coordinate
00E116  1  20 79 E0               jsr DumpTwoSpr            ;dump into both sprites
00E119  1  AD B3 03               lda Misc_Rel_XPos         ;get relative horizontal coordinate
00E11C  1  99 03 02               sta Sprite_X_Position,y   ;store as X coordinate for first sprite
00E11F  1  18                     clc
00E120  1  69 08                  adc #$08                  ;add eight pixels
00E122  1  99 07 02               sta Sprite_X_Position+4,y ;store as X coordinate for second sprite
00E125  1  A9 02                  lda #$02
00E127  1  99 02 02               sta Sprite_Attributes,y   ;store attribute byte in both sprites
00E12A  1  99 06 02               sta Sprite_Attributes+4,y
00E12D  1  A9 F7                  lda #$f7
00E12F  1  99 01 02               sta Sprite_Tilenumber,y   ;put tile numbers into both sprites
00E132  1  A9 FB                  lda #$fb                  ;that resemble "200"
00E134  1  99 05 02               sta Sprite_Tilenumber+4,y
00E137  1  4C 75 E1               jmp ExJCGfx               ;then jump to leave (why not an rts here instead?)
00E13A  1               
00E13A  1               JumpingCoinTiles:
00E13A  1  60 61 62 63        .byte $60, $61, $62, $63
00E13E  1               
00E13E  1               JCoinGfxHandler:
00E13E  1  BC F3 06              ldy Misc_SprDataOffset,x    ;get coin/floatey number's OAM data offset
00E141  1  B5 2A                 lda Misc_State,x            ;get state of misc object
00E143  1  C9 02                 cmp #$02                    ;if 2 or greater,
00E145  1  B0 C6                 bcs DrawFloateyNumber_Coin  ;branch to draw floatey number
00E147  1  B5 DB                 lda Misc_Y_Position,x       ;store vertical coordinate as
00E149  1  99 00 02              sta Sprite_Y_Position,y     ;Y coordinate for first sprite
00E14C  1  18                    clc
00E14D  1  69 08                 adc #$08                    ;add eight pixels
00E14F  1  99 04 02              sta Sprite_Y_Position+4,y   ;store as Y coordinate for second sprite
00E152  1  AD B3 03              lda Misc_Rel_XPos           ;get relative horizontal coordinate
00E155  1  99 03 02              sta Sprite_X_Position,y
00E158  1  99 07 02              sta Sprite_X_Position+4,y   ;store as X coordinate for first and second sprites
00E15B  1  A5 09                 lda FrameCounter            ;get frame counter
00E15D  1  4A                    lsr                         ;divide by 2 to alter every other frame
00E15E  1  29 03                 and #%00000011              ;mask out d2-d1
00E160  1  AA                    tax                         ;use as graphical offset
00E161  1  BD 3A E1              lda JumpingCoinTiles,x      ;load tile number
00E164  1  C8                    iny                         ;increment OAM data offset to write tile numbers
00E165  1  20 79 E0              jsr DumpTwoSpr              ;do sub to dump tile number into both sprites
00E168  1  88                    dey                         ;decrement to get old offset
00E169  1  A9 02                 lda #$02
00E16B  1  99 02 02              sta Sprite_Attributes,y     ;set attribute byte in first sprite
00E16E  1  A9 82                 lda #$82
00E170  1  99 06 02              sta Sprite_Attributes+4,y   ;set attribute byte with vertical flip in second sprite
00E173  1  A6 08                 ldx ObjectOffset            ;get misc object offset
00E175  1  60           ExJCGfx: rts                         ;leave
00E176  1               
00E176  1               ;-------------------------------------------------------------------------------------
00E176  1               ;$00-$01 - used to hold tiles for drawing the power-up, $00 also used to hold power-up type
00E176  1               ;$02 - used to hold bottom row Y position
00E176  1               ;$03 - used to hold flip control (not used here)
00E176  1               ;$04 - used to hold sprite attributes
00E176  1               ;$05 - used to hold X position
00E176  1               ;$07 - counter
00E176  1               
00E176  1               ;tiles arranged in top left, right, bottom left, right order
00E176  1               PowerUpGfxTable:
00E176  1  76 77 78 79        .byte $76, $77, $78, $79 ;regular mushroom
00E17A  1  D6 D6 D9 D9        .byte $d6, $d6, $d9, $d9 ;fire flower
00E17E  1  8D 8D E4 E4        .byte $8d, $8d, $e4, $e4 ;star
00E182  1  76 77 78 79        .byte $76, $77, $78, $79 ;1-up mushroom
00E186  1               
00E186  1               PowerUpAttributes:
00E186  1  02 01 02 01        .byte $02, $01, $02, $01
00E18A  1               
00E18A  1               DrawPowerUp:
00E18A  1  AC EA 06           ldy Enemy_SprDataOffset+5  ;get power-up's sprite data offset
00E18D  1  AD B9 03           lda Enemy_Rel_YPos         ;get relative vertical coordinate
00E190  1  18                 clc
00E191  1  69 08              adc #$08                   ;add eight pixels
00E193  1  85 02              sta $02                    ;store result here
00E195  1  AD AE 03           lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00E198  1  85 05              sta $05                    ;store here
00E19A  1  A6 39              ldx PowerUpType            ;get power-up type
00E19C  1  BD 86 E1           lda PowerUpAttributes,x    ;get attribute data for power-up type
00E19F  1  0D CA 03           ora Enemy_SprAttrib+5      ;add background priority bit if set
00E1A2  1  85 04              sta $04                    ;store attributes here
00E1A4  1  8A                 txa
00E1A5  1  48                 pha                        ;save power-up type to the stack
00E1A6  1  0A                 asl
00E1A7  1  0A                 asl                        ;multiply by four to get proper offset
00E1A8  1  AA                 tax                        ;use as X
00E1A9  1  A9 01              lda #$01
00E1AB  1  85 07              sta $07                    ;set counter here to draw two rows of sprite object
00E1AD  1  85 03              sta $03                    ;init d1 of flip control
00E1AF  1               
00E1AF  1               PUpDrawLoop:
00E1AF  1  BD 76 E1             lda PowerUpGfxTable,x      ;load left tile of power-up object
00E1B2  1  85 00                sta $00
00E1B4  1  BD 77 E1             lda PowerUpGfxTable+1,x    ;load right tile
00E1B7  1  20 6A E6             jsr DrawOneSpriteRow       ;branch to draw one row of our power-up object
00E1BA  1  C6 07                dec $07                    ;decrement counter
00E1BC  1  10 F1                bpl PUpDrawLoop            ;branch until two rows are drawn
00E1BE  1  AC EA 06             ldy Enemy_SprDataOffset+5  ;get sprite data offset again
00E1C1  1  68                   pla                        ;pull saved power-up type from the stack
00E1C2  1  F0 2F                beq PUpOfs                 ;if regular mushroom, branch, do not change colors or flip
00E1C4  1  C9 03                cmp #$03
00E1C6  1  F0 2B                beq PUpOfs                 ;if 1-up mushroom, branch, do not change colors or flip
00E1C8  1  85 00                sta $00                    ;store power-up type here now
00E1CA  1  A5 09                lda FrameCounter           ;get frame counter
00E1CC  1  4A                   lsr                        ;divide by 2 to change colors every two frames
00E1CD  1  29 03                and #%00000011             ;mask out all but d1 and d0 (previously d2 and d1)
00E1CF  1  0D CA 03             ora Enemy_SprAttrib+5      ;add background priority bit if any set
00E1D2  1  99 02 02             sta Sprite_Attributes,y    ;set as new palette bits for top left and
00E1D5  1  99 06 02             sta Sprite_Attributes+4,y  ;top right sprites for fire flower and star
00E1D8  1  A6 00                ldx $00
00E1DA  1  CA                   dex                        ;check power-up type for fire flower
00E1DB  1  F0 06                beq FlipPUpRightSide       ;if found, skip this part
00E1DD  1  99 0A 02             sta Sprite_Attributes+8,y  ;otherwise set new palette bits  for bottom left
00E1E0  1  99 0E 02             sta Sprite_Attributes+12,y ;and bottom right sprites as well for star only
00E1E3  1               
00E1E3  1               FlipPUpRightSide:
00E1E3  1  B9 06 02             lda Sprite_Attributes+4,y
00E1E6  1  09 40                ora #%01000000             ;set horizontal flip bit for top right sprite
00E1E8  1  99 06 02             sta Sprite_Attributes+4,y
00E1EB  1  B9 0E 02             lda Sprite_Attributes+12,y
00E1EE  1  09 40                ora #%01000000             ;set horizontal flip bit for bottom right sprite
00E1F0  1  99 0E 02             sta Sprite_Attributes+12,y ;note these are only done for fire flower and star power-ups
00E1F3  1  4C 1C E6     PUpOfs: jmp SprObjectOffscrChk     ;jump to check to see if power-up is offscreen at all, then leave
00E1F6  1               
00E1F6  1               ;-------------------------------------------------------------------------------------
00E1F6  1               ;$00-$01 - used in DrawEnemyObjRow to hold sprite tile numbers
00E1F6  1               ;$02 - used to store Y position
00E1F6  1               ;$03 - used to store moving direction, used to flip enemies horizontally
00E1F6  1               ;$04 - used to store enemy's sprite attributes
00E1F6  1               ;$05 - used to store X position
00E1F6  1               ;$eb - used to hold sprite data offset
00E1F6  1               ;$ec - used to hold either altered enemy state or special value used in gfx handler as condition
00E1F6  1               ;$ed - used to hold enemy state from buffer
00E1F6  1               ;$ef - used to hold enemy code used in gfx handler (may or may not resemble Enemy_ID values)
00E1F6  1               
00E1F6  1               ;tiles arranged in top left, right, middle left, right, bottom left, right order
00E1F6  1               EnemyGraphicsTable:
00E1F6  1  FC FC AA AB        .byte $fc, $fc, $aa, $ab, $ac, $ad  ;buzzy beetle frame 1
00E1FA  1  AC AD        
00E1FC  1  FC FC AE AF        .byte $fc, $fc, $ae, $af, $b0, $b1  ;             frame 2
00E200  1  B0 B1        
00E202  1  FC A5 A6 A7        .byte $fc, $a5, $a6, $a7, $a8, $a9  ;koopa troopa frame 1
00E206  1  A8 A9        
00E208  1  FC A0 A1 A2        .byte $fc, $a0, $a1, $a2, $a3, $a4  ;             frame 2
00E20C  1  A3 A4        
00E20E  1  69 A5 6A A7        .byte $69, $a5, $6a, $a7, $a8, $a9  ;koopa paratroopa frame 1
00E212  1  A8 A9        
00E214  1  6B A0 6C A2        .byte $6b, $a0, $6c, $a2, $a3, $a4  ;                 frame 2
00E218  1  A3 A4        
00E21A  1  FC FC 96 97        .byte $fc, $fc, $96, $97, $98, $99  ;spiny frame 1
00E21E  1  98 99        
00E220  1  FC FC 9A 9B        .byte $fc, $fc, $9a, $9b, $9c, $9d  ;      frame 2
00E224  1  9C 9D        
00E226  1  FC FC 8F 8E        .byte $fc, $fc, $8f, $8e, $8e, $8f  ;spiny's egg frame 1
00E22A  1  8E 8F        
00E22C  1  FC FC 95 94        .byte $fc, $fc, $95, $94, $94, $95  ;            frame 2
00E230  1  94 95        
00E232  1  FC FC DC DC        .byte $fc, $fc, $dc, $dc, $df, $df  ;bloober frame 1
00E236  1  DF DF        
00E238  1  DC DC DD DD        .byte $dc, $dc, $dd, $dd, $de, $de  ;        frame 2
00E23C  1  DE DE        
00E23E  1  FC FC B2 B3        .byte $fc, $fc, $b2, $b3, $b4, $b5  ;cheep-cheep frame 1
00E242  1  B4 B5        
00E244  1  FC FC B6 B3        .byte $fc, $fc, $b6, $b3, $b7, $b5  ;            frame 2
00E248  1  B7 B5        
00E24A  1  FC FC 70 71        .byte $fc, $fc, $70, $71, $72, $73  ;goomba
00E24E  1  72 73        
00E250  1  FC FC 6E 6E        .byte $fc, $fc, $6e, $6e, $6f, $6f  ;koopa shell frame 1 (upside-down)
00E254  1  6F 6F        
00E256  1  FC FC 6D 6D        .byte $fc, $fc, $6d, $6d, $6f, $6f  ;            frame 2
00E25A  1  6F 6F        
00E25C  1  FC FC 6F 6F        .byte $fc, $fc, $6f, $6f, $6e, $6e  ;koopa shell frame 1 (rightsideup)
00E260  1  6E 6E        
00E262  1  FC FC 6F 6F        .byte $fc, $fc, $6f, $6f, $6d, $6d  ;            frame 2
00E266  1  6D 6D        
00E268  1  FC FC F4 F4        .byte $fc, $fc, $f4, $f4, $f5, $f5  ;buzzy beetle shell frame 1 (rightsideup)
00E26C  1  F5 F5        
00E26E  1  FC FC F4 F4        .byte $fc, $fc, $f4, $f4, $f5, $f5  ;                   frame 2
00E272  1  F5 F5        
00E274  1  FC FC F5 F5        .byte $fc, $fc, $f5, $f5, $f4, $f4  ;buzzy beetle shell frame 1 (upside-down)
00E278  1  F4 F4        
00E27A  1  FC FC F5 F5        .byte $fc, $fc, $f5, $f5, $f4, $f4  ;                   frame 2
00E27E  1  F4 F4        
00E280  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $ef, $ef  ;defeated goomba
00E284  1  EF EF        
00E286  1  B9 B8 BB BA        .byte $b9, $b8, $bb, $ba, $bc, $bc  ;lakitu frame 1
00E28A  1  BC BC        
00E28C  1  FC FC BD BD        .byte $fc, $fc, $bd, $bd, $bc, $bc  ;       frame 2
00E290  1  BC BC        
00E292  1  7A 7B DA DB        .byte $7a, $7b, $da, $db, $d8, $d8  ;princess
00E296  1  D8 D8        
00E298  1  CD CD CE CE        .byte $cd, $cd, $ce, $ce, $cf, $cf  ;mushroom retainer
00E29C  1  CF CF        
00E29E  1  7D 7C D1 8C        .byte $7d, $7c, $d1, $8c, $d3, $d2  ;hammer bro frame 1
00E2A2  1  D3 D2        
00E2A4  1  7D 7C 89 88        .byte $7d, $7c, $89, $88, $8b, $8a  ;           frame 2
00E2A8  1  8B 8A        
00E2AA  1  D5 D4 E3 E2        .byte $d5, $d4, $e3, $e2, $d3, $d2  ;           frame 3
00E2AE  1  D3 D2        
00E2B0  1  D5 D4 E3 E2        .byte $d5, $d4, $e3, $e2, $8b, $8a  ;           frame 4
00E2B4  1  8B 8A        
00E2B6  1  E5 E5 E6 E6        .byte $e5, $e5, $e6, $e6, $eb, $eb  ;piranha plant frame 1
00E2BA  1  EB EB        
00E2BC  1  EC EC ED ED        .byte $ec, $ec, $ed, $ed, $ee, $ee  ;              frame 2
00E2C0  1  EE EE        
00E2C2  1  FC FC D0 D0        .byte $fc, $fc, $d0, $d0, $d7, $d7  ;podoboo
00E2C6  1  D7 D7        
00E2C8  1  BF BE C1 C0        .byte $bf, $be, $c1, $c0, $c2, $fc  ;bowser front frame 1
00E2CC  1  C2 FC        
00E2CE  1  C4 C3 C6 C5        .byte $c4, $c3, $c6, $c5, $c8, $c7  ;bowser rear frame 1
00E2D2  1  C8 C7        
00E2D4  1  BF BE CA C9        .byte $bf, $be, $ca, $c9, $c2, $fc  ;       front frame 2
00E2D8  1  C2 FC        
00E2DA  1  C4 C3 C6 C5        .byte $c4, $c3, $c6, $c5, $cc, $cb  ;       rear frame 2
00E2DE  1  CC CB        
00E2E0  1  FC FC E8 E7        .byte $fc, $fc, $e8, $e7, $ea, $e9  ;bullet bill
00E2E4  1  EA E9        
00E2E6  1  F2 F2 F3 F3        .byte $f2, $f2, $f3, $f3, $f2, $f2  ;jumpspring frame 1
00E2EA  1  F2 F2        
00E2EC  1  F1 F1 F1 F1        .byte $f1, $f1, $f1, $f1, $fc, $fc  ;           frame 2
00E2F0  1  FC FC        
00E2F2  1  F0 F0 FC FC        .byte $f0, $f0, $fc, $fc, $fc, $fc  ;           frame 3
00E2F6  1  FC FC        
00E2F8  1               
00E2F8  1               EnemyGfxTableOffsets:
00E2F8  1  0C 0C 00 0C        .byte $0c, $0c, $00, $0c, $0c, $a8, $54, $3c
00E2FC  1  0C A8 54 3C  
00E300  1  EA 18 48 48        .byte $ea, $18, $48, $48, $cc, $c0, $18, $18
00E304  1  CC C0 18 18  
00E308  1  18 90 24 FF        .byte $18, $90, $24, $ff, $48, $9c, $d2, $d8
00E30C  1  48 9C D2 D8  
00E310  1  F0 F6 FC           .byte $f0, $f6, $fc
00E313  1               
00E313  1               EnemyAttributeData:
00E313  1  01 02 03 02        .byte $01, $02, $03, $02, $01, $01, $03, $03
00E317  1  01 01 03 03  
00E31B  1  03 01 01 02        .byte $03, $01, $01, $02, $02, $21, $01, $02
00E31F  1  02 21 01 02  
00E323  1  01 01 02 FF        .byte $01, $01, $02, $ff, $02, $02, $01, $01
00E327  1  02 02 01 01  
00E32B  1  02 02 02           .byte $02, $02, $02
00E32E  1               
00E32E  1               EnemyAnimTimingBMask:
00E32E  1  08 18              .byte $08, $18
00E330  1               
00E330  1               JumpspringFrameOffsets:
00E330  1  18 19 1A 19        .byte $18, $19, $1a, $19, $18
00E334  1  18           
00E335  1               
00E335  1               EnemyGfxHandler:
00E335  1  B5 CF              lda Enemy_Y_Position,x      ;get enemy object vertical position
00E337  1  85 02              sta $02
00E339  1  AD AE 03           lda Enemy_Rel_XPos          ;get enemy object horizontal position
00E33C  1  85 05              sta $05                     ;relative to screen
00E33E  1  BC E5 06           ldy Enemy_SprDataOffset,x
00E341  1  84 EB              sty $eb                     ;get sprite data offset
00E343  1  A9 00              lda #$00
00E345  1  8D 09 01           sta VerticalFlipFlag        ;initialize vertical flip flag by default
00E348  1  B5 46              lda Enemy_MovingDir,x
00E34A  1  85 03              sta $03                     ;get enemy object moving direction
00E34C  1  BD C5 03           lda Enemy_SprAttrib,x
00E34F  1  85 04              sta $04                     ;get enemy object sprite attributes
00E351  1  B5 16              lda Enemy_ID,x
00E353  1  C9 0D              cmp #PiranhaPlant           ;is enemy object piranha plant?
00E355  1  D0 0A              bne CheckForRetainerObj     ;if not, branch
00E357  1  B4 58              ldy PiranhaPlant_Y_Speed,x
00E359  1  30 06              bmi CheckForRetainerObj     ;if piranha plant moving upwards, branch
00E35B  1  BC 8A 07           ldy EnemyFrameTimer,x
00E35E  1  F0 01              beq CheckForRetainerObj     ;if timer for movement expired, branch
00E360  1  60                 rts                         ;if all conditions fail, leave
00E361  1               
00E361  1               CheckForRetainerObj:
00E361  1  B5 1E              lda Enemy_State,x           ;store enemy state
00E363  1  85 ED              sta $ed
00E365  1  29 1F              and #%00011111              ;nullify all but 5 LSB and use as Y
00E367  1  A8                 tay
00E368  1  B5 16              lda Enemy_ID,x              ;check for mushroom retainer/princess object
00E36A  1  C9 35              cmp #RetainerObject
00E36C  1  D0 08              bne CheckForBulletBillCV    ;if not found, branch
00E36E  1  A0 00              ldy #$00                    ;if found, nullify saved state in Y
00E370  1  A9 01              lda #$01                    ;set value that will not be used
00E372  1  85 03              sta $03
00E374  1  A9 15              lda #$15                    ;set value $15 as code for mushroom retainer/princess object
00E376  1               
00E376  1               CheckForBulletBillCV:
00E376  1  C9 33               cmp #BulletBill_CannonVar   ;otherwise check for bullet bill object
00E378  1  D0 13               bne CheckForJumpspring      ;if not found, branch again
00E37A  1  C6 02               dec $02                     ;decrement saved vertical position
00E37C  1  A9 03               lda #$03
00E37E  1  BC 8A 07            ldy EnemyFrameTimer,x       ;get timer for enemy object
00E381  1  F0 02               beq SBBAt                   ;if expired, do not set priority bit
00E383  1  09 20               ora #%00100000              ;otherwise do so
00E385  1  85 04        SBBAt: sta $04                     ;set new sprite attributes
00E387  1  A0 00               ldy #$00                    ;nullify saved enemy state both in Y and in
00E389  1  84 ED               sty $ed                     ;memory location here
00E38B  1  A9 08               lda #$08                    ;set specific value to unconditionally branch once
00E38D  1               
00E38D  1               CheckForJumpspring:
00E38D  1  C9 32              cmp #JumpspringObject        ;check for jumpspring object
00E38F  1  D0 08              bne CheckForPodoboo
00E391  1  A0 03              ldy #$03                     ;set enemy state -2 MSB here for jumpspring object
00E393  1  AE 0E 07           ldx JumpspringAnimCtrl       ;get current frame number for jumpspring object
00E396  1  BD 30 E3           lda JumpspringFrameOffsets,x ;load data using frame number as offset
00E399  1               
00E399  1               CheckForPodoboo:
00E399  1  85 EF              sta $ef                 ;store saved enemy object value here
00E39B  1  84 EC              sty $ec                 ;and Y here (enemy state -2 MSB if not changed)
00E39D  1  A6 08              ldx ObjectOffset        ;get enemy object offset
00E39F  1  C9 0C              cmp #$0c                ;check for podoboo object
00E3A1  1  D0 07              bne CheckBowserGfxFlag  ;branch if not found
00E3A3  1  B5 A0              lda Enemy_Y_Speed,x     ;if moving upwards, branch
00E3A5  1  30 03              bmi CheckBowserGfxFlag
00E3A7  1  EE 09 01           inc VerticalFlipFlag    ;otherwise, set flag for vertical flip
00E3AA  1               
00E3AA  1               CheckBowserGfxFlag:
00E3AA  1  AD 6A 03                  lda BowserGfxFlag   ;if not drawing bowser at all, skip to something else
00E3AD  1  F0 09                     beq CheckForGoomba
00E3AF  1  A0 16                     ldy #$16            ;if set to 1, draw bowser's front
00E3B1  1  C9 01                     cmp #$01
00E3B3  1  F0 01                     beq SBwsrGfxOfs
00E3B5  1  C8                        iny                 ;otherwise draw bowser's rear
00E3B6  1  84 EF        SBwsrGfxOfs: sty $ef
00E3B8  1               
00E3B8  1               CheckForGoomba:
00E3B8  1  A4 EF                  ldy $ef               ;check value for goomba object
00E3BA  1  C0 06                  cpy #Goomba
00E3BC  1  D0 1D                  bne CheckBowserFront  ;branch if not found
00E3BE  1  B5 1E                  lda Enemy_State,x
00E3C0  1  C9 02                  cmp #$02              ;check for defeated state
00E3C2  1  90 04                  bcc GmbaAnim          ;if not defeated, go ahead and animate
00E3C4  1  A2 04                  ldx #$04              ;if defeated, write new value here
00E3C6  1  86 EC                  stx $ec
00E3C8  1  29 20        GmbaAnim: and #%00100000        ;check for d5 set in enemy object state
00E3CA  1  0D 47 07               ora TimerControl      ;or timer disable flag set
00E3CD  1  D0 0C                  bne CheckBowserFront  ;if either condition true, do not animate goomba
00E3CF  1  A5 09                  lda FrameCounter
00E3D1  1  29 08                  and #%00001000        ;check for every eighth frame
00E3D3  1  D0 06                  bne CheckBowserFront
00E3D5  1  A5 03                  lda $03
00E3D7  1  49 03                  eor #%00000011        ;invert bits to flip horizontally every eight frames
00E3D9  1  85 03                  sta $03               ;leave alone otherwise
00E3DB  1               
00E3DB  1               CheckBowserFront:
00E3DB  1  B9 13 E3                  lda EnemyAttributeData,y    ;load sprite attribute using enemy object
00E3DE  1  05 04                     ora $04                     ;as offset, and add to bits already loaded
00E3E0  1  85 04                     sta $04
00E3E2  1  B9 F8 E2                  lda EnemyGfxTableOffsets,y  ;load value based on enemy object as offset
00E3E5  1  AA                        tax                         ;save as X
00E3E6  1  A4 EC                     ldy $ec                     ;get previously saved value
00E3E8  1  AD 6A 03                  lda BowserGfxFlag
00E3EB  1  F0 30                     beq CheckForSpiny           ;if not drawing bowser object at all, skip all of this
00E3ED  1  C9 01                     cmp #$01
00E3EF  1  D0 13                     bne CheckBowserRear         ;if not drawing front part, branch to draw the rear part
00E3F1  1  AD 63 03                  lda BowserBodyControls      ;check bowser's body control bits
00E3F4  1  10 02                     bpl ChkFrontSte             ;branch if d7 not set (control's bowser's mouth)
00E3F6  1  A2 DE                     ldx #$de                    ;otherwise load offset for second frame
00E3F8  1  A5 ED        ChkFrontSte: lda $ed                     ;check saved enemy state
00E3FA  1  29 20                     and #%00100000              ;if bowser not defeated, do not set flag
00E3FC  1  F0 03                     beq DrawBowser
00E3FE  1               
00E3FE  1               FlipBowserOver:
00E3FE  1  8E 09 01           stx VerticalFlipFlag  ;set vertical flip flag to nonzero
00E401  1               
00E401  1               DrawBowser:
00E401  1  4C 03 E5           jmp DrawEnemyObject   ;draw bowser's graphics now
00E404  1               
00E404  1               CheckBowserRear:
00E404  1  AD 63 03                 lda BowserBodyControls  ;check bowser's body control bits
00E407  1  29 01                    and #$01
00E409  1  F0 02                    beq ChkRearSte          ;branch if d0 not set (control's bowser's feet)
00E40B  1  A2 E4                    ldx #$e4                ;otherwise load offset for second frame
00E40D  1  A5 ED        ChkRearSte: lda $ed                 ;check saved enemy state
00E40F  1  29 20                    and #%00100000          ;if bowser not defeated, do not set flag
00E411  1  F0 EE                    beq DrawBowser
00E413  1  A5 02                    lda $02                 ;subtract 16 pixels from
00E415  1  38                       sec                     ;saved vertical coordinate
00E416  1  E9 10                    sbc #$10
00E418  1  85 02                    sta $02
00E41A  1  4C FE E3                 jmp FlipBowserOver      ;jump to set vertical flip flag
00E41D  1               
00E41D  1               CheckForSpiny:
00E41D  1  E0 24                cpx #$24               ;check if value loaded is for spiny
00E41F  1  D0 11                bne CheckForLakitu     ;if not found, branch
00E421  1  C0 05                cpy #$05               ;if enemy state set to $05, do this,
00E423  1  D0 0A                bne NotEgg             ;otherwise branch
00E425  1  A2 30                ldx #$30               ;set to spiny egg offset
00E427  1  A9 02                lda #$02
00E429  1  85 03                sta $03                ;set enemy direction to reverse sprites horizontally
00E42B  1  A9 05                lda #$05
00E42D  1  85 EC                sta $ec                ;set enemy state
00E42F  1  4C 82 E4     NotEgg: jmp CheckForHammerBro  ;skip a big chunk of this if we found spiny but not in egg
00E432  1               
00E432  1               CheckForLakitu:
00E432  1  E0 90                cpx #$90                  ;check value for lakitu's offset loaded
00E434  1  D0 12                bne CheckUpsideDownShell  ;branch if not loaded
00E436  1  A5 ED                lda $ed
00E438  1  29 20                and #%00100000            ;check for d5 set in enemy state
00E43A  1  D0 09                bne NoLAFr                ;branch if set
00E43C  1  AD 8F 07             lda FrenzyEnemyTimer
00E43F  1  C9 10                cmp #$10                  ;check timer to see if we've reached a certain range
00E441  1  B0 02                bcs NoLAFr                ;branch if not
00E443  1  A2 96                ldx #$96                  ;if d6 not set and timer in range, load alt frame for lakitu
00E445  1  4C EF E4     NoLAFr: jmp CheckDefeatedState    ;skip this next part if we found lakitu but alt frame not needed
00E448  1               
00E448  1               CheckUpsideDownShell:
00E448  1  A5 EF              lda $ef                    ;check for enemy object => $04
00E44A  1  C9 04              cmp #$04
00E44C  1  B0 10              bcs CheckRightSideUpShell  ;branch if true
00E44E  1  C0 02              cpy #$02
00E450  1  90 0C              bcc CheckRightSideUpShell  ;branch if enemy state < $02
00E452  1  A2 5A              ldx #$5a                   ;set for upside-down koopa shell by default
00E454  1  A4 EF              ldy $ef
00E456  1  C0 02              cpy #BuzzyBeetle           ;check for buzzy beetle object
00E458  1  D0 04              bne CheckRightSideUpShell
00E45A  1  A2 7E              ldx #$7e                   ;set for upside-down buzzy beetle shell if found
00E45C  1  E6 02              inc $02                    ;increment vertical position by one pixel
00E45E  1               
00E45E  1               CheckRightSideUpShell:
00E45E  1  A5 EC              lda $ec                ;check for value set here
00E460  1  C9 04              cmp #$04               ;if enemy state < $02, do not change to shell, if
00E462  1  D0 1E              bne CheckForHammerBro  ;enemy state => $02 but not = $04, leave shell upside-down
00E464  1  A2 72              ldx #$72               ;set right-side up buzzy beetle shell by default
00E466  1  E6 02              inc $02                ;increment saved vertical position by one pixel
00E468  1  A4 EF              ldy $ef
00E46A  1  C0 02              cpy #BuzzyBeetle       ;check for buzzy beetle object
00E46C  1  F0 04              beq CheckForDefdGoomba ;branch if found
00E46E  1  A2 66              ldx #$66               ;change to right-side up koopa shell if not found
00E470  1  E6 02              inc $02                ;and increment saved vertical position again
00E472  1               
00E472  1               CheckForDefdGoomba:
00E472  1  C0 06              cpy #Goomba            ;check for goomba object (necessary if previously
00E474  1  D0 0C              bne CheckForHammerBro  ;failed buzzy beetle object test)
00E476  1  A2 54              ldx #$54               ;load for regular goomba
00E478  1  A5 ED              lda $ed                ;note that this only gets performed if enemy state => $02
00E47A  1  29 20              and #%00100000         ;check saved enemy state for d5 set
00E47C  1  D0 04              bne CheckForHammerBro  ;branch if set
00E47E  1  A2 8A              ldx #$8a               ;load offset for defeated goomba
00E480  1  C6 02              dec $02                ;set different value and decrement saved vertical position
00E482  1               
00E482  1               CheckForHammerBro:
00E482  1  A4 08              ldy ObjectOffset
00E484  1  A5 EF              lda $ef                  ;check for hammer bro object
00E486  1  C9 05              cmp #HammerBro
00E488  1  D0 0C              bne CheckForBloober      ;branch if not found
00E48A  1  A5 ED              lda $ed
00E48C  1  F0 24              beq CheckToAnimateEnemy  ;branch if not in normal enemy state
00E48E  1  29 08              and #%00001000
00E490  1  F0 5D              beq CheckDefeatedState   ;if d3 not set, branch further away
00E492  1  A2 B4              ldx #$b4                 ;otherwise load offset for different frame
00E494  1  D0 1C              bne CheckToAnimateEnemy  ;unconditional branch
00E496  1               
00E496  1               CheckForBloober:
00E496  1  E0 48              cpx #$48                 ;check for cheep-cheep offset loaded
00E498  1  F0 18              beq CheckToAnimateEnemy  ;branch if found
00E49A  1  B9 96 07           lda EnemyIntervalTimer,y
00E49D  1  C9 05              cmp #$05
00E49F  1  B0 4E              bcs CheckDefeatedState   ;branch if some timer is above a certain point
00E4A1  1  E0 3C              cpx #$3c                 ;check for bloober offset loaded
00E4A3  1  D0 0D              bne CheckToAnimateEnemy  ;branch if not found this time
00E4A5  1  C9 01              cmp #$01
00E4A7  1  F0 46              beq CheckDefeatedState   ;branch if timer is set to certain point
00E4A9  1  E6 02              inc $02                  ;increment saved vertical coordinate three pixels
00E4AB  1  E6 02              inc $02
00E4AD  1  E6 02              inc $02
00E4AF  1  4C E1 E4           jmp CheckAnimationStop   ;and do something else
00E4B2  1               
00E4B2  1               CheckToAnimateEnemy:
00E4B2  1  A5 EF              lda $ef                  ;check for specific enemy objects
00E4B4  1  C9 06              cmp #Goomba
00E4B6  1  F0 37              beq CheckDefeatedState   ;branch if goomba
00E4B8  1  C9 08              cmp #$08
00E4BA  1  F0 33              beq CheckDefeatedState   ;branch if bullet bill (note both variants use $08 here)
00E4BC  1  C9 0C              cmp #Podoboo
00E4BE  1  F0 2F              beq CheckDefeatedState   ;branch if podoboo
00E4C0  1  C9 18              cmp #$18                 ;branch if => $18
00E4C2  1  B0 2B              bcs CheckDefeatedState
00E4C4  1  A0 00              ldy #$00
00E4C6  1  C9 15              cmp #$15                 ;check for mushroom retainer/princess object
00E4C8  1  D0 10              bne CheckForSecondFrame  ;which uses different code here, branch if not found
00E4CA  1  C8                 iny                      ;residual instruction
00E4CB  1  AD 5F 07           lda WorldNumber          ;are we on world 8?
00E4CE  1  C9 07              cmp #World8
00E4D0  1  B0 1D              bcs CheckDefeatedState   ;if so, leave the offset alone (use princess)
00E4D2  1  A2 A2              ldx #$a2                 ;otherwise, set for mushroom retainer object instead
00E4D4  1  A9 03              lda #$03                 ;set alternate state here
00E4D6  1  85 EC              sta $ec
00E4D8  1  D0 15              bne CheckDefeatedState   ;unconditional branch
00E4DA  1               
00E4DA  1               CheckForSecondFrame:
00E4DA  1  A5 09              lda FrameCounter            ;load frame counter
00E4DC  1  39 2E E3           and EnemyAnimTimingBMask,y  ;mask it (partly residual, one byte not ever used)
00E4DF  1  D0 0E              bne CheckDefeatedState      ;branch if timing is off
00E4E1  1               
00E4E1  1               CheckAnimationStop:
00E4E1  1  A5 ED              lda $ed                 ;check saved enemy state
00E4E3  1  29 A0              and #%10100000          ;for d7 or d5, or check for timers stopped
00E4E5  1  0D 47 07           ora TimerControl
00E4E8  1  D0 05              bne CheckDefeatedState  ;if either condition true, branch
00E4EA  1  8A                 txa
00E4EB  1  18                 clc
00E4EC  1  69 06              adc #$06                ;add $06 to current enemy offset
00E4EE  1  AA                 tax                     ;to animate various enemy objects
00E4EF  1               
00E4EF  1               CheckDefeatedState:
00E4EF  1  A5 ED              lda $ed               ;check saved enemy state
00E4F1  1  29 20              and #%00100000        ;for d5 set
00E4F3  1  F0 0E              beq DrawEnemyObject   ;branch if not set
00E4F5  1  A5 EF              lda $ef
00E4F7  1  C9 04              cmp #$04              ;check for saved enemy object => $04
00E4F9  1  90 08              bcc DrawEnemyObject   ;branch if less
00E4FB  1  A0 01              ldy #$01
00E4FD  1  8C 09 01           sty VerticalFlipFlag  ;set vertical flip flag
00E500  1  88                 dey
00E501  1  84 EC              sty $ec               ;init saved value here
00E503  1               
00E503  1               DrawEnemyObject:
00E503  1  A4 EB              ldy $eb                    ;load sprite data offset
00E505  1  20 62 E6           jsr DrawEnemyObjRow        ;draw six tiles of data
00E508  1  20 62 E6           jsr DrawEnemyObjRow        ;into sprite data
00E50B  1  20 62 E6           jsr DrawEnemyObjRow
00E50E  1  A6 08              ldx ObjectOffset           ;get enemy object offset
00E510  1  BC E5 06           ldy Enemy_SprDataOffset,x  ;get sprite data offset
00E513  1  A5 EF              lda $ef
00E515  1  C9 08              cmp #$08                   ;get saved enemy object and check
00E517  1  D0 03              bne CheckForVerticalFlip   ;for bullet bill, branch if not found
00E519  1               
00E519  1               SkipToOffScrChk:
00E519  1  4C 1C E6           jmp SprObjectOffscrChk     ;jump if found
00E51C  1               
00E51C  1               CheckForVerticalFlip:
00E51C  1  AD 09 01           lda VerticalFlipFlag       ;check if vertical flip flag is set here
00E51F  1  F0 3D              beq CheckForESymmetry      ;branch if not
00E521  1  B9 02 02           lda Sprite_Attributes,y    ;get attributes of first sprite we dealt with
00E524  1  09 80              ora #%10000000             ;set bit for vertical flip
00E526  1  C8                 iny
00E527  1  C8                 iny                        ;increment two bytes so that we store the vertical flip
00E528  1  20 6D E0           jsr DumpSixSpr             ;in attribute bytes of enemy obj sprite data
00E52B  1  88                 dey
00E52C  1  88                 dey                        ;now go back to the Y coordinate offset
00E52D  1  98                 tya
00E52E  1  AA                 tax                        ;give offset to X
00E52F  1  A5 EF              lda $ef
00E531  1  C9 05              cmp #HammerBro             ;check saved enemy object for hammer bro
00E533  1  F0 0D              beq FlipEnemyVertically
00E535  1  C9 11              cmp #Lakitu                ;check saved enemy object for lakitu
00E537  1  F0 09              beq FlipEnemyVertically    ;branch for hammer bro or lakitu
00E539  1  C9 15              cmp #$15
00E53B  1  B0 05              bcs FlipEnemyVertically    ;also branch if enemy object => $15
00E53D  1  8A                 txa
00E53E  1  18                 clc
00E53F  1  69 08              adc #$08                   ;if not selected objects or => $15, set
00E541  1  AA                 tax                        ;offset in X for next row
00E542  1               
00E542  1               FlipEnemyVertically:
00E542  1  BD 01 02           lda Sprite_Tilenumber,x     ;load first or second row tiles
00E545  1  48                 pha                         ;and save tiles to the stack
00E546  1  BD 05 02           lda Sprite_Tilenumber+4,x
00E549  1  48                 pha
00E54A  1  B9 11 02           lda Sprite_Tilenumber+16,y  ;exchange third row tiles
00E54D  1  9D 01 02           sta Sprite_Tilenumber,x     ;with first or second row tiles
00E550  1  B9 15 02           lda Sprite_Tilenumber+20,y
00E553  1  9D 05 02           sta Sprite_Tilenumber+4,x
00E556  1  68                 pla                         ;pull first or second row tiles from stack
00E557  1  99 15 02           sta Sprite_Tilenumber+20,y  ;and save in third row
00E55A  1  68                 pla
00E55B  1  99 11 02           sta Sprite_Tilenumber+16,y
00E55E  1               
00E55E  1               CheckForESymmetry:
00E55E  1  AD 6A 03             lda BowserGfxFlag           ;are we drawing bowser at all?
00E561  1  D0 B6                bne SkipToOffScrChk         ;branch if so
00E563  1  A5 EF                lda $ef
00E565  1  A6 EC                ldx $ec                     ;get alternate enemy state
00E567  1  C9 05                cmp #$05                    ;check for hammer bro object
00E569  1  D0 03                bne ContES
00E56B  1  4C 1C E6             jmp SprObjectOffscrChk      ;jump if found
00E56E  1  C9 07        ContES: cmp #Bloober                ;check for bloober object
00E570  1  F0 1D                beq MirrorEnemyGfx
00E572  1  C9 0D                cmp #PiranhaPlant           ;check for piranha plant object
00E574  1  F0 19                beq MirrorEnemyGfx
00E576  1  C9 0C                cmp #Podoboo                ;check for podoboo object
00E578  1  F0 15                beq MirrorEnemyGfx          ;branch if either of three are found
00E57A  1  C9 12                cmp #Spiny                  ;check for spiny object
00E57C  1  D0 04                bne ESRtnr                  ;branch closer if not found
00E57E  1  E0 05                cpx #$05                    ;check spiny's state
00E580  1  D0 48                bne CheckToMirrorLakitu     ;branch if not an egg, otherwise
00E582  1  C9 15        ESRtnr: cmp #$15                    ;check for princess/mushroom retainer object
00E584  1  D0 05                bne SpnySC
00E586  1  A9 42                lda #$42                    ;set horizontal flip on bottom right sprite
00E588  1  99 16 02             sta Sprite_Attributes+20,y  ;note that palette bits were already set earlier
00E58B  1  E0 02        SpnySC: cpx #$02                    ;if alternate enemy state set to 1 or 0, branch
00E58D  1  90 3B                bcc CheckToMirrorLakitu
00E58F  1               
00E58F  1               MirrorEnemyGfx:
00E58F  1  AD 6A 03             lda BowserGfxFlag           ;if enemy object is bowser, skip all of this
00E592  1  D0 36                bne CheckToMirrorLakitu
00E594  1  B9 02 02             lda Sprite_Attributes,y     ;load attribute bits of first sprite
00E597  1  29 A3                and #%10100011
00E599  1  99 02 02             sta Sprite_Attributes,y     ;save vertical flip, priority, and palette bits
00E59C  1  99 0A 02             sta Sprite_Attributes+8,y   ;in left sprite column of enemy object OAM data
00E59F  1  99 12 02             sta Sprite_Attributes+16,y
00E5A2  1  09 40                ora #%01000000              ;set horizontal flip
00E5A4  1  E0 05                cpx #$05                    ;check for state used by spiny's egg
00E5A6  1  D0 02                bne EggExc                  ;if alternate state not set to $05, branch
00E5A8  1  09 80                ora #%10000000              ;otherwise set vertical flip
00E5AA  1  99 06 02     EggExc: sta Sprite_Attributes+4,y   ;set bits of right sprite column
00E5AD  1  99 0E 02             sta Sprite_Attributes+12,y  ;of enemy object sprite data
00E5B0  1  99 16 02             sta Sprite_Attributes+20,y
00E5B3  1  E0 04                cpx #$04                    ;check alternate enemy state
00E5B5  1  D0 13                bne CheckToMirrorLakitu     ;branch if not $04
00E5B7  1  B9 0A 02             lda Sprite_Attributes+8,y   ;get second row left sprite attributes
00E5BA  1  09 80                ora #%10000000
00E5BC  1  99 0A 02             sta Sprite_Attributes+8,y   ;store bits with vertical flip in
00E5BF  1  99 12 02             sta Sprite_Attributes+16,y  ;second and third row left sprites
00E5C2  1  09 40                ora #%01000000
00E5C4  1  99 0E 02             sta Sprite_Attributes+12,y  ;store with horizontal and vertical flip in
00E5C7  1  99 16 02             sta Sprite_Attributes+20,y  ;second and third row right sprites
00E5CA  1               
00E5CA  1               CheckToMirrorLakitu:
00E5CA  1  A5 EF                lda $ef                     ;check for lakitu enemy object
00E5CC  1  C9 11                cmp #Lakitu
00E5CE  1  D0 36                bne CheckToMirrorJSpring    ;branch if not found
00E5D0  1  AD 09 01             lda VerticalFlipFlag
00E5D3  1  D0 21                bne NVFLak                  ;branch if vertical flip flag not set
00E5D5  1  B9 12 02             lda Sprite_Attributes+16,y  ;save vertical flip and palette bits
00E5D8  1  29 81                and #%10000001              ;in third row left sprite
00E5DA  1  99 12 02             sta Sprite_Attributes+16,y
00E5DD  1  B9 16 02             lda Sprite_Attributes+20,y  ;set horizontal flip and palette bits
00E5E0  1  09 41                ora #%01000001              ;in third row right sprite
00E5E2  1  99 16 02             sta Sprite_Attributes+20,y
00E5E5  1  AE 8F 07             ldx FrenzyEnemyTimer        ;check timer
00E5E8  1  E0 10                cpx #$10
00E5EA  1  B0 30                bcs SprObjectOffscrChk      ;branch if timer has not reached a certain range
00E5EC  1  99 0E 02             sta Sprite_Attributes+12,y  ;otherwise set same for second row right sprite
00E5EF  1  29 81                and #%10000001
00E5F1  1  99 0A 02             sta Sprite_Attributes+8,y   ;preserve vertical flip and palette bits for left sprite
00E5F4  1  90 26                bcc SprObjectOffscrChk      ;unconditional branch
00E5F6  1  B9 02 02     NVFLak: lda Sprite_Attributes,y     ;get first row left sprite attributes
00E5F9  1  29 81                and #%10000001
00E5FB  1  99 02 02             sta Sprite_Attributes,y     ;save vertical flip and palette bits
00E5FE  1  B9 06 02             lda Sprite_Attributes+4,y   ;get first row right sprite attributes
00E601  1  09 41                ora #%01000001              ;set horizontal flip and palette bits
00E603  1  99 06 02             sta Sprite_Attributes+4,y   ;note that vertical flip is left as-is
00E606  1               
00E606  1               CheckToMirrorJSpring:
00E606  1  A5 EF              lda $ef                     ;check for jumpspring object (any frame)
00E608  1  C9 18              cmp #$18
00E60A  1  90 10              bcc SprObjectOffscrChk      ;branch if not jumpspring object at all
00E60C  1  A9 82              lda #$82
00E60E  1  99 0A 02           sta Sprite_Attributes+8,y   ;set vertical flip and palette bits of
00E611  1  99 12 02           sta Sprite_Attributes+16,y  ;second and third row left sprites
00E614  1  09 40              ora #%01000000
00E616  1  99 0E 02           sta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip
00E619  1  99 16 02           sta Sprite_Attributes+20,y  ;for second and third row right sprites
00E61C  1               
00E61C  1               SprObjectOffscrChk:
00E61C  1  A6 08                 ldx ObjectOffset          ;get enemy buffer offset
00E61E  1  AD D1 03              lda Enemy_OffscreenBits   ;check offscreen information
00E621  1  4A                    lsr
00E622  1  4A                    lsr                       ;shift three times to the right
00E623  1  4A                    lsr                       ;which puts d2 into carry
00E624  1  48                    pha                       ;save to stack
00E625  1  90 05                 bcc LcChk                 ;branch if not set
00E627  1  A9 04                 lda #$04                  ;set for right column sprites
00E629  1  20 79 E6              jsr MoveESprColOffscreen  ;and move them offscreen
00E62C  1  68           LcChk:   pla                       ;get from stack
00E62D  1  4A                    lsr                       ;move d3 to carry
00E62E  1  48                    pha                       ;save to stack
00E62F  1  90 05                 bcc Row3C                 ;branch if not set
00E631  1  A9 00                 lda #$00                  ;set for left column sprites,
00E633  1  20 79 E6              jsr MoveESprColOffscreen  ;move them offscreen
00E636  1  68           Row3C:   pla                       ;get from stack again
00E637  1  4A                    lsr                       ;move d5 to carry this time
00E638  1  4A                    lsr
00E639  1  48                    pha                       ;save to stack again
00E63A  1  90 05                 bcc Row23C                ;branch if carry not set
00E63C  1  A9 10                 lda #$10                  ;set for third row of sprites
00E63E  1  20 6F E6              jsr MoveESprRowOffscreen  ;and move them offscreen
00E641  1  68           Row23C:  pla                       ;get from stack
00E642  1  4A                    lsr                       ;move d6 into carry
00E643  1  48                    pha                       ;save to stack
00E644  1  90 05                 bcc AllRowC
00E646  1  A9 08                 lda #$08                  ;set for second and third rows
00E648  1  20 6F E6              jsr MoveESprRowOffscreen  ;move them offscreen
00E64B  1  68           AllRowC: pla                       ;get from stack once more
00E64C  1  4A                    lsr                       ;move d7 into carry
00E64D  1  90 12                 bcc ExEGHandler
00E64F  1  20 6F E6              jsr MoveESprRowOffscreen  ;move all sprites offscreen (A should be 0 by now)
00E652  1  B5 16                 lda Enemy_ID,x
00E654  1  C9 0C                 cmp #Podoboo              ;check enemy identifier for podoboo
00E656  1  F0 09                 beq ExEGHandler           ;skip this part if found, we do not want to erase podoboo!
00E658  1  B5 B6                 lda Enemy_Y_HighPos,x     ;check high byte of vertical position
00E65A  1  C9 02                 cmp #$02                  ;if not yet past the bottom of the screen, branch
00E65C  1  D0 03                 bne ExEGHandler
00E65E  1  20 CE C5              jsr EraseEnemyObject      ;what it says
00E661  1               
00E661  1               ExEGHandler:
00E661  1  60                 rts
00E662  1               
00E662  1               DrawEnemyObjRow:
00E662  1  BD F6 E1           lda EnemyGraphicsTable,x    ;load two tiles of enemy graphics
00E665  1  85 00              sta $00
00E667  1  BD F7 E1           lda EnemyGraphicsTable+1,x
00E66A  1               
00E66A  1               DrawOneSpriteRow:
00E66A  1  85 01              sta $01
00E66C  1  4C 1A ED           jmp DrawSpriteObject        ;draw them
00E66F  1               
00E66F  1               MoveESprRowOffscreen:
00E66F  1  18                 clc                         ;add A to enemy object OAM data offset
00E670  1  7D E5 06           adc Enemy_SprDataOffset,x
00E673  1  A8                 tay                         ;use as offset
00E674  1  A9 F8              lda #$f8
00E676  1  4C 79 E0           jmp DumpTwoSpr              ;move first row of sprites offscreen
00E679  1               
00E679  1               MoveESprColOffscreen:
00E679  1  18                 clc                         ;add A to enemy object OAM data offset
00E67A  1  7D E5 06           adc Enemy_SprDataOffset,x
00E67D  1  A8                 tay                         ;use as offset
00E67E  1  20 02 E7           jsr MoveColOffscreen        ;move first and second row sprites in column offscreen
00E681  1  99 10 02           sta Sprite_Data+16,y        ;move third row sprite in column offscreen
00E684  1  60                 rts
00E685  1               
00E685  1               ;-------------------------------------------------------------------------------------
00E685  1               ;$00-$01 - tile numbers
00E685  1               ;$02 - relative Y position
00E685  1               ;$03 - horizontal flip flag (not used here)
00E685  1               ;$04 - attributes
00E685  1               ;$05 - relative X position
00E685  1               
00E685  1               DefaultBlockObjTiles:
00E685  1  85 85 86 86        .byte $85, $85, $86, $86             ;brick w/ line (these are sprite tiles, not BG!)
00E689  1               
00E689  1               DrawBlock:
00E689  1  AD BC 03                lda Block_Rel_YPos            ;get relative vertical coordinate of block object
00E68C  1  85 02                   sta $02                       ;store here
00E68E  1  AD B1 03                lda Block_Rel_XPos            ;get relative horizontal coordinate of block object
00E691  1  85 05                   sta $05                       ;store here
00E693  1  A9 03                   lda #$03
00E695  1  85 04                   sta $04                       ;set attribute byte here
00E697  1  4A                      lsr
00E698  1  85 03                   sta $03                       ;set horizontal flip bit here (will not be used)
00E69A  1  BC EC 06                ldy Block_SprDataOffset,x     ;get sprite data offset
00E69D  1  A2 00                   ldx #$00                      ;reset X for use as offset to tile data
00E69F  1  BD 85 E6     DBlkLoop:  lda DefaultBlockObjTiles,x    ;get left tile number
00E6A2  1  85 00                   sta $00                       ;set here
00E6A4  1  BD 86 E6                lda DefaultBlockObjTiles+1,x  ;get right tile number
00E6A7  1  20 6A E6                jsr DrawOneSpriteRow          ;do sub to write tile numbers to first row of sprites
00E6AA  1  E0 04                   cpx #$04                      ;check incremented offset
00E6AC  1  D0 F1                   bne DBlkLoop                  ;and loop back until all four sprites are done
00E6AE  1  A6 08                   ldx ObjectOffset              ;get block object offset
00E6B0  1  BC EC 06                ldy Block_SprDataOffset,x     ;get sprite data offset
00E6B3  1  AD 4E 07                lda AreaType
00E6B6  1  C9 01                   cmp #$01                      ;check for ground level type area
00E6B8  1  F0 08                   beq ChkRep                    ;if found, branch to next part
00E6BA  1  A9 86                   lda #$86
00E6BC  1  99 01 02                sta Sprite_Tilenumber,y       ;otherwise remove brick tiles with lines
00E6BF  1  99 05 02                sta Sprite_Tilenumber+4,y     ;and replace then with lineless brick tiles
00E6C2  1  BD E8 03     ChkRep:    lda Block_Metatile,x          ;check replacement metatile
00E6C5  1  C9 C4                   cmp #$c4                      ;if not used block metatile, then
00E6C7  1  D0 24                   bne BlkOffscr                 ;branch ahead to use current graphics
00E6C9  1  A9 87                   lda #$87                      ;set A for used block tile
00E6CB  1  C8                      iny                           ;increment Y to write to tile bytes
00E6CC  1  20 73 E0                jsr DumpFourSpr               ;do sub to dump into all four sprites
00E6CF  1  88                      dey                           ;return Y to original offset
00E6D0  1  A9 03                   lda #$03                      ;set palette bits
00E6D2  1  AE 4E 07                ldx AreaType
00E6D5  1  CA                      dex                           ;check for ground level type area again
00E6D6  1  F0 01                   beq SetBFlip                  ;if found, use current palette bits
00E6D8  1  4A                      lsr                           ;otherwise set to $01
00E6D9  1  A6 08        SetBFlip:  ldx ObjectOffset              ;put block object offset back in X
00E6DB  1  99 02 02                sta Sprite_Attributes,y       ;store attribute byte as-is in first sprite
00E6DE  1  09 40                   ora #%01000000
00E6E0  1  99 06 02                sta Sprite_Attributes+4,y     ;set horizontal flip bit for second sprite
00E6E3  1  09 80                   ora #%10000000
00E6E5  1  99 0E 02                sta Sprite_Attributes+12,y    ;set both flip bits for fourth sprite
00E6E8  1  29 83                   and #%10000011
00E6EA  1  99 0A 02                sta Sprite_Attributes+8,y     ;set vertical flip bit for third sprite
00E6ED  1  AD D4 03     BlkOffscr: lda Block_OffscreenBits       ;get offscreen bits for block object
00E6F0  1  48                      pha                           ;save to stack
00E6F1  1  29 04                   and #%00000100                ;check to see if d2 in offscreen bits are set
00E6F3  1  F0 08                   beq PullOfsB                  ;if not set, branch, otherwise move sprites offscreen
00E6F5  1  A9 F8                   lda #$f8                      ;move offscreen two OAMs
00E6F7  1  99 04 02                sta Sprite_Y_Position+4,y     ;on the right side
00E6FA  1  99 0C 02                sta Sprite_Y_Position+12,y
00E6FD  1  68           PullOfsB:  pla                           ;pull offscreen bits from stack
00E6FE  1  29 08        ChkLeftCo: and #%00001000                ;check to see if d3 in offscreen bits are set
00E700  1  F0 08                   beq ExDBlk                    ;if not set, branch, otherwise move sprites offscreen
00E702  1               
00E702  1               MoveColOffscreen:
00E702  1  A9 F8                lda #$f8                   ;move offscreen two OAMs
00E704  1  99 00 02             sta Sprite_Y_Position,y    ;on the left side (or two rows of enemy on either side
00E707  1  99 08 02             sta Sprite_Y_Position+8,y  ;if branched here from enemy graphics handler)
00E70A  1  60           ExDBlk: rts
00E70B  1               
00E70B  1               ;-------------------------------------------------------------------------------------
00E70B  1               ;$00 - used to hold palette bits for attribute byte or relative X position
00E70B  1               
00E70B  1               DrawBrickChunks:
00E70B  1  A9 02                 lda #$02                   ;set palette bits here
00E70D  1  85 00                 sta $00
00E70F  1  A9 75                 lda #$75                   ;set tile number for ball (something residual, likely)
00E711  1  A4 0E                 ldy GameEngineSubroutine
00E713  1  C0 05                 cpy #$05                   ;if end-of-level routine running,
00E715  1  F0 06                 beq DChunks                ;use palette and tile number assigned
00E717  1  A9 03                 lda #$03                   ;otherwise set different palette bits
00E719  1  85 00                 sta $00
00E71B  1  A9 84                 lda #$84                   ;and set tile number for brick chunks
00E71D  1  BC EC 06     DChunks: ldy Block_SprDataOffset,x  ;get OAM data offset
00E720  1  C8                    iny                        ;increment to start with tile bytes in OAM
00E721  1  20 73 E0              jsr DumpFourSpr            ;do sub to dump tile number into all four sprites
00E724  1  A5 09                 lda FrameCounter           ;get frame counter
00E726  1  0A                    asl
00E727  1  0A                    asl
00E728  1  0A                    asl                        ;move low nybble to high
00E729  1  0A                    asl
00E72A  1  29 C0                 and #$c0                   ;get what was originally d3-d2 of low nybble
00E72C  1  05 00                 ora $00                    ;add palette bits
00E72E  1  C8                    iny                        ;increment offset for attribute bytes
00E72F  1  20 73 E0              jsr DumpFourSpr            ;do sub to dump attribute data into all four sprites
00E732  1  88                    dey
00E733  1  88                    dey                        ;decrement offset to Y coordinate
00E734  1  AD BC 03              lda Block_Rel_YPos         ;get first block object's relative vertical coordinate
00E737  1  20 79 E0              jsr DumpTwoSpr             ;do sub to dump current Y coordinate into two sprites
00E73A  1  AD B1 03              lda Block_Rel_XPos         ;get first block object's relative horizontal coordinate
00E73D  1  99 03 02              sta Sprite_X_Position,y    ;save into X coordinate of first sprite
00E740  1  BD F1 03              lda Block_Orig_XPos,x      ;get original horizontal coordinate
00E743  1  38                    sec
00E744  1  ED 1C 07              sbc ScreenLeft_X_Pos       ;subtract coordinate of left side from original coordinate
00E747  1  85 00                 sta $00                    ;store result as relative horizontal coordinate of original
00E749  1  38                    sec
00E74A  1  ED B1 03              sbc Block_Rel_XPos         ;get difference of relative positions of original - current
00E74D  1  65 00                 adc $00                    ;add original relative position to result
00E74F  1  69 06                 adc #$06                   ;plus 6 pixels to position second brick chunk correctly
00E751  1  99 07 02              sta Sprite_X_Position+4,y  ;save into X coordinate of second sprite
00E754  1  AD BD 03              lda Block_Rel_YPos+1       ;get second block object's relative vertical coordinate
00E757  1  99 08 02              sta Sprite_Y_Position+8,y
00E75A  1  99 0C 02              sta Sprite_Y_Position+12,y ;dump into Y coordinates of third and fourth sprites
00E75D  1  AD B2 03              lda Block_Rel_XPos+1       ;get second block object's relative horizontal coordinate
00E760  1  99 0B 02              sta Sprite_X_Position+8,y  ;save into X coordinate of third sprite
00E763  1  A5 00                 lda $00                    ;use original relative horizontal position
00E765  1  38                    sec
00E766  1  ED B2 03              sbc Block_Rel_XPos+1       ;get difference of relative positions of original - current
00E769  1  65 00                 adc $00                    ;add original relative position to result
00E76B  1  69 06                 adc #$06                   ;plus 6 pixels to position fourth brick chunk correctly
00E76D  1  99 0F 02              sta Sprite_X_Position+12,y ;save into X coordinate of fourth sprite
00E770  1  AD D4 03              lda Block_OffscreenBits    ;get offscreen bits for block object
00E773  1  20 FE E6              jsr ChkLeftCo              ;do sub to move left half of sprites offscreen if necessary
00E776  1  AD D4 03              lda Block_OffscreenBits    ;get offscreen bits again
00E779  1  0A                    asl                        ;shift d7 into carry
00E77A  1  90 05                 bcc ChnkOfs                ;if d7 not set, branch to last part
00E77C  1  A9 F8                 lda #$f8
00E77E  1  20 79 E0              jsr DumpTwoSpr             ;otherwise move top sprites offscreen
00E781  1  A5 00        ChnkOfs: lda $00                    ;if relative position on left side of screen,
00E783  1  10 10                 bpl ExBCDr                 ;go ahead and leave
00E785  1  B9 03 02              lda Sprite_X_Position,y    ;otherwise compare left-side X coordinate
00E788  1  D9 07 02              cmp Sprite_X_Position+4,y  ;to right-side X coordinate
00E78B  1  90 08                 bcc ExBCDr                 ;branch to leave if less
00E78D  1  A9 F8                 lda #$f8                   ;otherwise move right half of sprites offscreen
00E78F  1  99 04 02              sta Sprite_Y_Position+4,y
00E792  1  99 0C 02              sta Sprite_Y_Position+12,y
00E795  1  60           ExBCDr:  rts                        ;leave
00E796  1               
00E796  1               ;-------------------------------------------------------------------------------------
00E796  1               
00E796  1               DrawFireball:
00E796  1  BC F1 06           ldy FBall_SprDataOffset,x  ;get fireball's sprite data offset
00E799  1  AD BA 03           lda Fireball_Rel_YPos      ;get relative vertical coordinate
00E79C  1  99 00 02           sta Sprite_Y_Position,y    ;store as sprite Y coordinate
00E79F  1  AD AF 03           lda Fireball_Rel_XPos      ;get relative horizontal coordinate
00E7A2  1  99 03 02           sta Sprite_X_Position,y    ;store as sprite X coordinate, then do shared code
00E7A5  1               
00E7A5  1               DrawFirebar:
00E7A5  1  A5 09               lda FrameCounter         ;get frame counter
00E7A7  1  4A                  lsr                      ;divide by four
00E7A8  1  4A                  lsr
00E7A9  1  48                  pha                      ;save result to stack
00E7AA  1  29 01               and #$01                 ;mask out all but last bit
00E7AC  1  49 64               eor #$64                 ;set either tile $64 or $65 as fireball tile
00E7AE  1  99 01 02            sta Sprite_Tilenumber,y  ;thus tile changes every four frames
00E7B1  1  68                  pla                      ;get from stack
00E7B2  1  4A                  lsr                      ;divide by four again
00E7B3  1  4A                  lsr
00E7B4  1  A9 02               lda #$02                 ;load value $02 to set palette in attrib byte
00E7B6  1  90 02               bcc FireA                ;if last bit shifted out was not set, skip this
00E7B8  1  09 C0               ora #%11000000           ;otherwise flip both ways every eight frames
00E7BA  1  99 02 02     FireA: sta Sprite_Attributes,y  ;store attribute byte and leave
00E7BD  1  60                  rts
00E7BE  1               
00E7BE  1               ;-------------------------------------------------------------------------------------
00E7BE  1               
00E7BE  1               ExplosionTiles:
00E7BE  1  68 67 66           .byte $68, $67, $66
00E7C1  1               
00E7C1  1               DrawExplosion_Fireball:
00E7C1  1  BC EC 06           ldy Alt_SprDataOffset,x  ;get OAM data offset of alternate sort for fireball's explosion
00E7C4  1  B5 24              lda Fireball_State,x     ;load fireball state
00E7C6  1  F6 24              inc Fireball_State,x     ;increment state for next frame
00E7C8  1  4A                 lsr                      ;divide by 2
00E7C9  1  29 07              and #%00000111           ;mask out all but d3-d1
00E7CB  1  C9 03              cmp #$03                 ;check to see if time to kill fireball
00E7CD  1  B0 4A              bcs KillFireBall         ;branch if so, otherwise continue to draw explosion
00E7CF  1               
00E7CF  1               DrawExplosion_Fireworks:
00E7CF  1  AA                 tax                         ;use whatever's in A for offset
00E7D0  1  BD BE E7           lda ExplosionTiles,x        ;get tile number using offset
00E7D3  1  C8                 iny                         ;increment Y (contains sprite data offset)
00E7D4  1  20 73 E0           jsr DumpFourSpr             ;and dump into tile number part of sprite data
00E7D7  1  88                 dey                         ;decrement Y so we have the proper offset again
00E7D8  1  A6 08              ldx ObjectOffset            ;return enemy object buffer offset to X
00E7DA  1  AD BA 03           lda Fireball_Rel_YPos       ;get relative vertical coordinate
00E7DD  1  38                 sec                         ;subtract four pixels vertically
00E7DE  1  E9 04              sbc #$04                    ;for first and third sprites
00E7E0  1  99 00 02           sta Sprite_Y_Position,y
00E7E3  1  99 08 02           sta Sprite_Y_Position+8,y
00E7E6  1  18                 clc                         ;add eight pixels vertically
00E7E7  1  69 08              adc #$08                    ;for second and fourth sprites
00E7E9  1  99 04 02           sta Sprite_Y_Position+4,y
00E7EC  1  99 0C 02           sta Sprite_Y_Position+12,y
00E7EF  1  AD AF 03           lda Fireball_Rel_XPos       ;get relative horizontal coordinate
00E7F2  1  38                 sec                         ;subtract four pixels horizontally
00E7F3  1  E9 04              sbc #$04                    ;for first and second sprites
00E7F5  1  99 03 02           sta Sprite_X_Position,y
00E7F8  1  99 07 02           sta Sprite_X_Position+4,y
00E7FB  1  18                 clc                         ;add eight pixels horizontally
00E7FC  1  69 08              adc #$08                    ;for third and fourth sprites
00E7FE  1  99 0B 02           sta Sprite_X_Position+8,y
00E801  1  99 0F 02           sta Sprite_X_Position+12,y
00E804  1  A9 02              lda #$02                    ;set palette attributes for all sprites, but
00E806  1  99 02 02           sta Sprite_Attributes,y     ;set no flip at all for first sprite
00E809  1  A9 82              lda #$82
00E80B  1  99 06 02           sta Sprite_Attributes+4,y   ;set vertical flip for second sprite
00E80E  1  A9 42              lda #$42
00E810  1  99 0A 02           sta Sprite_Attributes+8,y   ;set horizontal flip for third sprite
00E813  1  A9 C2              lda #$c2
00E815  1  99 0E 02           sta Sprite_Attributes+12,y  ;set both flips for fourth sprite
00E818  1  60                 rts                         ;we are done
00E819  1               
00E819  1               KillFireBall:
00E819  1  A9 00              lda #$00                    ;clear fireball state to kill it
00E81B  1  95 24              sta Fireball_State,x
00E81D  1  60                 rts
00E81E  1               
00E81E  1               ;-------------------------------------------------------------------------------------
00E81E  1               
00E81E  1               DrawSmallPlatform:
00E81E  1  BC E5 06            ldy Enemy_SprDataOffset,x   ;get OAM data offset
00E821  1  A9 5B               lda #$5b                    ;load tile number for small platforms
00E823  1  C8                  iny                         ;increment offset for tile numbers
00E824  1  20 6D E0            jsr DumpSixSpr              ;dump tile number into all six sprites
00E827  1  C8                  iny                         ;increment offset for attributes
00E828  1  A9 02               lda #$02                    ;load palette controls
00E82A  1  20 6D E0            jsr DumpSixSpr              ;dump attributes into all six sprites
00E82D  1  88                  dey                         ;decrement for original offset
00E82E  1  88                  dey
00E82F  1  AD AE 03            lda Enemy_Rel_XPos          ;get relative horizontal coordinate
00E832  1  99 03 02            sta Sprite_X_Position,y
00E835  1  99 0F 02            sta Sprite_X_Position+12,y  ;dump as X coordinate into first and fourth sprites
00E838  1  18                  clc
00E839  1  69 08               adc #$08                    ;add eight pixels
00E83B  1  99 07 02            sta Sprite_X_Position+4,y   ;dump into second and fifth sprites
00E83E  1  99 13 02            sta Sprite_X_Position+16,y
00E841  1  18                  clc
00E842  1  69 08               adc #$08                    ;add eight more pixels
00E844  1  99 0B 02            sta Sprite_X_Position+8,y   ;dump into third and sixth sprites
00E847  1  99 17 02            sta Sprite_X_Position+20,y
00E84A  1  B5 CF               lda Enemy_Y_Position,x      ;get vertical coordinate
00E84C  1  AA                  tax
00E84D  1  48                  pha                         ;save to stack
00E84E  1  E0 20               cpx #$20                    ;if vertical coordinate below status bar,
00E850  1  B0 02               bcs TopSP                   ;do not mess with it
00E852  1  A9 F8               lda #$f8                    ;otherwise move first three sprites offscreen
00E854  1  20 76 E0     TopSP: jsr DumpThreeSpr            ;dump vertical coordinate into Y coordinates
00E857  1  68                  pla                         ;pull from stack
00E858  1  18                  clc
00E859  1  69 80               adc #$80                    ;add 128 pixels
00E85B  1  AA                  tax
00E85C  1  E0 20               cpx #$20                    ;if below status bar (taking wrap into account)
00E85E  1  B0 02               bcs BotSP                   ;then do not change altered coordinate
00E860  1  A9 F8               lda #$f8                    ;otherwise move last three sprites offscreen
00E862  1  99 0C 02     BotSP: sta Sprite_Y_Position+12,y  ;dump vertical coordinate + 128 pixels
00E865  1  99 10 02            sta Sprite_Y_Position+16,y  ;into Y coordinates
00E868  1  99 14 02            sta Sprite_Y_Position+20,y
00E86B  1  AD D1 03            lda Enemy_OffscreenBits     ;get offscreen bits
00E86E  1  48                  pha                         ;save to stack
00E86F  1  29 08               and #%00001000              ;check d3
00E871  1  F0 08               beq SOfs
00E873  1  A9 F8               lda #$f8                    ;if d3 was set, move first and
00E875  1  99 00 02            sta Sprite_Y_Position,y     ;fourth sprites offscreen
00E878  1  99 0C 02            sta Sprite_Y_Position+12,y
00E87B  1  68           SOfs:  pla                         ;move out and back into stack
00E87C  1  48                  pha
00E87D  1  29 04               and #%00000100              ;check d2
00E87F  1  F0 08               beq SOfs2
00E881  1  A9 F8               lda #$f8                    ;if d2 was set, move second and
00E883  1  99 04 02            sta Sprite_Y_Position+4,y   ;fifth sprites offscreen
00E886  1  99 10 02            sta Sprite_Y_Position+16,y
00E889  1  68           SOfs2: pla                         ;get from stack
00E88A  1  29 02               and #%00000010              ;check d1
00E88C  1  F0 08               beq ExSPl
00E88E  1  A9 F8               lda #$f8                    ;if d1 was set, move third and
00E890  1  99 08 02            sta Sprite_Y_Position+8,y   ;sixth sprites offscreen
00E893  1  99 14 02            sta Sprite_Y_Position+20,y
00E896  1  A6 08        ExSPl: ldx ObjectOffset            ;get enemy object offset and leave
00E898  1  60                  rts
00E899  1               
00E899  1               ;-------------------------------------------------------------------------------------
00E899  1               
00E899  1               DrawBubble:
00E899  1  A4 B5                ldy Player_Y_HighPos        ;if player's vertical high position
00E89B  1  88                   dey                         ;not within screen, skip all of this
00E89C  1  D0 20                bne ExDBub
00E89E  1  AD D3 03             lda Bubble_OffscreenBits    ;check air bubble's offscreen bits
00E8A1  1  29 08                and #%00001000
00E8A3  1  D0 19                bne ExDBub                  ;if bit set, branch to leave
00E8A5  1  BC EE 06             ldy Bubble_SprDataOffset,x  ;get air bubble's OAM data offset
00E8A8  1  AD B0 03             lda Bubble_Rel_XPos         ;get relative horizontal coordinate
00E8AB  1  99 03 02             sta Sprite_X_Position,y     ;store as X coordinate here
00E8AE  1  AD BB 03             lda Bubble_Rel_YPos         ;get relative vertical coordinate
00E8B1  1  99 00 02             sta Sprite_Y_Position,y     ;store as Y coordinate here
00E8B4  1  A9 74                lda #$74
00E8B6  1  99 01 02             sta Sprite_Tilenumber,y     ;put air bubble tile into OAM data
00E8B9  1  A9 02                lda #$02
00E8BB  1  99 02 02             sta Sprite_Attributes,y     ;set attribute byte
00E8BE  1  60           ExDBub: rts                         ;leave
00E8BF  1               
00E8BF  1               ;-------------------------------------------------------------------------------------
00E8BF  1               ;$00 - used to store player's vertical offscreen bits
00E8BF  1               
00E8BF  1               PlayerGfxTblOffsets:
00E8BF  1  20 28 C8 18        .byte $20, $28, $c8, $18, $00, $40, $50, $58
00E8C3  1  00 40 50 58  
00E8C7  1  80 88 B8 78        .byte $80, $88, $b8, $78, $60, $a0, $b0, $b8
00E8CB  1  60 A0 B0 B8  
00E8CF  1               
00E8CF  1               ;tiles arranged in order, 2 tiles per row, top to bottom
00E8CF  1               
00E8CF  1               PlayerGraphicsTable:
00E8CF  1               ;big player table
00E8CF  1  00 01 02 03        .byte $00, $01, $02, $03, $04, $05, $06, $07 ;walking frame 1
00E8D3  1  04 05 06 07  
00E8D7  1  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $0d, $0e, $0f ;        frame 2
00E8DB  1  0C 0D 0E 0F  
00E8DF  1  10 11 12 13        .byte $10, $11, $12, $13, $14, $15, $16, $17 ;        frame 3
00E8E3  1  14 15 16 17  
00E8E7  1  18 19 1A 1B        .byte $18, $19, $1a, $1b, $1c, $1d, $1e, $1f ;skidding
00E8EB  1  1C 1D 1E 1F  
00E8EF  1  20 21 22 23        .byte $20, $21, $22, $23, $24, $25, $26, $27 ;jumping
00E8F3  1  24 25 26 27  
00E8F7  1  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $2c, $2d ;swimming frame 1
00E8FB  1  2A 2B 2C 2D  
00E8FF  1  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $30, $2c, $2d ;         frame 2
00E903  1  0C 30 2C 2D  
00E907  1  08 09 0A 0B        .byte $08, $09, $0a, $0b, $2e, $2f, $2c, $2d ;         frame 3
00E90B  1  2E 2F 2C 2D  
00E90F  1  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $5c, $5d ;climbing frame 1
00E913  1  2A 2B 5C 5D  
00E917  1  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $0d, $5e, $5f ;         frame 2
00E91B  1  0C 0D 5E 5F  
00E91F  1  FC FC 08 09        .byte $fc, $fc, $08, $09, $58, $59, $5a, $5a ;crouching
00E923  1  58 59 5A 5A  
00E927  1  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $0e, $0f ;fireball throwing
00E92B  1  2A 2B 0E 0F  
00E92F  1               
00E92F  1               ;small player table
00E92F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $34, $35 ;walking frame 1
00E933  1  32 33 34 35  
00E937  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $36, $37, $38, $39 ;        frame 2
00E93B  1  36 37 38 39  
00E93F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $3b, $3c ;        frame 3
00E943  1  3A 37 3B 3C  
00E947  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3d, $3e, $3f, $40 ;skidding
00E94B  1  3D 3E 3F 40  
00E94F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $41, $42, $43 ;jumping
00E953  1  32 41 42 43  
00E957  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $44, $45 ;swimming frame 1
00E95B  1  32 33 44 45  
00E95F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $44, $47 ;         frame 2
00E963  1  32 33 44 47  
00E967  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $48, $49 ;         frame 3
00E96B  1  32 33 48 49  
00E96F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $90, $91 ;climbing frame 1
00E973  1  32 33 90 91  
00E977  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $92, $93 ;         frame 2
00E97B  1  3A 37 92 93  
00E97F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $9e, $9e, $9f, $9f ;killed
00E983  1  9E 9E 9F 9F  
00E987  1               
00E987  1               ;used by both player sizes
00E987  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $4f, $4f ;small player standing
00E98B  1  3A 37 4F 4F  
00E98F  1  FC FC 00 01        .byte $fc, $fc, $00, $01, $4c, $4d, $4e, $4e ;intermediate grow frame
00E993  1  4C 4D 4E 4E  
00E997  1  00 01 4C 4D        .byte $00, $01, $4c, $4d, $4a, $4a, $4b, $4b ;big player standing
00E99B  1  4A 4A 4B 4B  
00E99F  1               
00E99F  1               SwimKickTileNum:
00E99F  1  31 46              .byte $31, $46
00E9A1  1               
00E9A1  1               PlayerGfxHandler:
00E9A1  1  AD 9E 07             lda InjuryTimer             ;if player's injured invincibility timer
00E9A4  1  F0 05                beq CntPl                   ;not set, skip checkpoint and continue code
00E9A6  1  A5 09                lda FrameCounter
00E9A8  1  4A                   lsr                         ;otherwise check frame counter and branch
00E9A9  1  B0 40                bcs ExPGH                   ;to leave on every other frame (when d0 is set)
00E9AB  1  A5 0E        CntPl:  lda GameEngineSubroutine    ;if executing specific game engine routine,
00E9AD  1  C9 0B                cmp #$0b                    ;branch ahead to some other part
00E9AF  1  F0 47                beq PlayerKilled
00E9B1  1  AD 0B 07             lda PlayerChangeSizeFlag    ;if grow/shrink flag set
00E9B4  1  D0 3C                bne DoChangeSize            ;then branch to some other code
00E9B6  1  AC 04 07             ldy SwimmingFlag            ;if swimming flag set, branch to
00E9B9  1  F0 31                beq FindPlayerAction        ;different part, do not return
00E9BB  1  A5 1D                lda Player_State
00E9BD  1  C9 00                cmp #$00                    ;if player status normal,
00E9BF  1  F0 2B                beq FindPlayerAction        ;branch and do not return
00E9C1  1  20 EC E9             jsr FindPlayerAction        ;otherwise jump and return
00E9C4  1  A5 09                lda FrameCounter
00E9C6  1  29 04                and #%00000100              ;check frame counter for d2 set (8 frames every
00E9C8  1  D0 21                bne ExPGH                   ;eighth frame), and branch if set to leave
00E9CA  1  AA                   tax                         ;initialize X to zero
00E9CB  1  AC E4 06             ldy Player_SprDataOffset    ;get player sprite data offset
00E9CE  1  A5 33                lda PlayerFacingDir         ;get player's facing direction
00E9D0  1  4A                   lsr
00E9D1  1  B0 04                bcs SwimKT                  ;if player facing to the right, use current offset
00E9D3  1  C8                   iny
00E9D4  1  C8                   iny                         ;otherwise move to next OAM data
00E9D5  1  C8                   iny
00E9D6  1  C8                   iny
00E9D7  1  AD 54 07     SwimKT: lda PlayerSize              ;check player's size
00E9DA  1  F0 09                beq BigKTS                  ;if big, use first tile
00E9DC  1  B9 19 02             lda Sprite_Tilenumber+24,y  ;check tile number of seventh/eighth sprite
00E9DF  1  CD 6D E9             cmp SwimTileRepOffset       ;against tile number in player graphics table
00E9E2  1  F0 07                beq ExPGH                   ;if spr7/spr8 tile number = value, branch to leave
00E9E4  1  E8                   inx                         ;otherwise increment X for second tile
00E9E5  1  BD 9F E9     BigKTS: lda SwimKickTileNum,x       ;overwrite tile number in sprite 7/8
00E9E8  1  99 19 02             sta Sprite_Tilenumber+24,y  ;to animate player's feet when swimming
00E9EB  1  60           ExPGH:  rts                         ;then leave
00E9EC  1               
00E9EC  1               FindPlayerAction:
00E9EC  1  20 84 EA           jsr ProcessPlayerAction       ;find proper offset to graphics table by player's actions
00E9EF  1  4C FD E9           jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
00E9F2  1               
00E9F2  1               DoChangeSize:
00E9F2  1  20 48 EB           jsr HandleChangeSize          ;find proper offset to graphics table for grow/shrink
00E9F5  1  4C FD E9           jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
00E9F8  1               
00E9F8  1               PlayerKilled:
00E9F8  1  A0 0E              ldy #$0e                      ;load offset for player killed
00E9FA  1  B9 BF E8           lda PlayerGfxTblOffsets,y     ;get offset to graphics table
00E9FD  1               
00E9FD  1               PlayerGfxProcessing:
00E9FD  1  8D D5 06            sta PlayerGfxOffset           ;store offset to graphics table here
00EA00  1  A9 04               lda #$04
00EA02  1  20 56 EA            jsr RenderPlayerSub           ;draw player based on offset loaded
00EA05  1  20 81 EB            jsr ChkForPlayerAttrib        ;set horizontal flip bits as necessary
00EA08  1  AD 11 07            lda FireballThrowingTimer
00EA0B  1  F0 25               beq PlayerOffscreenChk        ;if fireball throw timer not set, skip to the end
00EA0D  1  A0 00               ldy #$00                      ;set value to initialize by default
00EA0F  1  AD 81 07            lda PlayerAnimTimer           ;get animation frame timer
00EA12  1  CD 11 07            cmp FireballThrowingTimer     ;compare to fireball throw timer
00EA15  1  8C 11 07            sty FireballThrowingTimer     ;initialize fireball throw timer
00EA18  1  B0 18               bcs PlayerOffscreenChk        ;if animation frame timer => fireball throw timer skip to end
00EA1A  1  8D 11 07            sta FireballThrowingTimer     ;otherwise store animation timer into fireball throw timer
00EA1D  1  A0 07               ldy #$07                      ;load offset for throwing
00EA1F  1  B9 BF E8            lda PlayerGfxTblOffsets,y     ;get offset to graphics table
00EA22  1  8D D5 06            sta PlayerGfxOffset           ;store it for use later
00EA25  1  A0 04               ldy #$04                      ;set to update four sprite rows by default
00EA27  1  A5 57               lda Player_X_Speed
00EA29  1  05 0C               ora Left_Right_Buttons        ;check for horizontal speed or left/right button press
00EA2B  1  F0 01               beq SUpdR                     ;if no speed or button press, branch using set value in Y
00EA2D  1  88                  dey                           ;otherwise set to update only three sprite rows
00EA2E  1  98           SUpdR: tya                           ;save in A for use
00EA2F  1  20 56 EA            jsr RenderPlayerSub           ;in sub, draw player object again
00EA32  1               
00EA32  1               PlayerOffscreenChk:
00EA32  1  AD D0 03                lda Player_OffscreenBits      ;get player's offscreen bits
00EA35  1  4A                      lsr
00EA36  1  4A                      lsr                           ;move vertical bits to low nybble
00EA37  1  4A                      lsr
00EA38  1  4A                      lsr
00EA39  1  85 00                   sta $00                       ;store here
00EA3B  1  A2 03                   ldx #$03                      ;check all four rows of player sprites
00EA3D  1  AD E4 06                lda Player_SprDataOffset      ;get player's sprite data offset
00EA40  1  18                      clc
00EA41  1  69 18                   adc #$18                      ;add 24 bytes to start at bottom row
00EA43  1  A8                      tay                           ;set as offset here
00EA44  1  A9 F8        PROfsLoop: lda #$f8                      ;load offscreen Y coordinate just in case
00EA46  1  46 00                   lsr $00                       ;shift bit into carry
00EA48  1  90 03                   bcc NPROffscr                 ;if bit not set, skip, do not move sprites
00EA4A  1  20 79 E0                jsr DumpTwoSpr                ;otherwise dump offscreen Y coordinate into sprite data
00EA4D  1  98           NPROffscr: tya
00EA4E  1  38                      sec                           ;subtract eight bytes to do
00EA4F  1  E9 08                   sbc #$08                      ;next row up
00EA51  1  A8                      tay
00EA52  1  CA                      dex                           ;decrement row counter
00EA53  1  10 EF                   bpl PROfsLoop                 ;do this until all sprite rows are checked
00EA55  1  60                      rts                           ;then we are done!
00EA56  1               
00EA56  1               ;-------------------------------------------------------------------------------------
00EA56  1               ;$00-$01 - used to hold tile numbers, $00 also used to hold upper extent of animation frames
00EA56  1               ;$02 - vertical position
00EA56  1               ;$03 - facing direction, used as horizontal flip control
00EA56  1               ;$04 - attributes
00EA56  1               ;$05 - horizontal position
00EA56  1               ;$07 - number of rows to draw
00EA56  1               ;these also used in IntermediatePlayerData
00EA56  1               
00EA56  1               RenderPlayerSub:
00EA56  1  85 07                sta $07                      ;store number of rows of sprites to draw
00EA58  1  AD AD 03             lda Player_Rel_XPos
00EA5B  1  8D 55 07             sta Player_Pos_ForScroll     ;store player's relative horizontal position
00EA5E  1  85 05                sta $05                      ;store it here also
00EA60  1  AD B8 03             lda Player_Rel_YPos
00EA63  1  85 02                sta $02                      ;store player's vertical position
00EA65  1  A5 33                lda PlayerFacingDir
00EA67  1  85 03                sta $03                      ;store player's facing direction
00EA69  1  AD C4 03             lda Player_SprAttrib
00EA6C  1  85 04                sta $04                      ;store player's sprite attributes
00EA6E  1  AE D5 06             ldx PlayerGfxOffset          ;load graphics table offset
00EA71  1  AC E4 06             ldy Player_SprDataOffset     ;get player's sprite data offset
00EA74  1               
00EA74  1               DrawPlayerLoop:
00EA74  1  BD CF E8             lda PlayerGraphicsTable,x    ;load player's left side
00EA77  1  85 00                sta $00
00EA79  1  BD D0 E8             lda PlayerGraphicsTable+1,x  ;now load right side
00EA7C  1  20 6A E6             jsr DrawOneSpriteRow
00EA7F  1  C6 07                dec $07                      ;decrement rows of sprites to draw
00EA81  1  D0 F1                bne DrawPlayerLoop           ;do this until all rows are drawn
00EA83  1  60                   rts
00EA84  1               
00EA84  1               ProcessPlayerAction:
00EA84  1  A5 1D                lda Player_State      ;get player's state
00EA86  1  C9 03                cmp #$03
00EA88  1  F0 52                beq ActionClimbing    ;if climbing, branch here
00EA8A  1  C9 02                cmp #$02
00EA8C  1  F0 3E                beq ActionFalling     ;if falling, branch here
00EA8E  1  C9 01                cmp #$01
00EA90  1  D0 11                bne ProcOnGroundActs  ;if not jumping, branch here
00EA92  1  AD 04 07             lda SwimmingFlag
00EA95  1  D0 51                bne ActionSwimming    ;if swimming flag set, branch elsewhere
00EA97  1  A0 06                ldy #$06              ;load offset for crouching
00EA99  1  AD 14 07             lda CrouchingFlag     ;get crouching flag
00EA9C  1  D0 22                bne NonAnimatedActs   ;if set, branch to get offset for graphics table
00EA9E  1  A0 00                ldy #$00              ;otherwise load offset for jumping
00EAA0  1  4C C0 EA             jmp NonAnimatedActs   ;go to get offset to graphics table
00EAA3  1               
00EAA3  1               ProcOnGroundActs:
00EAA3  1  A0 06                ldy #$06                   ;load offset for crouching
00EAA5  1  AD 14 07             lda CrouchingFlag          ;get crouching flag
00EAA8  1  D0 16                bne NonAnimatedActs        ;if set, branch to get offset for graphics table
00EAAA  1  A0 02                ldy #$02                   ;load offset for standing
00EAAC  1  A5 57                lda Player_X_Speed         ;check player's horizontal speed
00EAAE  1  05 0C                ora Left_Right_Buttons     ;and left/right controller bits
00EAB0  1  F0 0E                beq NonAnimatedActs        ;if no speed or buttons pressed, use standing offset
00EAB2  1  AD 00 07             lda Player_XSpeedAbsolute  ;load walking/running speed
00EAB5  1  C9 09                cmp #$09
00EAB7  1  90 1B                bcc ActionWalkRun          ;if less than a certain amount, branch, too slow to skid
00EAB9  1  A5 45                lda Player_MovingDir       ;otherwise check to see if moving direction
00EABB  1  25 33                and PlayerFacingDir        ;and facing direction are the same
00EABD  1  D0 15                bne ActionWalkRun          ;if moving direction = facing direction, branch, don't skid
00EABF  1  C8                   iny                        ;otherwise increment to skid offset ($03)
00EAC0  1               
00EAC0  1               NonAnimatedActs:
00EAC0  1  20 29 EB             jsr GetGfxOffsetAdder      ;do a sub here to get offset adder for graphics table
00EAC3  1  A9 00                lda #$00
00EAC5  1  8D 0D 07             sta PlayerAnimCtrl         ;initialize animation frame control
00EAC8  1  B9 BF E8             lda PlayerGfxTblOffsets,y  ;load offset to graphics table using size as offset
00EACB  1  60                   rts
00EACC  1               
00EACC  1               ActionFalling:
00EACC  1  A0 04                ldy #$04                  ;load offset for walking/running
00EACE  1  20 29 EB             jsr GetGfxOffsetAdder     ;get offset to graphics table
00EAD1  1  4C FA EA             jmp GetCurrentAnimOffset  ;execute instructions for falling state
00EAD4  1               
00EAD4  1               ActionWalkRun:
00EAD4  1  A0 04                ldy #$04               ;load offset for walking/running
00EAD6  1  20 29 EB             jsr GetGfxOffsetAdder  ;get offset to graphics table
00EAD9  1  4C 00 EB             jmp FourFrameExtent    ;execute instructions for normal state
00EADC  1               
00EADC  1               ActionClimbing:
00EADC  1  A0 05                ldy #$05               ;load offset for climbing
00EADE  1  A5 9F                lda Player_Y_Speed     ;check player's vertical speed
00EAE0  1  F0 DE                beq NonAnimatedActs    ;if no speed, branch, use offset as-is
00EAE2  1  20 29 EB             jsr GetGfxOffsetAdder  ;otherwise get offset for graphics table
00EAE5  1  4C 05 EB             jmp ThreeFrameExtent   ;then skip ahead to more code
00EAE8  1               
00EAE8  1               ActionSwimming:
00EAE8  1  A0 01                ldy #$01               ;load offset for swimming
00EAEA  1  20 29 EB             jsr GetGfxOffsetAdder
00EAED  1  AD 82 07             lda JumpSwimTimer      ;check jump/swim timer
00EAF0  1  0D 0D 07             ora PlayerAnimCtrl     ;and animation frame control
00EAF3  1  D0 0B                bne FourFrameExtent    ;if any one of these set, branch ahead
00EAF5  1  A5 0A                lda A_B_Buttons
00EAF7  1  0A                   asl                    ;check for A button pressed
00EAF8  1  B0 06                bcs FourFrameExtent    ;branch to same place if A button pressed
00EAFA  1               
00EAFA  1               GetCurrentAnimOffset:
00EAFA  1  AD 0D 07             lda PlayerAnimCtrl         ;get animation frame control
00EAFD  1  4C 68 EB             jmp GetOffsetFromAnimCtrl  ;jump to get proper offset to graphics table
00EB00  1               
00EB00  1               FourFrameExtent:
00EB00  1  A9 03                lda #$03              ;load upper extent for frame control
00EB02  1  4C 07 EB             jmp AnimationControl  ;jump to get offset and animate player object
00EB05  1               
00EB05  1               ThreeFrameExtent:
00EB05  1  A9 02                lda #$02              ;load upper extent for frame control for climbing
00EB07  1               
00EB07  1               AnimationControl:
00EB07  1  85 00                  sta $00                   ;store upper extent here
00EB09  1  20 FA EA               jsr GetCurrentAnimOffset  ;get proper offset to graphics table
00EB0C  1  48                     pha                       ;save offset to stack
00EB0D  1  AD 81 07               lda PlayerAnimTimer       ;load animation frame timer
00EB10  1  D0 15                  bne ExAnimC               ;branch if not expired
00EB12  1  AD 0C 07               lda PlayerAnimTimerSet    ;get animation frame timer amount
00EB15  1  8D 81 07               sta PlayerAnimTimer       ;and set timer accordingly
00EB18  1  AD 0D 07               lda PlayerAnimCtrl
00EB1B  1  18                     clc                       ;add one to animation frame control
00EB1C  1  69 01                  adc #$01
00EB1E  1  C5 00                  cmp $00                   ;compare to upper extent
00EB20  1  90 02                  bcc SetAnimC              ;if frame control + 1 < upper extent, use as next
00EB22  1  A9 00                  lda #$00                  ;otherwise initialize frame control
00EB24  1  8D 0D 07     SetAnimC: sta PlayerAnimCtrl        ;store as new animation frame control
00EB27  1  68           ExAnimC:  pla                       ;get offset to graphics table from stack and leave
00EB28  1  60                     rts
00EB29  1               
00EB29  1               GetGfxOffsetAdder:
00EB29  1  AD 54 07             lda PlayerSize  ;get player's size
00EB2C  1  F0 05                beq SzOfs       ;if player big, use current offset as-is
00EB2E  1  98                   tya             ;for big player
00EB2F  1  18                   clc             ;otherwise add eight bytes to offset
00EB30  1  69 08                adc #$08        ;for small player
00EB32  1  A8                   tay
00EB33  1  60           SzOfs:  rts             ;go back
00EB34  1               
00EB34  1               ChangeSizeOffsetAdder:
00EB34  1  00 01 00 01          .byte $00, $01, $00, $01, $00, $01, $02, $00, $01, $02
00EB38  1  00 01 02 00  
00EB3C  1  01 02        
00EB3E  1  02 00 02 00          .byte $02, $00, $02, $00, $02, $00, $02, $00, $02, $00
00EB42  1  02 00 02 00  
00EB46  1  02 00        
00EB48  1               
00EB48  1               HandleChangeSize:
00EB48  1  AC 0D 07              ldy PlayerAnimCtrl           ;get animation frame control
00EB4B  1  A5 09                 lda FrameCounter
00EB4D  1  29 03                 and #%00000011               ;get frame counter and execute this code every
00EB4F  1  D0 0D                 bne GorSLog                  ;fourth frame, otherwise branch ahead
00EB51  1  C8                    iny                          ;increment frame control
00EB52  1  C0 0A                 cpy #$0a                     ;check for preset upper extent
00EB54  1  90 05                 bcc CSzNext                  ;if not there yet, skip ahead to use
00EB56  1  A0 00                 ldy #$00                     ;otherwise initialize both grow/shrink flag
00EB58  1  8C 0B 07              sty PlayerChangeSizeFlag     ;and animation frame control
00EB5B  1  8C 0D 07     CSzNext: sty PlayerAnimCtrl           ;store proper frame control
00EB5E  1  AD 54 07     GorSLog: lda PlayerSize               ;get player's size
00EB61  1  D0 0C                 bne ShrinkPlayer             ;if player small, skip ahead to next part
00EB63  1               GrowPlayer:
00EB63  1  B9 34 EB              lda ChangeSizeOffsetAdder,y  ;get offset adder based on frame control as offset
00EB66  1  A0 0F                 ldy #$0f                     ;load offset for player growing
00EB68  1               
00EB68  1               GetOffsetFromAnimCtrl:
00EB68  1  0A                   asl                        ;multiply animation frame control
00EB69  1  0A                   asl                        ;by eight to get proper amount
00EB6A  1  0A                   asl                        ;to add to our offset
00EB6B  1  79 BF E8             adc PlayerGfxTblOffsets,y  ;add to offset to graphics table
00EB6E  1  60                   rts                        ;and return with result in A
00EB6F  1               
00EB6F  1               ShrinkPlayer:
00EB6F  1  98                   tya                          ;add ten bytes to frame control as offset
00EB70  1  18                   clc
00EB71  1  69 0A                adc #$0a                     ;this thing apparently uses two of the swimming frames
00EB73  1  AA                   tax                          ;to draw the player shrinking
00EB74  1  A0 09                ldy #$09                     ;load offset for small player swimming
00EB76  1  BD 34 EB             lda ChangeSizeOffsetAdder,x  ;get what would normally be offset adder
00EB79  1  D0 02                bne ShrPlF                   ;and branch to use offset if nonzero
00EB7B  1  A0 01                ldy #$01                     ;otherwise load offset for big player swimming
00EB7D  1  B9 BF E8     ShrPlF: lda PlayerGfxTblOffsets,y    ;get offset to graphics table based on offset loaded
00EB80  1  60                   rts                          ;and leave
00EB81  1               
00EB81  1               ChkForPlayerAttrib:
00EB81  1  AC E4 06                ldy Player_SprDataOffset    ;get sprite data offset
00EB84  1  A5 0E                   lda GameEngineSubroutine
00EB86  1  C9 0B                   cmp #$0b                    ;if executing specific game engine routine,
00EB88  1  F0 13                   beq KilledAtt               ;branch to change third and fourth row OAM attributes
00EB8A  1  AD D5 06                lda PlayerGfxOffset         ;get graphics table offset
00EB8D  1  C9 50                   cmp #$50
00EB8F  1  F0 1E                   beq C_S_IGAtt               ;if crouch offset, either standing offset,
00EB91  1  C9 B8                   cmp #$b8                    ;or intermediate growing offset,
00EB93  1  F0 1A                   beq C_S_IGAtt               ;go ahead and execute code to change
00EB95  1  C9 C0                   cmp #$c0                    ;fourth row OAM attributes only
00EB97  1  F0 16                   beq C_S_IGAtt
00EB99  1  C9 C8                   cmp #$c8
00EB9B  1  D0 24                   bne ExPlyrAt                ;if none of these, branch to leave
00EB9D  1  B9 12 02     KilledAtt: lda Sprite_Attributes+16,y
00EBA0  1  29 3F                   and #%00111111              ;mask out horizontal and vertical flip bits
00EBA2  1  99 12 02                sta Sprite_Attributes+16,y  ;for third row sprites and save
00EBA5  1  B9 16 02                lda Sprite_Attributes+20,y
00EBA8  1  29 3F                   and #%00111111
00EBAA  1  09 40                   ora #%01000000              ;set horizontal flip bit for second
00EBAC  1  99 16 02                sta Sprite_Attributes+20,y  ;sprite in the third row
00EBAF  1  B9 1A 02     C_S_IGAtt: lda Sprite_Attributes+24,y
00EBB2  1  29 3F                   and #%00111111              ;mask out horizontal and vertical flip bits
00EBB4  1  99 1A 02                sta Sprite_Attributes+24,y  ;for fourth row sprites and save
00EBB7  1  B9 1E 02                lda Sprite_Attributes+28,y
00EBBA  1  29 3F                   and #%00111111
00EBBC  1  09 40                   ora #%01000000              ;set horizontal flip bit for second
00EBBE  1  99 1E 02                sta Sprite_Attributes+28,y  ;sprite in the fourth row
00EBC1  1  60           ExPlyrAt:  rts                         ;leave
00EBC2  1               
00EBC2  1               ;-------------------------------------------------------------------------------------
00EBC2  1               ;$00 - used in adding to get proper offset
00EBC2  1               
00EBC2  1               RelativePlayerPosition:
00EBC2  1  A2 00                ldx #$00      ;set offsets for relative cooordinates
00EBC4  1  A0 00                ldy #$00      ;routine to correspond to player object
00EBC6  1  4C DA EB             jmp RelWOfs   ;get the coordinates
00EBC9  1               
00EBC9  1               RelativeBubblePosition:
00EBC9  1  A0 01                ldy #$01                ;set for air bubble offsets
00EBCB  1  20 40 EC             jsr GetProperObjOffset  ;modify X to get proper air bubble offset
00EBCE  1  A0 03                ldy #$03
00EBD0  1  4C DA EB             jmp RelWOfs             ;get the coordinates
00EBD3  1               
00EBD3  1               RelativeFireballPosition:
00EBD3  1  A0 00                 ldy #$00                    ;set for fireball offsets
00EBD5  1  20 40 EC              jsr GetProperObjOffset      ;modify X to get proper fireball offset
00EBD8  1  A0 02                 ldy #$02
00EBDA  1  20 09 EC     RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
00EBDD  1  A6 08                 ldx ObjectOffset            ;return original offset
00EBDF  1  60                    rts                         ;leave
00EBE0  1               
00EBE0  1               RelativeMiscPosition:
00EBE0  1  A0 02                ldy #$02                ;set for misc object offsets
00EBE2  1  20 40 EC             jsr GetProperObjOffset  ;modify X to get proper misc object offset
00EBE5  1  A0 06                ldy #$06
00EBE7  1  4C DA EB             jmp RelWOfs             ;get the coordinates
00EBEA  1               
00EBEA  1               RelativeEnemyPosition:
00EBEA  1  A9 01                lda #$01                     ;get coordinates of enemy object
00EBEC  1  A0 01                ldy #$01                     ;relative to the screen
00EBEE  1  4C FD EB             jmp VariableObjOfsRelPos
00EBF1  1               
00EBF1  1               RelativeBlockPosition:
00EBF1  1  A9 09                lda #$09                     ;get coordinates of one block object
00EBF3  1  A0 04                ldy #$04                     ;relative to the screen
00EBF5  1  20 FD EB             jsr VariableObjOfsRelPos
00EBF8  1  E8                   inx                          ;adjust offset for other block object if any
00EBF9  1  E8                   inx
00EBFA  1  A9 09                lda #$09
00EBFC  1  C8                   iny                          ;adjust other and get coordinates for other one
00EBFD  1               
00EBFD  1               VariableObjOfsRelPos:
00EBFD  1  86 00                stx $00                     ;store value to add to A here
00EBFF  1  18                   clc
00EC00  1  65 00                adc $00                     ;add A to value stored
00EC02  1  AA                   tax                         ;use as enemy offset
00EC03  1  20 09 EC             jsr GetObjRelativePosition
00EC06  1  A6 08                ldx ObjectOffset            ;reload old object offset and leave
00EC08  1  60                   rts
00EC09  1               
00EC09  1               GetObjRelativePosition:
00EC09  1  B5 CE                lda SprObject_Y_Position,x  ;load vertical coordinate low
00EC0B  1  99 B8 03             sta SprObject_Rel_YPos,y    ;store here
00EC0E  1  B5 86                lda SprObject_X_Position,x  ;load horizontal coordinate
00EC10  1  38                   sec                         ;subtract left edge coordinate
00EC11  1  ED 1C 07             sbc ScreenLeft_X_Pos
00EC14  1  99 AD 03             sta SprObject_Rel_XPos,y    ;store result here
00EC17  1  60                   rts
00EC18  1               
00EC18  1               ;-------------------------------------------------------------------------------------
00EC18  1               ;$00 - used as temp variable to hold offscreen bits
00EC18  1               
00EC18  1               GetPlayerOffscreenBits:
00EC18  1  A2 00                ldx #$00                 ;set offsets for player-specific variables
00EC1A  1  A0 00                ldy #$00                 ;and get offscreen information about player
00EC1C  1  4C 58 EC             jmp GetOffScreenBitsSet
00EC1F  1               
00EC1F  1               GetFireballOffscreenBits:
00EC1F  1  A0 00                ldy #$00                 ;set for fireball offsets
00EC21  1  20 40 EC             jsr GetProperObjOffset   ;modify X to get proper fireball offset
00EC24  1  A0 02                ldy #$02                 ;set other offset for fireball's offscreen bits
00EC26  1  4C 58 EC             jmp GetOffScreenBitsSet  ;and get offscreen information about fireball
00EC29  1               
00EC29  1               GetBubbleOffscreenBits:
00EC29  1  A0 01                ldy #$01                 ;set for air bubble offsets
00EC2B  1  20 40 EC             jsr GetProperObjOffset   ;modify X to get proper air bubble offset
00EC2E  1  A0 03                ldy #$03                 ;set other offset for airbubble's offscreen bits
00EC30  1  4C 58 EC             jmp GetOffScreenBitsSet  ;and get offscreen information about air bubble
00EC33  1               
00EC33  1               GetMiscOffscreenBits:
00EC33  1  A0 02                ldy #$02                 ;set for misc object offsets
00EC35  1  20 40 EC             jsr GetProperObjOffset   ;modify X to get proper misc object offset
00EC38  1  A0 06                ldy #$06                 ;set other offset for misc object's offscreen bits
00EC3A  1  4C 58 EC             jmp GetOffScreenBitsSet  ;and get offscreen information about misc object
00EC3D  1               
00EC3D  1               ObjOffsetData:
00EC3D  1  07 16 0D             .byte $07, $16, $0d
00EC40  1               
00EC40  1               GetProperObjOffset:
00EC40  1  8A                   txa                  ;move offset to A
00EC41  1  18                   clc
00EC42  1  79 3D EC             adc ObjOffsetData,y  ;add amount of bytes to offset depending on setting in Y
00EC45  1  AA                   tax                  ;put back in X and leave
00EC46  1  60                   rts
00EC47  1               
00EC47  1               GetEnemyOffscreenBits:
00EC47  1  A9 01                lda #$01                 ;set A to add 1 byte in order to get enemy offset
00EC49  1  A0 01                ldy #$01                 ;set Y to put offscreen bits in Enemy_OffscreenBits
00EC4B  1  4C 52 EC             jmp SetOffscrBitsOffset
00EC4E  1               
00EC4E  1               GetBlockOffscreenBits:
00EC4E  1  A9 09                lda #$09       ;set A to add 9 bytes in order to get block obj offset
00EC50  1  A0 04                ldy #$04       ;set Y to put offscreen bits in Block_OffscreenBits
00EC52  1               
00EC52  1               SetOffscrBitsOffset:
00EC52  1  86 00                stx $00
00EC54  1  18                   clc           ;add contents of X to A to get
00EC55  1  65 00                adc $00       ;appropriate offset, then give back to X
00EC57  1  AA                   tax
00EC58  1               
00EC58  1               GetOffScreenBitsSet:
00EC58  1  98                   tya                         ;save offscreen bits offset to stack for now
00EC59  1  48                   pha
00EC5A  1  20 6F EC             jsr RunOffscrBitsSubs
00EC5D  1  0A                   asl                         ;move low nybble to high nybble
00EC5E  1  0A                   asl
00EC5F  1  0A                   asl
00EC60  1  0A                   asl
00EC61  1  05 00                ora $00                     ;mask together with previously saved low nybble
00EC63  1  85 00                sta $00                     ;store both here
00EC65  1  68                   pla                         ;get offscreen bits offset from stack
00EC66  1  A8                   tay
00EC67  1  A5 00                lda $00                     ;get value here and store elsewhere
00EC69  1  99 D0 03             sta SprObject_OffscrBits,y
00EC6C  1  A6 08                ldx ObjectOffset
00EC6E  1  60                   rts
00EC6F  1               
00EC6F  1               RunOffscrBitsSubs:
00EC6F  1  20 8E EC             jsr GetXOffscreenBits  ;do subroutine here
00EC72  1  4A                   lsr                    ;move high nybble to low
00EC73  1  4A                   lsr
00EC74  1  4A                   lsr
00EC75  1  4A                   lsr
00EC76  1  85 00                sta $00                ;store here
00EC78  1  4C D1 EC             jmp GetYOffscreenBits
00EC7B  1               
00EC7B  1               ;--------------------------------
00EC7B  1               ;(these apply to these three subsections)
00EC7B  1               ;$04 - used to store proper offset
00EC7B  1               ;$05 - used as adder in DividePDiff
00EC7B  1               ;$06 - used to store preset value used to compare to pixel difference in $07
00EC7B  1               ;$07 - used to store difference between coordinates of object and screen edges
00EC7B  1               
00EC7B  1               XOffscreenBitsData:
00EC7B  1  7F 3F 1F 0F          .byte $7f, $3f, $1f, $0f, $07, $03, $01, $00
00EC7F  1  07 03 01 00  
00EC83  1  80 C0 E0 F0          .byte $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
00EC87  1  F8 FC FE FF  
00EC8B  1               
00EC8B  1               DefaultXOnscreenOfs:
00EC8B  1  07 0F 07             .byte $07, $0f, $07
00EC8E  1               
00EC8E  1               GetXOffscreenBits:
00EC8E  1  86 04                  stx $04                     ;save position in buffer to here
00EC90  1  A0 01                  ldy #$01                    ;start with right side of screen
00EC92  1  B9 1C 07     XOfsLoop: lda ScreenEdge_X_Pos,y      ;get pixel coordinate of edge
00EC95  1  38                     sec                         ;get difference between pixel coordinate of edge
00EC96  1  F5 86                  sbc SprObject_X_Position,x  ;and pixel coordinate of object position
00EC98  1  85 07                  sta $07                     ;store here
00EC9A  1  B9 1A 07               lda ScreenEdge_PageLoc,y    ;get page location of edge
00EC9D  1  F5 6D                  sbc SprObject_PageLoc,x     ;subtract from page location of object position
00EC9F  1  BE 8B EC               ldx DefaultXOnscreenOfs,y   ;load offset value here
00ECA2  1  C9 00                  cmp #$00
00ECA4  1  30 10                  bmi XLdBData                ;if beyond right edge or in front of left edge, branch
00ECA6  1  BE 8C EC               ldx DefaultXOnscreenOfs+1,y ;if not, load alternate offset value here
00ECA9  1  C9 01                  cmp #$01
00ECAB  1  10 09                  bpl XLdBData                ;if one page or more to the left of either edge, branch
00ECAD  1  A9 38                  lda #$38                    ;if no branching, load value here and store
00ECAF  1  85 06                  sta $06
00ECB1  1  A9 08                  lda #$08                    ;load some other value and execute subroutine
00ECB3  1  20 05 ED               jsr DividePDiff
00ECB6  1  BD 7B EC     XLdBData: lda XOffscreenBitsData,x    ;get bits here
00ECB9  1  A6 04                  ldx $04                     ;reobtain position in buffer
00ECBB  1  C9 00                  cmp #$00                    ;if bits not zero, branch to leave
00ECBD  1  D0 03                  bne ExXOfsBS
00ECBF  1  88                     dey                         ;otherwise, do left side of screen now
00ECC0  1  10 D0                  bpl XOfsLoop                ;branch if not already done with left side
00ECC2  1  60           ExXOfsBS: rts
00ECC3  1               
00ECC3  1               ;--------------------------------
00ECC3  1               
00ECC3  1               YOffscreenBitsData:
00ECC3  1  00 08 0C 0E          .byte $00, $08, $0c, $0e
00ECC7  1  0F 07 03 01          .byte $0f, $07, $03, $01
00ECCB  1  00                   .byte $00
00ECCC  1               
00ECCC  1               DefaultYOnscreenOfs:
00ECCC  1  04 00 04             .byte $04, $00, $04
00ECCF  1               
00ECCF  1               HighPosUnitData:
00ECCF  1  FF 00                .byte $ff, $00
00ECD1  1               
00ECD1  1               GetYOffscreenBits:
00ECD1  1  86 04                  stx $04                      ;save position in buffer to here
00ECD3  1  A0 01                  ldy #$01                     ;start with top of screen
00ECD5  1  B9 CF EC     YOfsLoop: lda HighPosUnitData,y        ;load coordinate for edge of vertical unit
00ECD8  1  38                     sec
00ECD9  1  F5 CE                  sbc SprObject_Y_Position,x   ;subtract from vertical coordinate of object
00ECDB  1  85 07                  sta $07                      ;store here
00ECDD  1  A9 01                  lda #$01                     ;subtract one from vertical high byte of object
00ECDF  1  F5 B5                  sbc SprObject_Y_HighPos,x
00ECE1  1  BE CC EC               ldx DefaultYOnscreenOfs,y    ;load offset value here
00ECE4  1  C9 00                  cmp #$00
00ECE6  1  30 10                  bmi YLdBData                 ;if under top of the screen or beyond bottom, branch
00ECE8  1  BE CD EC               ldx DefaultYOnscreenOfs+1,y  ;if not, load alternate offset value here
00ECEB  1  C9 01                  cmp #$01
00ECED  1  10 09                  bpl YLdBData                 ;if one vertical unit or more above the screen, branch
00ECEF  1  A9 20                  lda #$20                     ;if no branching, load value here and store
00ECF1  1  85 06                  sta $06
00ECF3  1  A9 04                  lda #$04                     ;load some other value and execute subroutine
00ECF5  1  20 05 ED               jsr DividePDiff
00ECF8  1  BD C3 EC     YLdBData: lda YOffscreenBitsData,x     ;get offscreen data bits using offset
00ECFB  1  A6 04                  ldx $04                      ;reobtain position in buffer
00ECFD  1  C9 00                  cmp #$00
00ECFF  1  D0 03                  bne ExYOfsBS                 ;if bits not zero, branch to leave
00ED01  1  88                     dey                          ;otherwise, do bottom of the screen now
00ED02  1  10 D1                  bpl YOfsLoop
00ED04  1  60           ExYOfsBS: rts
00ED05  1               
00ED05  1               ;--------------------------------
00ED05  1               
00ED05  1               DividePDiff:
00ED05  1  85 05                  sta $05       ;store current value in A here
00ED07  1  A5 07                  lda $07       ;get pixel difference
00ED09  1  C5 06                  cmp $06       ;compare to preset value
00ED0B  1  B0 0C                  bcs ExDivPD   ;if pixel difference >= preset value, branch
00ED0D  1  4A                     lsr           ;divide by eight
00ED0E  1  4A                     lsr
00ED0F  1  4A                     lsr
00ED10  1  29 07                  and #$07      ;mask out all but 3 LSB
00ED12  1  C0 01                  cpy #$01      ;right side of the screen or top?
00ED14  1  B0 02                  bcs SetOscrO  ;if so, branch, use difference / 8 as offset
00ED16  1  65 05                  adc $05       ;if not, add value to difference / 8
00ED18  1  AA           SetOscrO: tax           ;use as offset
00ED19  1  60           ExDivPD:  rts           ;leave
00ED1A  1               
00ED1A  1               ;-------------------------------------------------------------------------------------
00ED1A  1               ;$00-$01 - tile numbers
00ED1A  1               ;$02 - Y coordinate
00ED1A  1               ;$03 - flip control
00ED1A  1               ;$04 - sprite attributes
00ED1A  1               ;$05 - X coordinate
00ED1A  1               
00ED1A  1               DrawSpriteObject:
00ED1A  1  A5 03                 lda $03                    ;get saved flip control bits
00ED1C  1  4A                    lsr
00ED1D  1  4A                    lsr                        ;move d1 into carry
00ED1E  1  A5 00                 lda $00
00ED20  1  90 0C                 bcc NoHFlip                ;if d1 not set, branch
00ED22  1  99 05 02              sta Sprite_Tilenumber+4,y  ;store first tile into second sprite
00ED25  1  A5 01                 lda $01                    ;and second into first sprite
00ED27  1  99 01 02              sta Sprite_Tilenumber,y
00ED2A  1  A9 40                 lda #$40                   ;activate horizontal flip OAM attribute
00ED2C  1  D0 0A                 bne SetHFAt                ;and unconditionally branch
00ED2E  1  99 01 02     NoHFlip: sta Sprite_Tilenumber,y    ;store first tile into first sprite
00ED31  1  A5 01                 lda $01                    ;and second into second sprite
00ED33  1  99 05 02              sta Sprite_Tilenumber+4,y
00ED36  1  A9 00                 lda #$00                   ;clear bit for horizontal flip
00ED38  1  05 04        SetHFAt: ora $04                    ;add other OAM attributes if necessary
00ED3A  1  99 02 02              sta Sprite_Attributes,y    ;store sprite attributes
00ED3D  1  99 06 02              sta Sprite_Attributes+4,y
00ED40  1  A5 02                 lda $02                    ;now the y coordinates
00ED42  1  99 00 02              sta Sprite_Y_Position,y    ;note because they are
00ED45  1  99 04 02              sta Sprite_Y_Position+4,y  ;side by side, they are the same
00ED48  1  A5 05                 lda $05
00ED4A  1  99 03 02              sta Sprite_X_Position,y    ;store x coordinate, then
00ED4D  1  18                    clc                        ;add 8 pixels and store another to
00ED4E  1  69 08                 adc #$08                   ;put them side by side
00ED50  1  99 07 02              sta Sprite_X_Position+4,y
00ED53  1  A5 02                 lda $02                    ;add eight pixels to the next y
00ED55  1  18                    clc                        ;coordinate
00ED56  1  69 08                 adc #$08
00ED58  1  85 02                 sta $02
00ED5A  1  98                    tya                        ;add eight to the offset in Y to
00ED5B  1  18                    clc                        ;move to the next two sprites
00ED5C  1  69 08                 adc #$08
00ED5E  1  A8                    tay
00ED5F  1  E8                    inx                        ;increment offset to return it to the
00ED60  1  E8                    inx                        ;routine that called this subroutine
00ED61  1  60                    rts
00ED62  1               
00ED62  1               ;-------------------------------------------------------------------------------------
00ED62  1               ;$06-$07 - used to store block buffer address used as indirect
00ED62  1               
00ED62  1               BlockBufferAddr:
00ED62  1  00 D0              .byte <Block_Buffer_1, <Block_Buffer_2
00ED64  1  05 05              .byte >Block_Buffer_1, >Block_Buffer_2
00ED66  1               
00ED66  1               GetBlockBufferAddr:
00ED66  1  48                 pha                      ;take value of A, save
00ED67  1  4A                 lsr                      ;move high nybble to low
00ED68  1  4A                 lsr
00ED69  1  4A                 lsr
00ED6A  1  4A                 lsr
00ED6B  1  A8                 tay                      ;use nybble as pointer to high byte
00ED6C  1  B9 64 ED           lda BlockBufferAddr+2,y  ;of indirect here
00ED6F  1  85 07              sta $07
00ED71  1  68                 pla
00ED72  1  29 0F              and #%00001111           ;pull from stack, mask out high nybble
00ED74  1  18                 clc
00ED75  1  79 62 ED           adc BlockBufferAddr,y    ;add to low byte
00ED78  1  85 06              sta $06                  ;store here and leave
00ED7A  1  60                 rts
00ED7B  1               
00ED7B  1               ;-------------------------------------------------------------------------------------
00ED7B  1               
00ED7B  1               Setup_Vine:
00ED7B  1  A9 2F                lda #VineObject          ;load identifier for vine object
00ED7D  1  95 16                sta Enemy_ID,x           ;store in buffer
00ED7F  1  A9 01                lda #$01
00ED81  1  95 0F                sta Enemy_Flag,x         ;set flag for enemy object buffer
00ED83  1  B9 76 00             lda Block_PageLoc,y
00ED86  1  95 6E                sta Enemy_PageLoc,x      ;copy page location from previous object
00ED88  1  B9 8F 00             lda Block_X_Position,y
00ED8B  1  95 87                sta Enemy_X_Position,x   ;copy horizontal coordinate from previous object
00ED8D  1  B9 D7 00             lda Block_Y_Position,y
00ED90  1  95 CF                sta Enemy_Y_Position,x   ;copy vertical coordinate from previous object
00ED92  1  AC 98 03             ldy VineFlagOffset       ;load vine flag/offset to next available vine slot
00ED95  1  D0 03                bne NextVO               ;if set at all, don't bother to store vertical
00ED97  1  8D 9D 03             sta VineStart_Y_Position ;otherwise store vertical coordinate here
00ED9A  1  8A           NextVO: txa                      ;store object offset to next available vine slot
00ED9B  1  99 9A 03             sta VineObjOffset,y      ;using vine flag as offset
00ED9E  1  EE 98 03             inc VineFlagOffset       ;increment vine flag offset
00EDA1  1  A9 04                lda #Sfx_GrowVine
00EDA3  1  85 FE                sta Square2SoundQueue    ;load vine grow sound
00EDA5  1  60                   rts
00EDA6  1               
00EDA6  1               ;--------------------------------
00EDA6  1               ;$00 - used to store enemy identifier in KillEnemies
00EDA6  1               
00EDA6  1               KillEnemies:
00EDA6  1  85 00                   sta $00           ;store identifier here
00EDA8  1  A9 00                   lda #$00
00EDAA  1  A2 04                   ldx #$04          ;check for identifier in enemy object buffer
00EDAC  1  B4 16        KillELoop: ldy Enemy_ID,x
00EDAE  1  C4 00                   cpy $00           ;if not found, branch
00EDB0  1  D0 02                   bne NoKillE
00EDB2  1  95 0F                   sta Enemy_Flag,x  ;if found, deactivate enemy object flag
00EDB4  1  CA           NoKillE:   dex               ;do this until all slots are checked
00EDB5  1  10 F5                   bpl KillELoop
00EDB7  1  60                      rts
00EDB8  1               
00EDB8  1               ;-------------------------------------------------------------------------------------
00EDB8  1               
00EDB8  1               AreaPalette:
00EDB8  1  01 02 03 04        .byte $01, $02, $03, $04
00EDBC  1               
00EDBC  1               GetAreaPalette:
00EDBC  1  AC 4E 07                    ldy AreaType             ;select appropriate palette to load
00EDBF  1  BE B8 ED                    ldx AreaPalette,y        ;based on area type
00EDC2  1  8E 73 07     SetVRAMAddr_A: stx VRAM_Buffer_AddrCtrl ;store offset into buffer control
00EDC5  1  4C 4C EE              jmp IncSubtask           ;move onto next task
00EDC8  1               
00EDC8  1               ;-------------------------------------------------------------------------------------
00EDC8  1               ;$00 - used as temp counter in GetPlayerColors
00EDC8  1               
00EDC8  1               BGColorCtrl_Addr:
00EDC8  1  00 09 0A 04        .byte $00, $09, $0a, $04
00EDCC  1               
00EDCC  1               BackgroundColors:
00EDCC  1  22 22 0F 0F        .byte $22, $22, $0f, $0f ;used by area type if bg color ctrl not set
00EDD0  1  0F 22 0F 0F        .byte $0f, $22, $0f, $0f ;used by background color control if set
00EDD4  1               
00EDD4  1               PlayerColors:
00EDD4  1  22 16 27 18        .byte $22, $16, $27, $18 ;mario's colors
00EDD8  1  22 30 27 19        .byte $22, $30, $27, $19 ;luigi's colors
00EDDC  1  22 37 27 16        .byte $22, $37, $27, $16 ;fiery (used by both)
00EDE0  1               
00EDE0  1               GetBackgroundColor:
00EDE0  1  AC 44 07                ldy BackgroundColorCtrl   ;check background color control
00EDE3  1  F0 06                   beq NoBGColor             ;if not set, increment task and fetch palette
00EDE5  1  B9 C4 ED                lda BGColorCtrl_Addr-4,y  ;put appropriate palette into vram
00EDE8  1  8D 73 07                sta VRAM_Buffer_AddrCtrl  ;note that if set to 5-7, $0301 will not be read
00EDEB  1  EE 3C 07     NoBGColor: inc ScreenRoutineTask     ;increment to next subtask and plod on through
00EDEE  1               
00EDEE  1               GetPlayerColors:
00EDEE  1  AE 00 03                    ldx VRAM_Buffer1_Offset  ;get current buffer offset
00EDF1  1  A0 00                       ldy #$00
00EDF3  1  AD 53 07                    lda CurrentPlayer        ;check which player is on the screen
00EDF6  1  F0 02                       beq ChkFiery
00EDF8  1  A0 04                       ldy #$04                 ;load offset for luigi
00EDFA  1  AD 56 07     ChkFiery:      lda PlayerStatus         ;check player status
00EDFD  1  C9 02                       cmp #$02
00EDFF  1  D0 02                       bne StartClrGet          ;if fiery, load alternate offset for fiery player
00EE01  1  A0 08                       ldy #$08
00EE03  1  A9 03        StartClrGet:   lda #$03                 ;do four colors
00EE05  1  85 00                       sta $00
00EE07  1  B9 D4 ED     ClrGetLoop:    lda PlayerColors,y       ;fetch player colors and store them
00EE0A  1  9D 04 03                    sta VRAM_Buffer1+3,x     ;in the buffer
00EE0D  1  C8                          iny
00EE0E  1  E8                          inx
00EE0F  1  C6 00                       dec $00
00EE11  1  10 F4                       bpl ClrGetLoop
00EE13  1  AE 00 03                    ldx VRAM_Buffer1_Offset  ;load original offset from before
00EE16  1  AC 44 07                    ldy BackgroundColorCtrl  ;if this value is four or greater, it will be set
00EE19  1  D0 03                       bne SetBGColor           ;therefore use it as offset to background color
00EE1B  1  AC 4E 07                    ldy AreaType             ;otherwise use area type bits from area offset as offset
00EE1E  1  B9 CC ED     SetBGColor:    lda BackgroundColors,y   ;to background color instead
00EE21  1  9D 04 03                    sta VRAM_Buffer1+3,x
00EE24  1  A9 3F                       lda #$3f                 ;set for sprite palette address
00EE26  1  9D 01 03                    sta VRAM_Buffer1,x       ;save to buffer
00EE29  1  A9 10                       lda #$10
00EE2B  1  9D 02 03                    sta VRAM_Buffer1+1,x
00EE2E  1  A9 04                       lda #$04                 ;write length byte to buffer
00EE30  1  9D 03 03                    sta VRAM_Buffer1+2,x
00EE33  1  A9 00                       lda #$00                 ;now the null terminator
00EE35  1  9D 08 03                    sta VRAM_Buffer1+7,x
00EE38  1  8A                          txa                      ;move the buffer pointer ahead 7 bytes
00EE39  1  18                          clc                      ;in case we want to write anything else later
00EE3A  1  69 07                       adc #$07
00EE3C  1  8D 00 03     SetVRAMOffset: sta VRAM_Buffer1_Offset  ;store as new vram buffer offset
00EE3F  1  60                          rts
00EE40  1               
00EE40  1               ;-------------------------------------------------------------------------------------
00EE40  1               
00EE40  1               GetAlternatePalette1:
00EE40  1  AD 33 07                    lda AreaStyle            ;check for mushroom level style
00EE43  1  C9 01                       cmp #$01
00EE45  1  D0 05                       bne IncSubtask
00EE47  1  A9 0B                       lda #$0b                 ;if found, load appropriate palette
00EE49  1  8D 73 07     SetVRAMAddr_B: sta VRAM_Buffer_AddrCtrl
00EE4C  1  EE 3C 07     IncSubtask:  inc ScreenRoutineTask      ;move onto next task
00EE4F  1  60                        rts
00EE50  1               
00EE50  1               ;-------------------------------------------------------------------------------------
00EE50  1               
00EE50  1               Jumpspring_Y_PosData:
00EE50  1  08 10 08 00        .byte $08, $10, $08, $00
00EE54  1               
00EE54  1               JumpspringHandler:
00EE54  1  20 47 EC                jsr GetEnemyOffscreenBits   ;get offscreen information
00EE57  1  AD 47 07                lda TimerControl            ;check master timer control
00EE5A  1  D0 40                   bne DrawJSpr                ;branch to last section if set
00EE5C  1  AD 0E 07                lda JumpspringAnimCtrl      ;check jumpspring frame control
00EE5F  1  F0 3B                   beq DrawJSpr                ;branch to last section if not set
00EE61  1  A8                      tay
00EE62  1  88                      dey                         ;subtract one from frame control,
00EE63  1  98                      tya                         ;the only way a poor nmos 6502 can
00EE64  1  29 02                   and #%00000010              ;mask out all but d1, original value still in Y
00EE66  1  D0 07                   bne DownJSpr                ;if set, branch to move player up
00EE68  1  E6 CE                   inc Player_Y_Position
00EE6A  1  E6 CE                   inc Player_Y_Position       ;move player's vertical position down two pixels
00EE6C  1  4C 73 EE                jmp PosJSpr                 ;skip to next part
00EE6F  1  C6 CE        DownJSpr:  dec Player_Y_Position       ;move player's vertical position up two pixels
00EE71  1  C6 CE                   dec Player_Y_Position
00EE73  1  B5 58        PosJSpr:   lda Jumpspring_FixedYPos,x  ;get permanent vertical position
00EE75  1  18                      clc
00EE76  1  79 50 EE                adc Jumpspring_Y_PosData,y  ;add value using frame control as offset
00EE79  1  95 CF                   sta Enemy_Y_Position,x      ;store as new vertical position
00EE7B  1  C0 01                   cpy #$01                    ;check frame control offset (second frame is $00)
00EE7D  1  90 0F                   bcc BounceJS                ;if offset not yet at third frame ($01), skip to next part
00EE7F  1  A5 0A                   lda A_B_Buttons
00EE81  1  29 80                   and #A_Button               ;check saved controller bits for A button press
00EE83  1  F0 09                   beq BounceJS                ;skip to next part if A not pressed
00EE85  1  25 0D                   and PreviousA_B_Buttons     ;check for A button pressed in previous frame
00EE87  1  D0 05                   bne BounceJS                ;skip to next part if so
00EE89  1  A9 F4                   lda #$f4
00EE8B  1  8D DB 06                sta JumpspringForce         ;otherwise write new jumpspring force here
00EE8E  1  C0 03        BounceJS:  cpy #$03                    ;check frame control offset again
00EE90  1  D0 0A                   bne DrawJSpr                ;skip to last part if not yet at fifth frame ($03)
00EE92  1  AD DB 06                lda JumpspringForce
00EE95  1  85 9F                   sta Player_Y_Speed          ;store jumpspring force as player's new vertical speed
00EE97  1  A9 00                   lda #$00
00EE99  1  8D 0E 07                sta JumpspringAnimCtrl      ;initialize jumpspring frame control
00EE9C  1  20 EA EB     DrawJSpr:  jsr RelativeEnemyPosition   ;get jumpspring's relative coordinates
00EE9F  1  20 35 E3                jsr EnemyGfxHandler         ;draw jumpspring
00EEA2  1  20 95 D1                jsr OffscreenBoundsCheck    ;check to see if we need to kill it
00EEA5  1  AD 0E 07                lda JumpspringAnimCtrl      ;if frame control at zero, don't bother
00EEA8  1  F0 0D                   beq ExJSpring               ;trying to animate it, just leave
00EEAA  1  AD 86 07                lda JumpspringTimer
00EEAD  1  D0 08                   bne ExJSpring               ;if jumpspring timer not expired yet, leave
00EEAF  1  A9 04                   lda #$04
00EEB1  1  8D 86 07                sta JumpspringTimer         ;otherwise initialize jumpspring timer
00EEB4  1  EE 0E 07                inc JumpspringAnimCtrl      ;increment frame control to animate jumpspring
00EEB7  1  60           ExJSpring: rts                         ;leave
00EEB8  1               
00EEB8  1               
00EEB8  1               ;-------------------------------------------------------------------------------------
00EEB8  1               ;$02 - used to store vertical high nybble offset from block buffer routine
00EEB8  1               ;$06 - used to store low byte of block buffer address
00EEB8  1               
00EEB8  1               CoinBlock:
00EEB8  1  20 04 EF           jsr FindEmptyMiscSlot   ;set offset for empty or last misc object buffer slot
00EEBB  1  B5 76              lda Block_PageLoc,x     ;get page location of block object
00EEBD  1  99 7A 00           sta Misc_PageLoc,y      ;store as page location of misc object
00EEC0  1  B5 8F              lda Block_X_Position,x  ;get horizontal coordinate of block object
00EEC2  1  09 05              ora #$05                ;add 5 pixels
00EEC4  1  99 93 00           sta Misc_X_Position,y   ;store as horizontal coordinate of misc object
00EEC7  1  B5 D7              lda Block_Y_Position,x  ;get vertical coordinate of block object
00EEC9  1  E9 10              sbc #$10                ;subtract 16 pixels
00EECB  1  99 DB 00           sta Misc_Y_Position,y   ;store as vertical coordinate of misc object
00EECE  1  4C EC EE           jmp JCoinC              ;jump to rest of code as applies to this misc object
00EED1  1               
00EED1  1               SetupJumpCoin:
00EED1  1  20 04 EF             jsr FindEmptyMiscSlot  ;set offset for empty or last misc object buffer slot
00EED4  1  BD EA 03             lda Block_PageLoc2,x   ;get page location saved earlier
00EED7  1  99 7A 00             sta Misc_PageLoc,y     ;and save as page location for misc object
00EEDA  1  A5 06                lda $06                ;get low byte of block buffer offset
00EEDC  1  0A                   asl
00EEDD  1  0A                   asl                    ;multiply by 16 to use lower nybble
00EEDE  1  0A                   asl
00EEDF  1  0A                   asl
00EEE0  1  09 05                ora #$05               ;add five pixels
00EEE2  1  99 93 00             sta Misc_X_Position,y  ;save as horizontal coordinate for misc object
00EEE5  1  A5 02                lda $02                ;get vertical high nybble offset from earlier
00EEE7  1  69 20                adc #$20               ;add 32 pixels for the status bar
00EEE9  1  99 DB 00             sta Misc_Y_Position,y  ;store as vertical coordinate
00EEEC  1  A9 FB        JCoinC: lda #$fb
00EEEE  1  99 AC 00             sta Misc_Y_Speed,y     ;set vertical speed
00EEF1  1  A9 01                lda #$01
00EEF3  1  99 C2 00             sta Misc_Y_HighPos,y   ;set vertical high byte
00EEF6  1  99 2A 00             sta Misc_State,y       ;set state for misc object
00EEF9  1  85 FE                sta Square2SoundQueue  ;load coin grab sound
00EEFB  1  86 08                stx ObjectOffset       ;store current control bit as misc object offset
00EEFD  1  20 11 B4             jsr GiveOneCoin        ;update coin tally on the screen and coin amount variable
00EF00  1  EE 48 07             inc CoinTallyFor1Ups   ;increment coin tally used to activate 1-up block flag
00EF03  1  60                   rts
00EF04  1               
00EF04  1               FindEmptyMiscSlot:
00EF04  1  A0 08                   ldy #$08                ;start at end of misc objects buffer
00EF06  1  B9 2A 00     FMiscLoop: lda Misc_State,y        ;get misc object state
00EF09  1  F0 07                   beq UseMiscS            ;branch if none found to use current offset
00EF0B  1  88                      dey                     ;decrement offset
00EF0C  1  C0 05                   cpy #$05                ;do this for three slots
00EF0E  1  D0 F6                   bne FMiscLoop           ;do this until all slots are checked
00EF10  1  A0 08                   ldy #$08                ;if no empty slots found, use last slot
00EF12  1  8C B7 06     UseMiscS:  sty JumpCoinMiscOffset  ;store offset of misc object buffer here (residual)
00EF15  1  60                      rts
00EF16  1               
00EF16  1               ;-------------------------------------------------------------------------------------
00EF16  1               ;$00 - temp store for offset control bit
00EF16  1               ;$01 - temp vram buffer offset
00EF16  1               ;$02 - temp store for vertical high nybble in block buffer routine
00EF16  1               ;$03 - temp adder for high byte of name table address
00EF16  1               ;$04, $05 - name table address low/high
00EF16  1               ;$06, $07 - block buffer address low/high
00EF16  1               
00EF16  1               BlockGfxData:
00EF16  1  45 45 47 47         .byte $45, $45, $47, $47
00EF1A  1  47 47 47 47         .byte $47, $47, $47, $47
00EF1E  1  57 58 59 5A         .byte $57, $58, $59, $5a
00EF22  1  24 24 24 24         .byte $24, $24, $24, $24
00EF26  1  26 26 26 26         .byte $26, $26, $26, $26
00EF2A  1               
00EF2A  1               RemoveCoin_Axe:
00EF2A  1  A0 41                      ldy #$41                 ;set low byte so offset points to $0341
00EF2C  1  A9 03                      lda #$03                 ;load offset for default blank metatile
00EF2E  1  AE 4E 07                   ldx AreaType             ;check area type
00EF31  1  D0 02                      bne WriteBlankMT         ;if not water type, use offset
00EF33  1  A9 04                      lda #$04                 ;otherwise load offset for blank metatile used in water
00EF35  1  20 74 EF     WriteBlankMT: jsr PutBlockMetatile     ;do a sub to write blank metatile to vram buffer
00EF38  1  A9 06                      lda #$06
00EF3A  1  8D 73 07                   sta VRAM_Buffer_AddrCtrl ;set vram address controller to $0341 and leave
00EF3D  1  60                         rts
00EF3E  1               
00EF3E  1               ReplaceBlockMetatile:
00EF3E  1  20 4A EF            jsr WriteBlockMetatile    ;write metatile to vram buffer to replace block object
00EF41  1  EE F0 03            inc Block_ResidualCounter ;increment unused counter (residual code)
00EF44  1  DE EC 03            dec Block_RepFlag,x       ;decrement flag (residual code)
00EF47  1  60                  rts                       ;leave
00EF48  1               
00EF48  1               DestroyBlockMetatile:
00EF48  1  A9 00               lda #$00       ;force blank metatile if branched/jumped to this point
00EF4A  1               
00EF4A  1               WriteBlockMetatile:
00EF4A  1  A0 03                     ldy #$03                ;load offset for blank metatile
00EF4C  1  C9 00                     cmp #$00                ;check contents of A for blank metatile
00EF4E  1  F0 14                     beq UseBOffset          ;branch if found (unconditional if branched from 8a6b)
00EF50  1  A0 00                     ldy #$00                ;load offset for brick metatile w/ line
00EF52  1  C9 58                     cmp #$58
00EF54  1  F0 0E                     beq UseBOffset          ;use offset if metatile is brick with coins (w/ line)
00EF56  1  C9 51                     cmp #$51
00EF58  1  F0 0A                     beq UseBOffset          ;use offset if metatile is breakable brick w/ line
00EF5A  1  C8                        iny                     ;increment offset for brick metatile w/o line
00EF5B  1  C9 5D                     cmp #$5d
00EF5D  1  F0 05                     beq UseBOffset          ;use offset if metatile is brick with coins (w/o line)
00EF5F  1  C9 52                     cmp #$52
00EF61  1  F0 01                     beq UseBOffset          ;use offset if metatile is breakable brick w/o line
00EF63  1  C8                        iny                     ;if any other metatile, increment offset for empty block
00EF64  1  98           UseBOffset:  tya                     ;put Y in A
00EF65  1  AC 00 03                  ldy VRAM_Buffer1_Offset ;get vram buffer offset
00EF68  1  C8                        iny                     ;move onto next byte
00EF69  1  20 74 EF                  jsr PutBlockMetatile    ;get appropriate block data and write to vram buffer
00EF6C  1  88           MoveVOffset: dey                     ;decrement vram buffer offset
00EF6D  1  98                        tya                     ;add 10 bytes to it
00EF6E  1  18                        clc
00EF6F  1  69 0A                     adc #10
00EF71  1  4C 3C EE                  jmp SetVRAMOffset       ;branch to store as new vram buffer offset
00EF74  1               
00EF74  1               PutBlockMetatile:
00EF74  1  86 00                    stx $00               ;store control bit from SprDataOffset_Ctrl
00EF76  1  84 01                    sty $01               ;store vram buffer offset for next byte
00EF78  1  0A                       asl
00EF79  1  0A                       asl                   ;multiply A by four and use as X
00EF7A  1  AA                       tax
00EF7B  1  A0 20                    ldy #$20              ;load high byte for name table 0
00EF7D  1  A5 06                    lda $06               ;get low byte of block buffer pointer
00EF7F  1  C9 D0                    cmp #$d0              ;check to see if we're on odd-page block buffer
00EF81  1  90 02                    bcc SaveHAdder        ;if not, use current high byte
00EF83  1  A0 24                    ldy #$24              ;otherwise load high byte for name table 1
00EF85  1  84 03        SaveHAdder: sty $03               ;save high byte here
00EF87  1  29 0F                    and #$0f              ;mask out high nybble of block buffer pointer
00EF89  1  0A                       asl                   ;multiply by 2 to get appropriate name table low byte
00EF8A  1  85 04                    sta $04               ;and then store it here
00EF8C  1  A9 00                    lda #$00
00EF8E  1  85 05                    sta $05               ;initialize temp high byte
00EF90  1  A5 02                    lda $02               ;get vertical high nybble offset used in block buffer routine
00EF92  1  18                       clc
00EF93  1  69 20                    adc #$20              ;add 32 pixels for the status bar
00EF95  1  0A                       asl
00EF96  1  26 05                    rol $05               ;shift and rotate d7 onto d0 and d6 into carry
00EF98  1  0A                       asl
00EF99  1  26 05                    rol $05               ;shift and rotate d6 onto d0 and d5 into carry
00EF9B  1  65 04                    adc $04               ;add low byte of name table and carry to vertical high nybble
00EF9D  1  85 04                    sta $04               ;and store here
00EF9F  1  A5 05                    lda $05               ;get whatever was in d7 and d6 of vertical high nybble
00EFA1  1  69 00                    adc #$00              ;add carry
00EFA3  1  18                       clc
00EFA4  1  65 03                    adc $03               ;then add high byte of name table
00EFA6  1  85 05                    sta $05               ;store here
00EFA8  1  A4 01                    ldy $01               ;get vram buffer offset to be used
00EFAA  1  BD 16 EF     RemBridge:  lda BlockGfxData,x    ;write top left and top right
00EFAD  1  99 03 03                 sta VRAM_Buffer1+2,y  ;tile numbers into first spot
00EFB0  1  BD 17 EF                 lda BlockGfxData+1,x
00EFB3  1  99 04 03                 sta VRAM_Buffer1+3,y
00EFB6  1  BD 18 EF                 lda BlockGfxData+2,x  ;write bottom left and bottom
00EFB9  1  99 08 03                 sta VRAM_Buffer1+7,y  ;right tiles numbers into
00EFBC  1  BD 19 EF                 lda BlockGfxData+3,x  ;second spot
00EFBF  1  99 09 03                 sta VRAM_Buffer1+8,y
00EFC2  1  A5 04                    lda $04
00EFC4  1  99 01 03                 sta VRAM_Buffer1,y    ;write low byte of name table
00EFC7  1  18                       clc                   ;into first slot as read
00EFC8  1  69 20                    adc #$20              ;add 32 bytes to value
00EFCA  1  99 06 03                 sta VRAM_Buffer1+5,y  ;write low byte of name table
00EFCD  1  A5 05                    lda $05               ;plus 32 bytes into second slot
00EFCF  1  99 00 03                 sta VRAM_Buffer1-1,y  ;write high byte of name
00EFD2  1  99 05 03                 sta VRAM_Buffer1+4,y  ;table address to both slots
00EFD5  1  A9 02                    lda #$02
00EFD7  1  99 02 03                 sta VRAM_Buffer1+1,y  ;put length of 2 in
00EFDA  1  99 07 03                 sta VRAM_Buffer1+6,y  ;both slots
00EFDD  1  A9 00                    lda #$00
00EFDF  1  99 0A 03                 sta VRAM_Buffer1+9,y  ;put null terminator at end
00EFE2  1  A6 00                    ldx $00               ;get offset control bit here
00EFE4  1  60                       rts                   ;and leave
00EFE5  1               
00EFE5  1               
00EFE5  1               ;-------------------------------------------------------------------------------------
00EFE5  1               ;$06-$07 - used as address to block buffer data
00EFE5  1               ;$02 - used as vertical high nybble of block buffer offset
00EFE5  1               
00EFE5  1               VineHeightData:
00EFE5  1  30 60              .byte $30, $60
00EFE7  1               
00EFE7  1               VineObjectHandler:
00EFE7  1  E0 05                   cpx #$05                  ;check enemy offset for special use slot
00EFE9  1  D0 68                   bne ExitVH                ;if not in last slot, branch to leave
00EFEB  1  AC 98 03                ldy VineFlagOffset
00EFEE  1  88                      dey                       ;decrement vine flag in Y, use as offset
00EFEF  1  AD 99 03                lda VineHeight
00EFF2  1  D9 E5 EF                cmp VineHeightData,y      ;if vine has reached certain height,
00EFF5  1  F0 0F                   beq RunVSubs              ;branch ahead to skip this part
00EFF7  1  A5 09                   lda FrameCounter          ;get frame counter
00EFF9  1  4A                      lsr                       ;shift d1 into carry
00EFFA  1  4A                      lsr
00EFFB  1  90 09                   bcc RunVSubs              ;if d1 not set (2 frames every 4) skip this part
00EFFD  1  A5 D4                   lda Enemy_Y_Position+5
00EFFF  1  E9 01                   sbc #$01                  ;subtract vertical position of vine
00F001  1  85 D4                   sta Enemy_Y_Position+5    ;one pixel every frame it's time
00F003  1  EE 99 03                inc VineHeight            ;increment vine height
00F006  1  AD 99 03     RunVSubs:  lda VineHeight            ;if vine still very small,
00F009  1  C9 08                   cmp #$08                  ;branch to leave
00F00B  1  90 46                   bcc ExitVH
00F00D  1  20 EA EB                jsr RelativeEnemyPosition ;get relative coordinates of vine,
00F010  1  20 47 EC                jsr GetEnemyOffscreenBits ;and any offscreen bits
00F013  1  A0 00                   ldy #$00                  ;initialize offset used in draw vine sub
00F015  1  20 ED DE     VDrawLoop: jsr DrawVine              ;draw vine
00F018  1  C8                      iny                       ;increment offset
00F019  1  CC 98 03                cpy VineFlagOffset        ;if offset in Y and offset here
00F01C  1  D0 F7                   bne VDrawLoop             ;do not yet match, loop back to draw more vine
00F01E  1  AD D1 03                lda Enemy_OffscreenBits
00F021  1  29 0C                   and #%00001100            ;mask offscreen bits
00F023  1  F0 10                   beq WrCMTile              ;if none of the saved offscreen bits set, skip ahead
00F025  1  88                      dey                       ;otherwise decrement Y to get proper offset again
00F026  1  BE 9A 03     KillVine:  ldx VineObjOffset,y       ;get enemy object offset for this vine object
00F029  1  20 CE C5                jsr EraseEnemyObject      ;kill this vine object
00F02C  1  88                      dey                       ;decrement Y
00F02D  1  10 F7                   bpl KillVine              ;if any vine objects left, loop back to kill it
00F02F  1  8D 98 03                sta VineFlagOffset        ;initialize vine flag/offset
00F032  1  8D 99 03                sta VineHeight            ;initialize vine height
00F035  1  AD 99 03     WrCMTile:  lda VineHeight            ;check vine height
00F038  1  C9 20                   cmp #$20                  ;if vine small (less than 32 pixels tall)
00F03A  1  90 17                   bcc ExitVH                ;then branch ahead to leave
00F03C  1  A2 06                   ldx #$06                  ;set offset in X to last enemy slot
00F03E  1  A9 01                   lda #$01                  ;set A to obtain horizontal in $04, but we don't care
00F040  1  A0 1B                   ldy #$1b                  ;set Y to offset to get block at ($04, $10) of coordinates
00F042  1  20 A8 DE                jsr BlockBufferCollision  ;do a sub to get block buffer address set, return contents
00F045  1  A4 02                   ldy $02
00F047  1  C0 D0                   cpy #$d0                  ;if vertical high nybble offset beyond extent of
00F049  1  B0 08                   bcs ExitVH                ;current block buffer, branch to leave, do not write
00F04B  1  B1 06                   lda ($06),y               ;otherwise check contents of block buffer at
00F04D  1  D0 04                   bne ExitVH                ;current offset, if not empty, branch to leave
00F04F  1  A9 26                   lda #$26
00F051  1  91 06                   sta ($06),y               ;otherwise, write climbing metatile to block buffer
00F053  1  A6 08        ExitVH:    ldx ObjectOffset          ;get enemy object offset and leave
00F055  1  60                      rts
00F056  1               
00F056  1               ;-------------------------------------------------------------------------------------
00F056  1               
00F056  1               HammerEnemyOfsData:
00F056  1  04 04 04 05        .byte $04, $04, $04, $05, $05, $05
00F05A  1  05 05        
00F05C  1  06 06 06           .byte $06, $06, $06
00F05F  1               
00F05F  1               HammerXSpdData:
00F05F  1  10 F0              .byte $10, $f0
00F061  1               
00F061  1               SpawnHammerObj:
00F061  1  AD A8 07               lda PseudoRandomBitReg+1 ;get pseudorandom bits from
00F064  1  29 07                  and #%00000111           ;second part of LSFR
00F066  1  D0 05                  bne SetMOfs              ;if any bits are set, branch and use as offset
00F068  1  AD A8 07               lda PseudoRandomBitReg+1
00F06B  1  29 08                  and #%00001000           ;get d3 from same part of LSFR
00F06D  1  A8           SetMOfs:  tay                      ;use either d3 or d2-d0 for offset here
00F06E  1  B9 2A 00               lda Misc_State,y         ;if any values loaded in
00F071  1  D0 19                  bne NoHammer             ;$2a-$32 where offset is then leave with carry clear
00F073  1  BE 56 F0               ldx HammerEnemyOfsData,y ;get offset of enemy slot to check using Y as offset
00F076  1  B5 0F                  lda Enemy_Flag,x         ;check enemy buffer flag at offset
00F078  1  D0 12                  bne NoHammer             ;if buffer flag set, branch to leave with carry clear
00F07A  1  A6 08                  ldx ObjectOffset         ;get original enemy object offset
00F07C  1  8A                     txa
00F07D  1  99 AE 06               sta HammerEnemyOffset,y  ;save here
00F080  1  A9 90                  lda #$90
00F082  1  99 2A 00               sta Misc_State,y         ;save hammer's state here
00F085  1  A9 07                  lda #$07
00F087  1  99 A2 04               sta Misc_BoundBoxCtrl,y  ;set something else entirely, here
00F08A  1  38                     sec                      ;return with carry set
00F08B  1  60                     rts
00F08C  1  A6 08        NoHammer: ldx ObjectOffset         ;get original enemy object offset
00F08E  1  18                     clc                      ;return with carry clear
00F08F  1  60                     rts
00F090  1               
00F090  1                         .include "div10.inc"
00F090  2               .ifndef __DIV10_INC_DEF__
00F090  2               .define __DIV10_INC_DEF__
00F090  2               
00F090  2               DivByTen:
00F090  2  A2 00            ldx #$00
00F092  2               DivMore:
00F092  2  C9 0A            cmp #$0a
00F094  2  90 06            bcc DivByTenDone
00F096  2  E9 0A            sbc #$0a
00F098  2  E8               inx
00F099  2  38               sec
00F09A  2  B0 F6            bcs DivMore
00F09C  2               DivByTenDone:
00F09C  2  60               rts
00F09D  2               
00F09D  2               .endif
00F09D  2               
00F09D  1               
00F09D  1  EA EA EA EA            scenarios_callgate
00F0A1  1  EA EA EA EA  
00F0A5  1  EA EA EA EA  
00FE20  1  EA EA EA EA            control_bank
00FE24  1  EA EA EA EA  
00FE28  1  EA EA EA EA  
010000  1               
010000  1               
